module.exports = [
"[project]/node_modules/react-relay/lib/relay-hooks/ProfilerContext.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var ProfilerContext = React.createContext({
    wrapPrepareQueryResource: function wrapPrepareQueryResource(cb) {
        return cb();
    }
});
module.exports = ProfilerContext;
}),
"[project]/node_modules/react-relay/lib/ReactRelayContext.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), createRelayContext = _require.__internal.createRelayContext;
module.exports = createRelayContext(React);
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ReactRelayContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContext.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useContext = _require.useContext;
function useRelayEnvironment() {
    var context = useContext(ReactRelayContext);
    !(context != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'useRelayEnvironment: Expected to have found a Relay environment provided by ' + 'a `RelayEnvironmentProvider` component. ' + 'This usually means that useRelayEnvironment was used in a ' + 'component that is not a descendant of a `RelayEnvironmentProvider`. ' + 'Please make sure a `RelayEnvironmentProvider` has been rendered somewhere ' + 'as a parent or ancestor of your component.') : "TURBOPACK unreachable" : void 0;
    return context.environment;
}
module.exports = useRelayEnvironment;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/EntryPointContainer.react.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ProfilerContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/ProfilerContext.js [app-ssr] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useContext = _require.useContext, useEffect = _require.useEffect;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function EntryPointContainer(_ref) {
    var entryPointReference = _ref.entryPointReference, props = _ref.props;
    ("TURBOPACK compile-time truthy", 1) ? warning(entryPointReference.isDisposed === false, '<EntryPointContainer>: Expected entryPointReference to not be disposed ' + 'yet. This is because disposing the entrypoint marks it for future garbage ' + 'collection, and as such may no longer be present in the Relay store. ' + 'In the future, this will become a hard error.') : "TURBOPACK unreachable";
    var getComponent = entryPointReference.getComponent, queries = entryPointReference.queries, entryPoints = entryPointReference.entryPoints, extraProps = entryPointReference.extraProps, rootModuleID = entryPointReference.rootModuleID;
    var Component = getComponent();
    var profilerContext = useContext(ProfilerContext);
    var environment = useRelayEnvironment();
    useEffect(function() {
        environment.__log({
            name: 'entrypoint.root.consume',
            profilerContext: profilerContext,
            rootModuleID: rootModuleID
        });
    }, [
        environment,
        profilerContext,
        rootModuleID
    ]);
    return /*#__PURE__*/ React.createElement(Component, {
        entryPoints: entryPoints,
        extraProps: extraProps,
        props: props,
        queries: queries
    });
}
module.exports = EntryPointContainer;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/loadQuery.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), fetchQueryDeduped = _require.__internal.fetchQueryDeduped, Observable = _require.Observable, PreloadableQueryRegistry = _require.PreloadableQueryRegistry, ReplaySubject = _require.ReplaySubject, createOperationDescriptor = _require.createOperationDescriptor, getRequest = _require.getRequest, getRequestIdentifier = _require.getRequestIdentifier;
var fetchKey = 100001;
function loadQuery(environment, preloadableRequest, variables, options, environmentProviderOptions) {
    var _options$fetchPolicy;
    fetchKey++;
    var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'store-or-network';
    var networkCacheConfig = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, options === null || options === void 0 ? void 0 : options.networkCacheConfig), {}, {
        force: true
    });
    var retainReference;
    var didExecuteNetworkSource = false;
    var executeWithNetworkSource = function executeWithNetworkSource(operation, networkObservable) {
        didExecuteNetworkSource = true;
        return environment.executeWithSource({
            operation: operation,
            source: networkObservable
        });
    };
    var executionSubject = new ReplaySubject();
    var returnedObservable = Observable.create(function(sink) {
        return executionSubject.subscribe(sink);
    });
    var unsubscribeFromNetworkRequest;
    var networkError = null;
    var didMakeNetworkRequest = false;
    var makeNetworkRequest = function makeNetworkRequest(params, checkOperation) {
        didMakeNetworkRequest = true;
        var subject = new ReplaySubject();
        var identifier = 'raw-network-request-' + getRequestIdentifier(params, variables);
        var observable = fetchQueryDeduped(environment, identifier, function() {
            var network = environment.getNetwork();
            return network.execute(params, variables, networkCacheConfig, undefined, undefined, undefined, undefined, checkOperation);
        });
        var _observable$subscribe = observable.subscribe({
            error: function error(err) {
                networkError = err;
                subject.error(err);
            },
            next: function next(data) {
                subject.next(data);
            },
            complete: function complete() {
                subject.complete();
            }
        }), unsubscribe = _observable$subscribe.unsubscribe;
        unsubscribeFromNetworkRequest = unsubscribe;
        return Observable.create(function(sink) {
            var subjectSubscription = subject.subscribe(sink);
            return function() {
                subjectSubscription.unsubscribe();
                unsubscribeFromNetworkRequest();
            };
        });
    };
    var unsubscribeFromExecution;
    var executeDeduped = function executeDeduped(operation, fetchFn) {
        didMakeNetworkRequest = true;
        var _fetchQueryDeduped$su = fetchQueryDeduped(environment, operation.request.identifier, fetchFn).subscribe({
            error: function error(err) {
                executionSubject.error(err);
            },
            next: function next(data) {
                executionSubject.next(data);
            },
            complete: function complete() {
                executionSubject.complete();
            }
        });
        unsubscribeFromExecution = _fetchQueryDeduped$su.unsubscribe;
    };
    var checkAvailabilityAndExecute = function checkAvailabilityAndExecute(concreteRequest) {
        var operation = createOperationDescriptor(concreteRequest, variables, networkCacheConfig);
        retainReference = environment.retain(operation);
        if (fetchPolicy === 'store-only') {
            return;
        }
        var shouldFetch = fetchPolicy !== 'store-or-network' || environment.check(operation).status !== 'available';
        if (shouldFetch) {
            executeDeduped(operation, function() {
                var networkObservable = makeNetworkRequest(concreteRequest.params, function() {
                    return environment.check(operation);
                });
                var executeObservable = executeWithNetworkSource(operation, networkObservable);
                return executeObservable;
            });
        }
    };
    var params;
    var cancelOnLoadCallback;
    var queryId;
    if (preloadableRequest.kind === 'PreloadableConcreteRequest') {
        var preloadableConcreteRequest = preloadableRequest;
        params = preloadableConcreteRequest.params;
        var _params = params;
        queryId = _params.id;
        !(queryId !== null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: `loadQuery` requires that preloadable query `%s` has a persisted query id', params.name) : "TURBOPACK unreachable" : void 0;
        var _module = PreloadableQueryRegistry.get(queryId);
        if (_module != null) {
            checkAvailabilityAndExecute(_module);
        } else {
            var networkObservable = fetchPolicy === 'store-only' ? null : makeNetworkRequest(params);
            var _PreloadableQueryRegi = PreloadableQueryRegistry.onLoad(queryId, function(preloadedModule) {
                cancelOnLoadCallback();
                var operation = createOperationDescriptor(preloadedModule, variables, networkCacheConfig);
                retainReference = environment.retain(operation);
                if (networkObservable != null) {
                    executeDeduped(operation, function() {
                        return executeWithNetworkSource(operation, networkObservable);
                    });
                }
            });
            cancelOnLoadCallback = _PreloadableQueryRegi.dispose;
        }
    } else {
        var graphQlTaggedNode = preloadableRequest;
        var request = getRequest(graphQlTaggedNode);
        params = request.params;
        queryId = params.cacheID != null ? params.cacheID : params.id;
        checkAvailabilityAndExecute(request);
    }
    var isDisposed = false;
    var isReleased = false;
    var isNetworkRequestCancelled = false;
    var releaseQuery = function releaseQuery() {
        if (isReleased) {
            return;
        }
        retainReference && retainReference.dispose();
        isReleased = true;
    };
    var cancelNetworkRequest = function cancelNetworkRequest() {
        if (isNetworkRequestCancelled) {
            return;
        }
        if (didExecuteNetworkSource) {
            unsubscribeFromExecution && unsubscribeFromExecution();
        } else {
            unsubscribeFromNetworkRequest && unsubscribeFromNetworkRequest();
        }
        cancelOnLoadCallback && cancelOnLoadCallback();
        isNetworkRequestCancelled = true;
    };
    return {
        kind: 'PreloadedQuery',
        environment: environment,
        environmentProviderOptions: environmentProviderOptions,
        dispose: function dispose() {
            if (isDisposed) {
                return;
            }
            releaseQuery();
            cancelNetworkRequest();
            isDisposed = true;
        },
        releaseQuery: releaseQuery,
        cancelNetworkRequest: cancelNetworkRequest,
        fetchKey: fetchKey,
        id: queryId,
        get isDisposed () {
            return isDisposed || isReleased;
        },
        get networkError () {
            return networkError;
        },
        name: params.name,
        networkCacheConfig: networkCacheConfig,
        fetchPolicy: fetchPolicy,
        source: didMakeNetworkRequest ? returnedObservable : undefined,
        variables: variables
    };
}
module.exports = {
    loadQuery: loadQuery
};
}),
"[project]/node_modules/react-relay/lib/relay-hooks/loadEntryPoint.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/loadQuery.js [app-ssr] (ecmascript)"), loadQuery = _require.loadQuery;
function loadEntryPoint(environmentProvider, entryPoint, entryPointParams) {
    var loadingPromise = null;
    if (entryPoint.root.getModuleIfRequired() == null) {
        loadingPromise = entryPoint.root.load();
    }
    var preloadProps = entryPoint.getPreloadProps(entryPointParams);
    var queries = preloadProps.queries, entryPoints = preloadProps.entryPoints, extraProps = preloadProps.extraProps;
    var preloadedQueries = {};
    var preloadedEntryPoints = {};
    if (queries != null) {
        var queriesPropNames = Object.keys(queries);
        queriesPropNames.forEach(function(queryPropName) {
            var query = queries[queryPropName];
            if (query == null) {
                return;
            }
            var environmentProviderOptions = query.environmentProviderOptions, options = query.options, parameters = query.parameters, variables = query.variables;
            if ((options === null || options === void 0 ? void 0 : options.includeIf) === false) {
                return;
            }
            var environment = environmentProvider.getEnvironment(environmentProviderOptions);
            preloadedQueries[queryPropName] = loadQuery(environment, parameters, variables, {
                fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
                networkCacheConfig: options === null || options === void 0 ? void 0 : options.networkCacheConfig,
                __nameForWarning: 'loadEntryPoint'
            }, environmentProviderOptions);
        });
    }
    if (entryPoints != null) {
        var entryPointPropNames = Object.keys(entryPoints);
        entryPointPropNames.forEach(function(entryPointPropName) {
            var entryPointDescription = entryPoints[entryPointPropName];
            if (entryPointDescription == null) {
                return;
            }
            var nestedEntryPoint = entryPointDescription.entryPoint, nestedParams = entryPointDescription.entryPointParams;
            preloadedEntryPoints[entryPointPropName] = loadEntryPoint(environmentProvider, nestedEntryPoint, nestedParams);
        });
    }
    var isDisposed = false;
    return {
        dispose: function dispose() {
            if (isDisposed) {
                return;
            }
            if (preloadedQueries != null) {
                Object.values(preloadedQueries).forEach(function(_ref) {
                    var innerDispose = _ref.dispose;
                    innerDispose();
                });
            }
            if (preloadedEntryPoints != null) {
                Object.values(preloadedEntryPoints).forEach(function(_ref2) {
                    var innerDispose = _ref2.dispose;
                    innerDispose();
                });
            }
            isDisposed = true;
        },
        entryPoints: preloadedEntryPoints,
        extraProps: extraProps !== null && extraProps !== void 0 ? extraProps : null,
        getComponent: function getComponent() {
            var componentModule = entryPoint.root.getModuleIfRequired();
            if (componentModule == null) {
                var _loadingPromise;
                loadingPromise = (_loadingPromise = loadingPromise) !== null && _loadingPromise !== void 0 ? _loadingPromise : entryPoint.root.load();
                throw loadingPromise;
            }
            var component = componentModule["default"] != null ? componentModule["default"] : componentModule;
            return component;
        },
        get isDisposed () {
            return isDisposed;
        },
        queries: preloadedQueries,
        rootModuleID: entryPoint.root.getModuleId()
    };
}
module.exports = loadEntryPoint;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/RelayEnvironmentProvider.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ReactRelayContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContext.js [app-ssr] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var useMemo = React.useMemo;
function RelayEnvironmentProvider(props) {
    var children = props.children, environment = props.environment, getEnvironmentForActor = props.getEnvironmentForActor;
    var context = useMemo(function() {
        return {
            environment: environment,
            getEnvironmentForActor: getEnvironmentForActor
        };
    }, [
        environment,
        getEnvironmentForActor
    ]);
    return /*#__PURE__*/ React.createElement(ReactRelayContext.Provider, {
        value: context
    }, children);
}
module.exports = RelayEnvironmentProvider;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useEffect = _require.useEffect, useRef = _require.useRef;
function useIsMountedRef() {
    var isMountedRef = useRef(true);
    useEffect(function() {
        isMountedRef.current = true;
        return function() {
            isMountedRef.current = false;
        };
    }, []);
    return isMountedRef;
}
module.exports = useIsMountedRef;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useEntryPointLoader.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var loadEntryPoint = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/loadEntryPoint.js [app-ssr] (ecmascript)");
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useCallback = _require.useCallback, useEffect = _require.useEffect, useRef = _require.useRef, useState = _require.useState;
var initialNullEntryPointReferenceState = {
    kind: 'NullEntryPointReference'
};
function useLoadEntryPoint(environmentProvider, entryPoint, options) {
    var _options$TEST_ONLY__i, _options$TEST_ONLY__i2, _options$TEST_ONLY__i3, _options$TEST_ONLY__i4;
    var initialEntryPointReferenceInternal = (_options$TEST_ONLY__i = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i2 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i2 === void 0 ? void 0 : _options$TEST_ONLY__i2.entryPointReference) !== null && _options$TEST_ONLY__i !== void 0 ? _options$TEST_ONLY__i : initialNullEntryPointReferenceState;
    var initialEntryPointParamsInternal = (_options$TEST_ONLY__i3 = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i4 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i4 === void 0 ? void 0 : _options$TEST_ONLY__i4.entryPointParams) !== null && _options$TEST_ONLY__i3 !== void 0 ? _options$TEST_ONLY__i3 : null;
    var isMountedRef = useIsMountedRef();
    var undisposedEntryPointReferencesRef = useRef(new Set([
        initialEntryPointReferenceInternal
    ]));
    var _useState = useState(initialEntryPointReferenceInternal), entryPointReference = _useState[0], setEntryPointReference = _useState[1];
    var _useState2 = useState(initialEntryPointParamsInternal), entryPointParams = _useState2[0], setEntryPointParams = _useState2[1];
    var disposeEntryPoint = useCallback(function() {
        if (isMountedRef.current) {
            var nullEntryPointReference = {
                kind: 'NullEntryPointReference'
            };
            undisposedEntryPointReferencesRef.current.add(nullEntryPointReference);
            setEntryPointReference(nullEntryPointReference);
        }
    }, [
        setEntryPointReference,
        isMountedRef
    ]);
    var entryPointLoaderCallback = useCallback(function(params) {
        if (isMountedRef.current) {
            var updatedEntryPointReference = loadEntryPoint(environmentProvider, entryPoint, params);
            undisposedEntryPointReferencesRef.current.add(updatedEntryPointReference);
            setEntryPointReference(updatedEntryPointReference);
            setEntryPointParams(params);
        }
    }, [
        environmentProvider,
        entryPoint,
        setEntryPointReference,
        isMountedRef
    ]);
    var maybeHiddenOrFastRefresh = useRef(false);
    useEffect(function() {
        return function() {
            maybeHiddenOrFastRefresh.current = true;
        };
    }, []);
    useEffect(function() {
        if (maybeHiddenOrFastRefresh.current === true) {
            maybeHiddenOrFastRefresh.current = false;
            if (entryPointReference.kind !== 'NullEntryPointReference' && entryPointParams != null) {
                entryPointLoaderCallback(entryPointParams);
            }
            return;
        }
        var undisposedEntryPointReferences = undisposedEntryPointReferencesRef.current;
        if (isMountedRef.current) {
            var _iterator = (0, _createForOfIteratorHelper2["default"])(undisposedEntryPointReferences), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var undisposedEntryPointReference = _step.value;
                    if (undisposedEntryPointReference === entryPointReference) {
                        break;
                    }
                    undisposedEntryPointReferences["delete"](undisposedEntryPointReference);
                    if (undisposedEntryPointReference.kind !== 'NullEntryPointReference') {
                        undisposedEntryPointReference.dispose();
                    }
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
        }
    }, [
        entryPointReference,
        entryPointParams,
        entryPointLoaderCallback,
        isMountedRef
    ]);
    useEffect(function() {
        return function disposeAllRemainingEntryPointReferences() {
            var _iterator2 = (0, _createForOfIteratorHelper2["default"])(undisposedEntryPointReferencesRef.current), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var unhandledStateChange = _step2.value;
                    if (unhandledStateChange.kind !== 'NullEntryPointReference') {
                        unhandledStateChange.dispose();
                    }
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
        };
    }, []);
    return [
        entryPointReference.kind === 'NullEntryPointReference' ? null : entryPointReference,
        entryPointLoaderCallback,
        disposeEntryPoint
    ];
}
module.exports = useLoadEntryPoint;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/LRUCache.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var LRUCache = /*#__PURE__*/ function() {
    function LRUCache(capacity) {
        this._capacity = capacity;
        !(this._capacity > 0) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'LRUCache: Unable to create instance of cache with zero or negative capacity.') : "TURBOPACK unreachable" : void 0;
        this._map = new Map();
    }
    var _proto = LRUCache.prototype;
    _proto.set = function set(key, value) {
        this._map["delete"](key);
        this._map.set(key, value);
        if (this._map.size > this._capacity) {
            var firstKey = this._map.keys().next();
            if (!firstKey.done) {
                this._map["delete"](firstKey.value);
            }
        }
    };
    _proto.get = function get(key) {
        var value = this._map.get(key);
        if (value != null) {
            this._map["delete"](key);
            this._map.set(key, value);
        }
        return value;
    };
    _proto.has = function has(key) {
        return this._map.has(key);
    };
    _proto["delete"] = function _delete(key) {
        this._map["delete"](key);
    };
    _proto.size = function size() {
        return this._map.size;
    };
    _proto.capacity = function capacity() {
        return this._capacity - this._map.size;
    };
    _proto.clear = function clear() {
        this._map.clear();
    };
    return LRUCache;
}();
function create(capacity) {
    return new LRUCache(capacity);
}
module.exports = {
    create: create
};
}),
"[project]/node_modules/react-relay/lib/relay-hooks/SuspenseResource.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)"));
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
var TEMPORARY_RETAIN_DURATION_MS = 5 * 60 * 1000;
var SuspenseResource = /*#__PURE__*/ function() {
    function SuspenseResource(retain) {
        var _this = this;
        (0, _defineProperty2["default"])(this, "_retainCount", 0);
        (0, _defineProperty2["default"])(this, "_retainDisposable", null);
        (0, _defineProperty2["default"])(this, "_releaseTemporaryRetain", null);
        this._retain = function(environment) {
            _this._retainCount++;
            if (_this._retainCount === 1) {
                _this._retainDisposable = retain(environment);
            }
            return {
                dispose: function dispose() {
                    _this._retainCount = Math.max(0, _this._retainCount - 1);
                    if (_this._retainCount === 0) {
                        if (_this._retainDisposable != null) {
                            _this._retainDisposable.dispose();
                            _this._retainDisposable = null;
                        } else {
                            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected disposable to release query to be defined.' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable";
                        }
                    }
                }
            };
        };
    }
    var _proto = SuspenseResource.prototype;
    _proto.temporaryRetain = function temporaryRetain(environment) {
        var _this2 = this;
        var _this$_releaseTempora;
        if (environment.isServer()) {
            return {
                dispose: function dispose() {}
            };
        }
        var retention = this._retain(environment);
        var releaseQueryTimeout = null;
        var releaseTemporaryRetain = function releaseTemporaryRetain() {
            clearTimeout(releaseQueryTimeout);
            releaseQueryTimeout = null;
            _this2._releaseTemporaryRetain = null;
            retention.dispose();
        };
        releaseQueryTimeout = setTimeout(releaseTemporaryRetain, TEMPORARY_RETAIN_DURATION_MS);
        (_this$_releaseTempora = this._releaseTemporaryRetain) === null || _this$_releaseTempora === void 0 ? void 0 : _this$_releaseTempora.call(this);
        this._releaseTemporaryRetain = releaseTemporaryRetain;
        return {
            dispose: function dispose() {
                var _this$_releaseTempora2;
                (_this$_releaseTempora2 = _this2._releaseTemporaryRetain) === null || _this$_releaseTempora2 === void 0 ? void 0 : _this$_releaseTempora2.call(_this2);
            }
        };
    };
    _proto.permanentRetain = function permanentRetain(environment) {
        var disposable = this._retain(environment);
        this.releaseTemporaryRetain();
        return disposable;
    };
    _proto.releaseTemporaryRetain = function releaseTemporaryRetain() {
        var _this$_releaseTempora3;
        (_this$_releaseTempora3 = this._releaseTemporaryRetain) === null || _this$_releaseTempora3 === void 0 ? void 0 : _this$_releaseTempora3.call(this);
        this._releaseTemporaryRetain = null;
    };
    _proto.getRetainCount = function getRetainCount() {
        return this._retainCount;
    };
    return SuspenseResource;
}();
module.exports = SuspenseResource;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/QueryResource.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)"));
var LRUCache = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/LRUCache.js [app-ssr] (ecmascript)");
var SuspenseResource = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/SuspenseResource.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), isPromise = _require.isPromise;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
var CACHE_CAPACITY = 1000;
var DEFAULT_FETCH_POLICY = 'store-or-network';
var DEFAULT_LIVE_FETCH_POLICY = 'store-and-network';
var WEAKMAP_SUPPORTED = typeof WeakMap === 'function';
function operationIsLiveQuery(operation) {
    return operation.request.node.params.metadata.live !== undefined;
}
function getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {
    var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : operationIsLiveQuery(operation) ? DEFAULT_LIVE_FETCH_POLICY : DEFAULT_FETCH_POLICY;
    var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();
    var cacheIdentifier = "".concat(fetchPolicy, "-").concat(renderPolicy, "-").concat(operation.request.identifier);
    if (cacheBreaker != null) {
        return "".concat(cacheIdentifier, "-").concat(cacheBreaker);
    }
    return cacheIdentifier;
}
function getQueryResult(operation, cacheIdentifier) {
    var rootFragmentRef = {
        __id: operation.fragment.dataID,
        __fragments: (0, _defineProperty2["default"])({}, operation.fragment.node.name, operation.request.variables),
        __fragmentOwner: operation.request
    };
    return {
        cacheIdentifier: cacheIdentifier,
        fragmentNode: operation.request.node.fragment,
        fragmentRef: rootFragmentRef,
        operation: operation
    };
}
var nextID = 200000;
function createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {
    var isLiveQuery = operationIsLiveQuery(operation);
    var currentValue = value;
    var currentNetworkSubscription = networkSubscription;
    var suspenseResource = new SuspenseResource(function(environment) {
        var retention = environment.retain(operation);
        return {
            dispose: function dispose() {
                if (isLiveQuery && currentNetworkSubscription != null) {
                    currentNetworkSubscription.unsubscribe();
                }
                retention.dispose();
                onDispose(cacheEntry);
            }
        };
    });
    var cacheEntry = {
        cacheIdentifier: cacheIdentifier,
        id: nextID++,
        processedPayloadsCount: 0,
        operationAvailability: operationAvailability,
        getValue: function getValue() {
            return currentValue;
        },
        setValue: function setValue(val) {
            currentValue = val;
        },
        setNetworkSubscription: function setNetworkSubscription(subscription) {
            if (isLiveQuery && currentNetworkSubscription != null) {
                currentNetworkSubscription.unsubscribe();
            }
            currentNetworkSubscription = subscription;
        },
        temporaryRetain: function temporaryRetain(environment) {
            return suspenseResource.temporaryRetain(environment);
        },
        permanentRetain: function permanentRetain(environment) {
            return suspenseResource.permanentRetain(environment);
        },
        releaseTemporaryRetain: function releaseTemporaryRetain() {
            suspenseResource.releaseTemporaryRetain();
        }
    };
    return cacheEntry;
}
var QueryResourceImpl = /*#__PURE__*/ function() {
    function QueryResourceImpl(environment) {
        var _this = this;
        (0, _defineProperty2["default"])(this, "_clearCacheEntry", function(cacheEntry) {
            _this._cache["delete"](cacheEntry.cacheIdentifier);
        });
        this._environment = environment;
        this._cache = LRUCache.create(CACHE_CAPACITY);
    }
    var _proto = QueryResourceImpl.prototype;
    _proto.prepare = function prepare(operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, cacheBreaker, profilerContext) {
        var cacheIdentifier = getQueryCacheIdentifier(this._environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);
        return this.prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext);
    };
    _proto.prepareWithIdentifier = function prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext) {
        var environment = this._environment;
        var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : operationIsLiveQuery(operation) ? DEFAULT_LIVE_FETCH_POLICY : DEFAULT_FETCH_POLICY;
        var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();
        var cacheEntry = this._cache.get(cacheIdentifier);
        var temporaryRetainDisposable = null;
        var entryWasCached = cacheEntry != null;
        if (cacheEntry == null) {
            cacheEntry = this._fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, observer), {}, {
                unsubscribe: function unsubscribe(subscription) {
                    if (temporaryRetainDisposable != null) {
                        temporaryRetainDisposable.dispose();
                    }
                    var observerUnsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe;
                    observerUnsubscribe && observerUnsubscribe(subscription);
                }
            }));
        }
        temporaryRetainDisposable = cacheEntry.temporaryRetain(environment);
        var cachedValue = cacheEntry.getValue();
        if (isPromise(cachedValue)) {
            environment.__log({
                name: 'suspense.query',
                fetchPolicy: fetchPolicy,
                isPromiseCached: entryWasCached,
                operation: operation,
                queryAvailability: cacheEntry.operationAvailability,
                renderPolicy: renderPolicy
            });
            throw cachedValue;
        }
        if (cachedValue instanceof Error) {
            throw cachedValue;
        }
        return cachedValue;
    };
    _proto.retain = function retain(queryResult, profilerContext) {
        var environment = this._environment;
        var cacheIdentifier = queryResult.cacheIdentifier, operation = queryResult.operation;
        var cacheEntry = this._getOrCreateCacheEntry(cacheIdentifier, operation, null, queryResult, null);
        var disposable = cacheEntry.permanentRetain(environment);
        environment.__log({
            name: 'queryresource.retain',
            profilerContext: profilerContext,
            resourceID: cacheEntry.id
        });
        return {
            dispose: function dispose() {
                disposable.dispose();
            }
        };
    };
    _proto.releaseTemporaryRetain = function releaseTemporaryRetain(queryResult) {
        var cacheEntry = this._cache.get(queryResult.cacheIdentifier);
        if (cacheEntry != null) {
            cacheEntry.releaseTemporaryRetain();
        }
    };
    _proto.TESTS_ONLY__getCacheEntry = function TESTS_ONLY__getCacheEntry(operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {
        var environment = this._environment;
        var cacheIdentifier = getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);
        return this._cache.get(cacheIdentifier);
    };
    _proto._getOrCreateCacheEntry = function _getOrCreateCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription) {
        var cacheEntry = this._cache.get(cacheIdentifier);
        if (cacheEntry == null) {
            cacheEntry = createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, this._clearCacheEntry);
            this._cache.set(cacheIdentifier, cacheEntry);
        }
        return cacheEntry;
    };
    _proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {
        var _this2 = this;
        var environment = this._environment;
        var queryAvailability = environment.check(operation);
        var queryStatus = queryAvailability.status;
        var hasFullQuery = queryStatus === 'available';
        var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';
        var shouldFetch;
        var shouldAllowRender;
        var resolveNetworkPromise = function resolveNetworkPromise() {};
        switch(fetchPolicy){
            case 'store-only':
                {
                    shouldFetch = false;
                    shouldAllowRender = true;
                    break;
                }
            case 'store-or-network':
                {
                    shouldFetch = !hasFullQuery;
                    shouldAllowRender = canPartialRender;
                    break;
                }
            case 'store-and-network':
                {
                    shouldFetch = true;
                    shouldAllowRender = canPartialRender;
                    break;
                }
            case 'network-only':
            default:
                {
                    shouldFetch = true;
                    shouldAllowRender = false;
                    break;
                }
        }
        if (shouldAllowRender) {
            var queryResult = getQueryResult(operation, cacheIdentifier);
            var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryAvailability, queryResult, null, this._clearCacheEntry);
            this._cache.set(cacheIdentifier, _cacheEntry);
        }
        if (shouldFetch) {
            var _queryResult = getQueryResult(operation, cacheIdentifier);
            var networkSubscription;
            fetchObservable.subscribe({
                start: function start(subscription) {
                    networkSubscription = subscription;
                    var cacheEntry = _this2._cache.get(cacheIdentifier);
                    if (cacheEntry) {
                        cacheEntry.setNetworkSubscription(networkSubscription);
                    }
                    var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;
                    if (observerStart) {
                        var subscriptionWithConditionalCancelation = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, subscription), {}, {
                            unsubscribe: function unsubscribe() {
                                if (operationIsLiveQuery(operation)) {
                                    subscription.unsubscribe();
                                }
                            }
                        });
                        observerStart(subscriptionWithConditionalCancelation);
                    }
                },
                next: function next() {
                    var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _queryResult, networkSubscription);
                    cacheEntry.processedPayloadsCount += 1;
                    cacheEntry.setValue(_queryResult);
                    resolveNetworkPromise();
                    var observerNext = observer === null || observer === void 0 ? void 0 : observer.next;
                    if (observerNext != null) {
                        var snapshot = environment.lookup(operation.fragment);
                        observerNext(snapshot);
                    }
                },
                error: function error(_error) {
                    var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _error, networkSubscription);
                    if (cacheEntry.processedPayloadsCount === 0) {
                        cacheEntry.setValue(_error);
                    } else {
                        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'QueryResource: An incremental payload for query `%s` returned an error: `%s`.', operation.fragment.node.name, String(_error.message)) : "TURBOPACK unreachable";
                    }
                    resolveNetworkPromise();
                    networkSubscription = null;
                    cacheEntry.setNetworkSubscription(null);
                    var observerError = observer === null || observer === void 0 ? void 0 : observer.error;
                    observerError && observerError(_error);
                },
                complete: function complete() {
                    resolveNetworkPromise();
                    networkSubscription = null;
                    var cacheEntry = _this2._cache.get(cacheIdentifier);
                    if (cacheEntry) {
                        cacheEntry.setNetworkSubscription(null);
                    }
                    var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;
                    observerComplete && observerComplete();
                },
                unsubscribe: observer === null || observer === void 0 ? void 0 : observer.unsubscribe
            });
            var _cacheEntry2 = this._cache.get(cacheIdentifier);
            if (!_cacheEntry2) {
                var networkPromise = new Promise(function(resolve) {
                    resolveNetworkPromise = resolve;
                });
                networkPromise.displayName = 'Relay(' + operation.fragment.node.name + ')';
                _cacheEntry2 = createCacheEntry(cacheIdentifier, operation, queryAvailability, networkPromise, networkSubscription, this._clearCacheEntry);
                this._cache.set(cacheIdentifier, _cacheEntry2);
            }
        } else {
            var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;
            observerComplete && observerComplete();
        }
        var cacheEntry = this._cache.get(cacheIdentifier);
        !(cacheEntry != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to have cached a result when attempting to fetch query.' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable" : void 0;
        environment.__log({
            name: 'queryresource.fetch',
            resourceID: cacheEntry.id,
            operation: operation,
            profilerContext: profilerContext,
            fetchPolicy: fetchPolicy,
            renderPolicy: renderPolicy,
            queryAvailability: queryAvailability,
            shouldFetch: shouldFetch
        });
        return cacheEntry;
    };
    return QueryResourceImpl;
}();
function createQueryResource(environment) {
    return new QueryResourceImpl(environment);
}
var dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();
function getQueryResourceForEnvironment(environment) {
    var cached = dataResources.get(environment);
    if (cached) {
        return cached;
    }
    var newDataResource = createQueryResource(environment);
    dataResources.set(environment, newDataResource);
    return newDataResource;
}
module.exports = {
    createQueryResource: createQueryResource,
    getQueryResourceForEnvironment: getQueryResourceForEnvironment,
    getQueryCacheIdentifier: getQueryCacheIdentifier
};
}),
"[project]/node_modules/react-relay/lib/ReactRelayLoggingContext.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), createRelayLoggingContext = _require.__internal.createRelayLoggingContext;
module.exports = createRelayLoggingContext(React);
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useRelayLoggingContext.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ReactRelayLoggingContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayLoggingContext.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useContext = _require.useContext;
function useRelayLoggingContext() {
    return useContext(ReactRelayLoggingContext);
}
module.exports = useRelayLoggingContext;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal_CURRENT.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-ssr] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/QueryResource.js [app-ssr] (ecmascript)"), getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var useRelayLoggingContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayLoggingContext.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useDebugValue = _require2.useDebugValue, useEffect = _require2.useEffect, useMemo = _require2.useMemo, useRef = _require2.useRef, useState = _require2.useState;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), _require3$__internal = _require3.__internal, fetchQueryInternal = _require3$__internal.fetchQuery, getPromiseForActiveRequest = _require3$__internal.getPromiseForActiveRequest, RelayFeatureFlags = _require3.RelayFeatureFlags, areEqualSelectors = _require3.areEqualSelectors, createOperationDescriptor = _require3.createOperationDescriptor, getPendingOperationsForFragment = _require3.getPendingOperationsForFragment, getSelector = _require3.getSelector, getVariablesFromFragment = _require3.getVariablesFromFragment, handlePotentialSnapshotErrors = _require3.handlePotentialSnapshotErrors, recycleNodesInto = _require3.recycleNodesInto;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function isMissingData(state) {
    if (state.kind === 'bailout') {
        return false;
    } else if (state.kind === 'singular') {
        return state.snapshot.isMissingData;
    } else {
        return state.snapshots.some(function(s) {
            return s.isMissingData;
        });
    }
}
function getMissingClientEdges(state) {
    if (state.kind === 'bailout') {
        return null;
    } else if (state.kind === 'singular') {
        var _state$snapshot$missi;
        return (_state$snapshot$missi = state.snapshot.missingClientEdges) !== null && _state$snapshot$missi !== void 0 ? _state$snapshot$missi : null;
    } else {
        var edges = null;
        var _iterator = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var snapshot = _step.value;
                if (snapshot.missingClientEdges) {
                    var _edges;
                    edges = (_edges = edges) !== null && _edges !== void 0 ? _edges : [];
                    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(snapshot.missingClientEdges), _step2;
                    try {
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                            var edge = _step2.value;
                            edges.push(edge);
                        }
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        return edges;
    }
}
function getSuspendingLiveResolver(state) {
    if (state.kind === 'bailout') {
        return null;
    } else if (state.kind === 'singular') {
        var _state$snapshot$missi2;
        return (_state$snapshot$missi2 = state.snapshot.missingLiveResolverFields) !== null && _state$snapshot$missi2 !== void 0 ? _state$snapshot$missi2 : null;
    } else {
        var missingFields = null;
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var snapshot = _step3.value;
                if (snapshot.missingLiveResolverFields) {
                    var _missingFields;
                    missingFields = (_missingFields = missingFields) !== null && _missingFields !== void 0 ? _missingFields : [];
                    var _iterator4 = (0, _createForOfIteratorHelper2["default"])(snapshot.missingLiveResolverFields), _step4;
                    try {
                        for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                            var edge = _step4.value;
                            missingFields.push(edge);
                        }
                    } catch (err) {
                        _iterator4.e(err);
                    } finally{
                        _iterator4.f();
                    }
                }
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
        return missingFields;
    }
}
function handlePotentialSnapshotErrorsForState(environment, state, loggingContext) {
    if (state.kind === 'singular') {
        handlePotentialSnapshotErrors(environment, state.snapshot.fieldErrors, loggingContext);
    } else if (state.kind === 'plural') {
        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step5;
        try {
            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                var snapshot = _step5.value;
                handlePotentialSnapshotErrors(environment, snapshot.fieldErrors, loggingContext);
            }
        } catch (err) {
            _iterator5.e(err);
        } finally{
            _iterator5.f();
        }
    }
}
function handleMissedUpdates(environment, state) {
    if (state.kind === 'bailout') {
        return null;
    }
    var currentEpoch = environment.getStore().getEpoch();
    if (currentEpoch === state.epoch) {
        return null;
    }
    if (state.kind === 'singular') {
        var currentSnapshot = environment.lookup(state.snapshot.selector);
        var updatedData = recycleNodesInto(state.snapshot.data, currentSnapshot.data);
        var updatedCurrentSnapshot = {
            data: updatedData,
            isMissingData: currentSnapshot.isMissingData,
            missingClientEdges: currentSnapshot.missingClientEdges,
            missingLiveResolverFields: currentSnapshot.missingLiveResolverFields,
            seenRecords: currentSnapshot.seenRecords,
            selector: currentSnapshot.selector,
            fieldErrors: currentSnapshot.fieldErrors
        };
        return [
            updatedData !== state.snapshot.data,
            {
                kind: 'singular',
                snapshot: updatedCurrentSnapshot,
                epoch: currentEpoch
            }
        ];
    } else {
        var didMissUpdates = false;
        var currentSnapshots = [];
        for(var index = 0; index < state.snapshots.length; index++){
            var snapshot = state.snapshots[index];
            var _currentSnapshot = environment.lookup(snapshot.selector);
            var _updatedData = recycleNodesInto(snapshot.data, _currentSnapshot.data);
            var _updatedCurrentSnapshot = {
                data: _updatedData,
                isMissingData: _currentSnapshot.isMissingData,
                missingClientEdges: _currentSnapshot.missingClientEdges,
                missingLiveResolverFields: _currentSnapshot.missingLiveResolverFields,
                seenRecords: _currentSnapshot.seenRecords,
                selector: _currentSnapshot.selector,
                fieldErrors: _currentSnapshot.fieldErrors
            };
            if (_updatedData !== snapshot.data) {
                didMissUpdates = true;
            }
            currentSnapshots.push(_updatedCurrentSnapshot);
        }
        !(currentSnapshots.length === state.snapshots.length) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected same number of snapshots') : "TURBOPACK unreachable" : void 0;
        return [
            didMissUpdates,
            {
                kind: 'plural',
                snapshots: currentSnapshots,
                epoch: currentEpoch
            }
        ];
    }
}
function handleMissingClientEdge(environment, parentFragmentNode, parentFragmentRef, missingClientEdgeRequestInfo, queryOptions) {
    var originalVariables = getVariablesFromFragment(parentFragmentNode, parentFragmentRef);
    var variables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, originalVariables), {}, {
        id: missingClientEdgeRequestInfo.clientEdgeDestinationID
    });
    var queryOperationDescriptor = createOperationDescriptor(missingClientEdgeRequestInfo.request, variables, queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.networkCacheConfig);
    var QueryResource = getQueryResourceForEnvironment(environment);
    var queryResult = QueryResource.prepare(queryOperationDescriptor, fetchQueryInternal(environment, queryOperationDescriptor), queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.fetchPolicy);
    return [
        queryResult,
        getPromiseForActiveRequest(environment, queryOperationDescriptor.request)
    ];
}
function subscribeToSnapshot(environment, state, setState, hasPendingStateChanges) {
    if (state.kind === 'bailout') {
        return function() {};
    } else if (state.kind === 'singular') {
        var disposable = environment.subscribe(state.snapshot, function(latestSnapshot) {
            setState(function(prevState) {
                if (prevState.kind !== 'singular' || prevState.snapshot.selector !== latestSnapshot.selector) {
                    var updates = handleMissedUpdates(environment, prevState);
                    if (updates != null) {
                        var dataChanged = updates[0], nextState = updates[1];
                        environment.__log({
                            name: 'useFragment.subscription.missedUpdates',
                            hasDataChanges: dataChanged
                        });
                        hasPendingStateChanges.current = dataChanged;
                        return dataChanged ? nextState : prevState;
                    } else {
                        return prevState;
                    }
                }
                hasPendingStateChanges.current = true;
                return {
                    kind: 'singular',
                    snapshot: latestSnapshot,
                    epoch: environment.getStore().getEpoch()
                };
            });
        });
        return function() {
            disposable.dispose();
        };
    } else {
        var disposables = state.snapshots.map(function(snapshot, index) {
            return environment.subscribe(snapshot, function(latestSnapshot) {
                setState(function(prevState) {
                    var _prevState$snapshots$;
                    if (prevState.kind !== 'plural' || ((_prevState$snapshots$ = prevState.snapshots[index]) === null || _prevState$snapshots$ === void 0 ? void 0 : _prevState$snapshots$.selector) !== latestSnapshot.selector) {
                        var updates = handleMissedUpdates(environment, prevState);
                        if (updates != null) {
                            var dataChanged = updates[0], nextState = updates[1];
                            environment.__log({
                                name: 'useFragment.subscription.missedUpdates',
                                hasDataChanges: dataChanged
                            });
                            hasPendingStateChanges.current = hasPendingStateChanges.current || dataChanged;
                            return dataChanged ? nextState : prevState;
                        } else {
                            return prevState;
                        }
                    }
                    var updated = (0, _toConsumableArray2["default"])(prevState.snapshots);
                    updated[index] = latestSnapshot;
                    hasPendingStateChanges.current = true;
                    return {
                        kind: 'plural',
                        snapshots: updated,
                        epoch: environment.getStore().getEpoch()
                    };
                });
            });
        });
        return function() {
            var _iterator6 = (0, _createForOfIteratorHelper2["default"])(disposables), _step6;
            try {
                for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){
                    var d = _step6.value;
                    d.dispose();
                }
            } catch (err) {
                _iterator6.e(err);
            } finally{
                _iterator6.f();
            }
        };
    }
}
function getFragmentState(environment, fragmentSelector) {
    if (fragmentSelector == null) {
        return {
            kind: 'bailout'
        };
    } else if (fragmentSelector.kind === 'PluralReaderSelector') {
        return {
            kind: 'plural',
            snapshots: fragmentSelector.selectors.map(function(s) {
                return environment.lookup(s);
            }),
            epoch: environment.getStore().getEpoch()
        };
    } else {
        return {
            kind: 'singular',
            snapshot: environment.lookup(fragmentSelector),
            epoch: environment.getStore().getEpoch()
        };
    }
}
function useFragmentInternal(fragmentNode, fragmentRef, hookDisplayName, queryOptions) {
    var _fragmentNode$metadat, _fragmentNode$metadat2;
    var fragmentSelector = useMemo(function() {
        return getSelector(fragmentNode, fragmentRef);
    }, [
        fragmentNode,
        fragmentRef
    ]);
    var isPlural = (fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true;
    if (isPlural) {
        !(fragmentRef == null || Array.isArray(fragmentRef)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    } else {
        !!Array.isArray(fragmentRef) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` not to be ' + 'an array, instead got `%s`. Add `@relay(plural: true)` ' + 'to fragment `%s` to allow the prop to be an array.', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    }
    !(fragmentRef == null || isPlural && Array.isArray(fragmentRef) && fragmentRef.length === 0 || fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\n' + "- Forgetting to spread `%s` in `%s`'s parent's fragment.\n" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'This issue can generally be fixed by adding `@alias` after `...%s`.\n' + 'See https://relay.dev/docs/next/guides/alias-directive/', fragmentNode.name, fragmentNode.name, hookDisplayName, fragmentNode.name, hookDisplayName, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    var environment = useRelayEnvironment();
    var loggerContext;
    if (RelayFeatureFlags.ENABLE_UI_CONTEXT_ON_RELAY_LOGGER) {
        loggerContext = useRelayLoggingContext();
    }
    var _useState = useState(function() {
        return getFragmentState(environment, fragmentSelector);
    }), _state = _useState[0], setState = _useState[1];
    var state = _state;
    var _useState2 = useState(state), _subscribedState = _useState2[0], setSubscribedState = _useState2[1];
    var subscribedState = _subscribedState;
    var _useState3 = useState(fragmentSelector), previousFragmentSelector = _useState3[0], setPreviousFragmentSelector = _useState3[1];
    var _useState4 = useState(environment), previousEnvironment = _useState4[0], setPreviousEnvironment = _useState4[1];
    if (!areEqualSelectors(fragmentSelector, previousFragmentSelector) || environment !== previousEnvironment) {
        setPreviousFragmentSelector(fragmentSelector);
        setPreviousEnvironment(environment);
        var newState = getFragmentState(environment, fragmentSelector);
        setState(newState);
        setSubscribedState(newState);
        state = newState;
        subscribedState = newState;
    }
    var committedFragmentSelectorRef = useRef(false);
    useEffect(function() {
        committedFragmentSelectorRef.current = fragmentSelector;
    }, [
        fragmentSelector
    ]);
    if (((_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.hasClientEdges) === true || RelayFeatureFlags.CHECK_ALL_FRAGMENTS_FOR_MISSING_CLIENT_EDGES) {
        var _useMemo = useMemo(function() {
            var missingClientEdges = getMissingClientEdges(state);
            var clientEdgeQueries;
            var activeRequestPromises = [];
            if (missingClientEdges !== null && missingClientEdges !== void 0 && missingClientEdges.length) {
                clientEdgeQueries = [];
                var _iterator7 = (0, _createForOfIteratorHelper2["default"])(missingClientEdges), _step7;
                try {
                    for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){
                        var edge = _step7.value;
                        var _handleMissingClientE = handleMissingClientEdge(environment, fragmentNode, fragmentRef, edge, queryOptions), queryResult = _handleMissingClientE[0], requestPromise = _handleMissingClientE[1];
                        clientEdgeQueries.push(queryResult);
                        if (requestPromise != null) {
                            activeRequestPromises.push(requestPromise);
                        }
                    }
                } catch (err) {
                    _iterator7.e(err);
                } finally{
                    _iterator7.f();
                }
            }
            return [
                clientEdgeQueries,
                activeRequestPromises
            ];
        }, [
            state,
            environment,
            fragmentNode,
            fragmentRef,
            queryOptions
        ]), clientEdgeQueries = _useMemo[0], activeRequestPromises = _useMemo[1];
        if (activeRequestPromises.length) {
            throw Promise.all(activeRequestPromises);
        }
        useEffect(function() {
            var QueryResource = getQueryResourceForEnvironment(environment);
            if (clientEdgeQueries !== null && clientEdgeQueries !== void 0 && clientEdgeQueries.length) {
                var disposables = [];
                var _iterator8 = (0, _createForOfIteratorHelper2["default"])(clientEdgeQueries), _step8;
                try {
                    for(_iterator8.s(); !(_step8 = _iterator8.n()).done;){
                        var query = _step8.value;
                        disposables.push(QueryResource.retain(query));
                    }
                } catch (err) {
                    _iterator8.e(err);
                } finally{
                    _iterator8.f();
                }
                return function() {
                    for(var _i = 0, _disposables = disposables; _i < _disposables.length; _i++){
                        var disposable = _disposables[_i];
                        disposable.dispose();
                    }
                };
            }
        }, [
            environment,
            clientEdgeQueries
        ]);
    }
    if (isMissingData(state)) {
        var suspendingLiveResolvers = getSuspendingLiveResolver(state);
        if (suspendingLiveResolvers != null && suspendingLiveResolvers.length > 0) {
            throw Promise.all(suspendingLiveResolvers.map(function(liveStateID) {
                return environment.getStore().getLiveResolverPromise(liveStateID);
            }));
        }
        if (RelayFeatureFlags.ENABLE_RELAY_OPERATION_TRACKER_SUSPENSE || environment !== previousEnvironment || !committedFragmentSelectorRef.current || !areEqualSelectors(committedFragmentSelectorRef.current, fragmentSelector)) {
            !(fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'refinement, see invariants above') : "TURBOPACK unreachable" : void 0;
            var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;
            var pendingOperationsResult = getPendingOperationsForFragment(environment, fragmentNode, fragmentOwner);
            if (pendingOperationsResult) {
                throw pendingOperationsResult.promise;
            }
        }
    }
    handlePotentialSnapshotErrorsForState(environment, state, loggerContext);
    var hasPendingStateChanges = useRef(false);
    useEffect(function() {
        var currentState = subscribedState;
        var updates = handleMissedUpdates(environment, subscribedState);
        if (updates !== null) {
            var didMissUpdates = updates[0], updatedState = updates[1];
            if (didMissUpdates) {
                setState(updatedState);
            }
            currentState = updatedState;
        }
        return subscribeToSnapshot(environment, currentState, setState, hasPendingStateChanges);
    }, [
        environment,
        subscribedState
    ]);
    if (hasPendingStateChanges.current) {
        var updates = handleMissedUpdates(environment, state);
        if (updates != null) {
            var hasStateUpdates = updates[0], updatedState = updates[1];
            if (hasStateUpdates) {
                setState(updatedState);
                state = updatedState;
            }
        }
        hasPendingStateChanges.current = false;
    }
    var data;
    if (isPlural) {
        var fragmentRefIsNullish = fragmentRef == null;
        data = useMemo(function() {
            if (state.kind === 'bailout') {
                return fragmentRefIsNullish ? null : [];
            } else {
                !(state.kind === 'plural') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected state to be plural because fragment is plural') : "TURBOPACK unreachable" : void 0;
                return state.snapshots.map(function(s) {
                    return s.data;
                });
            }
        }, [
            state,
            fragmentRefIsNullish
        ]);
    } else if (state.kind === 'bailout') {
        data = null;
    } else {
        !(state.kind === 'singular') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected state to be singular because fragment is singular') : "TURBOPACK unreachable" : void 0;
        data = state.snapshot.data;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (fragmentRef != null && (data === undefined || Array.isArray(data) && data.length > 0 && data.every(function(d) {
            return d === undefined;
        }))) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected to have been able to read non-null data for ' + 'fragment `%s` declared in ' + '`%s`, since fragment reference was non-null. ' + "Make sure that that `%s`'s parent isn't " + 'holding on to and/or passing a fragment reference for data that ' + 'has been deleted.', fragmentNode.name, hookDisplayName, hookDisplayName) : "TURBOPACK unreachable";
        }
    }
    if ("TURBOPACK compile-time truthy", 1) {
        useDebugValue({
            fragment: fragmentNode.name,
            data: data
        });
    }
    return data;
}
module.exports = useFragmentInternal;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal_EXPERIMENTAL.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-ssr] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/QueryResource.js [app-ssr] (ecmascript)"), getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var useRelayLoggingContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayLoggingContext.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useDebugValue = _require2.useDebugValue, useEffect = _require2.useEffect, useMemo = _require2.useMemo, useRef = _require2.useRef, useState = _require2.useState;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), _require3$__internal = _require3.__internal, fetchQueryInternal = _require3$__internal.fetchQuery, getPromiseForActiveRequest = _require3$__internal.getPromiseForActiveRequest, RelayFeatureFlags = _require3.RelayFeatureFlags, areEqualSelectors = _require3.areEqualSelectors, createOperationDescriptor = _require3.createOperationDescriptor, getPendingOperationsForFragment = _require3.getPendingOperationsForFragment, getSelector = _require3.getSelector, getVariablesFromFragment = _require3.getVariablesFromFragment, handlePotentialSnapshotErrors = _require3.handlePotentialSnapshotErrors, recycleNodesInto = _require3.recycleNodesInto;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function isMissingData(state) {
    if (state.kind === 'bailout') {
        return false;
    } else if (state.kind === 'singular') {
        return state.snapshot.isMissingData;
    } else {
        return state.snapshots.some(function(s) {
            return s.isMissingData;
        });
    }
}
function getMissingClientEdges(state) {
    if (state.kind === 'bailout') {
        return null;
    } else if (state.kind === 'singular') {
        var _state$snapshot$missi;
        return (_state$snapshot$missi = state.snapshot.missingClientEdges) !== null && _state$snapshot$missi !== void 0 ? _state$snapshot$missi : null;
    } else {
        var edges = null;
        var _iterator = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var snapshot = _step.value;
                if (snapshot.missingClientEdges) {
                    var _edges;
                    edges = (_edges = edges) !== null && _edges !== void 0 ? _edges : [];
                    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(snapshot.missingClientEdges), _step2;
                    try {
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                            var edge = _step2.value;
                            edges.push(edge);
                        }
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        return edges;
    }
}
function getSuspendingLiveResolver(state) {
    if (state.kind === 'bailout') {
        return null;
    } else if (state.kind === 'singular') {
        var _state$snapshot$missi2;
        return (_state$snapshot$missi2 = state.snapshot.missingLiveResolverFields) !== null && _state$snapshot$missi2 !== void 0 ? _state$snapshot$missi2 : null;
    } else {
        var missingFields = null;
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var snapshot = _step3.value;
                if (snapshot.missingLiveResolverFields) {
                    var _missingFields;
                    missingFields = (_missingFields = missingFields) !== null && _missingFields !== void 0 ? _missingFields : [];
                    var _iterator4 = (0, _createForOfIteratorHelper2["default"])(snapshot.missingLiveResolverFields), _step4;
                    try {
                        for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                            var edge = _step4.value;
                            missingFields.push(edge);
                        }
                    } catch (err) {
                        _iterator4.e(err);
                    } finally{
                        _iterator4.f();
                    }
                }
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
        return missingFields;
    }
}
function handlePotentialSnapshotErrorsForState(environment, state, loggingContext) {
    if (state.kind === 'singular') {
        handlePotentialSnapshotErrors(environment, state.snapshot.fieldErrors, loggingContext);
    } else if (state.kind === 'plural') {
        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step5;
        try {
            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                var snapshot = _step5.value;
                handlePotentialSnapshotErrors(environment, snapshot.fieldErrors, loggingContext);
            }
        } catch (err) {
            _iterator5.e(err);
        } finally{
            _iterator5.f();
        }
    }
}
function handleMissedUpdates(environment, state) {
    if (state.kind === 'bailout') {
        return null;
    }
    var currentEpoch = environment.getStore().getEpoch();
    if (currentEpoch === state.epoch) {
        return null;
    }
    if (state.kind === 'singular') {
        var currentSnapshot = environment.lookup(state.snapshot.selector);
        var updatedData = recycleNodesInto(state.snapshot.data, currentSnapshot.data);
        var updatedCurrentSnapshot = {
            data: updatedData,
            isMissingData: currentSnapshot.isMissingData,
            missingClientEdges: currentSnapshot.missingClientEdges,
            missingLiveResolverFields: currentSnapshot.missingLiveResolverFields,
            seenRecords: currentSnapshot.seenRecords,
            selector: currentSnapshot.selector,
            fieldErrors: currentSnapshot.fieldErrors
        };
        return [
            updatedData !== state.snapshot.data,
            {
                kind: 'singular',
                snapshot: updatedCurrentSnapshot,
                epoch: currentEpoch,
                selector: state.selector,
                environment: state.environment
            }
        ];
    } else {
        var didMissUpdates = false;
        var currentSnapshots = [];
        for(var index = 0; index < state.snapshots.length; index++){
            var snapshot = state.snapshots[index];
            var _currentSnapshot = environment.lookup(snapshot.selector);
            var _updatedData = recycleNodesInto(snapshot.data, _currentSnapshot.data);
            var _updatedCurrentSnapshot = {
                data: _updatedData,
                isMissingData: _currentSnapshot.isMissingData,
                missingClientEdges: _currentSnapshot.missingClientEdges,
                missingLiveResolverFields: _currentSnapshot.missingLiveResolverFields,
                seenRecords: _currentSnapshot.seenRecords,
                selector: _currentSnapshot.selector,
                fieldErrors: _currentSnapshot.fieldErrors
            };
            if (_updatedData !== snapshot.data) {
                didMissUpdates = true;
            }
            currentSnapshots.push(_updatedCurrentSnapshot);
        }
        !(currentSnapshots.length === state.snapshots.length) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected same number of snapshots') : "TURBOPACK unreachable" : void 0;
        return [
            didMissUpdates,
            {
                kind: 'plural',
                snapshots: currentSnapshots,
                epoch: currentEpoch,
                selector: state.selector,
                environment: state.environment
            }
        ];
    }
}
function handleMissingClientEdge(environment, parentFragmentNode, parentFragmentRef, missingClientEdgeRequestInfo, queryOptions) {
    var originalVariables = getVariablesFromFragment(parentFragmentNode, parentFragmentRef);
    var variables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, originalVariables), {}, {
        id: missingClientEdgeRequestInfo.clientEdgeDestinationID
    });
    var queryOperationDescriptor = createOperationDescriptor(missingClientEdgeRequestInfo.request, variables, queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.networkCacheConfig);
    var QueryResource = getQueryResourceForEnvironment(environment);
    var queryResult = QueryResource.prepare(queryOperationDescriptor, fetchQueryInternal(environment, queryOperationDescriptor), queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.fetchPolicy);
    var promise = getPromiseForActiveRequest(environment, queryOperationDescriptor.request);
    if (promise != null && promise.displayName == null) {
        promise.displayName = missingClientEdgeRequestInfo.request.params.name;
    }
    return [
        queryResult,
        promise
    ];
}
function subscribeToSnapshot(environment, state, setState) {
    if (state.kind === 'bailout') {
        return function() {};
    } else if (state.kind === 'singular') {
        var disposable = environment.subscribe(state.snapshot, function(latestSnapshot) {
            setState(function(prevState) {
                var nextState = null;
                if (prevState.kind !== 'singular' || prevState.snapshot.selector !== latestSnapshot.selector || prevState.environment !== environment) {
                    var updates = handleMissedUpdates(prevState.environment, prevState);
                    if (updates != null) {
                        var dataChanged = updates[0], updatedState = updates[1];
                        environment.__log({
                            name: 'useFragment.subscription.missedUpdates',
                            hasDataChanges: dataChanged
                        });
                        nextState = dataChanged ? updatedState : prevState;
                    } else {
                        nextState = prevState;
                    }
                } else {
                    nextState = {
                        kind: 'singular',
                        snapshot: latestSnapshot,
                        epoch: environment.getStore().getEpoch(),
                        selector: state.selector,
                        environment: state.environment
                    };
                }
                return nextState;
            });
        });
        return function() {
            disposable.dispose();
        };
    } else {
        var disposables = state.snapshots.map(function(snapshot, index) {
            return environment.subscribe(snapshot, function(latestSnapshot) {
                setState(function(prevState) {
                    var _prevState$snapshots$;
                    var nextState = null;
                    if (prevState.kind !== 'plural' || ((_prevState$snapshots$ = prevState.snapshots[index]) === null || _prevState$snapshots$ === void 0 ? void 0 : _prevState$snapshots$.selector) !== latestSnapshot.selector || prevState.environment !== environment) {
                        var updates = handleMissedUpdates(prevState.environment, prevState);
                        if (updates != null) {
                            var dataChanged = updates[0], updatedState = updates[1];
                            environment.__log({
                                name: 'useFragment.subscription.missedUpdates',
                                hasDataChanges: dataChanged
                            });
                            nextState = dataChanged ? updatedState : prevState;
                        } else {
                            nextState = prevState;
                        }
                    } else {
                        var updated = (0, _toConsumableArray2["default"])(prevState.snapshots);
                        updated[index] = latestSnapshot;
                        nextState = {
                            kind: 'plural',
                            snapshots: updated,
                            epoch: environment.getStore().getEpoch(),
                            selector: state.selector,
                            environment: state.environment
                        };
                    }
                    return nextState;
                });
            });
        });
        return function() {
            var _iterator6 = (0, _createForOfIteratorHelper2["default"])(disposables), _step6;
            try {
                for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){
                    var d = _step6.value;
                    d.dispose();
                }
            } catch (err) {
                _iterator6.e(err);
            } finally{
                _iterator6.f();
            }
        };
    }
}
function getFragmentState(environment, fragmentSelector) {
    if (fragmentSelector == null) {
        return {
            kind: 'bailout',
            environment: environment
        };
    } else if (fragmentSelector.kind === 'PluralReaderSelector') {
        return {
            kind: 'plural',
            snapshots: fragmentSelector.selectors.map(function(s) {
                return environment.lookup(s);
            }),
            epoch: environment.getStore().getEpoch(),
            selector: fragmentSelector,
            environment: environment
        };
    } else {
        return {
            kind: 'singular',
            snapshot: environment.lookup(fragmentSelector),
            epoch: environment.getStore().getEpoch(),
            selector: fragmentSelector,
            environment: environment
        };
    }
}
function useFragmentInternal_EXPERIMENTAL(fragmentNode, fragmentRef, hookDisplayName, queryOptions) {
    var _fragmentNode$metadat, _fragmentNode$metadat2;
    var fragmentSelector = useMemo(function() {
        return getSelector(fragmentNode, fragmentRef);
    }, [
        fragmentNode,
        fragmentRef
    ]);
    var isPlural = (fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true;
    if (isPlural) {
        !(fragmentRef == null || Array.isArray(fragmentRef)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    } else {
        !!Array.isArray(fragmentRef) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` not to be ' + 'an array, instead got `%s`. Add `@relay(plural: true)` ' + 'to fragment `%s` to allow the prop to be an array.', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    }
    !(fragmentRef == null || isPlural && Array.isArray(fragmentRef) && fragmentRef.length === 0 || fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\n' + "- Forgetting to spread `%s` in `%s`'s parent's fragment.\n" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread - then the fragment reference will not exist. ' + 'This issue can generally be fixed by adding `@alias` after `...%s`.\n' + 'See https://relay.dev/docs/next/guides/alias-directive/', fragmentNode.name, fragmentNode.name, hookDisplayName, fragmentNode.name, hookDisplayName) : "TURBOPACK unreachable" : void 0;
    var environment = useRelayEnvironment();
    var loggerContext;
    if (RelayFeatureFlags.ENABLE_UI_CONTEXT_ON_RELAY_LOGGER) {
        loggerContext = useRelayLoggingContext();
    }
    var _useState = useState(function() {
        return getFragmentState(environment, fragmentSelector);
    }), _state = _useState[0], setState = _useState[1];
    var state = _state;
    var previousEnvironment = state.environment;
    if (!areEqualSelectors(fragmentSelector, state.selector) || environment !== state.environment) {
        var newState = getFragmentState(environment, fragmentSelector);
        setState(newState);
        state = newState;
    }
    var committedFragmentSelectorRef = useRef(false);
    useEffect(function() {
        committedFragmentSelectorRef.current = fragmentSelector;
    }, [
        fragmentSelector
    ]);
    if (((_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.hasClientEdges) === true || RelayFeatureFlags.CHECK_ALL_FRAGMENTS_FOR_MISSING_CLIENT_EDGES) {
        var _useMemo = useMemo(function() {
            var missingClientEdges = getMissingClientEdges(state);
            var clientEdgeQueries;
            var activeRequestPromises = [];
            if (missingClientEdges !== null && missingClientEdges !== void 0 && missingClientEdges.length) {
                clientEdgeQueries = [];
                var _iterator7 = (0, _createForOfIteratorHelper2["default"])(missingClientEdges), _step7;
                try {
                    for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){
                        var edge = _step7.value;
                        var _handleMissingClientE = handleMissingClientEdge(environment, fragmentNode, fragmentRef, edge, queryOptions), queryResult = _handleMissingClientE[0], requestPromise = _handleMissingClientE[1];
                        clientEdgeQueries.push(queryResult);
                        if (requestPromise != null) {
                            activeRequestPromises.push(requestPromise);
                        }
                    }
                } catch (err) {
                    _iterator7.e(err);
                } finally{
                    _iterator7.f();
                }
            }
            return [
                clientEdgeQueries,
                activeRequestPromises
            ];
        }, [
            state,
            environment,
            fragmentNode,
            fragmentRef,
            queryOptions
        ]), clientEdgeQueries = _useMemo[0], activeRequestPromises = _useMemo[1];
        if (activeRequestPromises.length) {
            var allPromises = Promise.all(activeRequestPromises);
            allPromises.displayName = "RelayClientEdge(".concat(activeRequestPromises.map(function(promise) {
                return promise.displayName;
            }).join(','), ")");
            throw allPromises;
        }
        useEffect(function() {
            var QueryResource = getQueryResourceForEnvironment(environment);
            if (clientEdgeQueries !== null && clientEdgeQueries !== void 0 && clientEdgeQueries.length) {
                var disposables = [];
                var _iterator8 = (0, _createForOfIteratorHelper2["default"])(clientEdgeQueries), _step8;
                try {
                    for(_iterator8.s(); !(_step8 = _iterator8.n()).done;){
                        var query = _step8.value;
                        disposables.push(QueryResource.retain(query));
                    }
                } catch (err) {
                    _iterator8.e(err);
                } finally{
                    _iterator8.f();
                }
                return function() {
                    for(var _i = 0, _disposables = disposables; _i < _disposables.length; _i++){
                        var disposable = _disposables[_i];
                        disposable.dispose();
                    }
                };
            }
        }, [
            environment,
            clientEdgeQueries
        ]);
    }
    if (isMissingData(state)) {
        var suspendingLiveResolvers = getSuspendingLiveResolver(state);
        if (suspendingLiveResolvers != null && suspendingLiveResolvers.length > 0) {
            var promise = Promise.all(suspendingLiveResolvers.map(function(liveStateID) {
                return environment.getStore().getLiveResolverPromise(liveStateID);
            }));
            promise.displayName = 'RelayLiveResolver(' + fragmentNode.name + ')';
            throw promise;
        }
        if (RelayFeatureFlags.ENABLE_RELAY_OPERATION_TRACKER_SUSPENSE || environment !== previousEnvironment || !committedFragmentSelectorRef.current || !areEqualSelectors(committedFragmentSelectorRef.current, fragmentSelector)) {
            !(fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'refinement, see invariants above') : "TURBOPACK unreachable" : void 0;
            var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;
            var pendingOperationsResult = getPendingOperationsForFragment(environment, fragmentNode, fragmentOwner);
            if (pendingOperationsResult) {
                throw pendingOperationsResult.promise;
            }
        }
    }
    handlePotentialSnapshotErrorsForState(environment, state, loggerContext);
    var storeSubscriptionRef = useRef(null);
    useEffect(function() {
        var storeSubscription = storeSubscriptionRef.current;
        if (storeSubscription != null) {
            if (state.environment === storeSubscription.environment && state.selector === storeSubscription.selector) {
                return;
            } else {
                storeSubscription.dispose();
            }
        }
        if (state.kind === 'bailout') {
            return;
        }
        var stateForSubscription = state;
        var updates = handleMissedUpdates(state.environment, state);
        if (updates !== null) {
            var didMissUpdates = updates[0], updatedState = updates[1];
            if (didMissUpdates) {
                setState(updatedState);
                return;
            }
            stateForSubscription = updatedState;
        }
        var dispose = subscribeToSnapshot(state.environment, stateForSubscription, setState);
        storeSubscriptionRef.current = {
            dispose: dispose,
            selector: state.selector,
            environment: state.environment
        };
    }, [
        state
    ]);
    useEffect(function() {
        if (storeSubscriptionRef.current == null && state.kind !== 'bailout') {
            var dispose = subscribeToSnapshot(state.environment, state, setState);
            storeSubscriptionRef.current = {
                dispose: dispose,
                selector: state.selector,
                environment: state.environment
            };
        }
        return function() {
            var _storeSubscriptionRef;
            (_storeSubscriptionRef = storeSubscriptionRef.current) === null || _storeSubscriptionRef === void 0 ? void 0 : _storeSubscriptionRef.dispose();
            storeSubscriptionRef.current = null;
        };
    }, []);
    var data;
    if (isPlural) {
        var fragmentRefIsNullish = fragmentRef == null;
        data = useMemo(function() {
            if (state.kind === 'bailout') {
                return fragmentRefIsNullish ? null : [];
            } else {
                !(state.kind === 'plural') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected state to be plural because fragment is plural') : "TURBOPACK unreachable" : void 0;
                return state.snapshots.map(function(s) {
                    return s.data;
                });
            }
        }, [
            state,
            fragmentRefIsNullish
        ]);
    } else if (state.kind === 'bailout') {
        data = null;
    } else {
        !(state.kind === 'singular') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected state to be singular because fragment is singular') : "TURBOPACK unreachable" : void 0;
        data = state.snapshot.data;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (fragmentRef != null && (data === undefined || Array.isArray(data) && data.length > 0 && data.every(function(d) {
            return d === undefined;
        }))) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected to have been able to read non-null data for ' + 'fragment `%s` declared in ' + '`%s`, since fragment reference was non-null. ' + "Make sure that that `%s`'s parent isn't " + 'holding on to and/or passing a fragment reference for data that ' + 'has been deleted.', fragmentNode.name, hookDisplayName, hookDisplayName) : "TURBOPACK unreachable";
        }
    }
    if ("TURBOPACK compile-time truthy", 1) {
        useDebugValue({
            fragment: fragmentNode.name,
            data: data
        });
    }
    return data;
}
module.exports = useFragmentInternal_EXPERIMENTAL;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _useFragmentInternal_CURRENT = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal_CURRENT.js [app-ssr] (ecmascript)"));
var _useFragmentInternal_EXPERIMENTAL = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal_EXPERIMENTAL.js [app-ssr] (ecmascript)"));
var _relayRuntime = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)");
function useFragmentInternal(fragmentNode, fragmentRef, hookDisplayName, queryOptions) {
    if (_relayRuntime.RelayFeatureFlags.ENABLE_ACTIVITY_COMPATIBILITY) {
        return (0, _useFragmentInternal_EXPERIMENTAL["default"])(fragmentNode, fragmentRef, hookDisplayName, queryOptions);
    }
    return (0, _useFragmentInternal_CURRENT["default"])(fragmentNode, fragmentRef, hookDisplayName, queryOptions);
}
module.exports = useFragmentInternal;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useUnsafeRef_DEPRECATED.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useMemo = _require.useMemo;
function useUnsafeRef_DEPRECATED(init) {
    return useMemo(function() {
        return {
            current: init
        };
    }, []);
}
module.exports = useUnsafeRef_DEPRECATED;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useStaticFragmentNodeWarning.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useUnsafeRef_DEPRECATED = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useUnsafeRef_DEPRECATED.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function useStaticFragmentNodeWarning(fragmentNode, warningContext) {
    if ("TURBOPACK compile-time truthy", 1) {
        var initialPropRef = useUnsafeRef_DEPRECATED(fragmentNode.name);
        ("TURBOPACK compile-time truthy", 1) ? warning(initialPropRef.current === fragmentNode.name, 'Relay: The %s has to remain the same over the lifetime of a component. ' + 'Changing it is not supported and will result in unexpected behavior.', warningContext) : "TURBOPACK unreachable";
    }
}
module.exports = useStaticFragmentNodeWarning;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useFragment.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useFragmentInternal = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal.js [app-ssr] (ecmascript)");
var useStaticFragmentNodeWarning = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useStaticFragmentNodeWarning.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useDebugValue = _require.useDebugValue;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), getFragment = _require2.getFragment;
function useFragment(fragment, key) {
    var fragmentNode = getFragment(fragment);
    useStaticFragmentNodeWarning(fragmentNode, 'first argument of useFragment()');
    var data = useFragmentInternal(fragmentNode, key, 'useFragment()');
    if ("TURBOPACK compile-time truthy", 1) {
        useDebugValue({
            fragment: fragmentNode.name,
            data: data
        });
    }
    return data;
}
module.exports = useFragment;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useFetchTrackingRef.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useUnsafeRef_DEPRECATED = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useUnsafeRef_DEPRECATED.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useCallback = _require.useCallback, useEffect = _require.useEffect;
function useFetchTrackingRef() {
    var subscriptionRef = useUnsafeRef_DEPRECATED(null);
    var isFetchingRef = useUnsafeRef_DEPRECATED(false);
    var disposeFetch = useCallback(function() {
        if (subscriptionRef.current != null) {
            subscriptionRef.current.unsubscribe();
            subscriptionRef.current = null;
        }
        isFetchingRef.current = false;
    }, []);
    var startFetch = useCallback(function(subscription) {
        subscriptionRef.current = subscription;
        isFetchingRef.current = true;
    }, []);
    var completeFetch = useCallback(function() {
        subscriptionRef.current = null;
        isFetchingRef.current = false;
    }, []);
    useEffect(function() {
        return disposeFetch;
    }, [
        disposeFetch
    ]);
    return {
        isFetchingRef: isFetchingRef,
        startFetch: startFetch,
        disposeFetch: disposeFetch,
        completeFetch: completeFetch
    };
}
module.exports = useFetchTrackingRef;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useLazyLoadQueryNode.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ProfilerContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/ProfilerContext.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/QueryResource.js [app-ssr] (ecmascript)"), getQueryCacheIdentifier = _require.getQueryCacheIdentifier, getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;
var useFetchTrackingRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFetchTrackingRef.js [app-ssr] (ecmascript)");
var useFragmentInternal = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal.js [app-ssr] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var useContext = React.useContext, useEffect = React.useEffect, useState = React.useState, useRef = React.useRef;
function useLazyLoadQueryNode(_ref) {
    var query = _ref.query, componentDisplayName = _ref.componentDisplayName, fetchObservable = _ref.fetchObservable, fetchPolicy = _ref.fetchPolicy, fetchKey = _ref.fetchKey, renderPolicy = _ref.renderPolicy;
    var environment = useRelayEnvironment();
    var profilerContext = useContext(ProfilerContext);
    var QueryResource = getQueryResourceForEnvironment(environment);
    var _useState = useState(0), forceUpdateKey = _useState[0], forceUpdate = _useState[1];
    var _useFetchTrackingRef = useFetchTrackingRef(), startFetch = _useFetchTrackingRef.startFetch, completeFetch = _useFetchTrackingRef.completeFetch;
    var cacheBreaker = "".concat(forceUpdateKey, "-").concat(fetchKey !== null && fetchKey !== void 0 ? fetchKey : '');
    var cacheIdentifier = getQueryCacheIdentifier(environment, query, fetchPolicy, renderPolicy, cacheBreaker);
    var preparedQueryResult = profilerContext.wrapPrepareQueryResource(function() {
        return QueryResource.prepareWithIdentifier(cacheIdentifier, query, fetchObservable, fetchPolicy, renderPolicy, {
            start: startFetch,
            complete: completeFetch,
            error: completeFetch
        }, profilerContext);
    });
    var maybeHiddenOrFastRefresh = useRef(false);
    useEffect(function() {
        return function() {
            maybeHiddenOrFastRefresh.current = true;
        };
    }, []);
    useEffect(function() {
        if (maybeHiddenOrFastRefresh.current === true) {
            maybeHiddenOrFastRefresh.current = false;
            forceUpdate(function(n) {
                return n + 1;
            });
            return;
        }
        var disposable = QueryResource.retain(preparedQueryResult, profilerContext);
        return function() {
            disposable.dispose();
        };
    }, [
        environment,
        cacheIdentifier
    ]);
    useEffect(function() {
        QueryResource.releaseTemporaryRetain(preparedQueryResult);
    });
    var fragmentNode = preparedQueryResult.fragmentNode, fragmentRef = preparedQueryResult.fragmentRef;
    var data = useFragmentInternal(fragmentNode, fragmentRef, componentDisplayName);
    return data;
}
module.exports = useLazyLoadQueryNode;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useMemoVariables.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useState = _require.useState;
function useMemoVariables(variables) {
    var _useState = useState(variables), mirroredVariables = _useState[0], setMirroredVariables = _useState[1];
    if (areEqual(variables, mirroredVariables)) {
        return mirroredVariables;
    } else {
        setMirroredVariables(variables);
        return variables;
    }
}
module.exports = useMemoVariables;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useMemoOperationDescriptor.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useMemoVariables = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useMemoVariables.js [app-ssr] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), createOperationDescriptor = _require.createOperationDescriptor, getRequest = _require.getRequest;
var useMemo = React.useMemo;
function useMemoOperationDescriptor(gqlQuery, variables, cacheConfig) {
    var memoVariables = useMemoVariables(variables);
    var memoCacheConfig = useMemoVariables(cacheConfig || {});
    return useMemo(function() {
        return createOperationDescriptor(getRequest(gqlQuery), memoVariables, memoCacheConfig);
    }, [
        gqlQuery,
        memoVariables,
        memoCacheConfig
    ]);
}
module.exports = useMemoOperationDescriptor;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useLazyLoadQuery.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useLazyLoadQueryNode = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useLazyLoadQueryNode.js [app-ssr] (ecmascript)");
var useMemoOperationDescriptor = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useMemoOperationDescriptor.js [app-ssr] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), fetchQuery = _require.__internal.fetchQuery;
function useLazyLoadQuery(gqlQuery, variables, options) {
    var environment = useRelayEnvironment();
    var query = useMemoOperationDescriptor(gqlQuery, variables, options && options.networkCacheConfig ? options.networkCacheConfig : {
        force: true
    });
    var data = useLazyLoadQueryNode({
        componentDisplayName: 'useLazyLoadQuery()',
        fetchKey: options === null || options === void 0 ? void 0 : options.fetchKey,
        fetchObservable: fetchQuery(environment, query),
        fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
        query: query,
        renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
    });
    return data;
}
module.exports = useLazyLoadQuery;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useMutation.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-ssr] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), defaultCommitMutation = _require.commitMutation;
var useState = React.useState, useEffect = React.useEffect, useRef = React.useRef, useCallback = React.useCallback;
function useMutation(mutation) {
    var commitMutationFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultCommitMutation;
    var environment = useRelayEnvironment();
    var isMountedRef = useIsMountedRef();
    var environmentRef = useRef(environment);
    var mutationRef = useRef(mutation);
    var inFlightMutationsRef = useRef(new Set());
    var _useState = useState(false), isMutationInFlight = _useState[0], setMutationInFlight = _useState[1];
    var cleanup = useCallback(function(disposable) {
        if (environmentRef.current === environment && mutationRef.current === mutation) {
            inFlightMutationsRef.current["delete"](disposable);
            if (isMountedRef.current) {
                setMutationInFlight(inFlightMutationsRef.current.size > 0);
            }
        }
    }, [
        environment,
        isMountedRef,
        mutation
    ]);
    useEffect(function() {
        if (environmentRef.current !== environment || mutationRef.current !== mutation) {
            inFlightMutationsRef.current = new Set();
            if (isMountedRef.current) {
                setMutationInFlight(false);
            }
            environmentRef.current = environment;
            mutationRef.current = mutation;
        }
    }, [
        environment,
        isMountedRef,
        mutation
    ]);
    var commit = useCallback(function(config) {
        if (isMountedRef.current) {
            setMutationInFlight(true);
        }
        var disposable = commitMutationFn(environment, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, config), {}, {
            mutation: mutation,
            onCompleted: function onCompleted(response, errors) {
                var _config$onCompleted;
                cleanup(disposable);
                (_config$onCompleted = config.onCompleted) === null || _config$onCompleted === void 0 ? void 0 : _config$onCompleted.call(config, response, errors);
            },
            onError: function onError(error) {
                var _config$onError;
                cleanup(disposable);
                (_config$onError = config.onError) === null || _config$onError === void 0 ? void 0 : _config$onError.call(config, error);
            },
            onUnsubscribe: function onUnsubscribe() {
                var _config$onUnsubscribe;
                cleanup(disposable);
                (_config$onUnsubscribe = config.onUnsubscribe) === null || _config$onUnsubscribe === void 0 ? void 0 : _config$onUnsubscribe.call(config);
            },
            onNext: function onNext() {
                var _config$onNext;
                (_config$onNext = config.onNext) === null || _config$onNext === void 0 ? void 0 : _config$onNext.call(config);
            }
        }));
        inFlightMutationsRef.current.add(disposable);
        return disposable;
    }, [
        cleanup,
        commitMutationFn,
        environment,
        isMountedRef,
        mutation
    ]);
    return [
        commit,
        isMutationInFlight
    ];
}
module.exports = useMutation;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/getConnectionState.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), ConnectionInterface = _require.ConnectionInterface, getValueAtPath = _require.getValueAtPath;
function getConnectionState(direction, fragmentNode, fragmentData, connectionPathInFragmentData) {
    var _pageInfo$END_CURSOR, _pageInfo$START_CURSO;
    var _ConnectionInterface$ = ConnectionInterface.get(), EDGES = _ConnectionInterface$.EDGES, PAGE_INFO = _ConnectionInterface$.PAGE_INFO, HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE, HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE, END_CURSOR = _ConnectionInterface$.END_CURSOR, START_CURSOR = _ConnectionInterface$.START_CURSOR;
    var connection = getValueAtPath(fragmentData, connectionPathInFragmentData);
    if (connection == null) {
        return {
            cursor: null,
            hasMore: false
        };
    }
    !(typeof connection === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected connection in fragment `%s` to have been `null`, or ' + 'a plain object with %s and %s properties. Instead got `%s`.', fragmentNode.name, EDGES, PAGE_INFO, connection) : "TURBOPACK unreachable" : void 0;
    var edges = connection[EDGES];
    var pageInfo = connection[PAGE_INFO];
    if (edges == null || pageInfo == null) {
        return {
            cursor: null,
            hasMore: false
        };
    }
    !Array.isArray(edges) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected connection in fragment `%s` to have a plural `%s` field. ' + 'Instead got `%s`.', fragmentNode.name, EDGES, edges) : "TURBOPACK unreachable" : void 0;
    !(typeof pageInfo === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected connection in fragment `%s` to have a `%s` field. ' + 'Instead got `%s`.', fragmentNode.name, PAGE_INFO, pageInfo) : "TURBOPACK unreachable" : void 0;
    var cursor = direction === 'forward' ? (_pageInfo$END_CURSOR = pageInfo[END_CURSOR]) !== null && _pageInfo$END_CURSOR !== void 0 ? _pageInfo$END_CURSOR : null : (_pageInfo$START_CURSO = pageInfo[START_CURSOR]) !== null && _pageInfo$START_CURSO !== void 0 ? _pageInfo$START_CURSO : null;
    !(cursor === null || typeof cursor === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected page info for connection in fragment `%s` to have a ' + 'valid `%s`. Instead got `%s`.', fragmentNode.name, START_CURSOR, cursor) : "TURBOPACK unreachable" : void 0;
    var hasMore;
    if (direction === 'forward') {
        hasMore = cursor != null && pageInfo[HAS_NEXT_PAGE] === true;
    } else {
        hasMore = cursor != null && pageInfo[HAS_PREV_PAGE] === true;
    }
    return {
        cursor: cursor,
        hasMore: hasMore
    };
}
module.exports = getConnectionState;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useIsOperationNodeActive.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), getObservableForActiveRequest = _require.__internal.getObservableForActiveRequest, getSelector = _require.getSelector;
var useEffect = React.useEffect, useState = React.useState, useMemo = React.useMemo;
function useIsOperationNodeActive(fragmentNode, fragmentRef) {
    var environment = useRelayEnvironment();
    var observable = useMemo(function() {
        var selector = getSelector(fragmentNode, fragmentRef);
        if (selector == null) {
            return null;
        }
        !(selector.kind === 'SingularReaderSelector') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'useIsOperationNodeActive: Plural fragments are not supported.') : "TURBOPACK unreachable" : void 0;
        return getObservableForActiveRequest(environment, selector.owner);
    }, [
        environment,
        fragmentNode,
        fragmentRef
    ]);
    var _useState = useState(observable != null), isActive = _useState[0], setIsActive = _useState[1];
    useEffect(function() {
        var subscription;
        setIsActive(observable != null);
        if (observable != null) {
            var onCompleteOrError = function onCompleteOrError() {
                setIsActive(false);
            };
            subscription = observable.subscribe({
                complete: onCompleteOrError,
                error: onCompleteOrError
            });
        }
        return function() {
            if (subscription) {
                subscription.unsubscribe();
            }
        };
    }, [
        observable
    ]);
    return isActive;
}
module.exports = useIsOperationNodeActive;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useLoadMoreFunction_EXPERIMENTAL.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var getConnectionState = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/getConnectionState.js [app-ssr] (ecmascript)");
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-ssr] (ecmascript)");
var useIsOperationNodeActive = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsOperationNodeActive.js [app-ssr] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useCallback = _require.useCallback, useRef = _require.useRef, useState = _require.useState;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), fetchQuery = _require2.__internal.fetchQuery, createOperationDescriptor = _require2.createOperationDescriptor, getPaginationVariables = _require2.getPaginationVariables, getRefetchMetadata = _require2.getRefetchMetadata, getSelector = _require2.getSelector;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function useLoadMoreFunction_EXPERIMENTAL(args) {
    var direction = args.direction, fragmentNode = args.fragmentNode, fragmentRef = args.fragmentRef, fragmentIdentifier = args.fragmentIdentifier, fragmentData = args.fragmentData, connectionPathInFragmentData = args.connectionPathInFragmentData, paginationRequest = args.paginationRequest, paginationMetadata = args.paginationMetadata, componentDisplayName = args.componentDisplayName, observer = args.observer, onReset = args.onReset;
    var environment = useRelayEnvironment();
    var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName), identifierInfo = _getRefetchMetadata.identifierInfo;
    var identifierValue = (identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField) != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierInfo.identifierField] : null;
    var fetchStatusRef = useRef({
        kind: 'none'
    });
    var _useState = useState(environment), mirroredEnvironment = _useState[0], setMirroredEnvironment = _useState[1];
    var _useState2 = useState(fragmentIdentifier), mirroredFragmentIdentifier = _useState2[0], setMirroredFragmentIdentifier = _useState2[1];
    var isParentQueryActive = useIsOperationNodeActive(fragmentNode, fragmentRef);
    var forceDisposeFn = useCallback(function() {
        if (fetchStatusRef.current.kind === 'fetching') {
            fetchStatusRef.current.subscription.unsubscribe();
        }
        fetchStatusRef.current = {
            kind: 'none'
        };
    }, []);
    var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;
    if (shouldReset) {
        forceDisposeFn();
        onReset();
        setMirroredEnvironment(environment);
        setMirroredFragmentIdentifier(fragmentIdentifier);
    }
    var _getConnectionState = getConnectionState(direction, fragmentNode, fragmentData, connectionPathInFragmentData), cursor = _getConnectionState.cursor, hasMore = _getConnectionState.hasMore;
    var isRequestInvalid = fragmentData == null || isParentQueryActive;
    var isMountedRef = useIsMountedRef();
    var loadMore = useCallback(function(count, options) {
        var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;
        if (isMountedRef.current !== true) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected fetch on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable";
            return {
                dispose: function dispose() {}
            };
        }
        var fragmentSelector = getSelector(fragmentNode, fragmentRef);
        if (fetchStatusRef.current.kind === 'fetching' || isRequestInvalid) {
            if (fragmentSelector == null) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected fetch while using a null fragment ref ' + 'for fragment `%s` in `%s`. When fetching more items, we expect ' + "initial fragment data to be non-null. Please make sure you're " + 'passing a valid fragment ref to `%s` before paginating.', fragmentNode.name, componentDisplayName, componentDisplayName) : "TURBOPACK unreachable";
            }
            if (onComplete) {
                onComplete(null);
            }
            return {
                dispose: function dispose() {}
            };
        }
        !(fragmentSelector != null && fragmentSelector.kind !== 'PluralReaderSelector') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to be able to find a non-plural fragment owner for ' + "fragment `%s` when using `%s`. If you're seeing this, " + 'this is likely a bug in Relay.', fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable" : void 0;
        var parentVariables = fragmentSelector.owner.variables;
        var fragmentVariables = fragmentSelector.variables;
        var extraVariables = options === null || options === void 0 ? void 0 : options.UNSTABLE_extraVariables;
        var baseVariables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, parentVariables), fragmentVariables);
        var paginationVariables = getPaginationVariables(direction, count, cursor, baseVariables, (0, _objectSpread2["default"])({}, extraVariables), paginationMetadata);
        if (identifierInfo != null) {
            if (typeof identifierValue !== 'string') {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierInfo.identifierField, identifierValue) : "TURBOPACK unreachable";
            }
            paginationVariables[identifierInfo.identifierQueryVariableName] = identifierValue;
        }
        var paginationQuery = createOperationDescriptor(paginationRequest, paginationVariables, {
            force: true
        });
        fetchQuery(environment, paginationQuery).subscribe((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, observer), {}, {
            start: function start(subscription) {
                fetchStatusRef.current = {
                    kind: 'fetching',
                    subscription: subscription
                };
                observer.start && observer.start(subscription);
            },
            complete: function complete() {
                fetchStatusRef.current = {
                    kind: 'none'
                };
                observer.complete && observer.complete();
                onComplete && onComplete(null);
            },
            error: function error(_error) {
                fetchStatusRef.current = {
                    kind: 'none'
                };
                observer.complete && observer.complete();
                onComplete && onComplete(_error);
            }
        }));
        return {
            dispose: function dispose() {}
        };
    }, [
        environment,
        identifierValue,
        direction,
        cursor,
        isRequestInvalid,
        fragmentNode.name,
        fragmentRef,
        componentDisplayName
    ]);
    return [
        loadMore,
        hasMore,
        forceDisposeFn
    ];
}
module.exports = useLoadMoreFunction_EXPERIMENTAL;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useLoadMoreFunction.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var getConnectionState = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/getConnectionState.js [app-ssr] (ecmascript)");
var useFetchTrackingRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFetchTrackingRef.js [app-ssr] (ecmascript)");
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-ssr] (ecmascript)");
var useIsOperationNodeActive = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsOperationNodeActive.js [app-ssr] (ecmascript)");
var useLoadMoreFunction_EXPERIMENTAL = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useLoadMoreFunction_EXPERIMENTAL.js [app-ssr] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useCallback = _require.useCallback, useEffect = _require.useEffect, useState = _require.useState;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), fetchQuery = _require2.__internal.fetchQuery, RelayFeatureFlags = _require2.RelayFeatureFlags, createOperationDescriptor = _require2.createOperationDescriptor, getPaginationVariables = _require2.getPaginationVariables, getRefetchMetadata = _require2.getRefetchMetadata, getSelector = _require2.getSelector;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function useLoadMoreFunction(args) {
    if (RelayFeatureFlags.ENABLE_ACTIVITY_COMPATIBILITY) {
        return useLoadMoreFunction_EXPERIMENTAL(args);
    }
    return useLoadMoreFunction_CURRENT(args);
}
function useLoadMoreFunction_CURRENT(args) {
    var direction = args.direction, fragmentNode = args.fragmentNode, fragmentRef = args.fragmentRef, fragmentIdentifier = args.fragmentIdentifier, fragmentData = args.fragmentData, connectionPathInFragmentData = args.connectionPathInFragmentData, paginationRequest = args.paginationRequest, paginationMetadata = args.paginationMetadata, componentDisplayName = args.componentDisplayName, observer = args.observer, onReset = args.onReset;
    var environment = useRelayEnvironment();
    var _useFetchTrackingRef = useFetchTrackingRef(), isFetchingRef = _useFetchTrackingRef.isFetchingRef, startFetch = _useFetchTrackingRef.startFetch, disposeFetch = _useFetchTrackingRef.disposeFetch, completeFetch = _useFetchTrackingRef.completeFetch;
    var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName), identifierInfo = _getRefetchMetadata.identifierInfo;
    var identifierValue = (identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField) != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierInfo.identifierField] : null;
    var isMountedRef = useIsMountedRef();
    var _useState = useState(environment), mirroredEnvironment = _useState[0], setMirroredEnvironment = _useState[1];
    var _useState2 = useState(fragmentIdentifier), mirroredFragmentIdentifier = _useState2[0], setMirroredFragmentIdentifier = _useState2[1];
    var isParentQueryActive = useIsOperationNodeActive(fragmentNode, fragmentRef);
    var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;
    if (shouldReset) {
        disposeFetch();
        onReset();
        setMirroredEnvironment(environment);
        setMirroredFragmentIdentifier(fragmentIdentifier);
    }
    var _getConnectionState = getConnectionState(direction, fragmentNode, fragmentData, connectionPathInFragmentData), cursor = _getConnectionState.cursor, hasMore = _getConnectionState.hasMore;
    useEffect(function() {
        return function() {
            disposeFetch();
        };
    }, [
        disposeFetch
    ]);
    var isRequestInvalid = fragmentData == null || isParentQueryActive;
    var loadMore = useCallback(function(count, options) {
        var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;
        if (isMountedRef.current !== true) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected fetch on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable";
            return {
                dispose: function dispose() {}
            };
        }
        var fragmentSelector = getSelector(fragmentNode, fragmentRef);
        if (isFetchingRef.current === true || isRequestInvalid) {
            if (fragmentSelector == null) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected fetch while using a null fragment ref ' + 'for fragment `%s` in `%s`. When fetching more items, we expect ' + "initial fragment data to be non-null. Please make sure you're " + 'passing a valid fragment ref to `%s` before paginating.', fragmentNode.name, componentDisplayName, componentDisplayName) : "TURBOPACK unreachable";
            }
            if (onComplete) {
                onComplete(null);
            }
            return {
                dispose: function dispose() {}
            };
        }
        !(fragmentSelector != null && fragmentSelector.kind !== 'PluralReaderSelector') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to be able to find a non-plural fragment owner for ' + "fragment `%s` when using `%s`. If you're seeing this, " + 'this is likely a bug in Relay.', fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable" : void 0;
        var parentVariables = fragmentSelector.owner.variables;
        var fragmentVariables = fragmentSelector.variables;
        var extraVariables = options === null || options === void 0 ? void 0 : options.UNSTABLE_extraVariables;
        var baseVariables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, parentVariables), fragmentVariables);
        var paginationVariables = getPaginationVariables(direction, count, cursor, baseVariables, (0, _objectSpread2["default"])({}, extraVariables), paginationMetadata);
        if (identifierInfo != null) {
            if (typeof identifierValue !== 'string') {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierInfo.identifierField, identifierValue) : "TURBOPACK unreachable";
            }
            paginationVariables[identifierInfo.identifierQueryVariableName] = identifierValue;
        }
        var paginationQuery = createOperationDescriptor(paginationRequest, paginationVariables, {
            force: true
        });
        fetchQuery(environment, paginationQuery).subscribe((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, observer), {}, {
            start: function start(subscription) {
                startFetch(subscription);
                observer.start && observer.start(subscription);
            },
            complete: function complete() {
                completeFetch();
                observer.complete && observer.complete();
                onComplete && onComplete(null);
            },
            error: function error(_error) {
                completeFetch();
                observer.error && observer.error(_error);
                onComplete && onComplete(_error);
            }
        }));
        return {
            dispose: disposeFetch
        };
    }, [
        environment,
        identifierValue,
        direction,
        cursor,
        startFetch,
        disposeFetch,
        completeFetch,
        isFetchingRef,
        isRequestInvalid,
        fragmentNode.name,
        fragmentRef,
        componentDisplayName
    ]);
    return [
        loadMore,
        hasMore,
        disposeFetch
    ];
}
module.exports = useLoadMoreFunction;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/readFragmentInternal.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/QueryResource.js [app-ssr] (ecmascript)"), getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), fetchQueryInternal = _require2.__internal.fetchQuery, RelayFeatureFlags = _require2.RelayFeatureFlags, createOperationDescriptor = _require2.createOperationDescriptor, getPendingOperationsForFragment = _require2.getPendingOperationsForFragment, getSelector = _require2.getSelector, getVariablesFromFragment = _require2.getVariablesFromFragment, handlePotentialSnapshotErrors = _require2.handlePotentialSnapshotErrors;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function isMissingData(state) {
    if (state.kind === 'bailout') {
        return false;
    } else if (state.kind === 'singular') {
        return state.snapshot.isMissingData;
    } else {
        return state.snapshots.some(function(s) {
            return s.isMissingData;
        });
    }
}
function getMissingClientEdges(state) {
    if (state.kind === 'bailout') {
        return null;
    } else if (state.kind === 'singular') {
        var _state$snapshot$missi;
        return (_state$snapshot$missi = state.snapshot.missingClientEdges) !== null && _state$snapshot$missi !== void 0 ? _state$snapshot$missi : null;
    } else {
        var edges = null;
        var _iterator = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var snapshot = _step.value;
                if (snapshot.missingClientEdges) {
                    var _edges;
                    edges = (_edges = edges) !== null && _edges !== void 0 ? _edges : [];
                    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(snapshot.missingClientEdges), _step2;
                    try {
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                            var edge = _step2.value;
                            edges.push(edge);
                        }
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        return edges;
    }
}
function handlePotentialSnapshotErrorsForState(environment, state) {
    if (state.kind === 'singular') {
        handlePotentialSnapshotErrors(environment, state.snapshot.fieldErrors);
    } else if (state.kind === 'plural') {
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var snapshot = _step3.value;
                handlePotentialSnapshotErrors(environment, snapshot.fieldErrors);
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
    }
}
function handleMissingClientEdge(environment, parentFragmentNode, parentFragmentRef, missingClientEdgeRequestInfo, queryOptions) {
    var originalVariables = getVariablesFromFragment(parentFragmentNode, parentFragmentRef);
    var variables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, originalVariables), {}, {
        id: missingClientEdgeRequestInfo.clientEdgeDestinationID
    });
    var queryOperationDescriptor = createOperationDescriptor(missingClientEdgeRequestInfo.request, variables, queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.networkCacheConfig);
    var QueryResource = getQueryResourceForEnvironment(environment);
    return QueryResource.prepare(queryOperationDescriptor, fetchQueryInternal(environment, queryOperationDescriptor), queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.fetchPolicy);
}
function getFragmentState(environment, fragmentSelector) {
    if (fragmentSelector == null) {
        return {
            kind: 'bailout'
        };
    } else if (fragmentSelector.kind === 'PluralReaderSelector') {
        if (fragmentSelector.selectors.length === 0) {
            return {
                kind: 'bailout'
            };
        } else {
            return {
                kind: 'plural',
                snapshots: fragmentSelector.selectors.map(function(s) {
                    return environment.lookup(s);
                }),
                epoch: environment.getStore().getEpoch()
            };
        }
    } else {
        return {
            kind: 'singular',
            snapshot: environment.lookup(fragmentSelector),
            epoch: environment.getStore().getEpoch()
        };
    }
}
function readFragmentInternal(environment, fragmentNode, fragmentRef, hookDisplayName, queryOptions, fragmentKey) {
    var _fragmentNode$metadat, _fragmentNode$metadat2;
    var fragmentSelector = getSelector(fragmentNode, fragmentRef);
    var isPlural = (fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true;
    if (isPlural) {
        !(fragmentRef == null || Array.isArray(fragmentRef)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? " for key `".concat(fragmentKey, "`") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    } else {
        !!Array.isArray(fragmentRef) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` not to be ' + 'an array, instead got `%s`. Add `@relay(plural: true)` ' + 'to fragment `%s` to allow the prop to be an array.', fragmentKey != null ? " for key `".concat(fragmentKey, "`") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    }
    !(fragmentRef == null || isPlural && Array.isArray(fragmentRef) && fragmentRef.length === 0 || fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\n' + "- Forgetting to spread `%s` in `%s`'s parent's fragment.\n" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'This issue can generally be fixed by adding `@alias` after `...%s`.\n' + 'See https://relay.dev/docs/next/guides/alias-directive/', fragmentNode.name, fragmentNode.name, hookDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : "the `".concat(fragmentKey, "`"), hookDisplayName, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    var state = getFragmentState(environment, fragmentSelector);
    var clientEdgeQueries = null;
    if (((_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.hasClientEdges) === true || RelayFeatureFlags.CHECK_ALL_FRAGMENTS_FOR_MISSING_CLIENT_EDGES) {
        var missingClientEdges = getMissingClientEdges(state);
        if (missingClientEdges !== null && missingClientEdges !== void 0 && missingClientEdges.length) {
            clientEdgeQueries = [];
            var _iterator4 = (0, _createForOfIteratorHelper2["default"])(missingClientEdges), _step4;
            try {
                for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                    var edge = _step4.value;
                    clientEdgeQueries.push(handleMissingClientEdge(environment, fragmentNode, fragmentRef, edge, queryOptions));
                }
            } catch (err) {
                _iterator4.e(err);
            } finally{
                _iterator4.f();
            }
        }
    }
    if (isMissingData(state)) {
        !(fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'refinement, see invariants above') : "TURBOPACK unreachable" : void 0;
        var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;
        var pendingOperationsResult = getPendingOperationsForFragment(environment, fragmentNode, fragmentOwner);
        if (pendingOperationsResult) {
            throw pendingOperationsResult.promise;
        }
        handlePotentialSnapshotErrorsForState(environment, state);
    }
    var data;
    if (state.kind === 'bailout') {
        data = isPlural ? [] : null;
    } else if (state.kind === 'singular') {
        data = state.snapshot.data;
    } else {
        data = state.snapshots.map(function(s) {
            return s.data;
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (fragmentRef != null && (data === undefined || Array.isArray(data) && data.length > 0 && data.every(function(d) {
            return d === undefined;
        }))) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected to have been able to read non-null data for ' + 'fragment `%s` declared in ' + '`%s`, since fragment reference was non-null. ' + "Make sure that that `%s`'s parent isn't " + 'holding on to and/or passing a fragment reference for data that ' + 'has been deleted.', fragmentNode.name, hookDisplayName, hookDisplayName) : "TURBOPACK unreachable";
        }
    }
    return {
        data: data,
        clientEdgeQueries: clientEdgeQueries
    };
}
module.exports = readFragmentInternal;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useQueryLoader_EXPERIMENTAL.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/loadQuery.js [app-ssr] (ecmascript)"), loadQuery = _require.loadQuery;
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-ssr] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useCallback = _require2.useCallback, useEffect = _require2.useEffect, useInsertionEffect = _require2.useInsertionEffect, useRef = _require2.useRef, useState = _require2.useState;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), getRequest = _require3.getRequest;
var initialNullQueryReferenceState = {
    kind: 'NullQueryReference'
};
function requestIsLiveQuery(preloadableRequest) {
    if (preloadableRequest.kind === 'PreloadableConcreteRequest') {
        return preloadableRequest.params.metadata.live !== undefined;
    }
    var request = getRequest(preloadableRequest);
    return request.params.metadata.live !== undefined;
}
var CLEANUP_TIMEOUT = 1000 * 60 * 5;
function useQueryLoader_EXPERIMENTAL(preloadableRequest, initialQueryReference) {
    var initialQueryReferenceInternal = initialQueryReference !== null && initialQueryReference !== void 0 ? initialQueryReference : initialNullQueryReferenceState;
    var environment = useRelayEnvironment();
    var isMountedRef = useIsMountedRef();
    var undisposedQueryReferencesRef = useRef(null);
    if (undisposedQueryReferencesRef.current == null) {
        undisposedQueryReferencesRef.current = new Set([
            initialQueryReferenceInternal
        ]);
    }
    var _useState = useState(function() {
        return initialQueryReferenceInternal;
    }), queryReference = _useState[0], setQueryReference = _useState[1];
    var _useState2 = useState(function() {
        return initialQueryReferenceInternal;
    }), previousInitialQueryReference = _useState2[0], setPreviousInitialQueryReference = _useState2[1];
    if (initialQueryReferenceInternal !== previousInitialQueryReference) {
        var _undisposedQueryRefer;
        (_undisposedQueryRefer = undisposedQueryReferencesRef.current) === null || _undisposedQueryRefer === void 0 ? void 0 : _undisposedQueryRefer.add(initialQueryReferenceInternal);
        setPreviousInitialQueryReference(initialQueryReferenceInternal);
        setQueryReference(initialQueryReferenceInternal);
    }
    var disposeQuery = useCallback(function() {
        if (isMountedRef.current) {
            var _undisposedQueryRefer2;
            (_undisposedQueryRefer2 = undisposedQueryReferencesRef.current) === null || _undisposedQueryRefer2 === void 0 ? void 0 : _undisposedQueryRefer2.add(initialNullQueryReferenceState);
            setQueryReference(initialNullQueryReferenceState);
        }
    }, [
        isMountedRef
    ]);
    var queryLoaderCallback = useCallback(function(variables, options) {
        var _options$__environmen, _undisposedQueryRefer3;
        if (!isMountedRef.current) {
            return;
        }
        var mergedOptions = options != null && options.hasOwnProperty('__environment') ? {
            fetchPolicy: options.fetchPolicy,
            networkCacheConfig: options.networkCacheConfig,
            __nameForWarning: options.__nameForWarning
        } : options;
        var updatedQueryReference = loadQuery((_options$__environmen = options === null || options === void 0 ? void 0 : options.__environment) !== null && _options$__environmen !== void 0 ? _options$__environmen : environment, preloadableRequest, variables, mergedOptions);
        (_undisposedQueryRefer3 = undisposedQueryReferencesRef.current) === null || _undisposedQueryRefer3 === void 0 ? void 0 : _undisposedQueryRefer3.add(updatedQueryReference);
        setQueryReference(updatedQueryReference);
    }, [
        environment,
        preloadableRequest,
        setQueryReference,
        isMountedRef
    ]);
    var disposeAllRemainingQueryReferences = useCallback(function disposeAllRemainingQueryReferences(preloadableRequest, currentQueryReference) {
        var _undisposedQueryRefer4;
        var undisposedQueryReferences = (_undisposedQueryRefer4 = undisposedQueryReferencesRef.current) !== null && _undisposedQueryRefer4 !== void 0 ? _undisposedQueryRefer4 : new Set();
        var _iterator = (0, _createForOfIteratorHelper2["default"])(undisposedQueryReferences), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var undisposedQueryReference = _step.value;
                if (undisposedQueryReference === currentQueryReference) {
                    continue;
                }
                if (undisposedQueryReference.kind !== 'NullQueryReference') {
                    if (requestIsLiveQuery(preloadableRequest)) {
                        undisposedQueryReference.dispose && undisposedQueryReference.dispose();
                    } else {
                        undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();
                    }
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
    }, []);
    var cleanupTimerRef = useRef(null);
    useEffect(function() {
        disposeAllRemainingQueryReferences(preloadableRequest, queryReference);
        if (cleanupTimerRef.current != null) {
            clearTimeout(cleanupTimerRef.current);
            cleanupTimerRef.current = null;
        }
        return function() {
            cleanupTimerRef.current = setTimeout(function() {
                disposeAllRemainingQueryReferences(preloadableRequest, null);
            }, CLEANUP_TIMEOUT);
        };
    }, [
        preloadableRequest,
        queryReference
    ]);
    useInsertionEffect(function() {
        return function() {
            cleanupTimerRef.current && clearTimeout(cleanupTimerRef.current);
            cleanupTimerRef.current = null;
            disposeAllRemainingQueryReferences(preloadableRequest, null);
        };
    }, [
        preloadableRequest
    ]);
    return [
        queryReference.kind === 'NullQueryReference' ? null : queryReference,
        queryLoaderCallback,
        disposeQuery
    ];
}
module.exports = useQueryLoader_EXPERIMENTAL;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useQueryLoader.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/loadQuery.js [app-ssr] (ecmascript)"), loadQuery = _require.loadQuery;
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-ssr] (ecmascript)");
var useQueryLoader_EXPERIMENTAL = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useQueryLoader_EXPERIMENTAL.js [app-ssr] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useCallback = _require2.useCallback, useEffect = _require2.useEffect, useRef = _require2.useRef, useState = _require2.useState;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), RelayFeatureFlags = _require3.RelayFeatureFlags, getRequest = _require3.getRequest;
var initialNullQueryReferenceState = {
    kind: 'NullQueryReference'
};
function requestIsLiveQuery(preloadableRequest) {
    if (preloadableRequest.kind === 'PreloadableConcreteRequest') {
        return preloadableRequest.params.metadata.live !== undefined;
    }
    var request = getRequest(preloadableRequest);
    return request.params.metadata.live !== undefined;
}
function useQueryLoader(preloadableRequest, initialQueryReference) {
    if (RelayFeatureFlags.ENABLE_ACTIVITY_COMPATIBILITY) {
        return useQueryLoader_EXPERIMENTAL(preloadableRequest, initialQueryReference);
    }
    return useQueryLoader_CURRENT(preloadableRequest, initialQueryReference);
}
function useQueryLoader_CURRENT(preloadableRequest, initialQueryReference) {
    var initialQueryReferenceInternal = initialQueryReference !== null && initialQueryReference !== void 0 ? initialQueryReference : initialNullQueryReferenceState;
    var environment = useRelayEnvironment();
    var isMountedRef = useIsMountedRef();
    var undisposedQueryReferencesRef = useRef(new Set([
        initialQueryReferenceInternal
    ]));
    var _useState = useState(function() {
        return initialQueryReferenceInternal;
    }), queryReference = _useState[0], setQueryReference = _useState[1];
    var _useState2 = useState(function() {
        return initialQueryReferenceInternal;
    }), previousInitialQueryReference = _useState2[0], setPreviousInitialQueryReference = _useState2[1];
    if (initialQueryReferenceInternal !== previousInitialQueryReference) {
        undisposedQueryReferencesRef.current.add(initialQueryReferenceInternal);
        setPreviousInitialQueryReference(initialQueryReferenceInternal);
        setQueryReference(initialQueryReferenceInternal);
    }
    var disposeQuery = useCallback(function() {
        if (isMountedRef.current) {
            undisposedQueryReferencesRef.current.add(initialNullQueryReferenceState);
            setQueryReference(initialNullQueryReferenceState);
        }
    }, [
        isMountedRef
    ]);
    var queryLoaderCallback = useCallback(function(variables, options) {
        var mergedOptions = options != null && options.hasOwnProperty('__environment') ? {
            fetchPolicy: options.fetchPolicy,
            networkCacheConfig: options.networkCacheConfig,
            __nameForWarning: options.__nameForWarning
        } : options;
        if (isMountedRef.current) {
            var _options$__environmen;
            var updatedQueryReference = loadQuery((_options$__environmen = options === null || options === void 0 ? void 0 : options.__environment) !== null && _options$__environmen !== void 0 ? _options$__environmen : environment, preloadableRequest, variables, mergedOptions);
            undisposedQueryReferencesRef.current.add(updatedQueryReference);
            setQueryReference(updatedQueryReference);
        }
    }, [
        environment,
        preloadableRequest,
        setQueryReference,
        isMountedRef
    ]);
    var maybeHiddenOrFastRefresh = useRef(false);
    useEffect(function() {
        return function() {
            maybeHiddenOrFastRefresh.current = true;
        };
    }, []);
    useEffect(function() {
        if (maybeHiddenOrFastRefresh.current === true) {
            maybeHiddenOrFastRefresh.current = false;
            if (queryReference.kind !== 'NullQueryReference') {
                queryLoaderCallback(queryReference.variables, {
                    fetchPolicy: queryReference.fetchPolicy,
                    networkCacheConfig: queryReference.networkCacheConfig
                });
            }
            return;
        }
        var undisposedQueryReferences = undisposedQueryReferencesRef.current;
        if (isMountedRef.current) {
            var _iterator = (0, _createForOfIteratorHelper2["default"])(undisposedQueryReferences), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var undisposedQueryReference = _step.value;
                    if (undisposedQueryReference === queryReference) {
                        break;
                    }
                    undisposedQueryReferences["delete"](undisposedQueryReference);
                    if (undisposedQueryReference.kind !== 'NullQueryReference') {
                        if (requestIsLiveQuery(preloadableRequest)) {
                            undisposedQueryReference.dispose && undisposedQueryReference.dispose();
                        } else {
                            undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();
                        }
                    }
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
        }
    }, [
        queryReference,
        isMountedRef,
        queryLoaderCallback,
        preloadableRequest
    ]);
    useEffect(function() {
        return function disposeAllRemainingQueryReferences() {
            var _iterator2 = (0, _createForOfIteratorHelper2["default"])(undisposedQueryReferencesRef.current), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var undisposedQueryReference = _step2.value;
                    if (undisposedQueryReference.kind !== 'NullQueryReference') {
                        if (requestIsLiveQuery(preloadableRequest)) {
                            undisposedQueryReference.dispose && undisposedQueryReference.dispose();
                        } else {
                            undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();
                        }
                    }
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
        };
    }, [
        preloadableRequest
    ]);
    return [
        queryReference.kind === 'NullQueryReference' ? null : queryReference,
        queryLoaderCallback,
        disposeQuery
    ];
}
module.exports = useQueryLoader;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useRefetchableFragmentInternal.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var ProfilerContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/ProfilerContext.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/QueryResource.js [app-ssr] (ecmascript)"), getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;
var readFragmentInternal = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/readFragmentInternal.js [app-ssr] (ecmascript)");
var useFragmentInternal = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal.js [app-ssr] (ecmascript)");
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-ssr] (ecmascript)");
var useQueryLoader = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useQueryLoader.js [app-ssr] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useCallback = _require2.useCallback, useContext = _require2.useContext, useReducer = _require2.useReducer;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), fetchQuery = _require3.__internal.fetchQuery, createOperationDescriptor = _require3.createOperationDescriptor, getFragmentIdentifier = _require3.getFragmentIdentifier, getRefetchMetadata = _require3.getRefetchMetadata, getSelector = _require3.getSelector, getValueAtPath = _require3.getValueAtPath;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function reducer(state, action) {
    switch(action.type){
        case 'refetch':
            {
                var _action$refetchEnviro;
                return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, state), {}, {
                    fetchPolicy: action.fetchPolicy,
                    mirroredEnvironment: (_action$refetchEnviro = action.refetchEnvironment) !== null && _action$refetchEnviro !== void 0 ? _action$refetchEnviro : state.mirroredEnvironment,
                    onComplete: action.onComplete,
                    refetchEnvironment: action.refetchEnvironment,
                    refetchQuery: action.refetchQuery,
                    renderPolicy: action.renderPolicy
                });
            }
        case 'reset':
            {
                return {
                    fetchPolicy: undefined,
                    mirroredEnvironment: action.environment,
                    mirroredFragmentIdentifier: action.fragmentIdentifier,
                    onComplete: undefined,
                    refetchQuery: null,
                    renderPolicy: undefined
                };
            }
        default:
            {
                action.type;
                throw new Error('useRefetchableFragmentNode: Unexpected action type');
            }
    }
}
function useRefetchableFragmentInternal(fragmentNode, parentFragmentRef, componentDisplayName) {
    var parentEnvironment = useRelayEnvironment();
    var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName), refetchableRequest = _getRefetchMetadata.refetchableRequest, fragmentRefPathInResponse = _getRefetchMetadata.fragmentRefPathInResponse, identifierInfo = _getRefetchMetadata.identifierInfo;
    var fragmentIdentifier = getFragmentIdentifier(fragmentNode, parentFragmentRef);
    var _useReducer = useReducer(reducer, {
        fetchPolicy: undefined,
        mirroredEnvironment: parentEnvironment,
        mirroredFragmentIdentifier: fragmentIdentifier,
        onComplete: undefined,
        refetchEnvironment: null,
        refetchQuery: null,
        renderPolicy: undefined
    }), refetchState = _useReducer[0], dispatch = _useReducer[1];
    var fetchPolicy = refetchState.fetchPolicy, mirroredEnvironment = refetchState.mirroredEnvironment, mirroredFragmentIdentifier = refetchState.mirroredFragmentIdentifier, onComplete = refetchState.onComplete, refetchEnvironment = refetchState.refetchEnvironment, refetchQuery = refetchState.refetchQuery, renderPolicy = refetchState.renderPolicy;
    var environment = refetchEnvironment !== null && refetchEnvironment !== void 0 ? refetchEnvironment : parentEnvironment;
    var QueryResource = getQueryResourceForEnvironment(environment);
    var profilerContext = useContext(ProfilerContext);
    var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;
    var _useQueryLoader = useQueryLoader(refetchableRequest), queryRef = _useQueryLoader[0], loadQuery = _useQueryLoader[1], disposeQuery = _useQueryLoader[2];
    var fragmentRef = parentFragmentRef;
    if (shouldReset) {
        dispatch({
            type: 'reset',
            environment: environment,
            fragmentIdentifier: fragmentIdentifier
        });
        disposeQuery();
    } else if (refetchQuery != null && queryRef != null) {
        var debugPreviousIDAndTypename;
        if ("TURBOPACK compile-time truthy", 1) {
            debugPreviousIDAndTypename = debugFunctions.getInitialIDAndType(refetchQuery.request.variables, fragmentRefPathInResponse, identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierQueryVariableName, environment);
        }
        var handleQueryCompleted = function handleQueryCompleted(maybeError) {
            onComplete && onComplete(maybeError !== null && maybeError !== void 0 ? maybeError : null);
        };
        var fetchObservable = queryRef.source != null ? queryRef.source : fetchQuery(environment, refetchQuery);
        var queryResult = profilerContext.wrapPrepareQueryResource(function() {
            return QueryResource.prepare(refetchQuery, fetchObservable, fetchPolicy, renderPolicy, {
                error: handleQueryCompleted,
                complete: function complete() {
                    if ("TURBOPACK compile-time truthy", 1) {
                        debugFunctions.checkSameTypeAfterRefetch(debugPreviousIDAndTypename, environment, fragmentNode, componentDisplayName);
                    }
                    handleQueryCompleted();
                }
            }, queryRef.fetchKey, profilerContext);
        });
        var queryData = readFragmentInternal(environment, queryResult.fragmentNode, queryResult.fragmentRef, componentDisplayName).data;
        !(queryData != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to be able to read refetch query response. ' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable" : void 0;
        var refetchedFragmentRef = getValueAtPath(queryData, fragmentRefPathInResponse);
        fragmentRef = refetchedFragmentRef;
        if ("TURBOPACK compile-time truthy", 1) {
            debugFunctions.checkSameIDAfterRefetch(debugPreviousIDAndTypename, fragmentRef, fragmentNode, componentDisplayName);
        }
    }
    var fragmentData = useFragmentInternal(fragmentNode, fragmentRef, componentDisplayName);
    var refetch = useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierInfo, loadQuery, parentFragmentRef, refetchableRequest);
    return {
        fragmentData: fragmentData,
        fragmentRef: fragmentRef,
        refetch: refetch
    };
}
function useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierInfo, loadQuery, parentFragmentRef, refetchableRequest) {
    var isMountedRef = useIsMountedRef();
    var identifierValue = (identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField) != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierInfo.identifierField] : null;
    return useCallback(function(providedRefetchVariables, options) {
        if (isMountedRef.current !== true) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected call to `refetch` on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable";
            return {
                dispose: function dispose() {}
            };
        }
        if (parentFragmentRef == null) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected call to `refetch` while using a null fragment ref ' + 'for fragment `%s` in `%s`. When calling `refetch`, we expect ' + "initial fragment data to be non-null. Please make sure you're " + 'passing a valid fragment ref to `%s` before calling ' + '`refetch`, or make sure you pass all required variables to `refetch`.', fragmentNode.name, componentDisplayName, componentDisplayName) : "TURBOPACK unreachable";
        }
        var refetchEnvironment = options === null || options === void 0 ? void 0 : options.__environment;
        var fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy;
        var renderPolicy = options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy;
        var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;
        var fragmentSelector = getSelector(fragmentNode, parentFragmentRef);
        var parentVariables;
        var fragmentVariables;
        if (fragmentSelector == null) {
            parentVariables = {};
            fragmentVariables = {};
        } else if (fragmentSelector.kind === 'PluralReaderSelector') {
            var _fragmentSelector$sel, _fragmentSelector$sel2, _fragmentSelector$sel3, _fragmentSelector$sel4;
            parentVariables = (_fragmentSelector$sel = (_fragmentSelector$sel2 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel2 === void 0 ? void 0 : _fragmentSelector$sel2.owner.variables) !== null && _fragmentSelector$sel !== void 0 ? _fragmentSelector$sel : {};
            fragmentVariables = (_fragmentSelector$sel3 = (_fragmentSelector$sel4 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel4 === void 0 ? void 0 : _fragmentSelector$sel4.variables) !== null && _fragmentSelector$sel3 !== void 0 ? _fragmentSelector$sel3 : {};
        } else {
            parentVariables = fragmentSelector.owner.variables;
            fragmentVariables = fragmentSelector.variables;
        }
        var refetchVariables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, parentVariables), fragmentVariables), providedRefetchVariables);
        if (identifierInfo != null && !providedRefetchVariables.hasOwnProperty(identifierInfo.identifierQueryVariableName)) {
            if (typeof identifierValue !== 'string') {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierInfo.identifierField, identifierValue) : "TURBOPACK unreachable";
            }
            refetchVariables[identifierInfo.identifierQueryVariableName] = identifierValue;
        }
        var refetchQuery = createOperationDescriptor(refetchableRequest, refetchVariables, {
            force: true
        });
        loadQuery(refetchQuery.request.variables, {
            fetchPolicy: fetchPolicy,
            __environment: refetchEnvironment,
            __nameForWarning: 'refetch'
        });
        dispatch({
            type: 'refetch',
            fetchPolicy: fetchPolicy,
            onComplete: onComplete,
            refetchEnvironment: refetchEnvironment,
            refetchQuery: refetchQuery,
            renderPolicy: renderPolicy
        });
        return {
            dispose: disposeQuery
        };
    }, [
        fragmentIdentifier,
        dispatch,
        disposeQuery,
        identifierValue,
        loadQuery
    ]);
}
var debugFunctions;
if ("TURBOPACK compile-time truthy", 1) {
    debugFunctions = {
        getInitialIDAndType: function getInitialIDAndType(memoRefetchVariables, fragmentRefPathInResponse, identifierQueryVariableName, environment) {
            var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), Record = _require4.Record;
            var id = memoRefetchVariables === null || memoRefetchVariables === void 0 ? void 0 : memoRefetchVariables[identifierQueryVariableName !== null && identifierQueryVariableName !== void 0 ? identifierQueryVariableName : 'id'];
            if (fragmentRefPathInResponse.length !== 1 || fragmentRefPathInResponse[0] !== 'node' || id == null) {
                return null;
            }
            var recordSource = environment.getStore().getSource();
            var record = recordSource.get(id);
            var typename = record == null ? null : Record.getType(record);
            if (typename == null) {
                return null;
            }
            return {
                id: id,
                typename: typename
            };
        },
        checkSameTypeAfterRefetch: function checkSameTypeAfterRefetch(previousIDAndType, environment, fragmentNode, componentDisplayName) {
            var _require5 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), Record = _require5.Record;
            if (!previousIDAndType) {
                return;
            }
            var recordSource = environment.getStore().getSource();
            var record = recordSource.get(previousIDAndType.id);
            var typename = record && Record.getType(record);
            if (typename !== previousIDAndType.typename) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Call to `refetch` returned data with a different ' + '__typename: was `%s`, now `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements' + 'unique id requirement.', previousIDAndType.typename, typename, fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable";
            }
        },
        checkSameIDAfterRefetch: function checkSameIDAfterRefetch(previousIDAndTypename, refetchedFragmentRef, fragmentNode, componentDisplayName) {
            if (previousIDAndTypename == null || refetchedFragmentRef == null) {
                return;
            }
            var _require6 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), ID_KEY = _require6.ID_KEY;
            var resultID = refetchedFragmentRef[ID_KEY];
            if (resultID != null && resultID !== previousIDAndTypename.id) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Call to `refetch` returned a different id, expected ' + '`%s`, got `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements ' + 'unique id requirement.', resultID, previousIDAndTypename.id, fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable";
            }
        }
    };
}
module.exports = useRefetchableFragmentInternal;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/usePaginationFragment.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var useLoadMoreFunction = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useLoadMoreFunction.js [app-ssr] (ecmascript)");
var useRefetchableFragmentInternal = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRefetchableFragmentInternal.js [app-ssr] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var useStaticFragmentNodeWarning = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useStaticFragmentNodeWarning.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useCallback = _require.useCallback, useDebugValue = _require.useDebugValue, useState = _require.useState;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), RelayFeatureFlags = _require2.RelayFeatureFlags, getFragment = _require2.getFragment, getFragmentIdentifier = _require2.getFragmentIdentifier, getPaginationMetadata = _require2.getPaginationMetadata;
function usePaginationFragment(fragmentInput, parentFragmentRef) {
    var fragmentNode = getFragment(fragmentInput);
    useStaticFragmentNodeWarning(fragmentNode, 'first argument of usePaginationFragment()');
    var componentDisplayName = 'usePaginationFragment()';
    var _getPaginationMetadat = getPaginationMetadata(fragmentNode, componentDisplayName), connectionPathInFragmentData = _getPaginationMetadat.connectionPathInFragmentData, paginationRequest = _getPaginationMetadat.paginationRequest, paginationMetadata = _getPaginationMetadat.paginationMetadata;
    var _useRefetchableFragme = useRefetchableFragmentInternal(fragmentNode, parentFragmentRef, componentDisplayName), fragmentData = _useRefetchableFragme.fragmentData, fragmentRef = _useRefetchableFragme.fragmentRef, refetch = _useRefetchableFragme.refetch;
    var fragmentIdentifier = getFragmentIdentifier(fragmentNode, fragmentRef);
    var _useLoadMore = useLoadMore({
        componentDisplayName: componentDisplayName,
        connectionPathInFragmentData: connectionPathInFragmentData,
        direction: 'backward',
        fragmentData: fragmentData,
        fragmentIdentifier: fragmentIdentifier,
        fragmentNode: fragmentNode,
        fragmentRef: fragmentRef,
        paginationMetadata: paginationMetadata,
        paginationRequest: paginationRequest
    }), loadPrevious = _useLoadMore[0], hasPrevious = _useLoadMore[1], isLoadingPrevious = _useLoadMore[2], disposeFetchPrevious = _useLoadMore[3];
    var _useLoadMore2 = useLoadMore({
        componentDisplayName: componentDisplayName,
        connectionPathInFragmentData: connectionPathInFragmentData,
        direction: 'forward',
        fragmentData: fragmentData,
        fragmentIdentifier: fragmentIdentifier,
        fragmentNode: fragmentNode,
        fragmentRef: fragmentRef,
        paginationMetadata: paginationMetadata,
        paginationRequest: paginationRequest
    }), loadNext = _useLoadMore2[0], hasNext = _useLoadMore2[1], isLoadingNext = _useLoadMore2[2], disposeFetchNext = _useLoadMore2[3];
    var refetchPagination = useCallback(function(variables, options) {
        disposeFetchNext();
        disposeFetchPrevious();
        return refetch(variables, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, options), {}, {
            __environment: undefined
        }));
    }, [
        disposeFetchNext,
        disposeFetchPrevious,
        refetch
    ]);
    if ("TURBOPACK compile-time truthy", 1) {
        useDebugValue({
            fragment: fragmentNode.name,
            data: fragmentData,
            hasNext: hasNext,
            isLoadingNext: isLoadingNext,
            hasPrevious: hasPrevious,
            isLoadingPrevious: isLoadingPrevious
        });
    }
    return {
        data: fragmentData,
        loadNext: loadNext,
        loadPrevious: loadPrevious,
        hasNext: hasNext,
        hasPrevious: hasPrevious,
        isLoadingNext: isLoadingNext,
        isLoadingPrevious: isLoadingPrevious,
        refetch: refetchPagination
    };
}
function useLoadMore(args) {
    var environment = useRelayEnvironment();
    var _useState = useState(false), isLoadingMore = _useState[0], reallySetIsLoadingMore = _useState[1];
    var setIsLoadingMore = function setIsLoadingMore(value) {
        var _environment$getSched;
        var schedule = (_environment$getSched = environment.getScheduler()) === null || _environment$getSched === void 0 ? void 0 : _environment$getSched.schedule;
        if (schedule) {
            schedule(function() {
                reallySetIsLoadingMore(value);
            });
        } else {
            reallySetIsLoadingMore(value);
        }
    };
    var observer = {
        start: function start() {
            return setIsLoadingMore(true);
        },
        complete: function complete() {
            return setIsLoadingMore(false);
        },
        error: function error() {
            return setIsLoadingMore(false);
        },
        unsubscribe: RelayFeatureFlags.ENABLE_USE_PAGINATION_IS_LOADING_FIX ? function() {
            return setIsLoadingMore(false);
        } : undefined
    };
    var handleReset = function handleReset() {
        return setIsLoadingMore(false);
    };
    var _useLoadMoreFunction = useLoadMoreFunction((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, args), {}, {
        observer: observer,
        onReset: handleReset
    })), loadMore = _useLoadMoreFunction[0], hasMore = _useLoadMoreFunction[1], disposeFetch = _useLoadMoreFunction[2];
    return [
        loadMore,
        hasMore,
        isLoadingMore,
        disposeFetch
    ];
}
module.exports = usePaginationFragment;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/usePreloadedQuery.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useLazyLoadQueryNode = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useLazyLoadQueryNode.js [app-ssr] (ecmascript)");
var useMemoOperationDescriptor = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useMemoOperationDescriptor.js [app-ssr] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useDebugValue = _require.useDebugValue;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), _require2$__internal = _require2.__internal, fetchQueryDeduped = _require2$__internal.fetchQueryDeduped, fetchQuery = _require2$__internal.fetchQuery;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function usePreloadedQuery(gqlQuery, preloadedQuery, options) {
    var environment = useRelayEnvironment();
    var fetchKey = preloadedQuery.fetchKey, fetchPolicy = preloadedQuery.fetchPolicy, source = preloadedQuery.source, variables = preloadedQuery.variables, networkCacheConfig = preloadedQuery.networkCacheConfig;
    var operation = useMemoOperationDescriptor(gqlQuery, variables, networkCacheConfig);
    var useLazyLoadQueryNodeParams;
    if (preloadedQuery.kind === 'PreloadedQuery_DEPRECATED') {
        !(operation.request.node.params.name === preloadedQuery.name) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'usePreloadedQuery(): Expected data to be prefetched for query `%s`, ' + 'got prefetch results for query `%s`.', operation.request.node.params.name, preloadedQuery.name) : "TURBOPACK unreachable" : void 0;
        useLazyLoadQueryNodeParams = {
            componentDisplayName: 'usePreloadedQuery()',
            fetchKey: fetchKey,
            fetchObservable: fetchQueryDeduped(environment, operation.request.identifier, function() {
                if (environment === preloadedQuery.environment && source != null) {
                    return environment.executeWithSource({
                        operation: operation,
                        source: source
                    });
                } else {
                    return environment.execute({
                        operation: operation
                    });
                }
            }),
            fetchPolicy: fetchPolicy,
            query: operation,
            renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
        };
    } else {
        ("TURBOPACK compile-time truthy", 1) ? warning(preloadedQuery.isDisposed === false, 'usePreloadedQuery(): Expected preloadedQuery to not be disposed yet. ' + 'This is because disposing the query marks it for future garbage ' + 'collection, and as such query results may no longer be present in the Relay ' + 'store. In the future, this will become a hard error.') : "TURBOPACK unreachable";
        var fallbackFetchObservable = fetchQuery(environment, operation);
        var fetchObservable;
        if (source != null && environment === preloadedQuery.environment) {
            fetchObservable = source.ifEmpty(fallbackFetchObservable);
        } else if (environment !== preloadedQuery.environment) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'usePreloadedQuery(): usePreloadedQuery was passed a preloaded query ' + 'that was created with a different environment than the one that is currently ' + 'in context. In the future, this will become a hard error.') : "TURBOPACK unreachable";
            fetchObservable = fallbackFetchObservable;
        } else {
            fetchObservable = fallbackFetchObservable;
        }
        useLazyLoadQueryNodeParams = {
            componentDisplayName: 'usePreloadedQuery()',
            fetchObservable: fetchObservable,
            fetchKey: fetchKey,
            fetchPolicy: fetchPolicy,
            query: operation,
            renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
        };
    }
    var data = useLazyLoadQueryNode(useLazyLoadQueryNodeParams);
    if ("TURBOPACK compile-time truthy", 1) {
        useDebugValue({
            query: preloadedQuery.name,
            variables: preloadedQuery.variables,
            data: data,
            fetchKey: fetchKey,
            fetchPolicy: fetchPolicy,
            renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
        });
    }
    return data;
}
module.exports = usePreloadedQuery;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useRefetchableFragment.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useRefetchableFragmentInternal = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRefetchableFragmentInternal.js [app-ssr] (ecmascript)");
var useStaticFragmentNodeWarning = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useStaticFragmentNodeWarning.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useDebugValue = _require.useDebugValue;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), getFragment = _require2.getFragment;
function useRefetchableFragment(fragmentInput, fragmentRef) {
    var fragmentNode = getFragment(fragmentInput);
    useStaticFragmentNodeWarning(fragmentNode, 'first argument of useRefetchableFragment()');
    var _useRefetchableFragme = useRefetchableFragmentInternal(fragmentNode, fragmentRef, 'useRefetchableFragment()'), fragmentData = _useRefetchableFragme.fragmentData, refetch = _useRefetchableFragme.refetch;
    if ("TURBOPACK compile-time truthy", 1) {
        useDebugValue({
            fragment: fragmentNode.name,
            data: fragmentData
        });
    }
    return [
        fragmentData,
        refetch
    ];
}
module.exports = useRefetchableFragment;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useSubscribeToInvalidationState.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useEffect = _require.useEffect, useRef = _require.useRef;
function useSubscribeToInvalidationState(dataIDs, callback) {
    var environment = useRelayEnvironment();
    var disposableRef = useRef(null);
    var stableDataIDs = Array.from(dataIDs).sort().join('');
    useEffect(function() {
        var store = environment.getStore();
        var invalidationState = store.lookupInvalidationState(dataIDs);
        var disposable = store.subscribeToInvalidationState(invalidationState, callback);
        disposableRef.current = disposable;
        return function() {
            return disposable.dispose();
        };
    }, [
        stableDataIDs,
        callback,
        environment
    ]);
    return {
        dispose: function dispose() {
            if (disposableRef.current != null) {
                disposableRef.current.dispose();
            }
        }
    };
}
module.exports = useSubscribeToInvalidationState;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useSubscription.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js [app-ssr] (ecmascript)"), useEffect = _require.useEffect;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)"), requestSubscription = _require2.requestSubscription;
function useSubscription(config, requestSubscriptionFn) {
    var actualRequestSubscription = requestSubscriptionFn !== null && requestSubscriptionFn !== void 0 ? requestSubscriptionFn : requestSubscription;
    var environment = useRelayEnvironment();
    useEffect(function() {
        var _actualRequestSubscri = actualRequestSubscription(environment, config), dispose = _actualRequestSubscri.dispose;
        return dispose;
    }, [
        environment,
        config,
        actualRequestSubscription
    ]);
}
module.exports = useSubscription;
}),
"[project]/node_modules/react-relay/lib/hooks.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var EntryPointContainer = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/EntryPointContainer.react.js [app-ssr] (ecmascript)");
var loadEntryPoint = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/loadEntryPoint.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/loadQuery.js [app-ssr] (ecmascript)"), loadQuery = _require.loadQuery;
var ProfilerContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/ProfilerContext.js [app-ssr] (ecmascript)");
var RelayEnvironmentProvider = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/RelayEnvironmentProvider.js [app-ssr] (ecmascript)");
var useEntryPointLoader = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useEntryPointLoader.js [app-ssr] (ecmascript)");
var useFragment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFragment.js [app-ssr] (ecmascript)");
var useLazyLoadQuery = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useLazyLoadQuery.js [app-ssr] (ecmascript)");
var useMutation = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useMutation.js [app-ssr] (ecmascript)");
var usePaginationFragment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/usePaginationFragment.js [app-ssr] (ecmascript)");
var usePreloadedQuery = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/usePreloadedQuery.js [app-ssr] (ecmascript)");
var useQueryLoader = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useQueryLoader.js [app-ssr] (ecmascript)");
var useRefetchableFragment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRefetchableFragment.js [app-ssr] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-ssr] (ecmascript)");
var useSubscribeToInvalidationState = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useSubscribeToInvalidationState.js [app-ssr] (ecmascript)");
var useSubscription = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useSubscription.js [app-ssr] (ecmascript)");
var RelayRuntime = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)");
module.exports = {
    ConnectionHandler: RelayRuntime.ConnectionHandler,
    applyOptimisticMutation: RelayRuntime.applyOptimisticMutation,
    commitLocalUpdate: RelayRuntime.commitLocalUpdate,
    commitMutation: RelayRuntime.commitMutation,
    graphql: RelayRuntime.graphql,
    readInlineData: RelayRuntime.readInlineData,
    requestSubscription: RelayRuntime.requestSubscription,
    EntryPointContainer: EntryPointContainer,
    RelayEnvironmentProvider: RelayEnvironmentProvider,
    ProfilerContext: ProfilerContext,
    fetchQuery: RelayRuntime.fetchQuery,
    loadQuery: loadQuery,
    loadEntryPoint: loadEntryPoint,
    useFragment: useFragment,
    useLazyLoadQuery: useLazyLoadQuery,
    useEntryPointLoader: useEntryPointLoader,
    useQueryLoader: useQueryLoader,
    useMutation: useMutation,
    usePaginationFragment: usePaginationFragment,
    usePreloadedQuery: usePreloadedQuery,
    useRefetchableFragment: useRefetchableFragment,
    useRelayEnvironment: useRelayEnvironment,
    useSubscribeToInvalidationState: useSubscribeToInvalidationState,
    useSubscription: useSubscription
};
}),
"[project]/node_modules/react-relay/hooks.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Relay v20.1.1
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ module.exports = __turbopack_context__.r("[project]/node_modules/react-relay/lib/hooks.js [app-ssr] (ecmascript)");
}),
];

//# sourceMappingURL=node_modules_react-relay_e9c63230._.js.map