module.exports = [
"[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayConcreteNode = {
    ACTOR_CHANGE: 'ActorChange',
    CATCH_FIELD: 'CatchField',
    CONDITION: 'Condition',
    CLIENT_COMPONENT: 'ClientComponent',
    CLIENT_EDGE_TO_SERVER_OBJECT: 'ClientEdgeToServerObject',
    CLIENT_EDGE_TO_CLIENT_OBJECT: 'ClientEdgeToClientObject',
    CLIENT_EXTENSION: 'ClientExtension',
    DEFER: 'Defer',
    CONNECTION: 'Connection',
    FRAGMENT: 'Fragment',
    FRAGMENT_SPREAD: 'FragmentSpread',
    INLINE_DATA_FRAGMENT_SPREAD: 'InlineDataFragmentSpread',
    INLINE_DATA_FRAGMENT: 'InlineDataFragment',
    INLINE_FRAGMENT: 'InlineFragment',
    LINKED_FIELD: 'LinkedField',
    LINKED_HANDLE: 'LinkedHandle',
    LITERAL: 'Literal',
    LIST_VALUE: 'ListValue',
    LOCAL_ARGUMENT: 'LocalArgument',
    MODULE_IMPORT: 'ModuleImport',
    ALIASED_FRAGMENT_SPREAD: 'AliasedFragmentSpread',
    ALIASED_INLINE_FRAGMENT_SPREAD: 'AliasedInlineFragmentSpread',
    RELAY_RESOLVER: 'RelayResolver',
    RELAY_LIVE_RESOLVER: 'RelayLiveResolver',
    REQUIRED_FIELD: 'RequiredField',
    OBJECT_VALUE: 'ObjectValue',
    OPERATION: 'Operation',
    REQUEST: 'Request',
    ROOT_ARGUMENT: 'RootArgument',
    SCALAR_FIELD: 'ScalarField',
    SCALAR_HANDLE: 'ScalarHandle',
    SPLIT_OPERATION: 'SplitOperation',
    STREAM: 'Stream',
    TYPE_DISCRIMINATOR: 'TypeDiscriminator',
    UPDATABLE_QUERY: 'UpdatableQuery',
    VARIABLE: 'Variable'
};
module.exports = RelayConcreteNode;
}),
"[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayConcreteNode = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function graphql(strings) {
    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'graphql: Unexpected invocation at runtime. Either the Babel transform ' + 'was not set up, or it failed to identify this call site. Make sure it ' + 'is being used verbatim as `graphql`. Note also that there cannot be ' + 'a space between graphql and the backtick that follows.') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
}
function getNode(taggedNode) {
    var node = taggedNode;
    if (typeof node === 'function') {
        node = node();
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayGraphQLTag: node `%s` unexpectedly wrapped in a function.', node.kind === 'Fragment' ? node.name : node.operation.name) : "TURBOPACK unreachable";
    } else if (node["default"]) {
        node = node["default"];
    }
    return node;
}
function isFragment(node) {
    var fragment = getNode(node);
    return typeof fragment === 'object' && fragment !== null && fragment.kind === RelayConcreteNode.FRAGMENT;
}
function isRequest(node) {
    var request = getNode(node);
    return typeof request === 'object' && request !== null && request.kind === RelayConcreteNode.REQUEST;
}
function isUpdatableQuery(node) {
    var updatableQuery = getNode(node);
    return typeof updatableQuery === 'object' && updatableQuery !== null && updatableQuery.kind === RelayConcreteNode.UPDATABLE_QUERY;
}
function isInlineDataFragment(node) {
    var fragment = getNode(node);
    return typeof fragment === 'object' && fragment !== null && fragment.kind === RelayConcreteNode.INLINE_DATA_FRAGMENT;
}
function getFragment(taggedNode) {
    var fragment = getNode(taggedNode);
    !isFragment(fragment) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'GraphQLTag: Expected a fragment, got `%s`.', JSON.stringify(fragment)) : "TURBOPACK unreachable" : void 0;
    return fragment;
}
function getPaginationFragment(taggedNode) {
    var _fragment$metadata;
    var fragment = getFragment(taggedNode);
    var refetch = (_fragment$metadata = fragment.metadata) === null || _fragment$metadata === void 0 ? void 0 : _fragment$metadata.refetch;
    var connection = refetch === null || refetch === void 0 ? void 0 : refetch.connection;
    if (refetch === null || typeof refetch !== 'object' || connection === null || typeof connection !== 'object') {
        return null;
    }
    return fragment;
}
function getRefetchableFragment(taggedNode) {
    var _fragment$metadata2;
    var fragment = getFragment(taggedNode);
    var refetch = (_fragment$metadata2 = fragment.metadata) === null || _fragment$metadata2 === void 0 ? void 0 : _fragment$metadata2.refetch;
    if (refetch === null || typeof refetch !== 'object') {
        return null;
    }
    return fragment;
}
function getRequest(taggedNode) {
    var request = getNode(taggedNode);
    !isRequest(request) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'GraphQLTag: Expected a request, got `%s`.', JSON.stringify(request)) : "TURBOPACK unreachable" : void 0;
    return request;
}
function getUpdatableQuery(taggedNode) {
    var updatableQuery = getNode(taggedNode);
    !isUpdatableQuery(updatableQuery) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'GraphQLTag: Expected a request, got `%s`.', JSON.stringify(updatableQuery)) : "TURBOPACK unreachable" : void 0;
    return updatableQuery;
}
function getInlineDataFragment(taggedNode) {
    var fragment = getNode(taggedNode);
    !isInlineDataFragment(fragment) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'GraphQLTag: Expected an inline data fragment, got `%s`.', JSON.stringify(fragment)) : "TURBOPACK unreachable" : void 0;
    return fragment;
}
module.exports = {
    getFragment: getFragment,
    getNode: getNode,
    getPaginationFragment: getPaginationFragment,
    getRefetchableFragment: getRefetchableFragment,
    getRequest: getRequest,
    getUpdatableQuery: getUpdatableQuery,
    getInlineDataFragment: getInlineDataFragment,
    graphql: graphql,
    isFragment: isFragment,
    isRequest: isRequest,
    isUpdatableQuery: isUpdatableQuery,
    isInlineDataFragment: isInlineDataFragment
};
}),
"[project]/node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function handleFieldErrors(environment, fieldErrors, loggingContext) {
    var _iterator = (0, _createForOfIteratorHelper2["default"])(fieldErrors), _step;
    try {
        for(_iterator.s(); !(_step = _iterator.n()).done;){
            var fieldError = _step.value;
            environment.relayFieldLogger((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, fieldError), {}, {
                uiContext: loggingContext
            }));
        }
    } catch (err) {
        _iterator.e(err);
    } finally{
        _iterator.f();
    }
    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(fieldErrors), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var _fieldError = _step2.value;
            if (eventShouldThrow(_fieldError)) {
                switch(_fieldError.kind){
                    case 'relay_resolver.error':
                        throw new Error("Relay: Resolver error at path '".concat(_fieldError.fieldPath, "' in '").concat(_fieldError.owner, "'. Message: ").concat(_fieldError.error.message));
                    case 'relay_field_payload.error':
                        throw new Error("Relay: Unexpected response payload - check server logs for details.");
                    case 'missing_expected_data.throw':
                        throw new Error("Relay: Missing expected data at path '".concat(_fieldError.fieldPath, "' in '").concat(_fieldError.owner, "'."));
                    case 'missing_required_field.throw':
                        throw new Error("Relay: Missing @required value at path '".concat(_fieldError.fieldPath, "' in '").concat(_fieldError.owner, "'."));
                    case 'missing_required_field.log':
                    case 'missing_expected_data.log':
                        break;
                    default:
                        _fieldError.kind;
                        ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Unexpected event kind: %s', _fieldError.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
                }
            }
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
}
function eventShouldThrow(event) {
    switch(event.kind){
        case 'relay_resolver.error':
        case 'relay_field_payload.error':
            return event.shouldThrow && !event.handled;
        case 'missing_expected_data.throw':
        case 'missing_required_field.throw':
            return !event.handled;
        case 'missing_required_field.log':
        case 'missing_expected_data.log':
            return false;
        default:
            event.kind;
            throw new Error('Relay: Unexpected event kind');
    }
}
function handlePotentialSnapshotErrors(environment, fieldErrors, loggingContext) {
    if (fieldErrors != null) {
        handleFieldErrors(environment, fieldErrors, loggingContext);
    }
}
module.exports = {
    handlePotentialSnapshotErrors: handlePotentialSnapshotErrors,
    eventShouldThrow: eventShouldThrow
};
}),
"[project]/node_modules/relay-runtime/lib/util/RelayDefaultHandleKey.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    DEFAULT_HANDLE_KEY: ''
};
}),
"[project]/node_modules/relay-runtime/lib/util/getRelayHandleKey.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayDefaultHandleKey.js [app-ssr] (ecmascript)"), DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function getRelayHandleKey(handleName, key, fieldName) {
    if (key && key !== DEFAULT_HANDLE_KEY) {
        return "__".concat(key, "_").concat(handleName);
    }
    !(fieldName != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'getRelayHandleKey: Expected either `fieldName` or `key` in `handle` to be provided') : "TURBOPACK unreachable" : void 0;
    return "__".concat(fieldName, "_").concat(handleName);
}
module.exports = getRelayHandleKey;
}),
"[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayFeatureFlags = {
    ENABLE_VARIABLE_CONNECTION_KEY: false,
    ENABLE_RELAY_RESOLVERS: false,
    ENABLE_GETFRAGMENTIDENTIFIER_OPTIMIZATION: false,
    ENABLE_FRIENDLY_QUERY_NAME_GQL_URL: false,
    ENABLE_DO_NOT_WRAP_LIVE_QUERY: false,
    ENABLE_NOTIFY_SUBSCRIPTION: false,
    BATCH_ASYNC_MODULE_UPDATES_FN: null,
    ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT: false,
    MAX_DATA_ID_LENGTH: null,
    STRING_INTERN_LEVEL: 0,
    LOG_MISSING_RECORDS_IN_PROD: false,
    ENABLE_STORE_ID_COLLISION_LOGGING: false,
    ENABLE_NONCOMPLIANT_ERROR_HANDLING_ON_LISTS: false,
    ENABLE_LOOSE_SUBSCRIPTION_ATTRIBUTION: false,
    ENABLE_OPERATION_TRACKER_OPTIMISTIC_UPDATES: false,
    ENABLE_RELAY_OPERATION_TRACKER_SUSPENSE: false,
    PROCESS_OPTIMISTIC_UPDATE_BEFORE_SUBSCRIPTION: false,
    MARK_RESOLVER_VALUES_AS_CLEAN_AFTER_FRAGMENT_REREAD: false,
    ENABLE_CYLE_DETECTION_IN_VARIABLES: false,
    ENABLE_ACTIVITY_COMPATIBILITY: false,
    ENABLE_READ_TIME_RESOLVER_STORAGE_KEY_PREFIX: true,
    ENABLE_USE_PAGINATION_IS_LOADING_FIX: false,
    DISALLOW_NESTED_UPDATES: false,
    ENABLE_TYPENAME_PREFIXED_DATA_ID: false,
    ENABLE_UI_CONTEXT_ON_RELAY_LOGGER: false,
    CHECK_ALL_FRAGMENTS_FOR_MISSING_CLIENT_EDGES: false
};
module.exports = RelayFeatureFlags;
}),
"[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function stableCopy(value) {
    if (!value || typeof value !== 'object') {
        return value;
    }
    if (Array.isArray(value)) {
        return value.map(stableCopy);
    }
    var keys = Object.keys(value).sort();
    var stable = {};
    for(var i = 0; i < keys.length; i++){
        stable[keys[i]] = stableCopy(value[keys[i]]);
    }
    return stable;
}
function hasCycle(value) {
    var parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
    if (!value || typeof value !== 'object') {
        return false;
    }
    if (parents.has(value)) {
        return true;
    }
    var newParents = new Set(parents);
    newParents.add(value);
    var children = Array.isArray(value) ? value : Object.values(value);
    return children.some(function(v) {
        return hasCycle(v, newParents);
    });
}
module.exports = {
    stableCopy: stableCopy,
    hasCycle: hasCycle
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-ssr] (ecmascript)"));
var getRelayHandleKey = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRelayHandleKey.js [app-ssr] (ecmascript)");
var RelayConcreteNode = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-ssr] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-ssr] (ecmascript)"), stableCopy = _require.stableCopy;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var VARIABLE = RelayConcreteNode.VARIABLE, LITERAL = RelayConcreteNode.LITERAL, OBJECT_VALUE = RelayConcreteNode.OBJECT_VALUE, LIST_VALUE = RelayConcreteNode.LIST_VALUE;
var ERRORS_KEY = '__errors';
var MODULE_COMPONENT_KEY_PREFIX = '__module_component_';
var MODULE_OPERATION_KEY_PREFIX = '__module_operation_';
var RELAY_READ_TIME_RESOLVER_KEY_PREFIX = '$r:';
function getArgumentValue(arg, variables) {
    if (arg.kind === VARIABLE) {
        return getStableVariableValue(arg.variableName, variables);
    } else if (arg.kind === LITERAL) {
        return arg.value;
    } else if (arg.kind === OBJECT_VALUE) {
        var value = {};
        arg.fields.forEach(function(field) {
            value[field.name] = getArgumentValue(field, variables);
        });
        return value;
    } else if (arg.kind === LIST_VALUE) {
        var _value = [];
        arg.items.forEach(function(item) {
            item != null ? _value.push(getArgumentValue(item, variables)) : null;
        });
        return _value;
    }
}
function getArgumentValues(args, variables, isWithinUnmatchedTypeRefinement) {
    var values = {};
    if (isWithinUnmatchedTypeRefinement) {
        values[RelayStoreUtils.FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] = true;
    }
    if (args) {
        args.forEach(function(arg) {
            values[arg.name] = getArgumentValue(arg, variables);
        });
    }
    return values;
}
function getHandleStorageKey(handleField, variables) {
    var dynamicKey = handleField.dynamicKey, handle = handleField.handle, key = handleField.key, name = handleField.name, args = handleField.args, filters = handleField.filters;
    var handleName = getRelayHandleKey(handle, key, name);
    var filterArgs = null;
    if (args && filters && args.length !== 0 && filters.length !== 0) {
        filterArgs = args.filter(function(arg) {
            return filters.indexOf(arg.name) > -1;
        });
    }
    if (dynamicKey) {
        filterArgs = filterArgs != null ? [
            dynamicKey
        ].concat((0, _toConsumableArray2["default"])(filterArgs)) : [
            dynamicKey
        ];
    }
    if (filterArgs === null) {
        return handleName;
    } else {
        return formatStorageKey(handleName, getArgumentValues(filterArgs, variables));
    }
}
function getStorageKey(field, variables) {
    if (field.storageKey) {
        return field.storageKey;
    }
    var args = getArguments(field);
    var name = field.name;
    return args && args.length !== 0 ? formatStorageKey(name, getArgumentValues(args, variables)) : name;
}
function getReadTimeResolverStorageKey(field, variables) {
    var storageKey = getStorageKey(field, variables);
    return RelayFeatureFlags.ENABLE_READ_TIME_RESOLVER_STORAGE_KEY_PREFIX ? '$r:' + storageKey : storageKey;
}
function getArguments(field) {
    if (field.kind === 'RelayResolver' || field.kind === 'RelayLiveResolver') {
        var _field$fragment2;
        if (field.args == null) {
            var _field$fragment;
            return (_field$fragment = field.fragment) === null || _field$fragment === void 0 ? void 0 : _field$fragment.args;
        }
        if (((_field$fragment2 = field.fragment) === null || _field$fragment2 === void 0 ? void 0 : _field$fragment2.args) == null) {
            return field.args;
        }
        return field.args.concat(field.fragment.args);
    }
    var args = typeof field.args === 'undefined' ? undefined : field.args;
    return args;
}
function getStableStorageKey(name, args) {
    return formatStorageKey(name, stableCopy(args));
}
function formatStorageKey(name, argValues) {
    if (!argValues) {
        return name;
    }
    var values = [];
    for(var argName in argValues){
        if (argValues.hasOwnProperty(argName)) {
            var value = argValues[argName];
            if (value != null) {
                var _JSON$stringify;
                values.push(argName + ':' + ((_JSON$stringify = JSON.stringify(value)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'undefined'));
            }
        }
    }
    return values.length === 0 ? name : name + "(".concat(values.join(','), ")");
}
function getStableVariableValue(name, variables) {
    !variables.hasOwnProperty(name) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'getVariableValue(): Undefined variable `%s`.', name) : "TURBOPACK unreachable" : void 0;
    return stableCopy(variables[name]);
}
function getModuleComponentKey(documentName) {
    return "".concat(MODULE_COMPONENT_KEY_PREFIX).concat(documentName);
}
function getModuleOperationKey(documentName) {
    return "".concat(MODULE_OPERATION_KEY_PREFIX).concat(documentName);
}
var RelayStoreUtils = {
    ACTOR_IDENTIFIER_KEY: '__actorIdentifier',
    CLIENT_EDGE_TRAVERSAL_PATH: '__clientEdgeTraversalPath',
    FRAGMENTS_KEY: '__fragments',
    FRAGMENT_OWNER_KEY: '__fragmentOwner',
    FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT: '$isWithinUnmatchedTypeRefinement',
    FRAGMENT_PROP_NAME_KEY: '__fragmentPropName',
    MODULE_COMPONENT_KEY: '__module_component',
    ERRORS_KEY: ERRORS_KEY,
    ID_KEY: '__id',
    REF_KEY: '__ref',
    REFS_KEY: '__refs',
    ROOT_ID: 'client:root',
    ROOT_TYPE: '__Root',
    TYPENAME_KEY: '__typename',
    INVALIDATED_AT_KEY: '__invalidated_at',
    RELAY_RESOLVER_VALUE_KEY: '__resolverValue',
    RELAY_RESOLVER_INVALIDATION_KEY: '__resolverValueMayBeInvalid',
    RELAY_RESOLVER_SNAPSHOT_KEY: '__resolverSnapshot',
    RELAY_RESOLVER_ERROR_KEY: '__resolverError',
    RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS: '__resolverOutputTypeRecordIDs',
    RELAY_READ_TIME_RESOLVER_KEY_PREFIX: RELAY_READ_TIME_RESOLVER_KEY_PREFIX,
    formatStorageKey: formatStorageKey,
    getArgumentValue: getArgumentValue,
    getArgumentValues: getArgumentValues,
    getHandleStorageKey: getHandleStorageKey,
    getStorageKey: getStorageKey,
    getReadTimeResolverStorageKey: getReadTimeResolverStorageKey,
    getStableStorageKey: getStableStorageKey,
    getModuleComponentKey: getModuleComponentKey,
    getModuleOperationKey: getModuleOperationKey
};
module.exports = RelayStoreUtils;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), getArgumentValues = _require.getArgumentValues;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function getFragmentVariables(fragment, rootVariables, argumentVariables) {
    if (fragment.argumentDefinitions == null) {
        return argumentVariables;
    }
    var variables;
    fragment.argumentDefinitions.forEach(function(definition) {
        if (argumentVariables.hasOwnProperty(definition.name)) {
            return;
        }
        variables = variables || (0, _objectSpread2["default"])({}, argumentVariables);
        switch(definition.kind){
            case 'LocalArgument':
                variables[definition.name] = definition.defaultValue;
                break;
            case 'RootArgument':
                if (!rootVariables.hasOwnProperty(definition.name)) {
                    variables[definition.name] = undefined;
                    break;
                }
                variables[definition.name] = rootVariables[definition.name];
                break;
            default:
                definition;
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayConcreteVariables: Unexpected node kind `%s` in fragment `%s`.', definition.kind, fragment.name) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
    });
    return variables || argumentVariables;
}
function getOperationVariables(operation, providedVariables, variables) {
    var operationVariables = {};
    operation.argumentDefinitions.forEach(function(def) {
        var value = def.defaultValue;
        if (variables[def.name] != null) {
            value = variables[def.name];
        }
        operationVariables[def.name] = value;
    });
    if (providedVariables != null) {
        Object.keys(providedVariables).forEach(function(varName) {
            operationVariables[varName] = providedVariables[varName].get();
        });
    }
    return operationVariables;
}
function getLocalVariables(currentVariables, argumentDefinitions, args) {
    if (argumentDefinitions == null) {
        return currentVariables;
    }
    var nextVariables = (0, _objectSpread2["default"])({}, currentVariables);
    var nextArgs = args ? getArgumentValues(args, currentVariables) : {};
    argumentDefinitions.forEach(function(def) {
        var _nextArgs$def$name;
        var value = (_nextArgs$def$name = nextArgs[def.name]) !== null && _nextArgs$def$name !== void 0 ? _nextArgs$def$name : def.defaultValue;
        nextVariables[def.name] = value;
    });
    return nextVariables;
}
module.exports = {
    getLocalVariables: getLocalVariables,
    getFragmentVariables: getFragmentVariables,
    getOperationVariables: getOperationVariables
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-ssr] (ecmascript)"), getFragmentVariables = _require.getFragmentVariables;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), CLIENT_EDGE_TRAVERSAL_PATH = _require2.CLIENT_EDGE_TRAVERSAL_PATH, FRAGMENT_OWNER_KEY = _require2.FRAGMENT_OWNER_KEY, FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = _require2.FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT, FRAGMENTS_KEY = _require2.FRAGMENTS_KEY, ID_KEY = _require2.ID_KEY;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function getSingularSelector(fragment, item) {
    !(typeof item === 'object' && item !== null && !Array.isArray(item)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernSelector: Expected value for fragment `%s` to be an object, got ' + '`%s`.', fragment.name, JSON.stringify(item)) : "TURBOPACK unreachable" : void 0;
    var dataID = item[ID_KEY];
    var fragments = item[FRAGMENTS_KEY];
    var mixedOwner = item[FRAGMENT_OWNER_KEY];
    var mixedClientEdgeTraversalPath = item[CLIENT_EDGE_TRAVERSAL_PATH];
    if (typeof dataID === 'string' && typeof fragments === 'object' && fragments !== null && typeof fragments[fragment.name] === 'object' && fragments[fragment.name] !== null && typeof mixedOwner === 'object' && mixedOwner !== null && (mixedClientEdgeTraversalPath == null || Array.isArray(mixedClientEdgeTraversalPath))) {
        var owner = mixedOwner;
        var clientEdgeTraversalPath = mixedClientEdgeTraversalPath;
        var argumentVariables = fragments[fragment.name];
        var fragmentVariables = getFragmentVariables(fragment, owner.variables, argumentVariables);
        var isWithinUnmatchedTypeRefinement = argumentVariables[FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] === true;
        return createReaderSelector(fragment, dataID, fragmentVariables, owner, isWithinUnmatchedTypeRefinement, clientEdgeTraversalPath);
    }
    if ("TURBOPACK compile-time truthy", 1) {
        var stringifiedItem = JSON.stringify(item);
        if (stringifiedItem.length > 499) {
            stringifiedItem = stringifiedItem.substr(0, 498) + "\u2026";
        }
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayModernSelector: Expected object to contain data for fragment `%s`, got ' + '`%s`. Make sure that the parent operation/fragment included fragment ' + '`...%s` without `@relay(mask: false)`.', fragment.name, stringifiedItem, fragment.name) : "TURBOPACK unreachable";
    }
    return null;
}
function getPluralSelector(fragment, items) {
    var selectors = null;
    items.forEach(function(item, ii) {
        var selector = item != null ? getSingularSelector(fragment, item) : null;
        if (selector != null) {
            selectors = selectors || [];
            selectors.push(selector);
        }
    });
    if (selectors == null) {
        return null;
    } else {
        return {
            kind: 'PluralReaderSelector',
            selectors: selectors
        };
    }
}
function getSelector(fragment, item) {
    if (item == null) {
        return item;
    } else if (fragment.metadata && fragment.metadata.plural === true) {
        !Array.isArray(item) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernSelector: Expected value for fragment `%s` to be an array, got `%s`. ' + 'Remove `@relay(plural: true)` from fragment `%s` to allow the prop to be an object.', fragment.name, JSON.stringify(item), fragment.name) : "TURBOPACK unreachable" : void 0;
        return getPluralSelector(fragment, item);
    } else {
        !!Array.isArray(item) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernSelector: Expected value for fragment `%s` to be an object, got `%s`. ' + 'Add `@relay(plural: true)` to fragment `%s` to allow the prop to be an array of items.', fragment.name, JSON.stringify(item), fragment.name) : "TURBOPACK unreachable" : void 0;
        return getSingularSelector(fragment, item);
    }
}
function getSelectorsFromObject(fragments, object) {
    var selectors = {};
    for(var key in fragments){
        if (fragments.hasOwnProperty(key)) {
            var fragment = fragments[key];
            var item = object[key];
            selectors[key] = getSelector(fragment, item);
        }
    }
    return selectors;
}
function getDataIDsFromObject(fragments, object) {
    var ids = {};
    for(var key in fragments){
        if (fragments.hasOwnProperty(key)) {
            var fragment = fragments[key];
            var item = object[key];
            ids[key] = getDataIDsFromFragment(fragment, item);
        }
    }
    return ids;
}
function getDataIDsFromFragment(fragment, item) {
    if (item == null) {
        return item;
    } else if (fragment.metadata && fragment.metadata.plural === true) {
        !Array.isArray(item) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernSelector: Expected value for fragment `%s` to be an array, got `%s`. ' + 'Remove `@relay(plural: true)` from fragment `%s` to allow the prop to be an object.', fragment.name, JSON.stringify(item), fragment.name) : "TURBOPACK unreachable" : void 0;
        return getDataIDs(fragment, item);
    } else {
        !!Array.isArray(item) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernFragmentSpecResolver: Expected value for fragment `%s` to be an object, got `%s`. ' + 'Add `@relay(plural: true)` to fragment `%s` to allow the prop to be an array of items.', fragment.name, JSON.stringify(item), fragment.name) : "TURBOPACK unreachable" : void 0;
        return getDataID(fragment, item);
    }
}
function getDataIDs(fragment, items) {
    var ids = null;
    items.forEach(function(item) {
        var id = item != null ? getDataID(fragment, item) : null;
        if (id != null) {
            ids = ids || [];
            ids.push(id);
        }
    });
    return ids;
}
function getDataID(fragment, item) {
    !(typeof item === 'object' && item !== null && !Array.isArray(item)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernSelector: Expected value for fragment `%s` to be an object, got ' + '`%s`.', fragment.name, JSON.stringify(item)) : "TURBOPACK unreachable" : void 0;
    var dataID = item[ID_KEY];
    if (typeof dataID === 'string') {
        return dataID;
    }
    ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayModernSelector: Expected object to contain data for fragment `%s`, got ' + '`%s`. Make sure that the parent operation/fragment included fragment ' + '`...%s` without `@relay(mask: false)`, or `null` is passed as the fragment ' + "reference for `%s` if it's conditonally included and the condition isn't met.", fragment.name, JSON.stringify(item), fragment.name, fragment.name) : "TURBOPACK unreachable";
    return null;
}
function getVariablesFromObject(fragments, object) {
    var variables = {};
    for(var key in fragments){
        if (fragments.hasOwnProperty(key)) {
            var fragment = fragments[key];
            var item = object[key];
            var itemVariables = getVariablesFromFragment(fragment, item);
            Object.assign(variables, itemVariables);
        }
    }
    return variables;
}
function getVariablesFromFragment(fragment, item) {
    var _fragment$metadata;
    if (item == null) {
        return {};
    } else if (((_fragment$metadata = fragment.metadata) === null || _fragment$metadata === void 0 ? void 0 : _fragment$metadata.plural) === true) {
        !Array.isArray(item) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernSelector: Expected value for fragment `%s` to be an array, got `%s`. ' + 'Remove `@relay(plural: true)` from fragment `%s` to allow the prop to be an object.', fragment.name, JSON.stringify(item), fragment.name) : "TURBOPACK unreachable" : void 0;
        return getVariablesFromPluralFragment(fragment, item);
    } else {
        !!Array.isArray(item) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernFragmentSpecResolver: Expected value for fragment `%s` to be an object, got `%s`. ' + 'Add `@relay(plural: true)` to fragment `%s` to allow the prop to be an array of items.', fragment.name, JSON.stringify(item), fragment.name) : "TURBOPACK unreachable" : void 0;
        return getVariablesFromSingularFragment(fragment, item) || {};
    }
}
function getVariablesFromSingularFragment(fragment, item) {
    var selector = getSingularSelector(fragment, item);
    if (!selector) {
        return null;
    }
    return selector.variables;
}
function getVariablesFromPluralFragment(fragment, items) {
    var variables = {};
    items.forEach(function(value, ii) {
        if (value != null) {
            var itemVariables = getVariablesFromSingularFragment(fragment, value);
            if (itemVariables != null) {
                Object.assign(variables, itemVariables);
            }
        }
    });
    return variables;
}
function areEqualSingularSelectors(thisSelector, thatSelector) {
    return thisSelector.dataID === thatSelector.dataID && thisSelector.node === thatSelector.node && areEqual(thisSelector.variables, thatSelector.variables) && areEqualOwners(thisSelector.owner, thatSelector.owner) && thisSelector.isWithinUnmatchedTypeRefinement === thatSelector.isWithinUnmatchedTypeRefinement && areEqualClientEdgeTraversalPaths(thisSelector.clientEdgeTraversalPath, thatSelector.clientEdgeTraversalPath);
}
function areEqualOwners(thisOwner, thatOwner) {
    if (thisOwner === thatOwner) {
        return true;
    } else {
        return thisOwner.identifier === thatOwner.identifier && areEqual(thisOwner.cacheConfig, thatOwner.cacheConfig);
    }
}
function areEqualClientEdgeTraversalPaths(thisPath, thatPath) {
    if (thisPath === thatPath) {
        return true;
    }
    if (thisPath == null || thatPath == null || thisPath.length !== thatPath.length) {
        return false;
    }
    var idx = thisPath.length;
    while(idx--){
        var a = thisPath[idx];
        var b = thatPath[idx];
        if (a === b) {
            continue;
        }
        if (a == null || b == null || a.clientEdgeDestinationID !== b.clientEdgeDestinationID || a.readerClientEdge !== b.readerClientEdge) {
            return false;
        }
    }
    return true;
}
function areEqualSelectors(a, b) {
    if (a === b) {
        return true;
    } else if (a == null) {
        return b == null;
    } else if (b == null) {
        return a == null;
    } else if (a.kind === 'SingularReaderSelector' && b.kind === 'SingularReaderSelector') {
        return areEqualSingularSelectors(a, b);
    } else if (a.kind === 'PluralReaderSelector' && b.kind === 'PluralReaderSelector') {
        return a.selectors.length === b.selectors.length && a.selectors.every(function(s, i) {
            return areEqualSingularSelectors(s, b.selectors[i]);
        });
    } else {
        return false;
    }
}
function createReaderSelector(fragment, dataID, variables, request) {
    var isWithinUnmatchedTypeRefinement = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var clientEdgeTraversalPath = arguments.length > 5 ? arguments[5] : undefined;
    return {
        kind: 'SingularReaderSelector',
        dataID: dataID,
        isWithinUnmatchedTypeRefinement: isWithinUnmatchedTypeRefinement,
        clientEdgeTraversalPath: clientEdgeTraversalPath !== null && clientEdgeTraversalPath !== void 0 ? clientEdgeTraversalPath : null,
        node: fragment,
        variables: variables,
        owner: request
    };
}
function createNormalizationSelector(node, dataID, variables) {
    return {
        dataID: dataID,
        node: node,
        variables: variables
    };
}
module.exports = {
    areEqualSelectors: areEqualSelectors,
    createReaderSelector: createReaderSelector,
    createNormalizationSelector: createNormalizationSelector,
    getDataIDsFromFragment: getDataIDsFromFragment,
    getDataIDsFromObject: getDataIDsFromObject,
    getSingularSelector: getSingularSelector,
    getPluralSelector: getPluralSelector,
    getSelector: getSelector,
    getSelectorsFromObject: getSelectorsFromObject,
    getVariablesFromSingularFragment: getVariablesFromSingularFragment,
    getVariablesFromPluralFragment: getVariablesFromPluralFragment,
    getVariablesFromFragment: getVariablesFromFragment,
    getVariablesFromObject: getVariablesFromObject
};
}),
"[project]/node_modules/relay-runtime/lib/store/ResolverFragments.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-ssr] (ecmascript)"), getFragment = _require.getFragment;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js [app-ssr] (ecmascript)"), eventShouldThrow = _require2.eventShouldThrow;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-ssr] (ecmascript)"), getSelector = _require3.getSelector;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var contextStack = [];
function withResolverContext(context, cb) {
    contextStack.push(context);
    try {
        return cb();
    } finally{
        contextStack.pop();
    }
}
function readFragment(fragmentInput, fragmentKey) {
    if (!contextStack.length) {
        throw new Error('readFragment should be called only from within a Relay Resolver function.');
    }
    var context = contextStack[contextStack.length - 1];
    var fragmentNode = getFragment(fragmentInput);
    var fragmentSelector = getSelector(fragmentNode, fragmentKey);
    !(fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, "Expected a selector for the fragment of the resolver ".concat(fragmentNode.name, ", but got null.")) : "TURBOPACK unreachable" : void 0;
    !(fragmentSelector.kind === 'SingularReaderSelector') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, "Expected a singular reader selector for the fragment of the resolver ".concat(fragmentNode.name, ", but it was plural.")) : "TURBOPACK unreachable" : void 0;
    var _context$getDataForRe = context.getDataForResolverFragment(fragmentSelector, fragmentKey), data = _context$getDataForRe.data, isMissingData = _context$getDataForRe.isMissingData, fieldErrors = _context$getDataForRe.fieldErrors;
    if (isMissingData || fieldErrors != null && fieldErrors.some(eventShouldThrow)) {
        throw RESOLVER_FRAGMENT_ERRORED_SENTINEL;
    }
    return data;
}
var RESOLVER_FRAGMENT_ERRORED_SENTINEL = {};
module.exports = {
    readFragment: readFragment,
    withResolverContext: withResolverContext,
    RESOLVER_FRAGMENT_ERRORED_SENTINEL: RESOLVER_FRAGMENT_ERRORED_SENTINEL
};
}),
"[project]/node_modules/relay-runtime/lib/store/live-resolvers/resolverDataInjector.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ResolverFragments.js [app-ssr] (ecmascript)"), readFragment = _require.readFragment;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function resolverDataInjector(fragment, _resolverFn, fieldName, isRequiredField) {
    var resolverFn = _resolverFn;
    return function(fragmentKey, args, resolverContext) {
        var data = readFragment(fragment, fragmentKey);
        if (fieldName != null) {
            if (data == null) {
                if (isRequiredField === true) {
                    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected required resolver field `%s` in fragment `%s` to be present. But resolvers fragment data is null/undefined.', fieldName, fragment.name) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
                } else {
                    return resolverFn(null, args, resolverContext);
                }
            }
            if (fieldName in data) {
                if (isRequiredField === true) {
                    !(data[fieldName] != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected required resolver field `%s` in fragment `%s` to be non-null.', fieldName, fragment.name) : "TURBOPACK unreachable" : void 0;
                }
                return resolverFn(data[fieldName], args, resolverContext);
            } else {
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Missing field `%s` in fragment `%s` in resolver response.', fieldName, fragment.name) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
        } else {
            return resolverFn(null, args, resolverContext);
        }
    };
}
module.exports = resolverDataInjector;
}),
"[project]/node_modules/relay-runtime/lib/util/isPromise.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function isPromise(p) {
    return p != null && typeof p === 'object' && typeof p.then === 'function';
}
module.exports = isPromise;
}),
"[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isPromise = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/isPromise.js [app-ssr] (ecmascript)");
var hostReportError = swallowError;
var RelayObservable = /*#__PURE__*/ function() {
    RelayObservable.create = function create(source) {
        return new RelayObservable(source);
    };
    function RelayObservable(source) {
        if ("TURBOPACK compile-time truthy", 1) {
            if (!source || typeof source !== 'function') {
                throw new Error('Source must be a Function: ' + String(source));
            }
        }
        this._source = source;
    }
    RelayObservable.onUnhandledError = function onUnhandledError(callback) {
        hostReportError = callback;
    };
    RelayObservable.from = function from(obj) {
        return isObservable(obj) ? fromObservable(obj) : isPromise(obj) ? fromPromise(obj) : fromValue(obj);
    };
    var _proto = RelayObservable.prototype;
    _proto["catch"] = function _catch(fn) {
        var _this = this;
        return RelayObservable.create(function(sink) {
            var subscription;
            _this.subscribe({
                start: function start(sub) {
                    subscription = sub;
                },
                next: sink.next,
                complete: sink.complete,
                error: function error(_error2) {
                    try {
                        fn(_error2).subscribe({
                            start: function start(sub) {
                                subscription = sub;
                            },
                            next: sink.next,
                            complete: sink.complete,
                            error: sink.error
                        });
                    } catch (error2) {
                        sink.error(error2, true);
                    }
                }
            });
            return function() {
                return subscription.unsubscribe();
            };
        });
    };
    _proto.concat = function concat(next) {
        var _this2 = this;
        return RelayObservable.create(function(sink) {
            var current;
            _this2.subscribe({
                start: function start(subscription) {
                    current = subscription;
                },
                next: sink.next,
                error: sink.error,
                complete: function complete() {
                    current = next.subscribe(sink);
                }
            });
            return function() {
                current && current.unsubscribe();
            };
        });
    };
    _proto["do"] = function _do(observer) {
        var _this3 = this;
        return RelayObservable.create(function(sink) {
            var both = function both(action) {
                return function() {
                    try {
                        observer[action] && observer[action].apply(observer, arguments);
                    } catch (error) {
                        hostReportError(error, true);
                    }
                    sink[action] && sink[action].apply(sink, arguments);
                };
            };
            return _this3.subscribe({
                start: both('start'),
                next: both('next'),
                error: both('error'),
                complete: both('complete'),
                unsubscribe: both('unsubscribe')
            });
        });
    };
    _proto["finally"] = function _finally(fn) {
        var _this4 = this;
        return RelayObservable.create(function(sink) {
            var subscription = _this4.subscribe(sink);
            return function() {
                subscription.unsubscribe();
                fn();
            };
        });
    };
    _proto.ifEmpty = function ifEmpty(alternate) {
        var _this5 = this;
        return RelayObservable.create(function(sink) {
            var hasValue = false;
            var current;
            current = _this5.subscribe({
                next: function next(value) {
                    hasValue = true;
                    sink.next(value);
                },
                error: sink.error,
                complete: function complete() {
                    if (hasValue) {
                        sink.complete();
                    } else {
                        current = alternate.subscribe(sink);
                    }
                }
            });
            return function() {
                current && current.unsubscribe();
            };
        });
    };
    _proto.subscribe = function subscribe(observer) {
        if ("TURBOPACK compile-time truthy", 1) {
            if (!observer || typeof observer !== 'object') {
                throw new Error('Observer must be an Object with callbacks: ' + String(observer));
            }
        }
        return _subscribe(this._source, observer);
    };
    _proto.map = function map(fn) {
        var _this6 = this;
        return RelayObservable.create(function(sink) {
            var subscription = _this6.subscribe({
                complete: sink.complete,
                error: sink.error,
                next: function next(value) {
                    try {
                        var mapValue = fn(value);
                        sink.next(mapValue);
                    } catch (error) {
                        sink.error(error, true);
                    }
                }
            });
            return function() {
                subscription.unsubscribe();
            };
        });
    };
    _proto.mergeMap = function mergeMap(fn) {
        var _this7 = this;
        return RelayObservable.create(function(sink) {
            var subscriptions = [];
            function start(subscription) {
                this._sub = subscription;
                subscriptions.push(subscription);
            }
            function complete() {
                subscriptions.splice(subscriptions.indexOf(this._sub), 1);
                if (subscriptions.length === 0) {
                    sink.complete();
                }
            }
            _this7.subscribe({
                start: start,
                next: function next(value) {
                    try {
                        if (!sink.closed) {
                            RelayObservable.from(fn(value)).subscribe({
                                start: start,
                                next: sink.next,
                                error: sink.error,
                                complete: complete
                            });
                        }
                    } catch (error) {
                        sink.error(error, true);
                    }
                },
                error: sink.error,
                complete: complete
            });
            return function() {
                subscriptions.forEach(function(sub) {
                    return sub.unsubscribe();
                });
                subscriptions.length = 0;
            };
        });
    };
    _proto.poll = function poll(pollInterval) {
        var _this8 = this;
        if ("TURBOPACK compile-time truthy", 1) {
            if (typeof pollInterval !== 'number' || pollInterval <= 0) {
                throw new Error('RelayObservable: Expected pollInterval to be positive, got: ' + pollInterval);
            }
        }
        return RelayObservable.create(function(sink) {
            var subscription;
            var timeout;
            var poll = function poll() {
                subscription = _this8.subscribe({
                    next: sink.next,
                    error: sink.error,
                    complete: function complete() {
                        timeout = setTimeout(poll, pollInterval);
                    }
                });
            };
            poll();
            return function() {
                clearTimeout(timeout);
                subscription.unsubscribe();
            };
        });
    };
    _proto.toPromise = function toPromise() {
        var _this9 = this;
        return new Promise(function(resolve, reject) {
            var resolved = false;
            _this9.subscribe({
                next: function next(val) {
                    if (!resolved) {
                        resolved = true;
                        resolve(val);
                    }
                },
                error: reject,
                complete: resolve
            });
        });
    };
    return RelayObservable;
}();
function isObservable(obj) {
    return typeof obj === 'object' && obj !== null && typeof obj.subscribe === 'function';
}
function fromObservable(obj) {
    return obj instanceof RelayObservable ? obj : RelayObservable.create(function(sink) {
        return obj.subscribe(sink);
    });
}
function fromPromise(promise) {
    return RelayObservable.create(function(sink) {
        promise.then(function(value) {
            sink.next(value);
            sink.complete();
        }, sink.error);
    });
}
function fromValue(value) {
    return RelayObservable.create(function(sink) {
        sink.next(value);
        sink.complete();
    });
}
function _subscribe(source, observer) {
    var closed = false;
    var cleanup;
    var withClosed = function withClosed(obj) {
        return Object.defineProperty(obj, 'closed', {
            get: function get() {
                return closed;
            }
        });
    };
    function doCleanup() {
        if (cleanup) {
            if (cleanup.unsubscribe) {
                cleanup.unsubscribe();
            } else {
                try {
                    cleanup();
                } catch (error) {
                    hostReportError(error, true);
                }
            }
            cleanup = undefined;
        }
    }
    var subscription = withClosed({
        unsubscribe: function unsubscribe() {
            if (!closed) {
                closed = true;
                try {
                    observer.unsubscribe && observer.unsubscribe(subscription);
                } catch (error) {
                    hostReportError(error, true);
                } finally{
                    doCleanup();
                }
            }
        }
    });
    try {
        observer.start && observer.start(subscription);
    } catch (error) {
        hostReportError(error, true);
    }
    if (closed) {
        return subscription;
    }
    var sink = withClosed({
        next: function next(value) {
            if (!closed && observer.next) {
                try {
                    observer.next(value);
                } catch (error) {
                    hostReportError(error, true);
                }
            }
        },
        error: function error(_error3, isUncaughtThrownError) {
            if (closed || !observer.error) {
                closed = true;
                hostReportError(_error3, isUncaughtThrownError || false);
                doCleanup();
            } else {
                closed = true;
                try {
                    observer.error(_error3);
                } catch (error2) {
                    hostReportError(error2, true);
                } finally{
                    doCleanup();
                }
            }
        },
        complete: function complete() {
            if (!closed) {
                closed = true;
                try {
                    observer.complete && observer.complete();
                } catch (error) {
                    hostReportError(error, true);
                } finally{
                    doCleanup();
                }
            }
        }
    });
    try {
        cleanup = source(sink);
    } catch (error) {
        sink.error(error, true);
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (cleanup !== undefined && typeof cleanup !== 'function' && (!cleanup || typeof cleanup.unsubscribe !== 'function')) {
            throw new Error('Returned cleanup function which cannot be called: ' + String(cleanup));
        }
    }
    if (closed) {
        doCleanup();
    }
    return subscription;
}
function swallowError(_error, _isUncaughtThrownError) {}
if ("TURBOPACK compile-time truthy", 1) {
    RelayObservable.onUnhandledError(function(error, isUncaughtThrownError) {
        if (isUncaughtThrownError) {
            setTimeout(function() {
                throw error;
            });
        } else if (typeof console !== 'undefined') {
            console.error('RelayObservable: Unhandled Error', error);
        }
    });
}
module.exports = RelayObservable;
}),
"[project]/node_modules/relay-runtime/lib/util/RelayReplaySubject.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)"));
var RelayObservable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var RelayReplaySubject = /*#__PURE__*/ function() {
    function RelayReplaySubject() {
        var _this = this;
        (0, _defineProperty2["default"])(this, "_complete", false);
        (0, _defineProperty2["default"])(this, "_events", []);
        (0, _defineProperty2["default"])(this, "_sinks", new Set());
        (0, _defineProperty2["default"])(this, "_subscription", []);
        this._observable = RelayObservable.create(function(sink) {
            _this._sinks.add(sink);
            var events = _this._events;
            for(var i = 0; i < events.length; i++){
                if (sink.closed) {
                    break;
                }
                var event = events[i];
                switch(event.kind){
                    case 'complete':
                        sink.complete();
                        break;
                    case 'error':
                        sink.error(event.error);
                        break;
                    case 'next':
                        sink.next(event.data);
                        break;
                    default:
                        event.kind;
                        ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReplaySubject: Unknown event kind `%s`.', event.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
                }
            }
            return function() {
                _this._sinks["delete"](sink);
            };
        });
    }
    var _proto = RelayReplaySubject.prototype;
    _proto.complete = function complete() {
        if (this._complete === true) {
            return;
        }
        this._complete = true;
        this._events.push({
            kind: 'complete'
        });
        this._sinks.forEach(function(sink) {
            return sink.complete();
        });
    };
    _proto.error = function error(_error) {
        if (this._complete === true) {
            return;
        }
        this._complete = true;
        this._events.push({
            kind: 'error',
            error: _error
        });
        this._sinks.forEach(function(sink) {
            return sink.error(_error);
        });
    };
    _proto.next = function next(data) {
        if (this._complete === true) {
            return;
        }
        this._events.push({
            kind: 'next',
            data: data
        });
        this._sinks.forEach(function(sink) {
            return sink.next(data);
        });
    };
    _proto.subscribe = function subscribe(observer) {
        var subscription = this._observable.subscribe(observer);
        this._subscription.push(subscription);
        return subscription;
    };
    _proto.unsubscribe = function unsubscribe() {
        var _iterator = (0, _createForOfIteratorHelper2["default"])(this._subscription), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var subscription = _step.value;
                subscription.unsubscribe();
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        this._subscription = [];
    };
    _proto.getObserverCount = function getObserverCount() {
        return this._sinks.size;
    };
    return RelayReplaySubject;
}();
module.exports = RelayReplaySubject;
}),
"[project]/node_modules/relay-runtime/lib/query/fetchQueryInternal.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Observable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-ssr] (ecmascript)");
var RelayReplaySubject = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayReplaySubject.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var WEAKMAP_SUPPORTED = typeof WeakMap === 'function';
var requestCachesByEnvironment = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();
function fetchQuery(environment, operation) {
    return fetchQueryDeduped(environment, operation.request.identifier, function() {
        return environment.execute({
            operation: operation
        });
    });
}
function fetchQueryDeduped(environment, identifier, fetchFn) {
    return Observable.create(function(sink) {
        var requestCache = getRequestCache(environment);
        var cachedRequest = requestCache.get(identifier);
        if (!cachedRequest) {
            fetchFn()["finally"](function() {
                return requestCache["delete"](identifier);
            }).subscribe({
                start: function start(subscription) {
                    cachedRequest = {
                        identifier: identifier,
                        subject: new RelayReplaySubject(),
                        subjectForInFlightStatus: new RelayReplaySubject(),
                        subscription: subscription,
                        promise: null
                    };
                    requestCache.set(identifier, cachedRequest);
                },
                next: function next(response) {
                    var cachedReq = getCachedRequest(requestCache, identifier);
                    cachedReq.subject.next(response);
                    cachedReq.subjectForInFlightStatus.next(response);
                },
                error: function error(_error) {
                    var cachedReq = getCachedRequest(requestCache, identifier);
                    cachedReq.subject.error(_error);
                    cachedReq.subjectForInFlightStatus.error(_error);
                },
                complete: function complete() {
                    var cachedReq = getCachedRequest(requestCache, identifier);
                    cachedReq.subject.complete();
                    cachedReq.subjectForInFlightStatus.complete();
                },
                unsubscribe: function unsubscribe(subscription) {
                    var cachedReq = getCachedRequest(requestCache, identifier);
                    cachedReq.subject.unsubscribe();
                    cachedReq.subjectForInFlightStatus.unsubscribe();
                }
            });
        }
        !(cachedRequest != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '[fetchQueryInternal] fetchQueryDeduped: Expected `start` to be ' + 'called synchronously') : "TURBOPACK unreachable" : void 0;
        return getObservableForCachedRequest(requestCache, cachedRequest).subscribe(sink);
    });
}
function getObservableForCachedRequest(requestCache, cachedRequest) {
    return Observable.create(function(sink) {
        var subscription = cachedRequest.subject.subscribe(sink);
        return function() {
            subscription.unsubscribe();
            var cachedRequestInstance = requestCache.get(cachedRequest.identifier);
            if (cachedRequestInstance) {
                var requestSubscription = cachedRequestInstance.subscription;
                if (requestSubscription != null && cachedRequestInstance.subject.getObserverCount() === 0) {
                    requestSubscription.unsubscribe();
                    requestCache["delete"](cachedRequest.identifier);
                }
            }
        };
    });
}
function getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest) {
    return Observable.create(function(sink) {
        var subscription = cachedRequest.subjectForInFlightStatus.subscribe({
            error: sink.error,
            next: function next(response) {
                if (!environment.isRequestActive(cachedRequest.identifier)) {
                    sink.complete();
                    return;
                }
                sink.next();
            },
            complete: sink.complete,
            unsubscribe: sink.complete
        });
        return function() {
            subscription.unsubscribe();
        };
    });
}
function getPromiseForActiveRequest(environment, request) {
    var requestCache = getRequestCache(environment);
    var cachedRequest = requestCache.get(request.identifier);
    if (!cachedRequest) {
        return null;
    }
    if (!environment.isRequestActive(cachedRequest.identifier)) {
        return null;
    }
    var promise = new Promise(function(resolve, reject) {
        var resolveOnNext = false;
        getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest).subscribe({
            complete: resolve,
            error: reject,
            next: function next(response) {
                if (resolveOnNext) {
                    resolve(response);
                }
            }
        });
        resolveOnNext = true;
    });
    return promise;
}
function getObservableForActiveRequest(environment, request) {
    var requestCache = getRequestCache(environment);
    var cachedRequest = requestCache.get(request.identifier);
    if (!cachedRequest) {
        return null;
    }
    if (!environment.isRequestActive(cachedRequest.identifier)) {
        return null;
    }
    return getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest);
}
function getRequestCache(environment) {
    var cached = requestCachesByEnvironment.get(environment);
    if (cached != null) {
        return cached;
    }
    var requestCache = new Map();
    requestCachesByEnvironment.set(environment, requestCache);
    return requestCache;
}
function getCachedRequest(requestCache, identifier) {
    var cached = requestCache.get(identifier);
    !(cached != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '[fetchQueryInternal] getCachedRequest: Expected request to be cached') : "TURBOPACK unreachable" : void 0;
    return cached;
}
module.exports = {
    fetchQuery: fetchQuery,
    fetchQueryDeduped: fetchQueryDeduped,
    getPromiseForActiveRequest: getPromiseForActiveRequest,
    getObservableForActiveRequest: getObservableForActiveRequest
};
}),
"[project]/node_modules/relay-runtime/lib/store/observeFragmentExperimental.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _asyncToGenerator = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/asyncToGenerator.js [app-ssr] (ecmascript)").default;
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var Observable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/fetchQueryInternal.js [app-ssr] (ecmascript)"), getObservableForActiveRequest = _require.getObservableForActiveRequest;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-ssr] (ecmascript)"), getFragment = _require2.getFragment;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js [app-ssr] (ecmascript)"), handlePotentialSnapshotErrors = _require3.handlePotentialSnapshotErrors;
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-ssr] (ecmascript)"), getSelector = _require4.getSelector;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function waitForFragmentData(_x, _x2, _x3) {
    return _waitForFragmentData.apply(this, arguments);
}
function _waitForFragmentData() {
    _waitForFragmentData = _asyncToGenerator(function*(environment, fragment, fragmentRef) {
        var subscription;
        try {
            var _subscription;
            var data = yield new Promise(function(resolve, reject) {
                subscription = observeFragment(environment, fragment, fragmentRef).subscribe({
                    next: function next(val) {
                        if (val.state === 'ok') {
                            resolve(val.value);
                        } else if (val.state === 'error') {
                            reject(val.error);
                        }
                    }
                });
            });
            (_subscription = subscription) === null || _subscription === void 0 ? void 0 : _subscription.unsubscribe();
            return data;
        } catch (e) {
            var _subscription2;
            (_subscription2 = subscription) === null || _subscription2 === void 0 ? void 0 : _subscription2.unsubscribe();
            throw e;
        }
    });
    return _waitForFragmentData.apply(this, arguments);
}
function observeFragment(environment, fragment, fragmentRef) {
    var _fragmentNode$metadat;
    var fragmentNode = getFragment(fragment);
    var fragmentSelector = getSelector(fragmentNode, fragmentRef);
    !(((_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.hasClientEdges) == null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, "Client edges aren't supported yet.") : "TURBOPACK unreachable" : void 0;
    !(fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected a selector, got null.') : "TURBOPACK unreachable" : void 0;
    switch(fragmentSelector.kind){
        case 'SingularReaderSelector':
            return observeSingularSelector(environment, fragment, fragmentSelector);
        case 'PluralReaderSelector':
            {
                return observePluralSelector(environment, fragment, fragmentSelector);
            }
    }
    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unsupported fragment selector kind') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
}
function observeSingularSelector(environment, fragmentNode, fragmentSelector) {
    var snapshot = environment.lookup(fragmentSelector);
    return Observable.create(function(sink) {
        sink.next(snapshotToFragmentState(environment, fragmentNode, fragmentSelector.owner, snapshot));
        var subscription = environment.subscribe(snapshot, function(nextSnapshot) {
            sink.next(snapshotToFragmentState(environment, fragmentNode, fragmentSelector.owner, nextSnapshot));
        });
        return function() {
            return subscription.dispose();
        };
    });
}
function observePluralSelector(environment, fragmentNode, fragmentSelector) {
    var snapshots = fragmentSelector.selectors.map(function(selector) {
        return environment.lookup(selector);
    });
    return Observable.create(function(sink) {
        var states = snapshots.map(function(snapshot, index) {
            return snapshotToFragmentState(environment, fragmentNode, fragmentSelector.selectors[index].owner, snapshot);
        });
        sink.next(mergeFragmentStates(states));
        var subscriptions = snapshots.map(function(snapshot, index) {
            return environment.subscribe(snapshot, function(latestSnapshot) {
                states[index] = snapshotToFragmentState(environment, fragmentNode, fragmentSelector.selectors[index].owner, latestSnapshot);
                sink.next(mergeFragmentStates(states));
            });
        });
        return function() {
            return subscriptions.forEach(function(subscription) {
                return subscription.dispose();
            });
        };
    });
}
function snapshotToFragmentState(environment, fragmentNode, owner, snapshot) {
    var missingLiveResolverFields = snapshot.missingLiveResolverFields != null && snapshot.missingLiveResolverFields.length > 0;
    var missingClientEdges = snapshot.missingClientEdges != null && snapshot.missingClientEdges.length > 0;
    if (missingLiveResolverFields || missingClientEdges) {
        return {
            state: 'loading'
        };
    }
    if (snapshot.isMissingData) {
        if (getObservableForActiveRequest(environment, owner) != null || environment.getOperationTracker().getPendingOperationsAffectingOwner(owner) != null) {
            return {
                state: 'loading'
            };
        }
    }
    try {
        handlePotentialSnapshotErrors(environment, snapshot.fieldErrors);
    } catch (error) {
        return {
            error: error,
            state: 'error'
        };
    }
    !(snapshot.data != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected data to be non-null.') : "TURBOPACK unreachable" : void 0;
    return {
        state: 'ok',
        value: snapshot.data
    };
}
function mergeFragmentStates(states) {
    var value = [];
    var _iterator = (0, _createForOfIteratorHelper2["default"])(states), _step;
    try {
        for(_iterator.s(); !(_step = _iterator.n()).done;){
            var state = _step.value;
            if (state.state === 'ok') {
                value.push(state.value);
            } else {
                return state;
            }
        }
    } catch (err) {
        _iterator.e(err);
    } finally{
        _iterator.f();
    }
    return {
        state: 'ok',
        value: value
    };
}
module.exports = {
    observeFragment: observeFragment,
    waitForFragmentData: waitForFragmentData
};
}),
"[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function deepFreeze(object) {
    if (!shouldBeFrozen(object)) {
        return object;
    }
    Object.freeze(object);
    Object.getOwnPropertyNames(object).forEach(function(name) {
        var property = object[name];
        if (property && typeof property === 'object' && !Object.isFrozen(property)) {
            deepFreeze(property);
        }
    });
    return object;
}
function shouldBeFrozen(value) {
    return value != null && (Array.isArray(value) || typeof value === 'object' && value.constructor === Object);
}
module.exports = deepFreeze;
}),
"[project]/node_modules/relay-runtime/lib/util/getRequestIdentifier.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-ssr] (ecmascript)"), stableCopy = _require.stableCopy;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function getRequestIdentifier(parameters, variables) {
    var requestID = parameters.cacheID != null ? parameters.cacheID : parameters.id;
    !(requestID != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'getRequestIdentifier: Expected request `%s` to have either a ' + 'valid `id` or `cacheID` property', parameters.name) : "TURBOPACK unreachable" : void 0;
    return requestID + JSON.stringify(stableCopy(variables));
}
module.exports = getRequestIdentifier;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var deepFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-ssr] (ecmascript)");
var getRequestIdentifier = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRequestIdentifier.js [app-ssr] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-ssr] (ecmascript)"), hasCycle = _require.hasCycle;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-ssr] (ecmascript)"), getOperationVariables = _require2.getOperationVariables;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-ssr] (ecmascript)"), createNormalizationSelector = _require3.createNormalizationSelector, createReaderSelector = _require3.createReaderSelector;
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), ROOT_ID = _require4.ROOT_ID;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function createOperationDescriptor(request, variables, cacheConfig) {
    var dataID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ROOT_ID;
    var operation = request.operation;
    var operationVariables = getOperationVariables(operation, request.params.providedVariables, variables);
    if (RelayFeatureFlags.ENABLE_CYLE_DETECTION_IN_VARIABLES) {
        !!hasCycle(operationVariables) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Cycle detected in variables passed to operation `%s`.', request.operation.name) : "TURBOPACK unreachable" : void 0;
    }
    var requestDescriptor = createRequestDescriptor(request, operationVariables, cacheConfig);
    var operationDescriptor = {
        fragment: createReaderSelector(request.fragment, dataID, operationVariables, requestDescriptor),
        request: requestDescriptor,
        root: createNormalizationSelector(operation, dataID, operationVariables)
    };
    if ("TURBOPACK compile-time truthy", 1) {
        Object.freeze(operationDescriptor.fragment);
        Object.freeze(operationDescriptor.root);
        Object.freeze(operationDescriptor);
    }
    return operationDescriptor;
}
function createRequestDescriptor(request, variables, cacheConfig) {
    var requestDescriptor = {
        identifier: getRequestIdentifier(request.params, variables),
        node: request,
        variables: variables,
        cacheConfig: cacheConfig
    };
    if ("TURBOPACK compile-time truthy", 1) {
        deepFreeze(variables);
        Object.freeze(request);
        Object.freeze(requestDescriptor);
    }
    return requestDescriptor;
}
module.exports = {
    createOperationDescriptor: createOperationDescriptor,
    createRequestDescriptor: createRequestDescriptor
};
}),
"[project]/node_modules/relay-runtime/lib/store/observeQueryExperimental.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/observeFragmentExperimental.js [app-ssr] (ecmascript)"), observeFragment = _require.observeFragment;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-ssr] (ecmascript)"), createOperationDescriptor = _require2.createOperationDescriptor;
function observeQuery(environment, gqlQuery, variables) {
    var operation = createOperationDescriptor(gqlQuery, variables);
    var rootFragmentRef = {
        __id: operation.fragment.dataID,
        __fragments: (0, _defineProperty2["default"])({}, operation.fragment.node.name, operation.request.variables),
        __fragmentOwner: operation.request
    };
    var fragmentNode = operation.request.node.fragment;
    return observeFragment(environment, fragmentNode, rootFragmentRef);
}
module.exports = {
    observeQuery: observeQuery
};
}),
"[project]/node_modules/relay-runtime/lib/store/waitForFragmentExperimental.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _asyncToGenerator = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/asyncToGenerator.js [app-ssr] (ecmascript)").default;
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/observeFragmentExperimental.js [app-ssr] (ecmascript)"), observeFragment = _require.observeFragment;
function waitForFragmentData(_x, _x2, _x3) {
    return _waitForFragmentData.apply(this, arguments);
}
function _waitForFragmentData() {
    _waitForFragmentData = _asyncToGenerator(function*(environment, fragment, fragmentRef) {
        var subscription;
        try {
            var _subscription;
            var data = yield new Promise(function(resolve, reject) {
                subscription = observeFragment(environment, fragment, fragmentRef).subscribe({
                    next: function next(val) {
                        if (val.state === 'ok') {
                            resolve(val.value);
                        } else if (val.state === 'error') {
                            reject(val.error);
                        }
                    }
                });
            });
            (_subscription = subscription) === null || _subscription === void 0 ? void 0 : _subscription.unsubscribe();
            return data;
        } catch (e) {
            var _subscription2;
            (_subscription2 = subscription) === null || _subscription2 === void 0 ? void 0 : _subscription2.unsubscribe();
            throw e;
        }
    });
    return _waitForFragmentData.apply(this, arguments);
}
module.exports = {
    waitForFragmentData: waitForFragmentData
};
}),
"[project]/node_modules/relay-runtime/lib/experimental.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var resolverDataInjector = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/resolverDataInjector.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/observeFragmentExperimental.js [app-ssr] (ecmascript)"), observeFragment = _require.observeFragment;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/observeQueryExperimental.js [app-ssr] (ecmascript)"), observeQuery = _require2.observeQuery;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/waitForFragmentExperimental.js [app-ssr] (ecmascript)"), waitForFragmentData = _require3.waitForFragmentData;
function isValueResult(input) {
    return input.ok === true;
}
function isErrorResult(input) {
    return input.ok === false;
}
module.exports = {
    resolverDataInjector: resolverDataInjector,
    isValueResult: isValueResult,
    isErrorResult: isErrorResult,
    observeQuery: observeQuery,
    observeFragment: observeFragment,
    waitForFragmentData: waitForFragmentData
};
}),
"[project]/node_modules/relay-runtime/lib/util/StringInterner.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var internTable = new Map();
var nextIndex = 1;
var digits = initDigitTable();
var INTERN_PREFIX = '\t';
var ESCAPE_PREFIX = '\v';
function initDigitTable() {
    var digits = new Set();
    for(var i = 0; i < 10; ++i){
        digits.add(i.toString());
    }
    return digits;
}
function escape(str) {
    if (str[0] === INTERN_PREFIX && digits.has(str[1]) || str[0] === ESCAPE_PREFIX) {
        return ESCAPE_PREFIX + str;
    }
    return str;
}
function intern(str, limit) {
    if (limit == null || str.length < limit) {
        return escape(str);
    }
    var internedString = internTable.get(str);
    if (internedString != null) {
        return internedString;
    }
    internedString = INTERN_PREFIX + nextIndex++;
    internTable.set(str, internedString);
    return internedString;
}
module.exports = {
    intern: intern
};
}),
"[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/StringInterner.js [app-ssr] (ecmascript)"), intern = _require.intern;
var PREFIX = 'client:';
function generateClientID(id, storageKey, index) {
    var internedId = RelayFeatureFlags.STRING_INTERN_LEVEL <= 0 ? id : intern(id, RelayFeatureFlags.MAX_DATA_ID_LENGTH);
    var key = internedId + ':' + storageKey;
    if (index != null) {
        key += ':' + index;
    }
    if (key.indexOf(PREFIX) !== 0) {
        key = PREFIX + key;
    }
    return key;
}
function isClientID(id) {
    return id.indexOf(PREFIX) === 0;
}
var localID = 0;
function generateUniqueClientID() {
    return "".concat(PREFIX, "local:").concat(localID++);
}
function generateClientObjectClientID(typename, localId, index) {
    var key = "".concat(PREFIX).concat(typename, ":").concat(localId);
    if (index != null) {
        key += ':' + index;
    }
    return key;
}
module.exports = {
    generateClientID: generateClientID,
    generateClientObjectClientID: generateClientObjectClientID,
    generateUniqueClientID: generateUniqueClientID,
    isClientID: isClientID
};
}),
"[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionInterface.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var CONNECTION_CALLS = {
    after: true,
    before: true,
    find: true,
    first: true,
    last: true,
    surrounds: true
};
var config = {
    CURSOR: 'cursor',
    EDGES: 'edges',
    END_CURSOR: 'endCursor',
    HAS_NEXT_PAGE: 'hasNextPage',
    HAS_PREV_PAGE: 'hasPreviousPage',
    NODE: 'node',
    PAGE_INFO_TYPE: 'PageInfo',
    PAGE_INFO: 'pageInfo',
    START_CURSOR: 'startCursor'
};
var ConnectionInterface = {
    inject: function inject(newConfig) {
        config = newConfig;
    },
    get: function get() {
        return config;
    },
    isConnectionCall: function isConnectionCall(call) {
        return CONNECTION_CALLS.hasOwnProperty(call.name);
    }
};
module.exports = ConnectionInterface;
}),
"[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-ssr] (ecmascript)"), generateClientID = _require.generateClientID;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), getStableStorageKey = _require2.getStableStorageKey;
var getRelayHandleKey = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRelayHandleKey.js [app-ssr] (ecmascript)");
var ConnectionInterface = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionInterface.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
var CONNECTION = 'connection';
var NEXT_EDGE_INDEX = '__connection_next_edge_index';
function update(store, payload) {
    var record = store.get(payload.dataID);
    if (!record) {
        return;
    }
    var _ConnectionInterface$ = ConnectionInterface.get(), EDGES = _ConnectionInterface$.EDGES, END_CURSOR = _ConnectionInterface$.END_CURSOR, HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE, HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE, PAGE_INFO = _ConnectionInterface$.PAGE_INFO, PAGE_INFO_TYPE = _ConnectionInterface$.PAGE_INFO_TYPE, START_CURSOR = _ConnectionInterface$.START_CURSOR;
    var serverConnection = record.getLinkedRecord(payload.fieldKey);
    var serverPageInfo = serverConnection && serverConnection.getLinkedRecord(PAGE_INFO);
    if (!serverConnection) {
        record.setValue(null, payload.handleKey, undefined, record.getErrors(payload.fieldKey));
        return;
    }
    var clientConnectionID = generateClientID(record.getDataID(), payload.handleKey);
    var clientConnectionField = record.getLinkedRecord(payload.handleKey);
    var clientConnection = clientConnectionField !== null && clientConnectionField !== void 0 ? clientConnectionField : store.get(clientConnectionID);
    var clientPageInfo = clientConnection && clientConnection.getLinkedRecord(PAGE_INFO);
    if (!clientConnection) {
        var connection = store.create(clientConnectionID, serverConnection.getType());
        connection.setValue(0, NEXT_EDGE_INDEX);
        connection.copyFieldsFrom(serverConnection);
        var serverEdges = serverConnection.getLinkedRecords(EDGES);
        if (serverEdges) {
            serverEdges = serverEdges.map(function(edge) {
                return buildConnectionEdge(store, connection, edge);
            });
            connection.setLinkedRecords(serverEdges, EDGES);
        }
        record.setLinkedRecord(connection, payload.handleKey);
        clientPageInfo = store.create(generateClientID(connection.getDataID(), PAGE_INFO), PAGE_INFO_TYPE);
        clientPageInfo.setValue(false, HAS_NEXT_PAGE);
        clientPageInfo.setValue(false, HAS_PREV_PAGE);
        clientPageInfo.setValue(null, END_CURSOR);
        clientPageInfo.setValue(null, START_CURSOR);
        if (serverPageInfo) {
            clientPageInfo.copyFieldsFrom(serverPageInfo);
        }
        connection.setLinkedRecord(clientPageInfo, PAGE_INFO);
    } else {
        if (clientConnectionField == null) {
            record.setLinkedRecord(clientConnection, payload.handleKey);
        }
        var _connection = clientConnection;
        var _serverEdges = serverConnection.getLinkedRecords(EDGES);
        if (_serverEdges) {
            _serverEdges = _serverEdges.map(function(edge) {
                return buildConnectionEdge(store, _connection, edge);
            });
        }
        var prevEdges = _connection.getLinkedRecords(EDGES);
        var prevPageInfo = _connection.getLinkedRecord(PAGE_INFO);
        _connection.copyFieldsFrom(serverConnection);
        if (prevEdges) {
            _connection.setLinkedRecords(prevEdges, EDGES);
        }
        if (prevPageInfo) {
            _connection.setLinkedRecord(prevPageInfo, PAGE_INFO);
        }
        var nextEdges = [];
        var args = payload.args;
        if (prevEdges && _serverEdges) {
            if (args.after != null) {
                var _clientPageInfo;
                var clientEndCursor = (_clientPageInfo = clientPageInfo) === null || _clientPageInfo === void 0 ? void 0 : _clientPageInfo.getValue(END_CURSOR);
                var serverEndCursor = serverPageInfo === null || serverPageInfo === void 0 ? void 0 : serverPageInfo.getValue(END_CURSOR);
                var isAddingEdgesAfterCurrentPage = clientPageInfo && args.after === clientEndCursor;
                var isFillingOutCurrentPage = clientPageInfo && clientEndCursor === serverEndCursor;
                if (isAddingEdgesAfterCurrentPage || isFillingOutCurrentPage) {
                    var nodeIDs = new Set();
                    mergeEdges(prevEdges, nextEdges, nodeIDs);
                    mergeEdges(_serverEdges, nextEdges, nodeIDs);
                } else {
                    ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected after cursor `%s`, edges must ' + 'be fetched from the end of the list (`%s`).', args.after, clientPageInfo && clientPageInfo.getValue(END_CURSOR)) : "TURBOPACK unreachable";
                    return;
                }
            } else if (args.before != null) {
                if (clientPageInfo && args.before === clientPageInfo.getValue(START_CURSOR)) {
                    var _nodeIDs = new Set();
                    mergeEdges(_serverEdges, nextEdges, _nodeIDs);
                    mergeEdges(prevEdges, nextEdges, _nodeIDs);
                } else {
                    ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected before cursor `%s`, edges must ' + 'be fetched from the beginning of the list (`%s`).', args.before, clientPageInfo && clientPageInfo.getValue(START_CURSOR)) : "TURBOPACK unreachable";
                    return;
                }
            } else {
                nextEdges = _serverEdges;
            }
        } else if (_serverEdges) {
            nextEdges = _serverEdges;
        } else {
            nextEdges = prevEdges;
        }
        if (nextEdges != null && nextEdges !== prevEdges) {
            _connection.setLinkedRecords(nextEdges, EDGES);
        }
        if (clientPageInfo && serverPageInfo) {
            if (args.after == null && args.before == null) {
                clientPageInfo.copyFieldsFrom(serverPageInfo);
            } else if (args.before != null || args.after == null && args.last) {
                clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_PREV_PAGE), HAS_PREV_PAGE);
                var startCursor = serverPageInfo.getValue(START_CURSOR);
                if (typeof startCursor === 'string') {
                    clientPageInfo.setValue(startCursor, START_CURSOR);
                }
            } else if (args.after != null || args.before == null && args.first) {
                clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_NEXT_PAGE), HAS_NEXT_PAGE);
                var endCursor = serverPageInfo.getValue(END_CURSOR);
                if (typeof endCursor === 'string') {
                    clientPageInfo.setValue(endCursor, END_CURSOR);
                }
            }
        }
    }
}
function getConnection(record, key, filters) {
    var handleKey = getRelayHandleKey(CONNECTION, key, null);
    return record.getLinkedRecord(handleKey, filters);
}
function getConnectionID(recordID, key, filters) {
    var handleKey = getRelayHandleKey(CONNECTION, key, null);
    var storageKey = getStableStorageKey(handleKey, filters);
    return generateClientID(recordID, storageKey);
}
function insertEdgeAfter(record, newEdge, cursor) {
    var _ConnectionInterface$2 = ConnectionInterface.get(), CURSOR = _ConnectionInterface$2.CURSOR, EDGES = _ConnectionInterface$2.EDGES;
    var edges = record.getLinkedRecords(EDGES);
    if (!edges) {
        record.setLinkedRecords([
            newEdge
        ], EDGES);
        return;
    }
    var nextEdges;
    if (cursor == null) {
        nextEdges = edges.concat(newEdge);
    } else {
        nextEdges = [];
        var foundCursor = false;
        for(var ii = 0; ii < edges.length; ii++){
            var edge = edges[ii];
            nextEdges.push(edge);
            if (edge == null) {
                continue;
            }
            var edgeCursor = edge.getValue(CURSOR);
            if (cursor === edgeCursor) {
                nextEdges.push(newEdge);
                foundCursor = true;
            }
        }
        if (!foundCursor) {
            nextEdges.push(newEdge);
        }
    }
    record.setLinkedRecords(nextEdges, EDGES);
}
function createEdge(store, record, node, edgeType) {
    var _ConnectionInterface$3 = ConnectionInterface.get(), NODE = _ConnectionInterface$3.NODE;
    var edgeID = generateClientID(record.getDataID(), node.getDataID());
    var edge = store.get(edgeID);
    if (!edge) {
        edge = store.create(edgeID, edgeType);
    }
    edge.setLinkedRecord(node, NODE);
    if (edge.getValue('cursor') == null) {
        edge.setValue(null, 'cursor');
    }
    return edge;
}
function insertEdgeBefore(record, newEdge, cursor) {
    var _ConnectionInterface$4 = ConnectionInterface.get(), CURSOR = _ConnectionInterface$4.CURSOR, EDGES = _ConnectionInterface$4.EDGES;
    var edges = record.getLinkedRecords(EDGES);
    if (!edges) {
        record.setLinkedRecords([
            newEdge
        ], EDGES);
        return;
    }
    var nextEdges;
    if (cursor == null) {
        nextEdges = [
            newEdge
        ].concat(edges);
    } else {
        nextEdges = [];
        var foundCursor = false;
        for(var ii = 0; ii < edges.length; ii++){
            var edge = edges[ii];
            if (edge != null) {
                var edgeCursor = edge.getValue(CURSOR);
                if (cursor === edgeCursor) {
                    nextEdges.push(newEdge);
                    foundCursor = true;
                }
            }
            nextEdges.push(edge);
        }
        if (!foundCursor) {
            nextEdges.unshift(newEdge);
        }
    }
    record.setLinkedRecords(nextEdges, EDGES);
}
function deleteNode(record, nodeID) {
    var _ConnectionInterface$5 = ConnectionInterface.get(), EDGES = _ConnectionInterface$5.EDGES, NODE = _ConnectionInterface$5.NODE;
    var edges = record.getLinkedRecords(EDGES);
    if (!edges) {
        return;
    }
    var nextEdges;
    for(var ii = 0; ii < edges.length; ii++){
        var edge = edges[ii];
        var node = edge && edge.getLinkedRecord(NODE);
        if (node != null && node.getDataID() === nodeID) {
            if (nextEdges === undefined) {
                nextEdges = edges.slice(0, ii);
            }
        } else if (nextEdges !== undefined) {
            nextEdges.push(edge);
        }
    }
    if (nextEdges !== undefined) {
        record.setLinkedRecords(nextEdges, EDGES);
    }
}
function buildConnectionEdge(store, connection, edge) {
    if (edge == null) {
        return edge;
    }
    var _ConnectionInterface$6 = ConnectionInterface.get(), EDGES = _ConnectionInterface$6.EDGES;
    var edgeIndex = connection.getValue(NEXT_EDGE_INDEX);
    !(typeof edgeIndex === 'number') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ConnectionHandler: Expected %s to be a number, got `%s`.', NEXT_EDGE_INDEX, edgeIndex) : "TURBOPACK unreachable" : void 0;
    var edgeID = generateClientID(connection.getDataID(), EDGES, edgeIndex);
    var connectionEdge = store.create(edgeID, edge.getType());
    connectionEdge.copyFieldsFrom(edge);
    if (connectionEdge.getValue('cursor') == null) {
        connectionEdge.setValue(null, 'cursor');
    }
    connection.setValue(edgeIndex + 1, NEXT_EDGE_INDEX);
    return connectionEdge;
}
function mergeEdges(sourceEdges, targetEdges, nodeIDs) {
    var _ConnectionInterface$7 = ConnectionInterface.get(), NODE = _ConnectionInterface$7.NODE;
    for(var ii = 0; ii < sourceEdges.length; ii++){
        var edge = sourceEdges[ii];
        if (!edge) {
            continue;
        }
        var node = edge.getLinkedRecord(NODE);
        var nodeID = node && node.getDataID();
        if (nodeID) {
            if (nodeIDs.has(nodeID)) {
                continue;
            }
            nodeIDs.add(nodeID);
        }
        targetEdges.push(edge);
    }
}
module.exports = {
    buildConnectionEdge: buildConnectionEdge,
    createEdge: createEdge,
    deleteNode: deleteNode,
    getConnection: getConnection,
    getConnectionID: getConnectionID,
    insertEdgeAfter: insertEdgeAfter,
    insertEdgeBefore: insertEdgeBefore,
    update: update
};
}),
"[project]/node_modules/relay-runtime/lib/handlers/connection/MutationHandlers.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var ConnectionHandler = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js [app-ssr] (ecmascript)");
var ConnectionInterface = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionInterface.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
var DeleteRecordHandler = {
    update: function update(store, payload) {
        var record = store.get(payload.dataID);
        if (record != null) {
            var idOrIds = record.getValue(payload.fieldKey);
            if (typeof idOrIds === 'string') {
                store["delete"](idOrIds);
            } else if (Array.isArray(idOrIds)) {
                idOrIds.forEach(function(id) {
                    if (typeof id === 'string') {
                        store["delete"](id);
                    }
                });
            }
        }
    }
};
var DeleteEdgeHandler = {
    update: function update(store, payload) {
        var record = store.get(payload.dataID);
        if (record == null) {
            return;
        }
        var connections = payload.handleArgs.connections;
        !(connections != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'MutationHandlers: Expected connection IDs to be specified.') : "TURBOPACK unreachable" : void 0;
        var idOrIds = record.getValue(payload.fieldKey);
        var idList = Array.isArray(idOrIds) ? idOrIds : [
            idOrIds
        ];
        idList.forEach(function(id) {
            if (typeof id === 'string') {
                var _iterator = (0, _createForOfIteratorHelper2["default"])(connections), _step;
                try {
                    for(_iterator.s(); !(_step = _iterator.n()).done;){
                        var connectionID = _step.value;
                        var connection = store.get(connectionID);
                        if (connection == null) {
                            ("TURBOPACK compile-time truthy", 1) ? warning(false, "[Relay] The connection with id `%s` doesn't exist.", connectionID) : "TURBOPACK unreachable";
                            continue;
                        }
                        ConnectionHandler.deleteNode(connection, id);
                    }
                } catch (err) {
                    _iterator.e(err);
                } finally{
                    _iterator.f();
                }
            }
        });
    }
};
var AppendEdgeHandler = {
    update: edgeUpdater(ConnectionHandler.insertEdgeAfter)
};
var PrependEdgeHandler = {
    update: edgeUpdater(ConnectionHandler.insertEdgeBefore)
};
var AppendNodeHandler = {
    update: nodeUpdater(ConnectionHandler.insertEdgeAfter)
};
var PrependNodeHandler = {
    update: nodeUpdater(ConnectionHandler.insertEdgeBefore)
};
function edgeUpdater(insertFn) {
    return function(store, payload) {
        var _serverEdges;
        var record = store.get(payload.dataID);
        if (record == null) {
            return;
        }
        var connections = payload.handleArgs.connections;
        !(connections != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'MutationHandlers: Expected connection IDs to be specified.') : "TURBOPACK unreachable" : void 0;
        var singleServerEdge, serverEdges;
        try {
            singleServerEdge = record.getLinkedRecord(payload.fieldKey);
        } catch (_unused) {}
        if (!singleServerEdge) {
            try {
                serverEdges = record.getLinkedRecords(payload.fieldKey);
            } catch (_unused2) {}
        }
        if (singleServerEdge == null && serverEdges == null) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'MutationHandlers: Expected the server edge to be non-null.') : "TURBOPACK unreachable";
            return;
        }
        var _ConnectionInterface$ = ConnectionInterface.get(), NODE = _ConnectionInterface$.NODE, EDGES = _ConnectionInterface$.EDGES;
        var serverEdgeList = (_serverEdges = serverEdges) !== null && _serverEdges !== void 0 ? _serverEdges : [
            singleServerEdge
        ];
        var _iterator2 = (0, _createForOfIteratorHelper2["default"])(serverEdgeList), _step2;
        try {
            var _loop = function _loop() {
                var serverEdge = _step2.value;
                if (serverEdge == null) {
                    return "continue";
                }
                var serverNode = serverEdge.getLinkedRecord('node');
                if (!serverNode) {
                    return "continue";
                }
                var serverNodeId = serverNode.getDataID();
                var _iterator3 = (0, _createForOfIteratorHelper2["default"])(connections), _step3;
                try {
                    for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                        var connectionID = _step3.value;
                        var connection = store.get(connectionID);
                        if (connection == null) {
                            ("TURBOPACK compile-time truthy", 1) ? warning(false, "[Relay] The connection with id `%s` doesn't exist.", connectionID) : "TURBOPACK unreachable";
                            continue;
                        }
                        var nodeAlreadyExistsInConnection = (_connection$getLinked = connection.getLinkedRecords(EDGES)) === null || _connection$getLinked === void 0 ? void 0 : _connection$getLinked.some(function(edge) {
                            var _edge$getLinkedRecord;
                            return (edge === null || edge === void 0 ? void 0 : (_edge$getLinkedRecord = edge.getLinkedRecord(NODE)) === null || _edge$getLinkedRecord === void 0 ? void 0 : _edge$getLinkedRecord.getDataID()) === serverNodeId;
                        });
                        if (nodeAlreadyExistsInConnection) {
                            continue;
                        }
                        var clientEdge = ConnectionHandler.buildConnectionEdge(store, connection, serverEdge);
                        !(clientEdge != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'MutationHandlers: Failed to build the edge.') : "TURBOPACK unreachable" : void 0;
                        insertFn(connection, clientEdge);
                    }
                } catch (err) {
                    _iterator3.e(err);
                } finally{
                    _iterator3.f();
                }
            };
            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                var _connection$getLinked;
                var _ret = _loop();
                if (_ret === "continue") continue;
            }
        } catch (err) {
            _iterator2.e(err);
        } finally{
            _iterator2.f();
        }
    };
}
function nodeUpdater(insertFn) {
    return function(store, payload) {
        var _serverNodes;
        var record = store.get(payload.dataID);
        if (record == null) {
            return;
        }
        var _payload$handleArgs = payload.handleArgs, connections = _payload$handleArgs.connections, edgeTypeName = _payload$handleArgs.edgeTypeName;
        !(connections != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'MutationHandlers: Expected connection IDs to be specified.') : "TURBOPACK unreachable" : void 0;
        !(edgeTypeName != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'MutationHandlers: Expected edge typename to be specified.') : "TURBOPACK unreachable" : void 0;
        var singleServerNode;
        var serverNodes;
        try {
            singleServerNode = record.getLinkedRecord(payload.fieldKey);
        } catch (_unused3) {}
        if (!singleServerNode) {
            try {
                serverNodes = record.getLinkedRecords(payload.fieldKey);
            } catch (_unused4) {}
        }
        if (singleServerNode == null && serverNodes == null) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'MutationHandlers: Expected target node to exist.') : "TURBOPACK unreachable";
            return;
        }
        var _ConnectionInterface$2 = ConnectionInterface.get(), NODE = _ConnectionInterface$2.NODE, EDGES = _ConnectionInterface$2.EDGES;
        var serverNodeList = (_serverNodes = serverNodes) !== null && _serverNodes !== void 0 ? _serverNodes : [
            singleServerNode
        ];
        var _iterator4 = (0, _createForOfIteratorHelper2["default"])(serverNodeList), _step4;
        try {
            var _loop2 = function _loop2() {
                var serverNode = _step4.value;
                if (serverNode == null) {
                    return "continue";
                }
                var serverNodeId = serverNode.getDataID();
                var _iterator5 = (0, _createForOfIteratorHelper2["default"])(connections), _step5;
                try {
                    for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                        var connectionID = _step5.value;
                        var connection = store.get(connectionID);
                        if (connection == null) {
                            ("TURBOPACK compile-time truthy", 1) ? warning(false, "[Relay] The connection with id `%s` doesn't exist.", connectionID) : "TURBOPACK unreachable";
                            continue;
                        }
                        var nodeAlreadyExistsInConnection = (_connection$getLinked2 = connection.getLinkedRecords(EDGES)) === null || _connection$getLinked2 === void 0 ? void 0 : _connection$getLinked2.some(function(edge) {
                            var _edge$getLinkedRecord2;
                            return (edge === null || edge === void 0 ? void 0 : (_edge$getLinkedRecord2 = edge.getLinkedRecord(NODE)) === null || _edge$getLinkedRecord2 === void 0 ? void 0 : _edge$getLinkedRecord2.getDataID()) === serverNodeId;
                        });
                        if (nodeAlreadyExistsInConnection) {
                            continue;
                        }
                        var clientEdge = ConnectionHandler.createEdge(store, connection, serverNode, edgeTypeName);
                        !(clientEdge != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'MutationHandlers: Failed to build the edge.') : "TURBOPACK unreachable" : void 0;
                        insertFn(connection, clientEdge);
                    }
                } catch (err) {
                    _iterator5.e(err);
                } finally{
                    _iterator5.f();
                }
            };
            for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                var _connection$getLinked2;
                var _ret2 = _loop2();
                if (_ret2 === "continue") continue;
            }
        } catch (err) {
            _iterator4.e(err);
        } finally{
            _iterator4.f();
        }
    };
}
module.exports = {
    AppendEdgeHandler: AppendEdgeHandler,
    DeleteRecordHandler: DeleteRecordHandler,
    PrependEdgeHandler: PrependEdgeHandler,
    AppendNodeHandler: AppendNodeHandler,
    PrependNodeHandler: PrependNodeHandler,
    DeleteEdgeHandler: DeleteEdgeHandler
};
}),
"[project]/node_modules/relay-runtime/lib/handlers/RelayDefaultHandlerProvider.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ConnectionHandler = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js [app-ssr] (ecmascript)");
var MutationHandlers = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/MutationHandlers.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function RelayDefaultHandlerProvider(handle) {
    switch(handle){
        case 'connection':
            return ConnectionHandler;
        case 'deleteRecord':
            return MutationHandlers.DeleteRecordHandler;
        case 'deleteEdge':
            return MutationHandlers.DeleteEdgeHandler;
        case 'appendEdge':
            return MutationHandlers.AppendEdgeHandler;
        case 'prependEdge':
            return MutationHandlers.PrependEdgeHandler;
        case 'appendNode':
            return MutationHandlers.AppendNodeHandler;
        case 'prependNode':
            return MutationHandlers.PrependNodeHandler;
    }
    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayDefaultHandlerProvider: No handler provided for `%s`.', handle) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
}
module.exports = RelayDefaultHandlerProvider;
}),
"[project]/node_modules/relay-runtime/lib/store/isRelayModernEnvironment.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function isRelayModernEnvironment(environment) {
    return Boolean(environment && environment['@@RelayModernEnvironment']);
}
module.exports = isRelayModernEnvironment;
}),
"[project]/node_modules/relay-runtime/lib/mutations/RelayDeclarativeMutationConfig.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var ConnectionHandler = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
var MutationTypes = Object.freeze({
    RANGE_ADD: 'RANGE_ADD',
    RANGE_DELETE: 'RANGE_DELETE',
    NODE_DELETE: 'NODE_DELETE'
});
var RangeOperations = Object.freeze({
    APPEND: 'append',
    PREPEND: 'prepend'
});
function convert(configs, request, optimisticUpdater, updater) {
    var configOptimisticUpdates = optimisticUpdater ? [
        optimisticUpdater
    ] : [];
    var configUpdates = updater ? [
        updater
    ] : [];
    configs.forEach(function(config) {
        switch(config.type){
            case 'NODE_DELETE':
                var nodeDeleteResult = nodeDelete(config, request);
                if (nodeDeleteResult) {
                    configOptimisticUpdates.push(nodeDeleteResult);
                    configUpdates.push(nodeDeleteResult);
                }
                break;
            case 'RANGE_ADD':
                var rangeAddResult = rangeAdd(config, request);
                if (rangeAddResult) {
                    configOptimisticUpdates.push(rangeAddResult);
                    configUpdates.push(rangeAddResult);
                }
                break;
            case 'RANGE_DELETE':
                var rangeDeleteResult = rangeDelete(config, request);
                if (rangeDeleteResult) {
                    configOptimisticUpdates.push(rangeDeleteResult);
                    configUpdates.push(rangeDeleteResult);
                }
                break;
        }
    });
    return {
        optimisticUpdater: function optimisticUpdater(store, data) {
            configOptimisticUpdates.forEach(function(eachOptimisticUpdater) {
                eachOptimisticUpdater(store, data);
            });
        },
        updater: function updater(store, data) {
            configUpdates.forEach(function(eachUpdater) {
                eachUpdater(store, data);
            });
        }
    };
}
function nodeDelete(config, request) {
    var deletedIDFieldName = config.deletedIDFieldName;
    var rootField = getRootField(request);
    if (!rootField) {
        return null;
    }
    return function(store, data) {
        var payload = store.getRootField(rootField);
        if (!payload) {
            return;
        }
        var deleteID = payload.getValue(deletedIDFieldName);
        var deleteIDs = Array.isArray(deleteID) ? deleteID : [
            deleteID
        ];
        deleteIDs.forEach(function(id) {
            if (id && typeof id === 'string') {
                store["delete"](id);
            }
        });
    };
}
function rangeAdd(config, request) {
    var parentID = config.parentID, connectionInfo = config.connectionInfo, edgeName = config.edgeName;
    if (!parentID) {
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayDeclarativeMutationConfig: For mutation config RANGE_ADD ' + 'to work you must include a parentID') : "TURBOPACK unreachable";
        return null;
    }
    var rootField = getRootField(request);
    if (!connectionInfo || !rootField) {
        return null;
    }
    return function(store, data) {
        var parent = store.get(parentID);
        if (!parent) {
            return;
        }
        var payload = store.getRootField(rootField);
        if (!payload) {
            return;
        }
        var serverEdge = payload.getLinkedRecord(edgeName);
        var _iterator = (0, _createForOfIteratorHelper2["default"])(connectionInfo), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var info = _step.value;
                if (!serverEdge) {
                    continue;
                }
                var connection = ConnectionHandler.getConnection(parent, info.key, info.filters);
                if (!connection) {
                    continue;
                }
                var clientEdge = ConnectionHandler.buildConnectionEdge(store, connection, serverEdge);
                if (!clientEdge) {
                    continue;
                }
                switch(info.rangeBehavior){
                    case 'append':
                        ConnectionHandler.insertEdgeAfter(connection, clientEdge);
                        break;
                    case 'prepend':
                        ConnectionHandler.insertEdgeBefore(connection, clientEdge);
                        break;
                    default:
                        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayDeclarativeMutationConfig: RANGE_ADD range behavior `%s` ' + 'will not work as expected in RelayModern, supported range ' + "behaviors are 'append', 'prepend'.", info.rangeBehavior) : "TURBOPACK unreachable";
                        break;
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
    };
}
function rangeDelete(config, request) {
    var parentID = config.parentID, connectionKeys = config.connectionKeys, pathToConnection = config.pathToConnection, deletedIDFieldName = config.deletedIDFieldName;
    if (!parentID) {
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayDeclarativeMutationConfig: For mutation config RANGE_DELETE ' + 'to work you must include a parentID') : "TURBOPACK unreachable";
        return null;
    }
    var rootField = getRootField(request);
    if (!rootField) {
        return null;
    }
    return function(store, data) {
        if (!data) {
            return;
        }
        var deleteIDs = [];
        var deletedIDField = data[rootField];
        if (deletedIDField && Array.isArray(deletedIDFieldName)) {
            var _iterator2 = (0, _createForOfIteratorHelper2["default"])(deletedIDFieldName), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var eachField = _step2.value;
                    if (deletedIDField && typeof deletedIDField === 'object') {
                        deletedIDField = deletedIDField[eachField];
                    }
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
            if (Array.isArray(deletedIDField)) {
                deletedIDField.forEach(function(idObject) {
                    if (idObject && idObject.id && typeof idObject === 'object' && typeof idObject.id === 'string') {
                        deleteIDs.push(idObject.id);
                    }
                });
            } else if (deletedIDField && deletedIDField.id && typeof deletedIDField.id === 'string') {
                deleteIDs.push(deletedIDField.id);
            }
        } else if (deletedIDField && typeof deletedIDFieldName === 'string' && typeof deletedIDField === 'object') {
            deletedIDField = deletedIDField[deletedIDFieldName];
            if (typeof deletedIDField === 'string') {
                deleteIDs.push(deletedIDField);
            } else if (Array.isArray(deletedIDField)) {
                deletedIDField.forEach(function(id) {
                    if (typeof id === 'string') {
                        deleteIDs.push(id);
                    }
                });
            }
        }
        deleteNode(parentID, connectionKeys, pathToConnection, store, deleteIDs);
    };
}
function deleteNode(parentID, connectionKeys, pathToConnection, store, deleteIDs) {
    ("TURBOPACK compile-time truthy", 1) ? warning(connectionKeys != null, 'RelayDeclarativeMutationConfig: RANGE_DELETE must provide a ' + 'connectionKeys') : "TURBOPACK unreachable";
    var parent = store.get(parentID);
    if (!parent) {
        return;
    }
    if (pathToConnection.length < 2) {
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayDeclarativeMutationConfig: RANGE_DELETE ' + 'pathToConnection must include at least parent and connection') : "TURBOPACK unreachable";
        return;
    }
    var recordProxy = parent;
    for(var i = 1; i < pathToConnection.length - 1; i++){
        if (recordProxy) {
            recordProxy = recordProxy.getLinkedRecord(pathToConnection[i]);
        }
    }
    if (!connectionKeys || !recordProxy) {
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayDeclarativeMutationConfig: RANGE_DELETE ' + 'pathToConnection is incorrect. Unable to find connection with ' + 'parentID: %s and path: %s', parentID, pathToConnection.toString()) : "TURBOPACK unreachable";
        return;
    }
    var _iterator3 = (0, _createForOfIteratorHelper2["default"])(connectionKeys), _step3;
    try {
        var _loop = function _loop() {
            var key = _step3.value;
            var connection = ConnectionHandler.getConnection(recordProxy, key.key, key.filters);
            if (connection) {
                deleteIDs.forEach(function(deleteID) {
                    ConnectionHandler.deleteNode(connection, deleteID);
                });
            }
        };
        for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
            _loop();
        }
    } catch (err) {
        _iterator3.e(err);
    } finally{
        _iterator3.f();
    }
}
function getRootField(request) {
    if (request.fragment.selections && request.fragment.selections.length > 0 && request.fragment.selections[0].kind === 'LinkedField') {
        return request.fragment.selections[0].name;
    }
    return null;
}
module.exports = {
    MutationTypes: MutationTypes,
    RangeOperations: RangeOperations,
    convert: convert
};
}),
"[project]/node_modules/relay-runtime/lib/mutations/applyOptimisticMutation.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-ssr] (ecmascript)"), getRequest = _require.getRequest;
var isRelayModernEnvironment = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/isRelayModernEnvironment.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-ssr] (ecmascript)"), createOperationDescriptor = _require2.createOperationDescriptor;
var RelayDeclarativeMutationConfig = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayDeclarativeMutationConfig.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function applyOptimisticMutation(environment, config) {
    !isRelayModernEnvironment(environment) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'commitMutation: expected `environment` to be an instance of ' + '`RelayModernEnvironment`.') : "TURBOPACK unreachable" : void 0;
    var mutation = getRequest(config.mutation);
    if (mutation.params.operationKind !== 'mutation') {
        throw new Error('commitMutation: Expected mutation operation');
    }
    var optimisticUpdater = config.optimisticUpdater;
    var configs = config.configs, optimisticResponse = config.optimisticResponse, variables = config.variables;
    var operation = createOperationDescriptor(mutation, variables);
    if (configs) {
        var _RelayDeclarativeMuta = RelayDeclarativeMutationConfig.convert(configs, mutation, optimisticUpdater);
        optimisticUpdater = _RelayDeclarativeMuta.optimisticUpdater;
    }
    return environment.applyMutation({
        operation: operation,
        response: optimisticResponse,
        updater: optimisticUpdater
    });
}
module.exports = applyOptimisticMutation;
}),
"[project]/node_modules/relay-runtime/lib/mutations/commitLocalUpdate.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function commitLocalUpdate(environment, updater) {
    environment.commitUpdate(updater);
}
module.exports = commitLocalUpdate;
}),
"[project]/node_modules/relay-runtime/lib/mutations/validateMutation.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
var hasOwnProperty = Object.prototype.hasOwnProperty;
var validateMutation = function validateMutation() {};
if ("TURBOPACK compile-time truthy", 1) {
    var addFieldToDiff = function addFieldToDiff(path, diff, isScalar) {
        var deepLoc = diff;
        path.split('.').forEach(function(key, index, arr) {
            if (deepLoc[key] == null) {
                deepLoc[key] = {};
            }
            if (isScalar && index === arr.length - 1) {
                deepLoc[key] = '<scalar>';
            }
            deepLoc = deepLoc[key];
        });
    };
    validateMutation = function validateMutation(optimisticResponse, mutation, variables) {
        var operationName = mutation.operation.name;
        var context = {
            path: 'ROOT',
            visitedPaths: new Set(),
            variables: variables || {},
            missingDiff: {},
            extraDiff: {},
            moduleImportPaths: new Set()
        };
        validateSelections(optimisticResponse, mutation.operation.selections, context);
        validateOptimisticResponse(optimisticResponse, context);
        ("TURBOPACK compile-time truthy", 1) ? warning(context.missingDiff.ROOT == null, 'Expected `optimisticResponse` to match structure of server response for mutation `%s`, please define fields for all of\n%s', operationName, JSON.stringify(context.missingDiff.ROOT, null, 2)) : "TURBOPACK unreachable";
        ("TURBOPACK compile-time truthy", 1) ? warning(context.extraDiff.ROOT == null, 'Expected `optimisticResponse` to match structure of server response for mutation `%s`, please remove all fields of\n%s', operationName, JSON.stringify(context.extraDiff.ROOT, null, 2)) : "TURBOPACK unreachable";
    };
    var validateSelections = function validateSelections(optimisticResponse, selections, context) {
        selections.forEach(function(selection) {
            return validateSelection(optimisticResponse, selection, context);
        });
    };
    var validateSelection = function validateSelection(optimisticResponse, selection, context) {
        switch(selection.kind){
            case 'Condition':
                validateSelections(optimisticResponse, selection.selections, context);
                return;
            case 'ClientComponent':
            case 'FragmentSpread':
                validateSelections(optimisticResponse, selection.fragment.selections, context);
                return;
            case 'ScalarField':
            case 'LinkedField':
                return validateField(optimisticResponse, selection, context);
            case 'ActorChange':
                return validateField(optimisticResponse, selection.linkedField, context);
            case 'InlineFragment':
                var type = selection.type;
                var isConcreteType = selection.abstractKey == null;
                validateAbstractKey(context, selection.abstractKey);
                selection.selections.forEach(function(subselection) {
                    if (isConcreteType && optimisticResponse.__typename !== type) {
                        return;
                    }
                    validateSelection(optimisticResponse, subselection, context);
                });
                return;
            case 'ClientExtension':
                selection.selections.forEach(function(subselection) {
                    validateSelection(optimisticResponse, subselection, context);
                });
                return;
            case 'ModuleImport':
                return validateModuleImport(context);
            case 'TypeDiscriminator':
                return validateAbstractKey(context, selection.abstractKey);
            case 'ClientEdgeToClientObject':
            case 'LinkedHandle':
            case 'ScalarHandle':
            case 'Defer':
            case 'Stream':
            case 'RelayResolver':
            case 'RelayLiveResolver':
                {
                    return;
                }
            default:
                selection;
                return;
        }
    };
    var validateModuleImport = function validateModuleImport(context) {
        context.moduleImportPaths.add(context.path);
    };
    var validateAbstractKey = function validateAbstractKey(context, abstractKey) {
        if (abstractKey != null) {
            var path = "".concat(context.path, ".").concat(abstractKey);
            context.visitedPaths.add(path);
        }
    };
    var validateField = function validateField(optimisticResponse, field, context) {
        var fieldName = field.alias || field.name;
        var path = "".concat(context.path, ".").concat(fieldName);
        context.visitedPaths.add(path);
        switch(field.kind){
            case 'ScalarField':
                if (hasOwnProperty.call(optimisticResponse, fieldName) === false) {
                    addFieldToDiff(path, context.missingDiff, true);
                }
                return;
            case 'LinkedField':
                var selections = field.selections;
                if (optimisticResponse[fieldName] === null || hasOwnProperty.call(optimisticResponse, fieldName) && optimisticResponse[fieldName] === undefined) {
                    return;
                }
                if (field.plural) {
                    if (Array.isArray(optimisticResponse[fieldName])) {
                        optimisticResponse[fieldName].forEach(function(r) {
                            if (r !== null) {
                                validateSelections(r, selections, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, context), {}, {
                                    path: path
                                }));
                            }
                        });
                        return;
                    } else {
                        addFieldToDiff(path, context.missingDiff);
                        return;
                    }
                } else {
                    if (optimisticResponse[fieldName] instanceof Object) {
                        validateSelections(optimisticResponse[fieldName], selections, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, context), {}, {
                            path: path
                        }));
                        return;
                    } else {
                        addFieldToDiff(path, context.missingDiff);
                        return;
                    }
                }
        }
    };
    var validateOptimisticResponse = function validateOptimisticResponse(optimisticResponse, context) {
        if (Array.isArray(optimisticResponse)) {
            optimisticResponse.forEach(function(r) {
                if (r instanceof Object) {
                    validateOptimisticResponse(r, context);
                }
            });
            return;
        }
        Object.keys(optimisticResponse).forEach(function(key) {
            var value = optimisticResponse[key];
            var path = "".concat(context.path, ".").concat(key);
            if (context.moduleImportPaths.has(path)) {
                return;
            }
            if (!context.visitedPaths.has(path)) {
                addFieldToDiff(path, context.extraDiff);
                return;
            }
            if (value instanceof Object) {
                validateOptimisticResponse(value, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, context), {}, {
                    path: path
                }));
            }
        });
    };
}
module.exports = validateMutation;
}),
"[project]/node_modules/relay-runtime/lib/mutations/commitMutation.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-ssr] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-ssr] (ecmascript)"), getRequest = _require.getRequest;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-ssr] (ecmascript)"), generateUniqueClientID = _require2.generateUniqueClientID;
var isRelayModernEnvironment = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/isRelayModernEnvironment.js [app-ssr] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-ssr] (ecmascript)"), createOperationDescriptor = _require3.createOperationDescriptor;
var RelayDeclarativeMutationConfig = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayDeclarativeMutationConfig.js [app-ssr] (ecmascript)");
var validateMutation = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/validateMutation.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function commitMutation(environment, config) {
    !isRelayModernEnvironment(environment) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'commitMutation: expected `environment` to be an instance of ' + '`RelayModernEnvironment`.') : "TURBOPACK unreachable" : void 0;
    var mutation = getRequest(config.mutation);
    if (mutation.params.operationKind !== 'mutation') {
        throw new Error('commitMutation: Expected mutation operation');
    }
    if (mutation.kind !== 'Request') {
        throw new Error('commitMutation: Expected mutation to be of type request');
    }
    var optimisticResponse = config.optimisticResponse, optimisticUpdater = config.optimisticUpdater, updater = config.updater;
    var configs = config.configs, cacheConfig = config.cacheConfig, onError = config.onError, onUnsubscribe = config.onUnsubscribe, variables = config.variables, uploadables = config.uploadables;
    var operation = createOperationDescriptor(mutation, variables, cacheConfig, generateUniqueClientID());
    if (typeof optimisticResponse === 'function') {
        optimisticResponse = optimisticResponse();
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'commitMutation: Expected `optimisticResponse` to be an object, ' + 'received a function.') : "TURBOPACK unreachable";
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (optimisticResponse instanceof Object) {
            validateMutation(optimisticResponse, mutation, variables);
        }
    }
    if (configs) {
        var _RelayDeclarativeMuta = RelayDeclarativeMutationConfig.convert(configs, mutation, optimisticUpdater, updater);
        optimisticUpdater = _RelayDeclarativeMuta.optimisticUpdater;
        updater = _RelayDeclarativeMuta.updater;
    }
    var errors = [];
    var subscription = environment.executeMutation({
        operation: operation,
        optimisticResponse: optimisticResponse,
        optimisticUpdater: optimisticUpdater,
        updater: updater,
        uploadables: uploadables
    }).subscribe({
        next: function next(payload) {
            var _config$onNext;
            if (Array.isArray(payload)) {
                payload.forEach(function(item) {
                    if (item.errors) {
                        errors.push.apply(errors, (0, _toConsumableArray2["default"])(item.errors));
                    }
                });
            } else {
                if (payload.errors) {
                    errors.push.apply(errors, (0, _toConsumableArray2["default"])(payload.errors));
                }
            }
            (_config$onNext = config.onNext) === null || _config$onNext === void 0 ? void 0 : _config$onNext.call(config);
        },
        complete: function complete() {
            var onCompleted = config.onCompleted;
            if (onCompleted) {
                var snapshot = environment.lookup(operation.fragment);
                onCompleted(snapshot.data, errors.length !== 0 ? errors : null);
            }
        },
        error: onError,
        unsubscribe: onUnsubscribe
    });
    return {
        dispose: subscription.unsubscribe
    };
}
module.exports = commitMutation;
}),
"[project]/node_modules/relay-runtime/lib/util/withProvidedVariables.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
var WEAKMAP_SUPPORTED = typeof WeakMap === 'function';
var debugCache = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();
function withProvidedVariables(userSuppliedVariables, providedVariables) {
    if (providedVariables != null) {
        var operationVariables = {};
        Object.assign(operationVariables, userSuppliedVariables);
        Object.keys(providedVariables).forEach(function(varName) {
            var providerFunction = providedVariables[varName].get;
            var providerResult = providerFunction();
            if (!debugCache.has(providerFunction)) {
                debugCache.set(providerFunction, providerResult);
                operationVariables[varName] = providerResult;
            } else {
                var cachedResult = debugCache.get(providerFunction);
                if ("TURBOPACK compile-time truthy", 1) {
                    ("TURBOPACK compile-time truthy", 1) ? warning(areEqual(providerResult, cachedResult), 'Relay: Expected function `%s` for provider `%s` to be a pure function, ' + 'but got conflicting return values `%s` and `%s`', providerFunction.name, varName, providerResult, cachedResult) : "TURBOPACK unreachable";
                }
                operationVariables[varName] = cachedResult;
            }
        });
        return operationVariables;
    } else {
        return userSuppliedVariables;
    }
}
withProvidedVariables.tests_only_resetDebugCache = ("TURBOPACK compile-time truthy", 1) ? function() {
    debugCache = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();
} : "TURBOPACK unreachable";
module.exports = withProvidedVariables;
}),
"[project]/node_modules/relay-runtime/lib/network/ConvertToExecuteFunction.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayObservable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-ssr] (ecmascript)");
function convertFetch(fn) {
    return function fetch(request, variables, cacheConfig, uploadables, logRequestInfo) {
        var result = fn(request, variables, cacheConfig, uploadables, logRequestInfo);
        if (result instanceof Error) {
            return RelayObservable.create(function(sink) {
                return sink.error(result);
            });
        }
        return RelayObservable.from(result);
    };
}
module.exports = {
    convertFetch: convertFetch
};
}),
"[project]/node_modules/relay-runtime/lib/network/RelayNetwork.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var withProvidedVariables = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/withProvidedVariables.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/ConvertToExecuteFunction.js [app-ssr] (ecmascript)"), convertFetch = _require.convertFetch;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function create(fetchFn, subscribe) {
    var observeFetch = convertFetch(fetchFn);
    function execute(request, variables, cacheConfig, uploadables, logRequestInfo) {
        var operationVariables = withProvidedVariables(variables, request.providedVariables);
        if (request.operationKind === 'subscription') {
            !subscribe ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayNetwork: This network layer does not support Subscriptions. ' + 'To use Subscriptions, provide a custom network layer.') : "TURBOPACK unreachable" : void 0;
            !!uploadables ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayNetwork: Cannot provide uploadables while subscribing.') : "TURBOPACK unreachable" : void 0;
            return subscribe(request, operationVariables, cacheConfig);
        }
        var pollInterval = cacheConfig.poll;
        if (pollInterval != null) {
            !!uploadables ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayNetwork: Cannot provide uploadables while polling.') : "TURBOPACK unreachable" : void 0;
            return observeFetch(request, operationVariables, {
                force: true
            }).poll(pollInterval);
        }
        return observeFetch(request, operationVariables, cacheConfig, uploadables, logRequestInfo);
    }
    return {
        execute: execute
    };
}
module.exports = {
    create: create
};
}),
"[project]/node_modules/relay-runtime/lib/network/RelayQueryResponseCache.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-ssr] (ecmascript)"), stableCopy = _require.stableCopy;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var RelayQueryResponseCache = /*#__PURE__*/ function() {
    function RelayQueryResponseCache(_ref) {
        var size = _ref.size, ttl = _ref.ttl;
        !(size > 0) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayQueryResponseCache: Expected the max cache size to be > 0, got ' + '`%s`.', size) : "TURBOPACK unreachable" : void 0;
        !(ttl > 0) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayQueryResponseCache: Expected the max ttl to be > 0, got `%s`.', ttl) : "TURBOPACK unreachable" : void 0;
        this._responses = new Map();
        this._size = size;
        this._ttl = ttl;
    }
    var _proto = RelayQueryResponseCache.prototype;
    _proto.clear = function clear() {
        this._responses.clear();
    };
    _proto.get = function get(queryID, variables) {
        var _this = this;
        var cacheKey = getCacheKey(queryID, variables);
        this._responses.forEach(function(response, key) {
            if (!isCurrent(response.fetchTime, _this._ttl)) {
                _this._responses["delete"](key);
            }
        });
        var response = this._responses.get(cacheKey);
        if (response == null) {
            return null;
        }
        if (Array.isArray(response.payload)) {
            return response.payload.map(function(payload) {
                return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, payload), {}, {
                    extensions: (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, payload.extensions), {}, {
                        cacheTimestamp: response.fetchTime
                    })
                });
            });
        }
        return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, response.payload), {}, {
            extensions: (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, response.payload.extensions), {}, {
                cacheTimestamp: response.fetchTime
            })
        });
    };
    _proto.set = function set(queryID, variables, payload) {
        var fetchTime = Date.now();
        var cacheKey = getCacheKey(queryID, variables);
        this._responses["delete"](cacheKey);
        this._responses.set(cacheKey, {
            fetchTime: fetchTime,
            payload: payload
        });
        if (this._responses.size > this._size) {
            var firstKey = this._responses.keys().next();
            if (!firstKey.done) {
                this._responses["delete"](firstKey.value);
            }
        }
    };
    return RelayQueryResponseCache;
}();
function getCacheKey(queryID, variables) {
    return JSON.stringify(stableCopy({
        queryID: queryID,
        variables: variables
    }));
}
function isCurrent(fetchTime, ttl) {
    return fetchTime + ttl >= Date.now();
}
module.exports = RelayQueryResponseCache;
}),
"[project]/node_modules/relay-runtime/lib/query/fetchQuery.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var RelayObservable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-ssr] (ecmascript)"), createOperationDescriptor = _require.createOperationDescriptor;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js [app-ssr] (ecmascript)"), handlePotentialSnapshotErrors = _require2.handlePotentialSnapshotErrors;
var fetchQueryInternal = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/fetchQueryInternal.js [app-ssr] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-ssr] (ecmascript)"), getRequest = _require3.getRequest;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function fetchQuery(environment, query, variables, options) {
    var _options$fetchPolicy;
    var queryNode = getRequest(query);
    !(queryNode.params.operationKind === 'query') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'fetchQuery: Expected query operation') : "TURBOPACK unreachable" : void 0;
    var networkCacheConfig = (0, _objectSpread2["default"])({
        force: true
    }, options === null || options === void 0 ? void 0 : options.networkCacheConfig);
    var operation = createOperationDescriptor(queryNode, variables, networkCacheConfig);
    var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'network-only';
    function readData(snapshot) {
        handlePotentialSnapshotErrors(environment, snapshot.fieldErrors);
        return snapshot.data;
    }
    switch(fetchPolicy){
        case 'network-only':
            {
                return getNetworkObservable(environment, operation).map(readData);
            }
        case 'store-or-network':
            {
                if (environment.check(operation).status === 'available') {
                    return RelayObservable.from(environment.lookup(operation.fragment)).map(readData);
                }
                return getNetworkObservable(environment, operation).map(readData);
            }
        default:
            fetchPolicy;
            throw new Error('fetchQuery: Invalid fetchPolicy ' + fetchPolicy);
    }
}
function getNetworkObservable(environment, operation) {
    return fetchQueryInternal.fetchQuery(environment, operation).map(function() {
        return environment.lookup(operation.fragment);
    });
}
module.exports = fetchQuery;
}),
"[project]/node_modules/relay-runtime/lib/query/fetchQuery_DEPRECATED.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-ssr] (ecmascript)"), createOperationDescriptor = _require.createOperationDescriptor;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-ssr] (ecmascript)"), getRequest = _require2.getRequest;
function fetchQuery_DEPRECATED(environment, taggedNode, variables, cacheConfig) {
    var query = getRequest(taggedNode);
    if (query.params.operationKind !== 'query') {
        throw new Error('fetchQuery: Expected query operation');
    }
    var operation = createOperationDescriptor(query, variables, cacheConfig);
    return environment.execute({
        operation: operation
    }).map(function() {
        return environment.lookup(operation.fragment).data;
    }).toPromise();
}
module.exports = fetchQuery_DEPRECATED;
}),
"[project]/node_modules/relay-runtime/lib/query/PreloadableQueryRegistry.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var PreloadableQueryRegistry = /*#__PURE__*/ function() {
    function PreloadableQueryRegistry() {
        this._preloadableQueries = new Map();
        this._callbacks = new Map();
    }
    var _proto = PreloadableQueryRegistry.prototype;
    _proto.set = function set(key, value) {
        this._preloadableQueries.set(key, value);
        var callbacks = this._callbacks.get(key);
        if (callbacks != null) {
            callbacks.forEach(function(cb) {
                try {
                    cb(value);
                } catch (e) {
                    setTimeout(function() {
                        throw e;
                    }, 0);
                }
            });
        }
    };
    _proto.get = function get(key) {
        return this._preloadableQueries.get(key);
    };
    _proto.onLoad = function onLoad(key, callback) {
        var _this$_callbacks$get;
        var callbacks = (_this$_callbacks$get = this._callbacks.get(key)) !== null && _this$_callbacks$get !== void 0 ? _this$_callbacks$get : new Set();
        callbacks.add(callback);
        var dispose = function dispose() {
            callbacks["delete"](callback);
        };
        this._callbacks.set(key, callbacks);
        return {
            dispose: dispose
        };
    };
    _proto.clear = function clear() {
        this._preloadableQueries.clear();
    };
    return PreloadableQueryRegistry;
}();
var preloadableQueryRegistry = new PreloadableQueryRegistry();
module.exports = preloadableQueryRegistry;
}),
"[project]/node_modules/relay-runtime/lib/util/getPendingOperationsForFragment.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/fetchQueryInternal.js [app-ssr] (ecmascript)"), getPromiseForActiveRequest = _require.getPromiseForActiveRequest;
function getPendingOperationsForFragment(environment, fragmentNode, fragmentOwner) {
    var _pendingOperations$ma, _pendingOperations;
    var pendingOperations = [];
    var promise = getPromiseForActiveRequest(environment, fragmentOwner);
    if (promise != null) {
        pendingOperations = [
            fragmentOwner
        ];
    } else {
        var _result$pendingOperat, _result$promise;
        var operationTracker = environment.getOperationTracker();
        var result = operationTracker.getPendingOperationsAffectingOwner(fragmentOwner);
        pendingOperations = (_result$pendingOperat = result === null || result === void 0 ? void 0 : result.pendingOperations) !== null && _result$pendingOperat !== void 0 ? _result$pendingOperat : [];
        promise = (_result$promise = result === null || result === void 0 ? void 0 : result.promise) !== null && _result$promise !== void 0 ? _result$promise : null;
    }
    if (!promise) {
        return null;
    }
    var pendingOperationName = (_pendingOperations$ma = (_pendingOperations = pendingOperations) === null || _pendingOperations === void 0 ? void 0 : _pendingOperations.map(function(op) {
        return op.node.params.name;
    }).join(',')) !== null && _pendingOperations$ma !== void 0 ? _pendingOperations$ma : null;
    if (pendingOperationName == null || pendingOperationName.length === 0) {
        pendingOperationName = 'Unknown pending operation';
    }
    var fragmentName = fragmentNode.name;
    var promiseDisplayName = pendingOperationName === fragmentName ? "Relay(".concat(pendingOperationName, ")") : "Relay(".concat(pendingOperationName, ":").concat(fragmentName, ")");
    promise.displayName = promiseDisplayName;
    environment.__log({
        name: 'pendingoperation.found',
        fragment: fragmentNode,
        fragmentOwner: fragmentOwner,
        pendingOperations: pendingOperations
    });
    return {
        promise: promise,
        pendingOperations: pendingOperations
    };
}
module.exports = getPendingOperationsForFragment;
}),
"[project]/node_modules/relay-runtime/lib/util/isScalarAndEqual.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function isScalarAndEqual(valueA, valueB) {
    return valueA === valueB && (valueA === null || typeof valueA !== 'object');
}
module.exports = isScalarAndEqual;
}),
"[project]/node_modules/relay-runtime/lib/util/recycleNodesInto.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function recycleNodesInto(prevData, nextData) {
    return recycleNodesIntoImpl(prevData, nextData, true);
}
function recycleNodesIntoImpl(prevData, nextData, canMutate) {
    if (prevData === nextData || typeof prevData !== 'object' || !prevData || prevData.constructor !== Object && !Array.isArray(prevData) || typeof nextData !== 'object' || !nextData || nextData.constructor !== Object && !Array.isArray(nextData)) {
        return nextData;
    }
    var canRecycle = false;
    var prevArray = Array.isArray(prevData) ? prevData : null;
    var nextArray = Array.isArray(nextData) ? nextData : null;
    if (prevArray && nextArray) {
        var canMutateNext = canMutate && !Object.isFrozen(nextArray);
        canRecycle = nextArray.reduce(function(wasEqual, nextItem, ii) {
            var prevValue = prevArray[ii];
            var nextValue = recycleNodesIntoImpl(prevValue, nextItem, canMutateNext);
            if (nextValue !== nextArray[ii] && canMutateNext) {
                nextArray[ii] = nextValue;
            }
            return wasEqual && nextValue === prevArray[ii];
        }, true) && prevArray.length === nextArray.length;
    } else if (!prevArray && !nextArray) {
        var prevObject = prevData;
        var nextObject = nextData;
        var prevKeys = Object.keys(prevObject);
        var nextKeys = Object.keys(nextObject);
        var _canMutateNext = canMutate && !Object.isFrozen(nextObject);
        canRecycle = nextKeys.reduce(function(wasEqual, key) {
            var prevValue = prevObject[key];
            var nextValue = recycleNodesIntoImpl(prevValue, nextObject[key], _canMutateNext);
            if (nextValue !== nextObject[key] && _canMutateNext) {
                nextObject[key] = nextValue;
            }
            return wasEqual && nextValue === prevObject[key];
        }, true) && prevKeys.length === nextKeys.length;
    }
    return canRecycle ? prevData : nextData;
}
module.exports = recycleNodesInto;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayModernFragmentSpecResolver.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)"));
var getPendingOperationsForFragment = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getPendingOperationsForFragment.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js [app-ssr] (ecmascript)"), handlePotentialSnapshotErrors = _require.handlePotentialSnapshotErrors;
var isScalarAndEqual = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/isScalarAndEqual.js [app-ssr] (ecmascript)");
var recycleNodesInto = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/recycleNodesInto.js [app-ssr] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-ssr] (ecmascript)"), createRequestDescriptor = _require2.createRequestDescriptor;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-ssr] (ecmascript)"), areEqualSelectors = _require3.areEqualSelectors, createReaderSelector = _require3.createReaderSelector, getSelectorsFromObject = _require3.getSelectorsFromObject;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
var RelayModernFragmentSpecResolver = /*#__PURE__*/ function() {
    function RelayModernFragmentSpecResolver(context, fragments, props, callback, rootIsQueryRenderer) {
        var _this = this;
        (0, _defineProperty2["default"])(this, "_onChange", function() {
            _this._stale = true;
            if (typeof _this._callback === 'function') {
                _this._callback();
            }
        });
        this._callback = callback;
        this._context = context;
        this._data = {};
        this._fragments = fragments;
        this._props = {};
        this._resolvers = {};
        this._stale = false;
        this._rootIsQueryRenderer = rootIsQueryRenderer;
        this.setProps(props);
    }
    var _proto = RelayModernFragmentSpecResolver.prototype;
    _proto.dispose = function dispose() {
        for(var key in this._resolvers){
            if (this._resolvers.hasOwnProperty(key)) {
                disposeCallback(this._resolvers[key]);
            }
        }
    };
    _proto.resolve = function resolve() {
        if (this._stale) {
            var prevData = this._data;
            var nextData;
            for(var key in this._resolvers){
                if (this._resolvers.hasOwnProperty(key)) {
                    var resolver = this._resolvers[key];
                    var prevItem = prevData[key];
                    if (resolver) {
                        var nextItem = resolver.resolve();
                        if (nextData || nextItem !== prevItem) {
                            nextData = nextData || (0, _objectSpread2["default"])({}, prevData);
                            nextData[key] = nextItem;
                        }
                    } else {
                        var prop = this._props[key];
                        var _nextItem = prop !== undefined ? prop : null;
                        if (nextData || !isScalarAndEqual(_nextItem, prevItem)) {
                            nextData = nextData || (0, _objectSpread2["default"])({}, prevData);
                            nextData[key] = _nextItem;
                        }
                    }
                }
            }
            this._data = nextData || prevData;
            this._stale = false;
        }
        return this._data;
    };
    _proto.setCallback = function setCallback(props, callback) {
        this._callback = callback;
        if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
            this.setProps(props);
        }
    };
    _proto.setProps = function setProps(props) {
        this._props = {};
        var ownedSelectors = getSelectorsFromObject(this._fragments, props);
        for(var key in ownedSelectors){
            if (ownedSelectors.hasOwnProperty(key)) {
                var ownedSelector = ownedSelectors[key];
                var resolver = this._resolvers[key];
                if (ownedSelector == null) {
                    if (resolver != null) {
                        resolver.dispose();
                    }
                    resolver = null;
                } else if (ownedSelector.kind === 'PluralReaderSelector') {
                    if (resolver == null) {
                        resolver = new SelectorListResolver(this._context.environment, this._rootIsQueryRenderer, ownedSelector, this._callback != null, this._onChange);
                    } else {
                        !(resolver instanceof SelectorListResolver) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an array.', key) : "TURBOPACK unreachable" : void 0;
                        resolver.setSelector(ownedSelector);
                    }
                } else {
                    if (resolver == null) {
                        resolver = new SelectorResolver(this._context.environment, this._rootIsQueryRenderer, ownedSelector, this._callback != null, this._onChange);
                    } else {
                        !(resolver instanceof SelectorResolver) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an object.', key) : "TURBOPACK unreachable" : void 0;
                        resolver.setSelector(ownedSelector);
                    }
                }
                this._props[key] = props[key];
                this._resolvers[key] = resolver;
            }
        }
        this._stale = true;
    };
    _proto.setVariables = function setVariables(variables, request) {
        for(var key in this._resolvers){
            if (this._resolvers.hasOwnProperty(key)) {
                var resolver = this._resolvers[key];
                if (resolver) {
                    resolver.setVariables(variables, request);
                }
            }
        }
        this._stale = true;
    };
    return RelayModernFragmentSpecResolver;
}();
var SelectorResolver = /*#__PURE__*/ function() {
    function SelectorResolver(environment, rootIsQueryRenderer, selector, subscribeOnConstruction, callback) {
        var _this2 = this;
        (0, _defineProperty2["default"])(this, "_onChange", function(snapshot) {
            _this2._data = snapshot.data;
            _this2._isMissingData = snapshot.isMissingData;
            _this2._fieldErrors = snapshot.fieldErrors;
            _this2._callback();
        });
        var _snapshot = environment.lookup(selector);
        this._callback = callback;
        this._data = _snapshot.data;
        this._isMissingData = _snapshot.isMissingData;
        this._fieldErrors = _snapshot.fieldErrors;
        this._environment = environment;
        this._rootIsQueryRenderer = rootIsQueryRenderer;
        this._selector = selector;
        if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
            if (subscribeOnConstruction) {
                this._subscription = environment.subscribe(_snapshot, this._onChange);
            }
        } else {
            this._subscription = environment.subscribe(_snapshot, this._onChange);
        }
    }
    var _proto2 = SelectorResolver.prototype;
    _proto2.dispose = function dispose() {
        if (this._subscription) {
            this._subscription.dispose();
            this._subscription = null;
        }
    };
    _proto2.resolve = function resolve() {
        if (this._isMissingData === true) {
            var pendingOperationsResult = getPendingOperationsForFragment(this._environment, this._selector.node, this._selector.owner);
            var promise = pendingOperationsResult === null || pendingOperationsResult === void 0 ? void 0 : pendingOperationsResult.promise;
            if (promise != null) {
                if (this._rootIsQueryRenderer) {
                    ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Relay Container for fragment `%s` has missing data and ' + 'would suspend. When using features such as @defer or @module, ' + 'use `useFragment` instead of a Relay Container.', this._selector.node.name) : "TURBOPACK unreachable";
                } else {
                    var _pendingOperationsRes;
                    var pendingOperations = (_pendingOperationsRes = pendingOperationsResult === null || pendingOperationsResult === void 0 ? void 0 : pendingOperationsResult.pendingOperations) !== null && _pendingOperationsRes !== void 0 ? _pendingOperationsRes : [];
                    ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Relay Container for fragment `%s` suspended. When using ' + 'features such as @defer or @module, use `useFragment` instead ' + 'of a Relay Container.', this._selector.node.name) : "TURBOPACK unreachable";
                    this._environment.__log({
                        name: 'suspense.fragment',
                        data: this._data,
                        fragment: this._selector.node,
                        isRelayHooks: false,
                        isMissingData: this._isMissingData,
                        isPromiseCached: false,
                        pendingOperations: pendingOperations
                    });
                    throw promise;
                }
            }
        }
        handlePotentialSnapshotErrors(this._environment, this._fieldErrors);
        return this._data;
    };
    _proto2.setSelector = function setSelector(selector) {
        if (this._subscription != null && areEqualSelectors(selector, this._selector)) {
            return;
        }
        this.dispose();
        var snapshot = this._environment.lookup(selector);
        this._data = recycleNodesInto(this._data, snapshot.data);
        this._isMissingData = snapshot.isMissingData;
        this._fieldErrors = snapshot.fieldErrors;
        this._selector = selector;
        this._subscription = this._environment.subscribe(snapshot, this._onChange);
    };
    _proto2.setVariables = function setVariables(variables, request) {
        if (areEqual(variables, this._selector.variables)) {
            return;
        }
        var requestDescriptor = createRequestDescriptor(request, variables);
        var selector = createReaderSelector(this._selector.node, this._selector.dataID, variables, requestDescriptor);
        this.setSelector(selector);
    };
    return SelectorResolver;
}();
var SelectorListResolver = /*#__PURE__*/ function() {
    function SelectorListResolver(environment, rootIsQueryRenderer, selector, subscribeOnConstruction, callback) {
        var _this3 = this;
        (0, _defineProperty2["default"])(this, "_onChange", function(data) {
            _this3._stale = true;
            _this3._callback();
        });
        this._callback = callback;
        this._data = [];
        this._environment = environment;
        this._resolvers = [];
        this._stale = true;
        this._rootIsQueryRenderer = rootIsQueryRenderer;
        this._subscribeOnConstruction = subscribeOnConstruction;
        this.setSelector(selector);
    }
    var _proto3 = SelectorListResolver.prototype;
    _proto3.dispose = function dispose() {
        this._resolvers.forEach(disposeCallback);
    };
    _proto3.resolve = function resolve() {
        if (this._stale) {
            var prevData = this._data;
            var nextData;
            for(var ii = 0; ii < this._resolvers.length; ii++){
                var prevItem = prevData[ii];
                var nextItem = this._resolvers[ii].resolve();
                if (nextData || nextItem !== prevItem) {
                    nextData = nextData || prevData.slice(0, ii);
                    nextData.push(nextItem);
                }
            }
            if (!nextData && this._resolvers.length !== prevData.length) {
                nextData = prevData.slice(0, this._resolvers.length);
            }
            this._data = nextData || prevData;
            this._stale = false;
        }
        return this._data;
    };
    _proto3.setSelector = function setSelector(selector) {
        var selectors = selector.selectors;
        while(this._resolvers.length > selectors.length){
            var resolver = this._resolvers.pop();
            resolver.dispose();
        }
        for(var ii = 0; ii < selectors.length; ii++){
            if (ii < this._resolvers.length) {
                this._resolvers[ii].setSelector(selectors[ii]);
            } else {
                this._resolvers[ii] = new SelectorResolver(this._environment, this._rootIsQueryRenderer, selectors[ii], this._subscribeOnConstruction, this._onChange);
            }
        }
        this._stale = true;
    };
    _proto3.setVariables = function setVariables(variables, request) {
        this._resolvers.forEach(function(resolver) {
            return resolver.setVariables(variables, request);
        });
        this._stale = true;
    };
    return SelectorListResolver;
}();
function disposeCallback(disposable) {
    disposable && disposable.dispose();
}
module.exports = RelayModernFragmentSpecResolver;
}),
"[project]/node_modules/relay-runtime/lib/store/createFragmentSpecResolver.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayModernFragmentSpecResolver = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernFragmentSpecResolver.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function createFragmentSpecResolver(context, containerName, fragments, props, rootIsQueryRenderer, callback) {
    if ("TURBOPACK compile-time truthy", 1) {
        var fragmentNames = Object.keys(fragments);
        fragmentNames.forEach(function(fragmentName) {
            var propValue = props[fragmentName];
            ("TURBOPACK compile-time truthy", 1) ? warning(propValue !== undefined, 'createFragmentSpecResolver: Expected prop `%s` to be supplied to `%s`, but ' + 'got `undefined`. Pass an explicit `null` if this is intentional.', fragmentName, containerName) : "TURBOPACK unreachable";
        });
    }
    return new RelayModernFragmentSpecResolver(context, fragments, props, callback, rootIsQueryRenderer);
}
module.exports = createFragmentSpecResolver;
}),
"[project]/node_modules/relay-runtime/lib/store/createRelayContext.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var relayContext;
var firstReact;
function createRelayContext(react) {
    if (!relayContext) {
        relayContext = react.createContext(null);
        if ("TURBOPACK compile-time truthy", 1) {
            relayContext.displayName = 'RelayContext';
        }
        firstReact = react;
    }
    !(react === firstReact) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '[createRelayContext]: You are passing a different instance of React', react.version) : "TURBOPACK unreachable" : void 0;
    return relayContext;
}
module.exports = createRelayContext;
}),
"[project]/node_modules/relay-runtime/lib/store/createRelayLoggingContext.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var relayLoggingContext;
var firstReact;
function createRelayLoggingContext(react) {
    if (!relayLoggingContext) {
        relayLoggingContext = react.createContext(null);
        if ("TURBOPACK compile-time truthy", 1) {
            relayLoggingContext.displayName = 'RelayLoggingContext';
        }
        firstReact = react;
    }
    !(react === firstReact) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '[createRelayLoggingContext]: You are passing a different instance of React', react.version) : "TURBOPACK unreachable" : void 0;
    return relayLoggingContext;
}
module.exports = createRelayLoggingContext;
}),
"[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverSuspenseSentinel.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var LIVE_RESOLVER_SUSPENSE_SENTINEL = Object.freeze({
    __LIVE_RESOLVER_SUSPENSE_SENTINEL: true
});
function suspenseSentinel() {
    return LIVE_RESOLVER_SUSPENSE_SENTINEL;
}
function isSuspenseSentinel(value) {
    return value === LIVE_RESOLVER_SUSPENSE_SENTINEL;
}
module.exports = {
    isSuspenseSentinel: isSuspenseSentinel,
    suspenseSentinel: suspenseSentinel
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js [app-ssr] (ecmascript)"));
var _toPropertyKey2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toPropertyKey.js [app-ssr] (ecmascript)"));
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var deepFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-ssr] (ecmascript)"), generateClientObjectClientID = _require.generateClientObjectClientID, isClientID = _require.isClientID;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverSuspenseSentinel.js [app-ssr] (ecmascript)"), isSuspenseSentinel = _require2.isSuspenseSentinel;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), ACTOR_IDENTIFIER_KEY = _require3.ACTOR_IDENTIFIER_KEY, ERRORS_KEY = _require3.ERRORS_KEY, ID_KEY = _require3.ID_KEY, INVALIDATED_AT_KEY = _require3.INVALIDATED_AT_KEY, REF_KEY = _require3.REF_KEY, REFS_KEY = _require3.REFS_KEY, RELAY_RESOLVER_VALUE_KEY = _require3.RELAY_RESOLVER_VALUE_KEY, ROOT_ID = _require3.ROOT_ID, TYPENAME_KEY = _require3.TYPENAME_KEY;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function clone(record) {
    return (0, _objectSpread2["default"])({}, record);
}
function copyFields(source, sink) {
    for(var key in source){
        if (source.hasOwnProperty(key)) {
            if (key !== ID_KEY && key !== TYPENAME_KEY) {
                sink[key] = source[key];
            }
        }
    }
}
function create(dataID, typeName) {
    var record = {};
    record[ID_KEY] = dataID;
    record[TYPENAME_KEY] = typeName;
    return record;
}
function fromObject(json) {
    return json;
}
function getDataID(record) {
    return record[ID_KEY];
}
function getFields(record) {
    if (ERRORS_KEY in record) {
        return Object.keys(record).filter(function(field) {
            return field !== ERRORS_KEY;
        });
    }
    return Object.keys(record);
}
function getType(record) {
    return record[TYPENAME_KEY];
}
function getErrors(record, storageKey) {
    var _record$ERRORS_KEY;
    return (_record$ERRORS_KEY = record[ERRORS_KEY]) === null || _record$ERRORS_KEY === void 0 ? void 0 : _record$ERRORS_KEY[storageKey];
}
function getValue(record, storageKey) {
    var value = record[storageKey];
    if (value && typeof value === 'object') {
        !(!value.hasOwnProperty(REF_KEY) && !value.hasOwnProperty(REFS_KEY)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getValue(): Expected a scalar (non-link) value for `%s.%s` ' + 'but found %s.', record[ID_KEY], storageKey, value.hasOwnProperty(REF_KEY) ? 'a linked record' : 'plural linked records') : "TURBOPACK unreachable" : void 0;
    }
    return value;
}
function hasValue(record, storageKey) {
    return storageKey in record;
}
function getLinkedRecordID(record, storageKey) {
    var maybeLink = record[storageKey];
    if (maybeLink == null) {
        return maybeLink;
    }
    var link = maybeLink;
    !(typeof link === 'object' && link && typeof link[REF_KEY] === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getLinkedRecordID(): Expected `%s.%s` to be a linked ID, ' + 'was `%s`.%s', record[ID_KEY], storageKey, JSON.stringify(link), typeof link === 'object' && link[REFS_KEY] !== undefined ? ' It appears to be a plural linked record: did you mean to call ' + 'getLinkedRecords() instead of getLinkedRecord()?' : '') : "TURBOPACK unreachable" : void 0;
    return link[REF_KEY];
}
function hasLinkedRecordID(record, storageKey) {
    var maybeLink = record[storageKey];
    if (maybeLink == null) {
        return false;
    }
    var link = maybeLink;
    return typeof link === 'object' && link && typeof link[REF_KEY] === 'string';
}
function getLinkedRecordIDs(record, storageKey) {
    var links = record[storageKey];
    if (links == null) {
        return links;
    }
    !(typeof links === 'object' && Array.isArray(links[REFS_KEY])) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getLinkedRecordIDs(): Expected `%s.%s` to contain an array ' + 'of linked IDs, got `%s`.%s', record[ID_KEY], storageKey, JSON.stringify(links), typeof links === 'object' && links[REF_KEY] !== undefined ? ' It appears to be a singular linked record: did you mean to call ' + 'getLinkedRecord() instead of getLinkedRecords()?' : '') : "TURBOPACK unreachable" : void 0;
    return links[REFS_KEY];
}
function hasLinkedRecordIDs(record, storageKey) {
    var links = record[storageKey];
    if (links == null) {
        return false;
    }
    return typeof links === 'object' && Array.isArray(links[REFS_KEY]) && links[REFS_KEY].every(function(link) {
        return typeof link === 'string';
    });
}
function getInvalidationEpoch(record) {
    if (record == null) {
        return null;
    }
    var invalidatedAt = record[INVALIDATED_AT_KEY];
    if (typeof invalidatedAt !== 'number') {
        return null;
    }
    return invalidatedAt;
}
function update(prevRecord, nextRecord) {
    var _updated2;
    if ("TURBOPACK compile-time truthy", 1) {
        var _getType, _getType2;
        var prevID = getDataID(prevRecord);
        var nextID = getDataID(nextRecord);
        ("TURBOPACK compile-time truthy", 1) ? warning(prevID === nextID, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : "TURBOPACK unreachable";
        var prevType = (_getType = getType(prevRecord)) !== null && _getType !== void 0 ? _getType : null;
        var nextType = (_getType2 = getType(nextRecord)) !== null && _getType2 !== void 0 ? _getType2 : null;
        ("TURBOPACK compile-time truthy", 1) ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : "TURBOPACK unreachable";
    }
    var prevErrorsByKey = prevRecord[ERRORS_KEY];
    var nextErrorsByKey = nextRecord[ERRORS_KEY];
    var updated = null;
    if (prevErrorsByKey == null && nextErrorsByKey == null) {
        var _updated;
        for(var storageKey in nextRecord){
            if (updated || !areEqual(prevRecord[storageKey], nextRecord[storageKey])) {
                updated = updated !== null ? updated : (0, _objectSpread2["default"])({}, prevRecord);
                updated[storageKey] = nextRecord[storageKey];
            }
        }
        return (_updated = updated) !== null && _updated !== void 0 ? _updated : prevRecord;
    }
    for(var _storageKey2 in nextRecord){
        if (_storageKey2 === ERRORS_KEY) {
            continue;
        }
        var nextValue = nextRecord[_storageKey2];
        var nextErrors = nextErrorsByKey === null || nextErrorsByKey === void 0 ? void 0 : nextErrorsByKey[_storageKey2];
        if (updated == null) {
            var prevValue = prevRecord[_storageKey2];
            var prevErrors = prevErrorsByKey === null || prevErrorsByKey === void 0 ? void 0 : prevErrorsByKey[_storageKey2];
            if (areEqual(prevValue, nextValue) && areEqual(prevErrors, nextErrors)) {
                continue;
            }
            updated = (0, _objectSpread2["default"])({}, prevRecord);
            if (prevErrorsByKey != null) {
                updated[ERRORS_KEY] = (0, _objectSpread2["default"])({}, prevErrorsByKey);
            }
        }
        setValue(updated, _storageKey2, nextValue);
        setErrors(updated, _storageKey2, nextErrors);
    }
    return (_updated2 = updated) !== null && _updated2 !== void 0 ? _updated2 : prevRecord;
}
function merge(record1, record2) {
    if ("TURBOPACK compile-time truthy", 1) {
        var _getType3, _getType4;
        var prevID = getDataID(record1);
        var nextID = getDataID(record2);
        ("TURBOPACK compile-time truthy", 1) ? warning(prevID === nextID, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : "TURBOPACK unreachable";
        var prevType = (_getType3 = getType(record1)) !== null && _getType3 !== void 0 ? _getType3 : null;
        var nextType = (_getType4 = getType(record2)) !== null && _getType4 !== void 0 ? _getType4 : null;
        ("TURBOPACK compile-time truthy", 1) ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : "TURBOPACK unreachable";
    }
    if (ERRORS_KEY in record1 || ERRORS_KEY in record2) {
        var errors1 = record1[ERRORS_KEY], fields1 = (0, _objectWithoutPropertiesLoose2["default"])(record1, [
            ERRORS_KEY
        ].map(_toPropertyKey2["default"]));
        var errors2 = record2[ERRORS_KEY], fields2 = (0, _objectWithoutPropertiesLoose2["default"])(record2, [
            ERRORS_KEY
        ].map(_toPropertyKey2["default"]));
        var updated = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, fields1), fields2);
        if (errors1 == null && errors2 == null) {
            return updated;
        }
        var updatedErrors = {};
        for(var storageKey in errors1){
            if (fields2.hasOwnProperty(storageKey)) {
                continue;
            }
            updatedErrors[storageKey] = errors1[storageKey];
        }
        for(var _storageKey3 in errors2){
            updatedErrors[_storageKey3] = errors2[_storageKey3];
        }
        for(var _storageKey in updatedErrors){
            updated[ERRORS_KEY] = updatedErrors;
            break;
        }
        return updated;
    } else {
        return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, record1), record2);
    }
}
function freeze(record) {
    deepFreeze(record);
}
function setErrors(record, storageKey, errors) {
    if ("TURBOPACK compile-time truthy", 1) {
        ("TURBOPACK compile-time truthy", 1) ? warning(storageKey in record, 'RelayModernRecord: Invalid error update, `%s` should not be undefined.', storageKey) : "TURBOPACK unreachable";
    }
    var errorsByStorageKey = record[ERRORS_KEY];
    if (errors != null && errors.length > 0) {
        if (errorsByStorageKey == null) {
            record[ERRORS_KEY] = (0, _defineProperty2["default"])({}, storageKey, errors);
        } else {
            errorsByStorageKey[storageKey] = errors;
        }
    } else if (errorsByStorageKey != null) {
        if (delete errorsByStorageKey[storageKey]) {
            for(var otherStorageKey in errorsByStorageKey){
                if (errorsByStorageKey.hasOwnProperty(otherStorageKey)) {
                    return;
                }
            }
            delete record[ERRORS_KEY];
        }
    }
}
function setValue(record, storageKey, value) {
    if ("TURBOPACK compile-time truthy", 1) {
        var prevID = getDataID(record);
        if (storageKey === ID_KEY) {
            ("TURBOPACK compile-time truthy", 1) ? warning(prevID === value, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, value) : "TURBOPACK unreachable";
        } else if (storageKey === TYPENAME_KEY) {
            var _getType5;
            var prevType = (_getType5 = getType(record)) !== null && _getType5 !== void 0 ? _getType5 : null;
            var nextType = value !== null && value !== void 0 ? value : null;
            ("TURBOPACK compile-time truthy", 1) ? warning(isClientID(getDataID(record)) && getDataID(record) !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : "TURBOPACK unreachable";
        }
    }
    record[storageKey] = value;
}
function setLinkedRecordID(record, storageKey, linkedID) {
    var link = {};
    link[REF_KEY] = linkedID;
    record[storageKey] = link;
}
function setLinkedRecordIDs(record, storageKey, linkedIDs) {
    var links = {};
    links[REFS_KEY] = linkedIDs;
    record[storageKey] = links;
}
function setActorLinkedRecordID(record, storageKey, actorIdentifier, linkedID) {
    var link = {};
    link[REF_KEY] = linkedID;
    link[ACTOR_IDENTIFIER_KEY] = actorIdentifier;
    record[storageKey] = link;
}
function getActorLinkedRecordID(record, storageKey) {
    var link = record[storageKey];
    if (link == null) {
        return link;
    }
    !(typeof link === 'object' && typeof link[REF_KEY] === 'string' && link[ACTOR_IDENTIFIER_KEY] != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getActorLinkedRecordID(): Expected `%s.%s` to be an actor specific linked ID, ' + 'was `%s`.', record[ID_KEY], storageKey, JSON.stringify(link)) : "TURBOPACK unreachable" : void 0;
    return [
        link[ACTOR_IDENTIFIER_KEY],
        link[REF_KEY]
    ];
}
function getResolverLinkedRecordID(record, typeName) {
    var id = getValue(record, RELAY_RESOLVER_VALUE_KEY);
    if (id == null || isSuspenseSentinel(id)) {
        return null;
    }
    if (typeof id === 'object') {
        id = id.id;
    }
    !(typeof id === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getResolverLinkedRecordID(): Expected value to be a linked ID, ' + 'was `%s`.', JSON.stringify(id)) : "TURBOPACK unreachable" : void 0;
    return generateClientObjectClientID(typeName, id);
}
function getResolverLinkedRecordIDs(record, typeName) {
    var resolverValue = getValue(record, RELAY_RESOLVER_VALUE_KEY);
    if (resolverValue == null || isSuspenseSentinel(resolverValue)) {
        return null;
    }
    !Array.isArray(resolverValue) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getResolverLinkedRecordIDs(): Expected value to be an array of linked IDs, ' + 'was `%s`.', JSON.stringify(resolverValue)) : "TURBOPACK unreachable" : void 0;
    return resolverValue.map(function(id) {
        if (id == null) {
            return null;
        }
        if (typeof id === 'object') {
            id = id.id;
        }
        !(typeof id === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getResolverLinkedRecordIDs(): Expected item within resolver linked field to be a DataID, ' + 'was `%s`.', JSON.stringify(id)) : "TURBOPACK unreachable" : void 0;
        return generateClientObjectClientID(typeName, id);
    });
}
function toJSON(record) {
    return record;
}
module.exports = {
    clone: clone,
    copyFields: copyFields,
    create: create,
    freeze: freeze,
    fromObject: fromObject,
    getDataID: getDataID,
    getErrors: getErrors,
    getFields: getFields,
    getInvalidationEpoch: getInvalidationEpoch,
    getLinkedRecordID: getLinkedRecordID,
    getLinkedRecordIDs: getLinkedRecordIDs,
    getType: getType,
    getValue: getValue,
    hasValue: hasValue,
    hasLinkedRecordID: hasLinkedRecordID,
    hasLinkedRecordIDs: hasLinkedRecordIDs,
    merge: merge,
    setErrors: setErrors,
    setValue: setValue,
    setLinkedRecordID: setLinkedRecordID,
    setLinkedRecordIDs: setLinkedRecordIDs,
    update: update,
    getActorLinkedRecordID: getActorLinkedRecordID,
    setActorLinkedRecordID: setActorLinkedRecordID,
    getResolverLinkedRecordID: getResolverLinkedRecordID,
    getResolverLinkedRecordIDs: getResolverLinkedRecordIDs,
    toJSON: toJSON
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayRecordState.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayRecordState = {
    EXISTENT: 'EXISTENT',
    NONEXISTENT: 'NONEXISTENT',
    UNKNOWN: 'UNKNOWN'
};
module.exports = RelayRecordState;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)");
var RelayRecordState = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordState.js [app-ssr] (ecmascript)");
var EXISTENT = RelayRecordState.EXISTENT, NONEXISTENT = RelayRecordState.NONEXISTENT, UNKNOWN = RelayRecordState.UNKNOWN;
var RelayRecordSource = /*#__PURE__*/ function() {
    function RelayRecordSource(records) {
        var _this = this;
        this._records = new Map();
        if (records != null) {
            Object.keys(records).forEach(function(key) {
                var object = records[key];
                var record = RelayModernRecord.fromObject(object);
                _this._records.set(key, record);
            });
        }
    }
    RelayRecordSource.create = function create(records) {
        return new RelayRecordSource(records);
    };
    var _proto = RelayRecordSource.prototype;
    _proto.clear = function clear() {
        this._records = new Map();
    };
    _proto["delete"] = function _delete(dataID) {
        this._records.set(dataID, null);
    };
    _proto.get = function get(dataID) {
        return this._records.get(dataID);
    };
    _proto.getRecordIDs = function getRecordIDs() {
        return Array.from(this._records.keys());
    };
    _proto.getStatus = function getStatus(dataID) {
        if (!this._records.has(dataID)) {
            return UNKNOWN;
        }
        return this._records.get(dataID) == null ? NONEXISTENT : EXISTENT;
    };
    _proto.has = function has(dataID) {
        return this._records.has(dataID);
    };
    _proto.remove = function remove(dataID) {
        this._records["delete"](dataID);
    };
    _proto.set = function set(dataID, record) {
        this._records.set(dataID, record);
    };
    _proto.size = function size() {
        return this._records.size;
    };
    _proto.toJSON = function toJSON() {
        var obj = {};
        var _iterator = (0, _createForOfIteratorHelper2["default"])(this._records), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var _step$value = _step.value, key = _step$value[0], record = _step$value[1];
                obj[key] = RelayModernRecord.toJSON(record);
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        return obj;
    };
    return RelayRecordSource;
}();
module.exports = RelayRecordSource;
}),
"[project]/node_modules/relay-runtime/lib/multi-actor-environment/ActorIdentifier.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE = 'INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE';
function assertInternalActorIdentifier(actorIdentifier) {
    !(actorIdentifier === INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected to use only internal version of the `actorIdentifier`. "%s" was provided.', actorIdentifier) : "TURBOPACK unreachable" : void 0;
}
module.exports = {
    assertInternalActorIdentifier: assertInternalActorIdentifier,
    getActorIdentifier: function getActorIdentifier(actorID) {
        return actorID;
    },
    getDefaultActorIdentifier: function getDefaultActorIdentifier() {
        throw new Error('Not Implemented');
    },
    INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE: INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE
};
}),
"[project]/node_modules/relay-runtime/lib/multi-actor-environment/ActorUtils.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ACTOR_IDENTIFIER_FIELD_NAME = 'actor_key';
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/multi-actor-environment/ActorIdentifier.js [app-ssr] (ecmascript)"), getActorIdentifier = _require.getActorIdentifier;
function getActorIdentifierFromPayload(payload) {
    if (payload != null && typeof payload === 'object' && typeof payload[ACTOR_IDENTIFIER_FIELD_NAME] === 'string') {
        return getActorIdentifier(payload[ACTOR_IDENTIFIER_FIELD_NAME]);
    }
}
module.exports = {
    ACTOR_IDENTIFIER_FIELD_NAME: ACTOR_IDENTIFIER_FIELD_NAME,
    getActorIdentifierFromPayload: getActorIdentifierFromPayload
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayErrorTrie.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js [app-ssr] (ecmascript)"));
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-ssr] (ecmascript)"));
var _excluded = [
    "path",
    "locations"
];
var SELF = Symbol('$SELF');
function buildErrorTrie(errors) {
    if (errors == null) {
        return null;
    }
    var trie = new Map();
    var _iterator = (0, _createForOfIteratorHelper2["default"])(errors), _step;
    try {
        ERRORS: for(_iterator.s(); !(_step = _iterator.n()).done;){
            var _step$value = _step.value, path = _step$value.path, _ = _step$value.locations, error = (0, _objectWithoutPropertiesLoose2["default"])(_step$value, _excluded);
            if (path == null) {
                continue;
            }
            var length = path.length;
            if (length === 0) {
                continue;
            }
            var lastIndex = length - 1;
            var currentTrie = trie;
            for(var index = 0; index < lastIndex; index++){
                var key = path[index];
                var existingValue = currentTrie.get(key);
                if (existingValue instanceof Map) {
                    currentTrie = existingValue;
                    continue;
                }
                var newValue = new Map();
                if (Array.isArray(existingValue)) {
                    newValue.set(SELF, existingValue);
                }
                currentTrie.set(key, newValue);
                currentTrie = newValue;
            }
            var lastKey = path[lastIndex];
            var container = currentTrie.get(lastKey);
            if (container instanceof Map) {
                currentTrie = container;
                container = currentTrie.get(lastKey);
                lastKey = SELF;
            }
            if (Array.isArray(container)) {
                container.push(error);
            } else {
                currentTrie.set(lastKey, [
                    error
                ]);
            }
        }
    } catch (err) {
        _iterator.e(err);
    } finally{
        _iterator.f();
    }
    return trie;
}
function getErrorsByKey(trie, key) {
    var value = trie.get(key);
    if (value == null) {
        return null;
    }
    if (Array.isArray(value)) {
        return value;
    }
    var errors = [];
    recursivelyCopyErrorsIntoArray(value, errors);
    return errors;
}
function recursivelyCopyErrorsIntoArray(trieOrSet, errors) {
    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(trieOrSet), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var _step2$value = _step2.value, childKey = _step2$value[0], value = _step2$value[1];
            var oldLength = errors.length;
            if (Array.isArray(value)) {
                errors.push.apply(errors, (0, _toConsumableArray2["default"])(value));
            } else {
                recursivelyCopyErrorsIntoArray(value, errors);
            }
            if (childKey === SELF) {
                continue;
            }
            var newLength = errors.length;
            for(var index = oldLength; index < newLength; index++){
                var error = errors[index];
                if (error.path == null) {
                    errors[index] = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, error), {}, {
                        path: [
                            childKey
                        ]
                    });
                } else {
                    error.path.unshift(childKey);
                }
            }
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
}
function getNestedErrorTrieByKey(trie, key) {
    var value = trie.get(key);
    if (value instanceof Map) {
        return value;
    }
    return null;
}
module.exports = {
    SELF: SELF,
    buildErrorTrie: buildErrorTrie,
    getNestedErrorTrieByKey: getNestedErrorTrieByKey,
    getErrorsByKey: getErrorsByKey
};
}),
"[project]/node_modules/relay-runtime/lib/store/TypeID.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var PREFIX = 'client:__type:';
var TYPE_SCHEMA_TYPE = '__TypeSchema';
function generateTypeID(typeName) {
    return PREFIX + typeName;
}
function isTypeID(id) {
    return id.indexOf(PREFIX) === 0;
}
module.exports = {
    generateTypeID: generateTypeID,
    isTypeID: isTypeID,
    TYPE_SCHEMA_TYPE: TYPE_SCHEMA_TYPE
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayResponseNormalizer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-ssr] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/multi-actor-environment/ActorUtils.js [app-ssr] (ecmascript)"), ACTOR_IDENTIFIER_FIELD_NAME = _require.ACTOR_IDENTIFIER_FIELD_NAME, getActorIdentifierFromPayload = _require.getActorIdentifierFromPayload;
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-ssr] (ecmascript)"), generateClientID = _require2.generateClientID, isClientID = _require2.isClientID;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-ssr] (ecmascript)"), getLocalVariables = _require3.getLocalVariables;
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayErrorTrie.js [app-ssr] (ecmascript)"), buildErrorTrie = _require4.buildErrorTrie, getErrorsByKey = _require4.getErrorsByKey, getNestedErrorTrieByKey = _require4.getNestedErrorTrieByKey;
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)");
var _require5 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-ssr] (ecmascript)"), createNormalizationSelector = _require5.createNormalizationSelector;
var _require6 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), ROOT_ID = _require6.ROOT_ID, TYPENAME_KEY = _require6.TYPENAME_KEY, getArgumentValues = _require6.getArgumentValues, getHandleStorageKey = _require6.getHandleStorageKey, getModuleComponentKey = _require6.getModuleComponentKey, getModuleOperationKey = _require6.getModuleOperationKey, getStorageKey = _require6.getStorageKey;
var _require7 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/TypeID.js [app-ssr] (ecmascript)"), TYPE_SCHEMA_TYPE = _require7.TYPE_SCHEMA_TYPE, generateTypeID = _require7.generateTypeID;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function normalize(recordSource, selector, response, options, errors, useExecTimeResolvers) {
    var dataID = selector.dataID, node = selector.node, variables = selector.variables;
    var normalizer = new RelayResponseNormalizer(recordSource, variables, options, useExecTimeResolvers !== null && useExecTimeResolvers !== void 0 ? useExecTimeResolvers : false);
    return normalizer.normalizeResponse(node, dataID, response, errors);
}
var RelayResponseNormalizer = /*#__PURE__*/ function() {
    function RelayResponseNormalizer(recordSource, variables, options, useExecTimeResolvers) {
        this._actorIdentifier = options.actorIdentifier;
        this._getDataId = options.getDataID;
        this._handleFieldPayloads = [];
        this._treatMissingFieldsAsNull = options.treatMissingFieldsAsNull;
        this._incrementalPlaceholders = [];
        this._isClientExtension = false;
        this._isUnmatchedAbstractType = false;
        this._useExecTimeResolvers = useExecTimeResolvers;
        this._followupPayloads = [];
        this._path = options.path ? (0, _toConsumableArray2["default"])(options.path) : [];
        this._recordSource = recordSource;
        this._variables = variables;
        this._shouldProcessClientComponents = options.shouldProcessClientComponents;
        this._log = options.log;
    }
    var _proto = RelayResponseNormalizer.prototype;
    _proto.normalizeResponse = function normalizeResponse(node, dataID, data, errors) {
        var record = this._recordSource.get(dataID);
        !record ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer(): Expected root record `%s` to exist.', dataID) : "TURBOPACK unreachable" : void 0;
        this._assignClientAbstractTypes(node);
        this._errorTrie = buildErrorTrie(errors);
        this._traverseSelections(node, record, data);
        return {
            errors: errors,
            fieldPayloads: this._handleFieldPayloads,
            incrementalPlaceholders: this._incrementalPlaceholders,
            followupPayloads: this._followupPayloads,
            source: this._recordSource,
            isFinal: false
        };
    };
    _proto._assignClientAbstractTypes = function _assignClientAbstractTypes(node) {
        var clientAbstractTypes = node.clientAbstractTypes;
        if (clientAbstractTypes != null) {
            for(var _i = 0, _Object$keys = Object.keys(clientAbstractTypes); _i < _Object$keys.length; _i++){
                var abstractType = _Object$keys[_i];
                var _iterator = (0, _createForOfIteratorHelper2["default"])(clientAbstractTypes[abstractType]), _step;
                try {
                    for(_iterator.s(); !(_step = _iterator.n()).done;){
                        var concreteType = _step.value;
                        var typeID = generateTypeID(concreteType);
                        var typeRecord = this._recordSource.get(typeID);
                        if (typeRecord == null) {
                            typeRecord = RelayModernRecord.create(typeID, TYPE_SCHEMA_TYPE);
                            this._recordSource.set(typeID, typeRecord);
                        }
                        RelayModernRecord.setValue(typeRecord, abstractType, true);
                    }
                } catch (err) {
                    _iterator.e(err);
                } finally{
                    _iterator.f();
                }
            }
        }
    };
    _proto._getVariableValue = function _getVariableValue(name) {
        !this._variables.hasOwnProperty(name) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer(): Undefined variable `%s`.', name) : "TURBOPACK unreachable" : void 0;
        return this._variables[name];
    };
    _proto._getRecordType = function _getRecordType(data) {
        var typeName = data[TYPENAME_KEY];
        !(typeName != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer(): Expected a typename for record `%s`.', JSON.stringify(data, null, 2)) : "TURBOPACK unreachable" : void 0;
        return typeName;
    };
    _proto._traverseSelections = function _traverseSelections(node, record, data) {
        for(var i = 0; i < node.selections.length; i++){
            var selection = node.selections[i];
            switch(selection.kind){
                case 'ScalarField':
                case 'LinkedField':
                    this._normalizeField(selection, record, data);
                    break;
                case 'Condition':
                    var conditionValue = Boolean(this._getVariableValue(selection.condition));
                    if (conditionValue === selection.passingValue) {
                        this._traverseSelections(selection, record, data);
                    }
                    break;
                case 'FragmentSpread':
                    {
                        var prevVariables = this._variables;
                        this._variables = getLocalVariables(this._variables, selection.fragment.argumentDefinitions, selection.args);
                        this._traverseSelections(selection.fragment, record, data);
                        this._variables = prevVariables;
                        break;
                    }
                case 'InlineFragment':
                    {
                        var abstractKey = selection.abstractKey;
                        if (abstractKey == null) {
                            var typeName = RelayModernRecord.getType(record);
                            if (typeName === selection.type) {
                                this._traverseSelections(selection, record, data);
                            }
                        } else {
                            var implementsInterface = Object.prototype.hasOwnProperty.call(data, abstractKey);
                            var _typeName = RelayModernRecord.getType(record);
                            var typeID = generateTypeID(_typeName);
                            var typeRecord = this._recordSource.get(typeID);
                            if (typeRecord == null) {
                                typeRecord = RelayModernRecord.create(typeID, TYPE_SCHEMA_TYPE);
                                this._recordSource.set(typeID, typeRecord);
                            }
                            RelayModernRecord.setValue(typeRecord, abstractKey, implementsInterface);
                            if (implementsInterface) {
                                this._traverseSelections(selection, record, data);
                            }
                        }
                        break;
                    }
                case 'TypeDiscriminator':
                    {
                        var _abstractKey = selection.abstractKey;
                        var _implementsInterface = Object.prototype.hasOwnProperty.call(data, _abstractKey);
                        var _typeName2 = RelayModernRecord.getType(record);
                        var _typeID = generateTypeID(_typeName2);
                        var _typeRecord = this._recordSource.get(_typeID);
                        if (_typeRecord == null) {
                            _typeRecord = RelayModernRecord.create(_typeID, TYPE_SCHEMA_TYPE);
                            this._recordSource.set(_typeID, _typeRecord);
                        }
                        RelayModernRecord.setValue(_typeRecord, _abstractKey, _implementsInterface);
                        break;
                    }
                case 'LinkedHandle':
                case 'ScalarHandle':
                    var args = selection.args ? getArgumentValues(selection.args, this._variables) : {};
                    var fieldKey = getStorageKey(selection, this._variables);
                    var handleKey = getHandleStorageKey(selection, this._variables);
                    this._handleFieldPayloads.push({
                        args: args,
                        dataID: RelayModernRecord.getDataID(record),
                        fieldKey: fieldKey,
                        handle: selection.handle,
                        handleKey: handleKey,
                        handleArgs: selection.handleArgs ? getArgumentValues(selection.handleArgs, this._variables) : {}
                    });
                    break;
                case 'ModuleImport':
                    this._normalizeModuleImport(selection, record, data);
                    break;
                case 'Defer':
                    this._normalizeDefer(selection, record, data);
                    break;
                case 'Stream':
                    this._normalizeStream(selection, record, data);
                    break;
                case 'ClientExtension':
                    var isClientExtension = this._isClientExtension;
                    this._isClientExtension = true;
                    this._traverseSelections(selection, record, data);
                    this._isClientExtension = isClientExtension;
                    break;
                case 'ClientComponent':
                    if (this._shouldProcessClientComponents === false) {
                        break;
                    }
                    this._traverseSelections(selection.fragment, record, data);
                    break;
                case 'ActorChange':
                    this._normalizeActorChange(selection, record, data);
                    break;
                case 'RelayResolver':
                case 'RelayLiveResolver':
                    if (!this._useExecTimeResolvers) {
                        this._normalizeResolver(selection, record, data);
                    }
                    break;
                case 'ClientEdgeToClientObject':
                    if (!this._useExecTimeResolvers) {
                        this._normalizeResolver(selection.backingField, record, data);
                    }
                    break;
                default:
                    selection;
                    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer(): Unexpected ast kind `%s`.', selection.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
        }
    };
    _proto._normalizeResolver = function _normalizeResolver(resolver, record, data) {
        if (resolver.fragment != null) {
            this._traverseSelections(resolver.fragment, record, data);
        }
    };
    _proto._normalizeDefer = function _normalizeDefer(defer, record, data) {
        var isDeferred = defer["if"] === null || this._getVariableValue(defer["if"]);
        if ("TURBOPACK compile-time truthy", 1) {
            ("TURBOPACK compile-time truthy", 1) ? warning(typeof isDeferred === 'boolean', 'RelayResponseNormalizer: Expected value for @defer `if` argument to ' + 'be a boolean, got `%s`.', isDeferred) : "TURBOPACK unreachable";
        }
        if (isDeferred === false) {
            this._traverseSelections(defer, record, data);
        } else {
            this._incrementalPlaceholders.push({
                kind: 'defer',
                data: data,
                label: defer.label,
                path: (0, _toConsumableArray2["default"])(this._path),
                selector: createNormalizationSelector(defer, RelayModernRecord.getDataID(record), this._variables),
                typeName: RelayModernRecord.getType(record),
                actorIdentifier: this._actorIdentifier
            });
        }
    };
    _proto._normalizeStream = function _normalizeStream(stream, record, data) {
        this._traverseSelections(stream, record, data);
        var isStreamed = stream["if"] === null || this._getVariableValue(stream["if"]);
        if ("TURBOPACK compile-time truthy", 1) {
            ("TURBOPACK compile-time truthy", 1) ? warning(typeof isStreamed === 'boolean', 'RelayResponseNormalizer: Expected value for @stream `if` argument ' + 'to be a boolean, got `%s`.', isStreamed) : "TURBOPACK unreachable";
        }
        if (isStreamed === true) {
            this._incrementalPlaceholders.push({
                kind: 'stream',
                label: stream.label,
                path: (0, _toConsumableArray2["default"])(this._path),
                parentID: RelayModernRecord.getDataID(record),
                node: stream,
                variables: this._variables,
                actorIdentifier: this._actorIdentifier
            });
        }
    };
    _proto._normalizeModuleImport = function _normalizeModuleImport(moduleImport, record, data) {
        !(typeof data === 'object' && data) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected data for @module to be an object.') : "TURBOPACK unreachable" : void 0;
        var typeName = RelayModernRecord.getType(record);
        var componentKey = getModuleComponentKey(moduleImport.documentName);
        var componentReference = moduleImport.componentModuleProvider || data[componentKey];
        RelayModernRecord.setValue(record, componentKey, componentReference !== null && componentReference !== void 0 ? componentReference : null);
        var operationKey = getModuleOperationKey(moduleImport.documentName);
        var operationReference = moduleImport.operationModuleProvider || data[operationKey];
        RelayModernRecord.setValue(record, operationKey, operationReference !== null && operationReference !== void 0 ? operationReference : null);
        if (operationReference != null) {
            this._followupPayloads.push({
                kind: 'ModuleImportPayload',
                args: moduleImport.args,
                data: data,
                dataID: RelayModernRecord.getDataID(record),
                operationReference: operationReference,
                path: (0, _toConsumableArray2["default"])(this._path),
                typeName: typeName,
                variables: this._variables,
                actorIdentifier: this._actorIdentifier
            });
        }
    };
    _proto._normalizeField = function _normalizeField(selection, record, data) {
        !(typeof data === 'object' && data) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'writeField(): Expected data for field `%s` to be an object.', selection.name) : "TURBOPACK unreachable" : void 0;
        var responseKey = selection.alias || selection.name;
        var storageKey = getStorageKey(selection, this._variables);
        var fieldValue = data[responseKey];
        var isNoncompliantlyNullish = RelayFeatureFlags.ENABLE_NONCOMPLIANT_ERROR_HANDLING_ON_LISTS && Array.isArray(fieldValue) && fieldValue.length === 0;
        if (fieldValue == null || isNoncompliantlyNullish) {
            if (fieldValue === undefined) {
                var isOptionalField = this._isClientExtension || this._isUnmatchedAbstractType;
                if (isOptionalField) {
                    return;
                } else if (!this._treatMissingFieldsAsNull) {
                    if ("TURBOPACK compile-time truthy", 1) {
                        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayResponseNormalizer: Payload did not contain a value ' + 'for field `%s: %s`. Check that you are parsing with the same ' + 'query that was used to fetch the payload.', responseKey, storageKey) : "TURBOPACK unreachable";
                    }
                    return;
                }
            }
            if (selection.kind === 'ScalarField') {
                this._validateConflictingFieldsWithIdenticalId(record, storageKey, null);
            }
            if (isNoncompliantlyNullish) {
                if (selection.kind === 'LinkedField') {
                    RelayModernRecord.setLinkedRecordIDs(record, storageKey, []);
                } else {
                    RelayModernRecord.setValue(record, storageKey, []);
                }
            } else {
                RelayModernRecord.setValue(record, storageKey, null);
            }
            var errorTrie = this._errorTrie;
            if (errorTrie != null) {
                var errors = getErrorsByKey(errorTrie, responseKey);
                if (errors != null) {
                    RelayModernRecord.setErrors(record, storageKey, errors);
                }
            }
            return;
        }
        if (selection.kind === 'ScalarField') {
            this._validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue);
            RelayModernRecord.setValue(record, storageKey, fieldValue);
        } else if (selection.kind === 'LinkedField') {
            this._path.push(responseKey);
            var oldErrorTrie = this._errorTrie;
            this._errorTrie = oldErrorTrie == null ? null : getNestedErrorTrieByKey(oldErrorTrie, responseKey);
            if (selection.plural) {
                this._normalizePluralLink(selection, record, storageKey, fieldValue);
            } else {
                this._normalizeLink(selection, record, storageKey, fieldValue);
            }
            this._errorTrie = oldErrorTrie;
            this._path.pop();
        } else {
            selection;
            ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer(): Unexpected ast kind `%s` during normalization.', selection.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
    };
    _proto._normalizeActorChange = function _normalizeActorChange(selection, record, data) {
        var _field$concreteType;
        var field = selection.linkedField;
        !(typeof data === 'object' && data) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '_normalizeActorChange(): Expected data for field `%s` to be an object.', field.name) : "TURBOPACK unreachable" : void 0;
        var responseKey = field.alias || field.name;
        var storageKey = getStorageKey(field, this._variables);
        var fieldValue = data[responseKey];
        if (fieldValue == null) {
            if (fieldValue === undefined) {
                var isOptionalField = this._isClientExtension || this._isUnmatchedAbstractType;
                if (isOptionalField) {
                    return;
                } else if (!this._treatMissingFieldsAsNull) {
                    if ("TURBOPACK compile-time truthy", 1) {
                        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayResponseNormalizer: Payload did not contain a value ' + 'for field `%s: %s`. Check that you are parsing with the same ' + 'query that was used to fetch the payload.', responseKey, storageKey) : "TURBOPACK unreachable";
                    }
                    return;
                }
            }
            RelayModernRecord.setValue(record, storageKey, null);
            return;
        }
        var actorIdentifier = getActorIdentifierFromPayload(fieldValue);
        if (actorIdentifier == null) {
            if ("TURBOPACK compile-time truthy", 1) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayResponseNormalizer: Payload did not contain a value ' + 'for field `%s`. Check that you are parsing with the same ' + 'query that was used to fetch the payload. Payload is `%s`.', ACTOR_IDENTIFIER_FIELD_NAME, JSON.stringify(fieldValue, null, 2)) : "TURBOPACK unreachable";
            }
            RelayModernRecord.setValue(record, storageKey, null);
            return;
        }
        var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : this._getRecordType(fieldValue);
        var nextID = this._getDataId(fieldValue, typeName) || RelayModernRecord.getLinkedRecordID(record, storageKey) || generateClientID(RelayModernRecord.getDataID(record), storageKey);
        !(typeof nextID === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected id on field `%s` to be a string.', storageKey) : "TURBOPACK unreachable" : void 0;
        RelayModernRecord.setActorLinkedRecordID(record, storageKey, actorIdentifier, nextID);
        this._followupPayloads.push({
            kind: 'ActorPayload',
            data: fieldValue,
            dataID: nextID,
            path: [].concat((0, _toConsumableArray2["default"])(this._path), [
                responseKey
            ]),
            typeName: typeName,
            variables: this._variables,
            node: field,
            actorIdentifier: actorIdentifier
        });
    };
    _proto._normalizeLink = function _normalizeLink(field, record, storageKey, fieldValue) {
        var _field$concreteType2;
        !(typeof fieldValue === 'object' && fieldValue) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected data for field `%s` to be an object.', storageKey) : "TURBOPACK unreachable" : void 0;
        var nextID = this._getDataId(fieldValue, (_field$concreteType2 = field.concreteType) !== null && _field$concreteType2 !== void 0 ? _field$concreteType2 : this._getRecordType(fieldValue)) || RelayModernRecord.getLinkedRecordID(record, storageKey) || generateClientID(RelayModernRecord.getDataID(record), storageKey);
        !(typeof nextID === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected id on field `%s` to be a string.', storageKey) : "TURBOPACK unreachable" : void 0;
        this._validateConflictingLinkedFieldsWithIdenticalId(RelayModernRecord.getLinkedRecordID(record, storageKey), nextID, storageKey);
        RelayModernRecord.setLinkedRecordID(record, storageKey, nextID);
        var nextRecord = this._recordSource.get(nextID);
        if (!nextRecord) {
            var typeName = field.concreteType || this._getRecordType(fieldValue);
            nextRecord = RelayModernRecord.create(nextID, typeName);
            this._recordSource.set(nextID, nextRecord);
        } else {
            this._validateRecordType(nextRecord, field, fieldValue);
        }
        this._traverseSelections(field, nextRecord, fieldValue);
    };
    _proto._normalizePluralLink = function _normalizePluralLink(field, record, storageKey, fieldValue) {
        var _this = this;
        !Array.isArray(fieldValue) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected data for field `%s` to be an array ' + 'of objects.', storageKey) : "TURBOPACK unreachable" : void 0;
        var prevIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);
        var nextIDs = [];
        fieldValue.forEach(function(item, nextIndex) {
            var _field$concreteType3;
            if (item == null) {
                nextIDs.push(item);
                return;
            }
            _this._path.push(String(nextIndex));
            var oldErrorTrie = _this._errorTrie;
            _this._errorTrie = oldErrorTrie == null ? null : getNestedErrorTrieByKey(oldErrorTrie, nextIndex);
            !(typeof item === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected elements for field `%s` to be ' + 'objects.', storageKey) : "TURBOPACK unreachable" : void 0;
            var nextID = _this._getDataId(item, (_field$concreteType3 = field.concreteType) !== null && _field$concreteType3 !== void 0 ? _field$concreteType3 : _this._getRecordType(item)) || prevIDs && prevIDs[nextIndex] || generateClientID(RelayModernRecord.getDataID(record), storageKey, nextIndex);
            !(typeof nextID === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : "TURBOPACK unreachable" : void 0;
            nextIDs.push(nextID);
            var nextRecord = _this._recordSource.get(nextID);
            if (!nextRecord) {
                var typeName = field.concreteType || _this._getRecordType(item);
                nextRecord = RelayModernRecord.create(nextID, typeName);
                _this._recordSource.set(nextID, nextRecord);
            } else {
                _this._validateRecordType(nextRecord, field, item);
            }
            if (prevIDs) {
                _this._validateConflictingLinkedFieldsWithIdenticalId(prevIDs[nextIndex], nextID, storageKey);
            }
            _this._traverseSelections(field, nextRecord, item);
            _this._errorTrie = oldErrorTrie;
            _this._path.pop();
        });
        RelayModernRecord.setLinkedRecordIDs(record, storageKey, nextIDs);
    };
    _proto._validateRecordType = function _validateRecordType(record, field, payload) {
        if (RelayFeatureFlags.ENABLE_STORE_ID_COLLISION_LOGGING) {
            var _field$concreteType4;
            var typeName = (_field$concreteType4 = field.concreteType) !== null && _field$concreteType4 !== void 0 ? _field$concreteType4 : this._getRecordType(payload);
            var dataID = RelayModernRecord.getDataID(record);
            var expected = isClientID(dataID) && dataID !== ROOT_ID || RelayModernRecord.getType(record) === typeName;
            if (!expected) {
                var logEvent = {
                    name: 'idCollision.typename',
                    previous_typename: RelayModernRecord.getType(record),
                    new_typename: typeName
                };
                if (this._log != null) {
                    this._log(logEvent);
                }
            }
        }
        if ("TURBOPACK compile-time truthy", 1) {
            var _field$concreteType5;
            var _typeName3 = (_field$concreteType5 = field.concreteType) !== null && _field$concreteType5 !== void 0 ? _field$concreteType5 : this._getRecordType(payload);
            var _dataID = RelayModernRecord.getDataID(record);
            var _expected = isClientID(_dataID) && _dataID !== ROOT_ID || RelayModernRecord.getType(record) === _typeName3;
            ("TURBOPACK compile-time truthy", 1) ? warning(_expected, 'RelayResponseNormalizer: Invalid record `%s`. Expected %s to be ' + 'consistent, but the record was assigned conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', _dataID, TYPENAME_KEY, RelayModernRecord.getType(record), _typeName3) : "TURBOPACK unreachable";
        }
    };
    _proto._validateConflictingFieldsWithIdenticalId = function _validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue) {
        if ("TURBOPACK compile-time truthy", 1) {
            var previousValue = RelayModernRecord.getValue(record, storageKey);
            var dataID = RelayModernRecord.getDataID(record);
            var expected = storageKey === TYPENAME_KEY || previousValue === undefined || areEqual(previousValue, fieldValue);
            ("TURBOPACK compile-time truthy", 1) ? warning(expected, 'RelayResponseNormalizer: Invalid record. The record contains two ' + 'instances of the same id: `%s` with conflicting field, %s and its values: %s and %s. ' + 'If two fields are different but share ' + 'the same id, one field will overwrite the other.', dataID, storageKey, previousValue, fieldValue) : "TURBOPACK unreachable";
        }
    };
    _proto._validateConflictingLinkedFieldsWithIdenticalId = function _validateConflictingLinkedFieldsWithIdenticalId(prevID, nextID, storageKey) {
        if ("TURBOPACK compile-time truthy", 1) {
            var expected = prevID === undefined || prevID === nextID;
            ("TURBOPACK compile-time truthy", 1) ? warning(expected, 'RelayResponseNormalizer: Invalid record. The record contains ' + 'references to the conflicting field, %s and its id values: %s and %s. ' + 'We need to make sure that the record the field points ' + 'to remains consistent or one field will overwrite the other.', storageKey, prevID, nextID) : "TURBOPACK unreachable";
        }
    };
    return RelayResponseNormalizer;
}();
module.exports = {
    normalize: normalize
};
}),
"[project]/node_modules/relay-runtime/lib/store/normalizeResponse.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var _RelayModernRecord = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)"));
var _RelayRecordSource = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-ssr] (ecmascript)"));
var _RelayResponseNormalizer = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayResponseNormalizer.js [app-ssr] (ecmascript)"));
function normalizeResponse(response, selector, typeName, options, useExecTimeResolvers) {
    var _response$extensions;
    var data = response.data, errors = response.errors;
    var source = _RelayRecordSource["default"].create();
    var record = _RelayModernRecord["default"].create(selector.dataID, typeName);
    source.set(selector.dataID, record);
    var relayPayload = _RelayResponseNormalizer["default"].normalize(source, selector, data, options, errors, useExecTimeResolvers);
    return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, relayPayload), {}, {
        isFinal: ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.is_final) === true
    });
}
module.exports = normalizeResponse;
}),
"[project]/node_modules/relay-runtime/lib/store/readInlineData.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-ssr] (ecmascript)"), getInlineDataFragment = _require.getInlineDataFragment;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), FRAGMENTS_KEY = _require2.FRAGMENTS_KEY;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function readInlineData(fragment, fragmentRef) {
    var _fragmentRef$FRAGMENT;
    var inlineDataFragment = getInlineDataFragment(fragment);
    if (fragmentRef == null) {
        return fragmentRef;
    }
    !(typeof fragmentRef === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'readInlineData(): Expected an object, got `%s`.', typeof fragmentRef) : "TURBOPACK unreachable" : void 0;
    var inlineData = (_fragmentRef$FRAGMENT = fragmentRef[FRAGMENTS_KEY]) === null || _fragmentRef$FRAGMENT === void 0 ? void 0 : _fragmentRef$FRAGMENT[inlineDataFragment.name];
    !(inlineData != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'readInlineData(): Expected fragment `%s` to be spread in the parent ' + 'fragment.', inlineDataFragment.name) : "TURBOPACK unreachable" : void 0;
    return inlineData;
}
module.exports = readInlineData;
}),
"[project]/node_modules/relay-runtime/lib/util/generateID.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var id = 100000;
function generateID() {
    return id++;
}
module.exports = generateID;
}),
"[project]/node_modules/relay-runtime/lib/network/wrapNetworkWithLogObserver.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var generateID = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/generateID.js [app-ssr] (ecmascript)");
function wrapNetworkWithLogObserver(env, network) {
    return {
        execute: function execute(params, variables, cacheConfig, uploadables, _, encryptedVariables, preprocessResponse, checkOperation) {
            var networkRequestId = generateID();
            var logObserver = {
                start: function start(subscription) {
                    env.__log({
                        name: 'network.start',
                        networkRequestId: networkRequestId,
                        params: params,
                        variables: variables,
                        cacheConfig: cacheConfig
                    });
                },
                next: function next(response) {
                    env.__log({
                        name: 'network.next',
                        networkRequestId: networkRequestId,
                        response: response
                    });
                },
                error: function error(_error) {
                    env.__log({
                        name: 'network.error',
                        networkRequestId: networkRequestId,
                        error: _error
                    });
                },
                complete: function complete() {
                    env.__log({
                        name: 'network.complete',
                        networkRequestId: networkRequestId
                    });
                },
                unsubscribe: function unsubscribe() {
                    env.__log({
                        name: 'network.unsubscribe',
                        networkRequestId: networkRequestId
                    });
                }
            };
            var logRequestInfo = function logRequestInfo(info) {
                env.__log({
                    name: 'network.info',
                    networkRequestId: networkRequestId,
                    info: info
                });
            };
            return network.execute(params, variables, cacheConfig, uploadables, logRequestInfo, encryptedVariables, preprocessResponse, checkOperation)["do"](logObserver);
        }
    };
}
module.exports = wrapNetworkWithLogObserver;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayOperationTracker.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var RelayOperationTracker = /*#__PURE__*/ function() {
    function RelayOperationTracker() {
        this._ownersToPendingOperations = new Map();
        this._pendingOperationsToOwners = new Map();
        this._ownersToPendingPromise = new Map();
    }
    var _proto = RelayOperationTracker.prototype;
    _proto.update = function update(pendingOperation, affectedOwners) {
        if (affectedOwners.size === 0) {
            return;
        }
        var pendingOperationIdentifier = pendingOperation.identifier;
        var newlyAffectedOwnersIdentifier = new Set();
        var _iterator = (0, _createForOfIteratorHelper2["default"])(affectedOwners), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var owner = _step.value;
                var ownerIdentifier = owner.identifier;
                var pendingOperationsAffectingOwner = this._ownersToPendingOperations.get(ownerIdentifier);
                if (pendingOperationsAffectingOwner != null) {
                    if (!pendingOperationsAffectingOwner.has(pendingOperationIdentifier)) {
                        pendingOperationsAffectingOwner.set(pendingOperationIdentifier, pendingOperation);
                        newlyAffectedOwnersIdentifier.add(ownerIdentifier);
                    }
                } else {
                    this._ownersToPendingOperations.set(ownerIdentifier, new Map([
                        [
                            pendingOperationIdentifier,
                            pendingOperation
                        ]
                    ]));
                    newlyAffectedOwnersIdentifier.add(ownerIdentifier);
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        if (newlyAffectedOwnersIdentifier.size === 0) {
            return;
        }
        var ownersAffectedByPendingOperation = this._pendingOperationsToOwners.get(pendingOperationIdentifier) || new Set();
        var _iterator2 = (0, _createForOfIteratorHelper2["default"])(newlyAffectedOwnersIdentifier), _step2;
        try {
            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                var _ownerIdentifier = _step2.value;
                this._resolveOwnerResolvers(_ownerIdentifier);
                ownersAffectedByPendingOperation.add(_ownerIdentifier);
            }
        } catch (err) {
            _iterator2.e(err);
        } finally{
            _iterator2.f();
        }
        this._pendingOperationsToOwners.set(pendingOperationIdentifier, ownersAffectedByPendingOperation);
    };
    _proto.complete = function complete(pendingOperation) {
        var pendingOperationIdentifier = pendingOperation.identifier;
        var affectedOwnersIdentifier = this._pendingOperationsToOwners.get(pendingOperationIdentifier);
        if (affectedOwnersIdentifier == null) {
            return;
        }
        var completedOwnersIdentifier = new Set();
        var updatedOwnersIdentifier = new Set();
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(affectedOwnersIdentifier), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var ownerIdentifier = _step3.value;
                var pendingOperationsAffectingOwner = this._ownersToPendingOperations.get(ownerIdentifier);
                if (!pendingOperationsAffectingOwner) {
                    continue;
                }
                pendingOperationsAffectingOwner["delete"](pendingOperationIdentifier);
                if (pendingOperationsAffectingOwner.size > 0) {
                    updatedOwnersIdentifier.add(ownerIdentifier);
                } else {
                    completedOwnersIdentifier.add(ownerIdentifier);
                }
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
        var _iterator4 = (0, _createForOfIteratorHelper2["default"])(completedOwnersIdentifier), _step4;
        try {
            for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                var _ownerIdentifier2 = _step4.value;
                this._resolveOwnerResolvers(_ownerIdentifier2);
                this._ownersToPendingOperations["delete"](_ownerIdentifier2);
            }
        } catch (err) {
            _iterator4.e(err);
        } finally{
            _iterator4.f();
        }
        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(updatedOwnersIdentifier), _step5;
        try {
            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                var _ownerIdentifier3 = _step5.value;
                this._resolveOwnerResolvers(_ownerIdentifier3);
            }
        } catch (err) {
            _iterator5.e(err);
        } finally{
            _iterator5.f();
        }
        this._pendingOperationsToOwners["delete"](pendingOperationIdentifier);
    };
    _proto._resolveOwnerResolvers = function _resolveOwnerResolvers(ownerIdentifier) {
        var promiseEntry = this._ownersToPendingPromise.get(ownerIdentifier);
        if (promiseEntry != null) {
            promiseEntry.resolve();
        }
        this._ownersToPendingPromise["delete"](ownerIdentifier);
    };
    _proto.getPendingOperationsAffectingOwner = function getPendingOperationsAffectingOwner(owner) {
        var ownerIdentifier = owner.identifier;
        var pendingOperationsForOwner = this._ownersToPendingOperations.get(ownerIdentifier);
        if (pendingOperationsForOwner == null || pendingOperationsForOwner.size === 0) {
            return null;
        }
        var cachedPromiseEntry = this._ownersToPendingPromise.get(ownerIdentifier);
        if (cachedPromiseEntry != null) {
            return {
                promise: cachedPromiseEntry.promise,
                pendingOperations: cachedPromiseEntry.pendingOperations
            };
        }
        var resolve;
        var promise = new Promise(function(r) {
            resolve = r;
        });
        !(resolve != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayOperationTracker: Expected resolver to be defined. If you' + 'are seeing this, it is likely a bug in Relay.') : "TURBOPACK unreachable" : void 0;
        var pendingOperations = Array.from(pendingOperationsForOwner.values());
        this._ownersToPendingPromise.set(ownerIdentifier, {
            promise: promise,
            resolve: resolve,
            pendingOperations: pendingOperations
        });
        return {
            promise: promise,
            pendingOperations: pendingOperations
        };
    };
    return RelayOperationTracker;
}();
module.exports = RelayOperationTracker;
}),
"[project]/node_modules/relay-runtime/lib/util/registerEnvironmentWithDevTools.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function registerEnvironmentWithDevTools(environment) {
    var _global = ("TURBOPACK compile-time truthy", 1) ? /*TURBOPACK member replacement*/ __turbopack_context__.g : "TURBOPACK unreachable";
    var devToolsHook = _global && _global.__RELAY_DEVTOOLS_HOOK__;
    if (devToolsHook) {
        devToolsHook.registerEnvironment(environment);
    }
}
module.exports = registerEnvironmentWithDevTools;
}),
"[project]/node_modules/relay-runtime/lib/store/ViewerPattern.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-ssr] (ecmascript)"), generateClientID = _require.generateClientID;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), ROOT_ID = _require2.ROOT_ID;
var VIEWER_ID = generateClientID(ROOT_ID, 'viewer');
var VIEWER_TYPE = 'Viewer';
module.exports = {
    VIEWER_ID: VIEWER_ID,
    VIEWER_TYPE: VIEWER_TYPE
};
}),
"[project]/node_modules/relay-runtime/lib/store/defaultGetDataID.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ViewerPattern.js [app-ssr] (ecmascript)"), VIEWER_ID = _require.VIEWER_ID, VIEWER_TYPE = _require.VIEWER_TYPE;
function defaultGetDataID(fieldValue, typeName) {
    if (typeName === VIEWER_TYPE) {
        return fieldValue.id == null ? VIEWER_ID : fieldValue.id;
    }
    return fieldValue.id;
}
module.exports = defaultGetDataID;
}),
"[project]/node_modules/relay-runtime/lib/store/defaultRelayFieldLogger.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var defaultRelayFieldLogger = function defaultRelayFieldLogger(event) {
    if (("TURBOPACK compile-time value", "development") !== "production" && event.kind === 'missing_required_field.log') {
        throw new Error('Relay Environment Configuration Error (dev only): `@required(action: LOG)` requires that the Relay Environment be configured with a `relayFieldLogger`.');
    }
};
module.exports = defaultRelayFieldLogger;
}),
"[project]/node_modules/relay-runtime/lib/util/getOperation.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-ssr] (ecmascript)"), REQUEST = _require.REQUEST, SPLIT_OPERATION = _require.SPLIT_OPERATION;
function getOperation(node) {
    switch(node.kind){
        case REQUEST:
            return node.operation;
        case SPLIT_OPERATION:
        default:
            return node;
    }
}
module.exports = getOperation;
}),
"[project]/node_modules/relay-runtime/lib/util/RelayError.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function createError(type, name, messageFormat) {
    for(var _len = arguments.length, messageParams = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
        messageParams[_key - 3] = arguments[_key];
    }
    var index = 0;
    var message = messageFormat.replace(/%s/g, function() {
        return String(messageParams[index++]);
    });
    var err = new Error(message);
    var error = Object.assign(err, {
        name: name,
        messageFormat: messageFormat,
        messageParams: messageParams,
        type: type,
        taalOpcodes: [
            2,
            2
        ]
    });
    if (error.stack === undefined) {
        try {
            throw error;
        } catch (_unused) {}
    }
    return error;
}
module.exports = {
    create: function create(name, messageFormat) {
        for(var _len2 = arguments.length, messageParams = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++){
            messageParams[_key2 - 2] = arguments[_key2];
        }
        return createError.apply(void 0, [
            'error',
            name,
            messageFormat
        ].concat(messageParams));
    },
    createWarning: function createWarning(name, messageFormat) {
        for(var _len3 = arguments.length, messageParams = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++){
            messageParams[_key3 - 2] = arguments[_key3];
        }
        return createError.apply(void 0, [
            'warn',
            name,
            messageFormat
        ].concat(messageParams));
    }
};
}),
"[project]/node_modules/relay-runtime/lib/util/withStartAndDuration.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _window, _window$performance;
var isPerformanceNowAvailable = ("TURBOPACK compile-time value", "undefined") !== 'undefined' && typeof ((_window = window) === null || _window === void 0 ? void 0 : (_window$performance = _window.performance) === null || _window$performance === void 0 ? void 0 : _window$performance.now) === 'function';
function currentTimestamp() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return Date.now();
}
function withStartAndDuration(cb) {
    var startTime = currentTimestamp();
    var result = cb();
    return [
        startTime,
        currentTimestamp() - startTime,
        result
    ];
}
module.exports = withStartAndDuration;
}),
"[project]/node_modules/relay-runtime/lib/store/OperationExecutor.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-ssr] (ecmascript)"));
var RelayObservable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-ssr] (ecmascript)");
var generateID = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/generateID.js [app-ssr] (ecmascript)");
var getOperation = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getOperation.js [app-ssr] (ecmascript)");
var RelayError = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayError.js [app-ssr] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-ssr] (ecmascript)"), stableCopy = _require.stableCopy;
var withStartAndDuration = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/withStartAndDuration.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-ssr] (ecmascript)"), generateClientID = _require2.generateClientID, generateUniqueClientID = _require2.generateUniqueClientID;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-ssr] (ecmascript)"), getLocalVariables = _require3.getLocalVariables;
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)");
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-ssr] (ecmascript)"), createNormalizationSelector = _require4.createNormalizationSelector, createReaderSelector = _require4.createReaderSelector;
var RelayRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-ssr] (ecmascript)");
var _require5 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), ROOT_TYPE = _require5.ROOT_TYPE, TYPENAME_KEY = _require5.TYPENAME_KEY, getStorageKey = _require5.getStorageKey;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function execute(config) {
    return new Executor(config);
}
var Executor = /*#__PURE__*/ function() {
    function Executor(_ref3) {
        var _this = this;
        var _ref, _this$_operation$requ, _this$_operation$requ2;
        var actorIdentifier = _ref3.actorIdentifier, getDataID = _ref3.getDataID, getPublishQueue = _ref3.getPublishQueue, getStore = _ref3.getStore, isClientPayload = _ref3.isClientPayload, operation = _ref3.operation, operationExecutions = _ref3.operationExecutions, operationLoader = _ref3.operationLoader, operationTracker = _ref3.operationTracker, optimisticConfig = _ref3.optimisticConfig, scheduler = _ref3.scheduler, shouldProcessClientComponents = _ref3.shouldProcessClientComponents, sink = _ref3.sink, source = _ref3.source, treatMissingFieldsAsNull = _ref3.treatMissingFieldsAsNull, updater = _ref3.updater, log = _ref3.log, normalizeResponse = _ref3.normalizeResponse;
        this._actorIdentifier = actorIdentifier;
        this._getDataID = getDataID;
        this._treatMissingFieldsAsNull = treatMissingFieldsAsNull;
        this._incrementalPayloadsPending = false;
        this._incrementalResults = new Map();
        this._log = log;
        this._executeId = generateID();
        this._nextSubscriptionId = 0;
        this._operation = operation;
        this._operationExecutions = operationExecutions;
        this._operationLoader = operationLoader;
        this._operationTracker = operationTracker;
        this._operationUpdateEpochs = new Map();
        this._optimisticUpdates = null;
        this._useExecTimeResolvers = (_ref = (_this$_operation$requ = this._operation.request.node.operation.use_exec_time_resolvers) !== null && _this$_operation$requ !== void 0 ? _this$_operation$requ : ((_this$_operation$requ2 = this._operation.request.node.operation.exec_time_resolvers_enabled_provider) === null || _this$_operation$requ2 === void 0 ? void 0 : _this$_operation$requ2.get()) === true) !== null && _ref !== void 0 ? _ref : false;
        this._execTimeResolverResponseComplete = false;
        this._pendingModulePayloadsCount = 0;
        this._getPublishQueue = getPublishQueue;
        this._scheduler = scheduler;
        this._sink = sink;
        this._source = new Map();
        this._state = 'started';
        this._getStore = getStore;
        this._subscriptions = new Map();
        this._updater = updater;
        this._isClientPayload = isClientPayload === true;
        this._isSubscriptionOperation = this._operation.request.node.params.operationKind === 'subscription';
        this._shouldProcessClientComponents = shouldProcessClientComponents;
        this._retainDisposables = new Map();
        this._seenActors = new Set();
        this._completeFns = [];
        this._normalizeResponse = normalizeResponse;
        var id = this._nextSubscriptionId++;
        if (RelayFeatureFlags.PROCESS_OPTIMISTIC_UPDATE_BEFORE_SUBSCRIPTION && optimisticConfig != null) {
            this._processOptimisticResponse(optimisticConfig.response != null ? {
                data: optimisticConfig.response
            } : null, optimisticConfig.updater, false);
        }
        source.subscribe({
            complete: function complete() {
                return _this._complete(id);
            },
            error: function error(_error2) {
                return _this._error(_error2);
            },
            next: function next(response) {
                try {
                    _this._next(id, response);
                } catch (error) {
                    sink.error(error);
                }
            },
            start: function start(subscription) {
                var _this$_operation$requ3;
                _this._start(id, subscription);
                _this._log({
                    name: 'execute.start',
                    executeId: _this._executeId,
                    params: _this._operation.request.node.params,
                    variables: _this._operation.request.variables,
                    cacheConfig: (_this$_operation$requ3 = _this._operation.request.cacheConfig) !== null && _this$_operation$requ3 !== void 0 ? _this$_operation$requ3 : {}
                });
            },
            unsubscribe: function unsubscribe() {
                _this._log({
                    name: 'execute.unsubscribe',
                    executeId: _this._executeId
                });
            }
        });
        if (!RelayFeatureFlags.PROCESS_OPTIMISTIC_UPDATE_BEFORE_SUBSCRIPTION && optimisticConfig != null) {
            this._processOptimisticResponse(optimisticConfig.response != null ? {
                data: optimisticConfig.response
            } : null, optimisticConfig.updater, false);
        }
    }
    var _proto = Executor.prototype;
    _proto.cancel = function cancel() {
        var _this2 = this;
        if (this._state === 'completed') {
            return;
        }
        this._state = 'completed';
        this._operationExecutions["delete"](this._operation.request.identifier);
        if (this._subscriptions.size !== 0) {
            this._subscriptions.forEach(function(sub) {
                return sub.unsubscribe();
            });
            this._subscriptions.clear();
        }
        var optimisticUpdates = this._optimisticUpdates;
        if (optimisticUpdates !== null) {
            this._optimisticUpdates = null;
            optimisticUpdates.forEach(function(update) {
                return _this2._getPublishQueueAndSaveActor().revertUpdate(update);
            });
            this._runPublishQueue();
        }
        this._incrementalResults.clear();
        if (this._asyncStoreUpdateDisposable != null) {
            this._asyncStoreUpdateDisposable.dispose();
            this._asyncStoreUpdateDisposable = null;
        }
        this._completeFns = [];
        this._completeOperationTracker();
        this._disposeRetainedData();
    };
    _proto._updateActiveState = function _updateActiveState() {
        var activeState;
        switch(this._state){
            case 'started':
                {
                    activeState = 'active';
                    break;
                }
            case 'loading_incremental':
                {
                    activeState = 'active';
                    break;
                }
            case 'completed':
                {
                    activeState = 'inactive';
                    break;
                }
            case 'loading_final':
                {
                    activeState = this._pendingModulePayloadsCount > 0 || this._useExecTimeResolvers && !this._execTimeResolverResponseComplete ? 'active' : 'inactive';
                    break;
                }
            default:
                this._state;
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: invalid executor state.') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
        this._operationExecutions.set(this._operation.request.identifier, activeState);
    };
    _proto._schedule = function _schedule(task, priority) {
        var _this3 = this;
        var scheduler = this._scheduler;
        if (scheduler != null) {
            var id = this._nextSubscriptionId++;
            RelayObservable.create(function(sink) {
                var cancellationToken = scheduler.schedule(function() {
                    try {
                        task();
                        sink.complete();
                    } catch (error) {
                        sink.error(error);
                    }
                }, priority);
                return function() {
                    return scheduler.cancel(cancellationToken);
                };
            }).subscribe({
                complete: function complete() {
                    return _this3._complete(id);
                },
                error: function error(_error3) {
                    return _this3._error(_error3);
                },
                start: function start(subscription) {
                    return _this3._start(id, subscription);
                }
            });
        } else {
            task();
        }
    };
    _proto._complete = function _complete(id) {
        this._subscriptions["delete"](id);
        if (this._subscriptions.size === 0) {
            this.cancel();
            this._sink.complete();
            this._log({
                name: 'execute.complete',
                executeId: this._executeId
            });
        }
    };
    _proto._error = function _error(error) {
        this.cancel();
        this._sink.error(error);
        this._log({
            name: 'execute.error',
            executeId: this._executeId,
            error: error
        });
    };
    _proto._start = function _start(id, subscription) {
        this._subscriptions.set(id, subscription);
        this._updateActiveState();
    };
    _proto._next = function _next(_id, response) {
        var _this4 = this;
        var priority = this._state === 'loading_incremental' ? 'low' : 'default';
        this._schedule(function() {
            _this4._log({
                name: 'execute.next.start',
                executeId: _this4._executeId,
                response: response,
                operation: _this4._operation
            });
            _this4._handleNext(response);
            _this4._maybeCompleteSubscriptionOperationTracking();
            _this4._log({
                name: 'execute.next.end',
                executeId: _this4._executeId,
                response: response,
                operation: _this4._operation
            });
        }, priority);
    };
    _proto._handleErrorResponse = function _handleErrorResponse(responses) {
        var _this5 = this;
        var results = [];
        responses.forEach(function(response) {
            if (response.data === null && response.extensions != null && !response.hasOwnProperty('errors')) {
                return;
            } else if (response.data == null) {
                var errors = response.hasOwnProperty('errors') && response.errors != null ? response.errors : null;
                var messages = errors ? errors.map(function(_ref4) {
                    var message = _ref4.message;
                    return message;
                }).join('\n') : '(No errors)';
                var error = RelayError.create('RelayNetwork', 'No data returned for operation `' + _this5._operation.request.node.params.name + '`, got error(s):\n' + messages + '\n\nSee the error `source` property for more information.');
                error.source = {
                    errors: errors,
                    operation: _this5._operation.request.node,
                    variables: _this5._operation.request.variables
                };
                error.stack;
                throw error;
            } else {
                var responseWithData = response;
                results.push(responseWithData);
            }
        });
        return results;
    };
    _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {
        var _response$extensions;
        if (responses.length > 1) {
            if (responses.some(function(responsePart) {
                var _responsePart$extensi;
                return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;
            })) {
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Optimistic responses cannot be batched.') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
            return false;
        }
        var response = responses[0];
        var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;
        if (isOptimistic && this._state !== 'started') {
            ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: optimistic payload received after server payload.') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
        if (isOptimistic) {
            this._processOptimisticResponse(response, null, this._treatMissingFieldsAsNull);
            this._sink.next(response);
            return true;
        }
        return false;
    };
    _proto._handleNext = function _handleNext(response) {
        if (this._state === 'completed') {
            return;
        }
        this._seenActors.clear();
        var responses = Array.isArray(response) ? response : [
            response
        ];
        var responsesWithData = this._handleErrorResponse(responses);
        if (responsesWithData.length === 0) {
            var isFinal = responses.some(function(x) {
                var _x$extensions;
                return ((_x$extensions = x.extensions) === null || _x$extensions === void 0 ? void 0 : _x$extensions.is_final) === true;
            });
            if (isFinal) {
                this._state = 'loading_final';
                this._updateActiveState();
                this._incrementalPayloadsPending = false;
            }
            this._sink.next(response);
            return;
        }
        var isOptimistic = this._handleOptimisticResponses(responsesWithData);
        if (isOptimistic) {
            return;
        }
        var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData), nonIncrementalResponses = _partitionGraphQLResp[0], incrementalResponses = _partitionGraphQLResp[1], normalizedResponses = _partitionGraphQLResp[2];
        var hasNonIncrementalResponses = nonIncrementalResponses.length > 0;
        var hasNormalizedResponses = normalizedResponses.length > 0;
        if (hasNonIncrementalResponses) {
            if (this._isSubscriptionOperation) {
                var nextID = generateUniqueClientID();
                this._operation = {
                    request: this._operation.request,
                    fragment: createReaderSelector(this._operation.fragment.node, nextID, this._operation.fragment.variables, this._operation.fragment.owner),
                    root: createNormalizationSelector(this._operation.root.node, nextID, this._operation.root.variables)
                };
            }
            var payloadFollowups = this._processResponses(nonIncrementalResponses);
            this._processPayloadFollowups(payloadFollowups);
        }
        if (hasNormalizedResponses) {
            var _payloadFollowups = [];
            for(var i = 0; i < normalizedResponses.length; i++){
                var _response$extensions2;
                var _response = normalizedResponses[i];
                var source = new RelayRecordSource(_response.data);
                var isFinal = ((_response$extensions2 = _response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true;
                var payload = {
                    errors: [],
                    fieldPayloads: [],
                    followupPayloads: [],
                    incrementalPlaceholders: [],
                    isFinal: isFinal,
                    source: source
                };
                this._getPublishQueueAndSaveActor().commitPayload(this._operation, payload, this._updater);
                _payloadFollowups.push(payload);
                this._execTimeResolverResponseComplete = isFinal;
                if (isFinal) {
                    this._updateActiveState();
                }
            }
        }
        if (incrementalResponses.length > 0) {
            var _payloadFollowups2 = this._processIncrementalResponses(incrementalResponses);
            this._processPayloadFollowups(_payloadFollowups2);
        }
        if (this._isSubscriptionOperation) {
            if (responsesWithData[0].extensions == null) {
                responsesWithData[0].extensions = {
                    __relay_subscription_root_id: this._operation.fragment.dataID
                };
            } else {
                responsesWithData[0].extensions.__relay_subscription_root_id = this._operation.fragment.dataID;
            }
        }
        var updatedOwners = this._runPublishQueue(hasNonIncrementalResponses || hasNormalizedResponses ? this._operation : undefined);
        if (hasNonIncrementalResponses) {
            if (this._incrementalPayloadsPending) {
                this._retainData();
            }
        }
        this._updateOperationTracker(updatedOwners);
        this._sink.next(response);
    };
    _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater, treatMissingFieldsAsNull) {
        var _this6 = this;
        !(this._optimisticUpdates === null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: environment.execute: only support one optimistic response per ' + 'execute.') : "TURBOPACK unreachable" : void 0;
        if (response == null && updater == null) {
            return;
        }
        var optimisticUpdates = [];
        if (response) {
            var payload = this._normalizeResponse(response, this._operation.root, ROOT_TYPE, {
                actorIdentifier: this._actorIdentifier,
                getDataID: this._getDataID,
                log: this._log,
                path: [],
                shouldProcessClientComponents: this._shouldProcessClientComponents,
                treatMissingFieldsAsNull: treatMissingFieldsAsNull
            }, this._useExecTimeResolvers);
            validateOptimisticResponsePayload(payload);
            optimisticUpdates.push({
                operation: this._operation,
                payload: payload,
                updater: updater
            });
            this._processOptimisticFollowups(payload, optimisticUpdates);
        } else if (updater) {
            optimisticUpdates.push({
                operation: this._operation,
                payload: {
                    errors: null,
                    fieldPayloads: null,
                    incrementalPlaceholders: null,
                    followupPayloads: null,
                    source: RelayRecordSource.create(),
                    isFinal: false
                },
                updater: updater
            });
        }
        this._optimisticUpdates = optimisticUpdates;
        optimisticUpdates.forEach(function(update) {
            return _this6._getPublishQueueAndSaveActor().applyUpdate(update);
        });
        var updatedOwners = this._runPublishQueue();
        if (RelayFeatureFlags.ENABLE_OPERATION_TRACKER_OPTIMISTIC_UPDATES) {
            this._updateOperationTracker(updatedOwners);
        }
    };
    _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {
        if (payload.followupPayloads && payload.followupPayloads.length) {
            var followupPayloads = payload.followupPayloads;
            var _iterator = (0, _createForOfIteratorHelper2["default"])(followupPayloads), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var followupPayload = _step.value;
                    switch(followupPayload.kind){
                        case 'ModuleImportPayload':
                            var operationLoader = this._expectOperationLoader();
                            var operation = operationLoader.get(followupPayload.operationReference);
                            if (operation == null) {
                                this._processAsyncOptimisticModuleImport(followupPayload);
                            } else {
                                var moduleImportOptimisticUpdates = this._processOptimisticModuleImport(operation, followupPayload);
                                optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2["default"])(moduleImportOptimisticUpdates));
                            }
                            break;
                        case 'ActorPayload':
                            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'OperationExecutor: Unexpected optimistic ActorPayload. These updates are not supported.') : "TURBOPACK unreachable";
                            break;
                        default:
                            followupPayload;
                            ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Unexpected followup kind `%s`. when processing optimistic updates.', followupPayload.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
                    }
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
        }
    };
    _proto._normalizeFollowupPayload = function _normalizeFollowupPayload(followupPayload, normalizationNode) {
        var variables;
        if (normalizationNode.kind === 'SplitOperation' && followupPayload.kind === 'ModuleImportPayload') {
            variables = getLocalVariables(followupPayload.variables, normalizationNode.argumentDefinitions, followupPayload.args);
        } else {
            variables = followupPayload.variables;
        }
        var selector = createNormalizationSelector(normalizationNode, followupPayload.dataID, variables);
        var nextResponse = {
            data: followupPayload.data,
            extensions: this._state === 'loading_final' ? {
                is_final: true
            } : undefined
        };
        return this._normalizeResponse(nextResponse, selector, followupPayload.typeName, {
            actorIdentifier: this._actorIdentifier,
            getDataID: this._getDataID,
            log: this._log,
            path: followupPayload.path,
            treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
            shouldProcessClientComponents: this._shouldProcessClientComponents
        }, this._useExecTimeResolvers);
    };
    _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(normalizationRootNode, moduleImportPayload) {
        var operation = getOperation(normalizationRootNode);
        var optimisticUpdates = [];
        var modulePayload = this._normalizeFollowupPayload(moduleImportPayload, operation);
        validateOptimisticResponsePayload(modulePayload);
        optimisticUpdates.push({
            operation: this._operation,
            payload: modulePayload,
            updater: null
        });
        this._processOptimisticFollowups(modulePayload, optimisticUpdates);
        return optimisticUpdates;
    };
    _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(moduleImportPayload) {
        var _this7 = this;
        this._expectOperationLoader().load(moduleImportPayload.operationReference).then(function(operation) {
            if (operation == null || _this7._state !== 'started') {
                return;
            }
            var moduleImportOptimisticUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);
            moduleImportOptimisticUpdates.forEach(function(update) {
                return _this7._getPublishQueueAndSaveActor().applyUpdate(update);
            });
            if (_this7._optimisticUpdates == null) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'OperationExecutor: Unexpected ModuleImport optimistic ' + 'update in operation %s.' + _this7._operation.request.node.params.name) : "TURBOPACK unreachable";
            } else {
                var _this$_optimisticUpda;
                (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2["default"])(moduleImportOptimisticUpdates));
                _this7._runPublishQueue();
            }
        });
    };
    _proto._processResponses = function _processResponses(responses) {
        var _this8 = this;
        this._log({
            name: 'execute.normalize.start',
            operation: this._operation
        });
        if (this._optimisticUpdates !== null) {
            this._optimisticUpdates.forEach(function(update) {
                _this8._getPublishQueueAndSaveActor().revertUpdate(update);
            });
            this._optimisticUpdates = null;
        }
        this._incrementalPayloadsPending = false;
        this._incrementalResults.clear();
        this._source.clear();
        return responses.map(function(payloadPart) {
            var relayPayload = _this8._normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE, {
                actorIdentifier: _this8._actorIdentifier,
                getDataID: _this8._getDataID,
                log: _this8._log,
                path: [],
                treatMissingFieldsAsNull: _this8._treatMissingFieldsAsNull,
                shouldProcessClientComponents: _this8._shouldProcessClientComponents
            }, _this8._useExecTimeResolvers);
            _this8._getPublishQueueAndSaveActor().commitPayload(_this8._operation, relayPayload, _this8._updater);
            _this8._log({
                name: 'execute.normalize.end',
                operation: _this8._operation
            });
            return relayPayload;
        });
    };
    _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {
        var _this9 = this;
        if (this._state === 'completed') {
            return;
        }
        payloads.forEach(function(payload) {
            var incrementalPlaceholders = payload.incrementalPlaceholders, followupPayloads = payload.followupPayloads, isFinal = payload.isFinal;
            _this9._state = isFinal ? 'loading_final' : 'loading_incremental';
            _this9._updateActiveState();
            if (isFinal) {
                _this9._incrementalPayloadsPending = false;
            }
            if (followupPayloads && followupPayloads.length !== 0) {
                followupPayloads.forEach(function(followupPayload) {
                    var _followupPayload$acto;
                    var prevActorIdentifier = _this9._actorIdentifier;
                    _this9._actorIdentifier = (_followupPayload$acto = followupPayload.actorIdentifier) !== null && _followupPayload$acto !== void 0 ? _followupPayload$acto : _this9._actorIdentifier;
                    _this9._processFollowupPayload(followupPayload);
                    _this9._actorIdentifier = prevActorIdentifier;
                });
            }
            if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {
                _this9._incrementalPayloadsPending = _this9._state !== 'loading_final';
                incrementalPlaceholders.forEach(function(incrementalPlaceholder) {
                    var _incrementalPlacehold;
                    var prevActorIdentifier = _this9._actorIdentifier;
                    _this9._actorIdentifier = (_incrementalPlacehold = incrementalPlaceholder.actorIdentifier) !== null && _incrementalPlacehold !== void 0 ? _incrementalPlacehold : _this9._actorIdentifier;
                    _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);
                    _this9._actorIdentifier = prevActorIdentifier;
                });
                if (_this9._isClientPayload || _this9._state === 'loading_final') {
                    ("TURBOPACK compile-time truthy", 1) ? warning(_this9._isClientPayload, 'RelayModernEnvironment: Operation `%s` contains @defer/@stream ' + 'directives but was executed in non-streaming mode. See ' + 'https://fburl.com/relay-incremental-delivery-non-streaming-warning.', _this9._operation.request.node.params.name) : "TURBOPACK unreachable";
                    var relayPayloads = [];
                    incrementalPlaceholders.forEach(function(placeholder) {
                        if (placeholder.kind === 'defer') {
                            relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {
                                data: placeholder.data,
                                extensions: {
                                    is_final: true
                                }
                            }));
                        }
                    });
                    if (relayPayloads.length > 0) {
                        _this9._processPayloadFollowups(relayPayloads);
                    }
                }
            }
        });
    };
    _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {
        if (!this._isSubscriptionOperation && !(this._useExecTimeResolvers && this._execTimeResolverResponseComplete && this._state === 'loading_final')) {
            return;
        }
        if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {
            this._completeOperationTracker();
        }
    };
    _proto._processFollowupPayload = function _processFollowupPayload(followupPayload) {
        var _this10 = this;
        switch(followupPayload.kind){
            case 'ModuleImportPayload':
                var operationLoader = this._expectOperationLoader();
                var node = operationLoader.get(followupPayload.operationReference);
                if (node != null) {
                    this._processFollowupPayloadWithNormalizationNode(followupPayload, getOperation(node));
                } else {
                    var id = this._nextSubscriptionId++;
                    this._pendingModulePayloadsCount++;
                    var decrementPendingCount = function decrementPendingCount() {
                        _this10._pendingModulePayloadsCount--;
                        _this10._maybeCompleteSubscriptionOperationTracking();
                    };
                    var networkObservable = RelayObservable.from(new Promise(function(resolve, reject) {
                        operationLoader.load(followupPayload.operationReference).then(resolve, reject);
                    }));
                    RelayObservable.create(function(sink) {
                        var cancellationToken;
                        var subscription = networkObservable.subscribe({
                            next: function next(loadedNode) {
                                if (loadedNode != null) {
                                    var publishModuleImportPayload = function publishModuleImportPayload() {
                                        try {
                                            var operation = getOperation(loadedNode);
                                            var batchAsyncModuleUpdatesFN = RelayFeatureFlags.BATCH_ASYNC_MODULE_UPDATES_FN;
                                            var shouldScheduleAsyncStoreUpdate = batchAsyncModuleUpdatesFN != null && _this10._pendingModulePayloadsCount > 1;
                                            var _withStartAndDuration = withStartAndDuration(function() {
                                                _this10._handleFollowupPayload(followupPayload, operation);
                                                if (shouldScheduleAsyncStoreUpdate) {
                                                    _this10._scheduleAsyncStoreUpdate(batchAsyncModuleUpdatesFN, sink.complete);
                                                } else {
                                                    var updatedOwners = _this10._runPublishQueue();
                                                    _this10._updateOperationTracker(updatedOwners);
                                                }
                                            }), _ = _withStartAndDuration[0], duration = _withStartAndDuration[1];
                                            _this10._log({
                                                name: 'execute.async.module',
                                                executeId: _this10._executeId,
                                                operationName: operation.name,
                                                duration: duration
                                            });
                                            if (!shouldScheduleAsyncStoreUpdate) {
                                                sink.complete();
                                            }
                                        } catch (error) {
                                            sink.error(error);
                                        }
                                    };
                                    var scheduler = _this10._scheduler;
                                    if (scheduler == null) {
                                        publishModuleImportPayload();
                                    } else {
                                        cancellationToken = scheduler.schedule(publishModuleImportPayload);
                                    }
                                } else {
                                    sink.complete();
                                }
                            },
                            error: sink.error
                        });
                        return function() {
                            subscription.unsubscribe();
                            if (_this10._scheduler != null && cancellationToken != null) {
                                _this10._scheduler.cancel(cancellationToken);
                            }
                        };
                    }).subscribe({
                        complete: function complete() {
                            _this10._complete(id);
                            decrementPendingCount();
                        },
                        error: function error(_error4) {
                            _this10._error(_error4);
                            decrementPendingCount();
                        },
                        start: function start(subscription) {
                            return _this10._start(id, subscription);
                        }
                    });
                }
                break;
            case 'ActorPayload':
                this._processFollowupPayloadWithNormalizationNode(followupPayload, followupPayload.node);
                break;
            default:
                followupPayload;
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Unexpected followup kind `%s`.', followupPayload.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
    };
    _proto._processFollowupPayloadWithNormalizationNode = function _processFollowupPayloadWithNormalizationNode(followupPayload, normalizationNode) {
        this._handleFollowupPayload(followupPayload, normalizationNode);
        this._maybeCompleteSubscriptionOperationTracking();
    };
    _proto._handleFollowupPayload = function _handleFollowupPayload(followupPayload, normalizationNode) {
        var relayPayload = this._normalizeFollowupPayload(followupPayload, normalizationNode);
        this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload);
        this._processPayloadFollowups([
            relayPayload
        ]);
    };
    _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {
        var _relayPayload$fieldPa;
        var label = placeholder.label, path = placeholder.path;
        var pathKey = path.map(String).join('.');
        var resultForLabel = this._incrementalResults.get(label);
        if (resultForLabel == null) {
            resultForLabel = new Map();
            this._incrementalResults.set(label, resultForLabel);
        }
        var resultForPath = resultForLabel.get(pathKey);
        var pendingResponses = resultForPath != null && resultForPath.kind === 'response' ? resultForPath.responses : null;
        resultForLabel.set(pathKey, {
            kind: 'placeholder',
            placeholder: placeholder
        });
        var parentID;
        if (placeholder.kind === 'stream') {
            parentID = placeholder.parentID;
        } else if (placeholder.kind === 'defer') {
            parentID = placeholder.selector.dataID;
        } else {
            placeholder;
            ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Unsupported incremental placeholder kind `%s`.', placeholder.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
        var parentRecord = relayPayload.source.get(parentID);
        var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function(fieldPayload) {
            var fieldID = generateClientID(fieldPayload.dataID, fieldPayload.fieldKey);
            return fieldPayload.dataID === parentID || fieldID === parentID;
        });
        !(parentRecord != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected record `%s` to exist.', parentID) : "TURBOPACK unreachable" : void 0;
        var nextParentRecord;
        var nextParentPayloads;
        var previousParentEntry = this._source.get(parentID);
        if (previousParentEntry != null) {
            nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);
            var handlePayloads = new Map();
            var dedupePayload = function dedupePayload(payload) {
                var key = stableStringify(payload);
                handlePayloads.set(key, payload);
            };
            previousParentEntry.fieldPayloads.forEach(dedupePayload);
            parentPayloads.forEach(dedupePayload);
            nextParentPayloads = Array.from(handlePayloads.values());
        } else {
            nextParentRecord = parentRecord;
            nextParentPayloads = parentPayloads;
        }
        this._source.set(parentID, {
            record: nextParentRecord,
            fieldPayloads: nextParentPayloads
        });
        if (pendingResponses != null) {
            var payloadFollowups = this._processIncrementalResponses(pendingResponses);
            this._processPayloadFollowups(payloadFollowups);
        }
    };
    _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {
        var _this11 = this;
        var relayPayloads = [];
        incrementalResponses.forEach(function(incrementalResponse) {
            var label = incrementalResponse.label, path = incrementalResponse.path, response = incrementalResponse.response;
            var resultForLabel = _this11._incrementalResults.get(label);
            if (resultForLabel == null) {
                resultForLabel = new Map();
                _this11._incrementalResults.set(label, resultForLabel);
            }
            if (label.indexOf('$defer$') !== -1) {
                var pathKey = path.map(String).join('.');
                var resultForPath = resultForLabel.get(pathKey);
                if (resultForPath == null) {
                    resultForPath = {
                        kind: 'response',
                        responses: [
                            incrementalResponse
                        ]
                    };
                    resultForLabel.set(pathKey, resultForPath);
                    return;
                } else if (resultForPath.kind === 'response') {
                    resultForPath.responses.push(incrementalResponse);
                    return;
                }
                var placeholder = resultForPath.placeholder;
                !(placeholder.kind === 'defer') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected data for path `%s` for label `%s` ' + 'to be data for @defer, was `@%s`.', pathKey, label, placeholder.kind) : "TURBOPACK unreachable" : void 0;
                relayPayloads.push(_this11._processDeferResponse(label, path, placeholder, response));
            } else {
                var _pathKey = path.slice(0, -2).map(String).join('.');
                var _resultForPath = resultForLabel.get(_pathKey);
                if (_resultForPath == null) {
                    _resultForPath = {
                        kind: 'response',
                        responses: [
                            incrementalResponse
                        ]
                    };
                    resultForLabel.set(_pathKey, _resultForPath);
                    return;
                } else if (_resultForPath.kind === 'response') {
                    _resultForPath.responses.push(incrementalResponse);
                    return;
                }
                var _placeholder = _resultForPath.placeholder;
                !(_placeholder.kind === 'stream') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected data for path `%s` for label `%s` ' + 'to be data for @stream, was `@%s`.', _pathKey, label, _placeholder.kind) : "TURBOPACK unreachable" : void 0;
                relayPayloads.push(_this11._processStreamResponse(label, path, _placeholder, response));
            }
        });
        return relayPayloads;
    };
    _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {
        var _placeholder$actorIde;
        var parentID = placeholder.selector.dataID;
        var prevActorIdentifier = this._actorIdentifier;
        this._actorIdentifier = (_placeholder$actorIde = placeholder.actorIdentifier) !== null && _placeholder$actorIde !== void 0 ? _placeholder$actorIde : this._actorIdentifier;
        var relayPayload = this._normalizeResponse(response, placeholder.selector, placeholder.typeName, {
            actorIdentifier: this._actorIdentifier,
            getDataID: this._getDataID,
            log: this._log,
            path: placeholder.path,
            treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
            shouldProcessClientComponents: this._shouldProcessClientComponents
        }, this._useExecTimeResolvers);
        this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload);
        var parentEntry = this._source.get(parentID);
        !(parentEntry != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected the parent record `%s` for @defer ' + 'data to exist.', parentID) : "TURBOPACK unreachable" : void 0;
        var fieldPayloads = parentEntry.fieldPayloads;
        if (fieldPayloads.length !== 0) {
            var _response$extensions3;
            var handleFieldsRelayPayload = {
                errors: null,
                fieldPayloads: fieldPayloads,
                incrementalPlaceholders: null,
                followupPayloads: null,
                source: RelayRecordSource.create(),
                isFinal: ((_response$extensions3 = response.extensions) === null || _response$extensions3 === void 0 ? void 0 : _response$extensions3.is_final) === true
            };
            this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);
        }
        this._actorIdentifier = prevActorIdentifier;
        return relayPayload;
    };
    _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {
        var parentID = placeholder.parentID, node = placeholder.node, variables = placeholder.variables, actorIdentifier = placeholder.actorIdentifier;
        var prevActorIdentifier = this._actorIdentifier;
        this._actorIdentifier = actorIdentifier !== null && actorIdentifier !== void 0 ? actorIdentifier : this._actorIdentifier;
        var field = node.selections[0];
        !(field != null && field.kind === 'LinkedField' && field.plural === true) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected @stream to be used on a plural field.') : "TURBOPACK unreachable" : void 0;
        var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path), fieldPayloads = _this$_normalizeStrea.fieldPayloads, itemID = _this$_normalizeStrea.itemID, itemIndex = _this$_normalizeStrea.itemIndex, prevIDs = _this$_normalizeStrea.prevIDs, relayPayload = _this$_normalizeStrea.relayPayload, storageKey = _this$_normalizeStrea.storageKey;
        this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload, function(store) {
            var currentParentRecord = store.get(parentID);
            if (currentParentRecord == null) {
                return;
            }
            var currentItems = currentParentRecord.getLinkedRecords(storageKey);
            if (currentItems == null) {
                return;
            }
            if (currentItems.length !== prevIDs.length || currentItems.some(function(currentItem, index) {
                return prevIDs[index] !== (currentItem && currentItem.getDataID());
            })) {
                return;
            }
            var nextItems = (0, _toConsumableArray2["default"])(currentItems);
            nextItems[itemIndex] = store.get(itemID);
            currentParentRecord.setLinkedRecords(nextItems, storageKey);
        });
        if (fieldPayloads.length !== 0) {
            var handleFieldsRelayPayload = {
                errors: null,
                fieldPayloads: fieldPayloads,
                incrementalPlaceholders: null,
                followupPayloads: null,
                source: RelayRecordSource.create(),
                isFinal: false
            };
            this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);
        }
        this._actorIdentifier = prevActorIdentifier;
        return relayPayload;
    };
    _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {
        var _field$alias, _field$concreteType, _ref2, _this$_getDataID;
        var data = response.data;
        !(typeof data === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected the GraphQL @stream payload `data` ' + 'value to be an object.') : "TURBOPACK unreachable" : void 0;
        var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;
        var storageKey = getStorageKey(field, variables);
        var parentEntry = this._source.get(parentID);
        !(parentEntry != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected the parent record `%s` for @stream ' + 'data to exist.', parentID) : "TURBOPACK unreachable" : void 0;
        var parentRecord = parentEntry.record, fieldPayloads = parentEntry.fieldPayloads;
        var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);
        !(prevIDs != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected record `%s` to have fetched field ' + '`%s` with @stream.', parentID, field.name) : "TURBOPACK unreachable" : void 0;
        var finalPathEntry = path[path.length - 1];
        var itemIndex = parseInt(finalPathEntry, 10);
        !(itemIndex === finalPathEntry && itemIndex >= 0) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected path for @stream to end in a ' + 'positive integer index, got `%s`', finalPathEntry) : "TURBOPACK unreachable" : void 0;
        var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY];
        !(typeof typeName === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected @stream field `%s` to have a ' + '__typename.', field.name) : "TURBOPACK unreachable" : void 0;
        var itemID = (_ref2 = (_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs === null || prevIDs === void 0 ? void 0 : prevIDs[itemIndex]) !== null && _ref2 !== void 0 ? _ref2 : generateClientID(parentID, storageKey, itemIndex);
        !(typeof itemID === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : "TURBOPACK unreachable" : void 0;
        var selector = createNormalizationSelector(field, itemID, variables);
        var nextParentRecord = RelayModernRecord.clone(parentRecord);
        var nextIDs = (0, _toConsumableArray2["default"])(prevIDs);
        nextIDs[itemIndex] = itemID;
        RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);
        this._source.set(parentID, {
            record: nextParentRecord,
            fieldPayloads: fieldPayloads
        });
        var relayPayload = this._normalizeResponse(response, selector, typeName, {
            actorIdentifier: this._actorIdentifier,
            getDataID: this._getDataID,
            log: this._log,
            path: [].concat((0, _toConsumableArray2["default"])(normalizationPath), [
                responseKey,
                String(itemIndex)
            ]),
            treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
            shouldProcessClientComponents: this._shouldProcessClientComponents
        }, this._useExecTimeResolvers);
        return {
            fieldPayloads: fieldPayloads,
            itemID: itemID,
            itemIndex: itemIndex,
            prevIDs: prevIDs,
            relayPayload: relayPayload,
            storageKey: storageKey
        };
    };
    _proto._scheduleAsyncStoreUpdate = function _scheduleAsyncStoreUpdate(scheduleFn, completeFn) {
        var _this12 = this;
        this._completeFns.push(completeFn);
        if (this._asyncStoreUpdateDisposable != null) {
            return;
        }
        this._asyncStoreUpdateDisposable = scheduleFn(function() {
            _this12._asyncStoreUpdateDisposable = null;
            var updatedOwners = _this12._runPublishQueue();
            _this12._updateOperationTracker(updatedOwners);
            var _iterator2 = (0, _createForOfIteratorHelper2["default"])(_this12._completeFns), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var complete = _step2.value;
                    complete();
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
            _this12._completeFns = [];
        });
    };
    _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {
        if (updatedOwners != null && updatedOwners.length > 0) {
            this._operationTracker.update(this._operation.request, new Set(updatedOwners));
        }
    };
    _proto._completeOperationTracker = function _completeOperationTracker() {
        this._operationTracker.complete(this._operation.request);
    };
    _proto._getPublishQueueAndSaveActor = function _getPublishQueueAndSaveActor() {
        this._seenActors.add(this._actorIdentifier);
        return this._getPublishQueue(this._actorIdentifier);
    };
    _proto._getActorsToVisit = function _getActorsToVisit() {
        if (this._seenActors.size === 0) {
            return new Set([
                this._actorIdentifier
            ]);
        } else {
            return this._seenActors;
        }
    };
    _proto._runPublishQueue = function _runPublishQueue(operation) {
        var updatedOwners = new Set();
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(this._getActorsToVisit()), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var actorIdentifier = _step3.value;
                var owners = this._getPublishQueue(actorIdentifier).run(operation);
                owners.forEach(function(owner) {
                    return updatedOwners.add(owner);
                });
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
        return Array.from(updatedOwners);
    };
    _proto._retainData = function _retainData() {
        var _iterator4 = (0, _createForOfIteratorHelper2["default"])(this._getActorsToVisit()), _step4;
        try {
            for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                var actorIdentifier = _step4.value;
                if (!this._retainDisposables.has(actorIdentifier)) {
                    this._retainDisposables.set(actorIdentifier, this._getStore(actorIdentifier).retain(this._operation));
                }
            }
        } catch (err) {
            _iterator4.e(err);
        } finally{
            _iterator4.f();
        }
    };
    _proto._disposeRetainedData = function _disposeRetainedData() {
        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(this._retainDisposables.values()), _step5;
        try {
            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                var disposable = _step5.value;
                disposable.dispose();
            }
        } catch (err) {
            _iterator5.e(err);
        } finally{
            _iterator5.f();
        }
        this._retainDisposables.clear();
    };
    _proto._expectOperationLoader = function _expectOperationLoader() {
        var operationLoader = this._operationLoader;
        !operationLoader ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected an operationLoader to be ' + 'configured when using `@match`.') : "TURBOPACK unreachable" : void 0;
        return operationLoader;
    };
    return Executor;
}();
function partitionGraphQLResponses(responses) {
    var nonIncrementalResponses = [];
    var incrementalResponses = [];
    var normalizedResponses = [];
    responses.forEach(function(response) {
        var _response$extensions4;
        if (response.path != null || response.label != null) {
            var label = response.label, path = response.path;
            if (label == null || path == null) {
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: invalid incremental payload, expected ' + '`path` and `label` to either both be null/undefined, or ' + '`path` to be an `Array<string | number>` and `label` to be a ' + '`string`.') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
            incrementalResponses.push({
                label: label,
                path: path,
                response: response
            });
        } else if (((_response$extensions4 = response.extensions) === null || _response$extensions4 === void 0 ? void 0 : _response$extensions4.is_normalized) === true) {
            normalizedResponses.push(response);
        } else {
            nonIncrementalResponses.push(response);
        }
    });
    return [
        nonIncrementalResponses,
        incrementalResponses,
        normalizedResponses
    ];
}
function stableStringify(value) {
    var _JSON$stringify;
    return (_JSON$stringify = JSON.stringify(stableCopy(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : '';
}
function validateOptimisticResponsePayload(payload) {
    var incrementalPlaceholders = payload.incrementalPlaceholders;
    if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {
        ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: optimistic responses cannot be returned ' + 'for operations that use incremental data delivery (@defer, ' + '@stream, and @stream_connection).') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
    }
}
module.exports = {
    execute: execute
};
}),
"[project]/node_modules/relay-runtime/lib/util/resolveImmediate.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var resolvedPromise = Promise.resolve();
function resolveImmediate(callback) {
    resolvedPromise.then(callback)["catch"](throwNext);
}
function throwNext(error) {
    setTimeout(function() {
        throw error;
    }, 0);
}
module.exports = resolveImmediate;
}),
"[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceMutator.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordState.js [app-ssr] (ecmascript)"), EXISTENT = _require.EXISTENT;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var RelayRecordSourceMutator = /*#__PURE__*/ function() {
    function RelayRecordSourceMutator(base, sink) {
        this.__sources = [
            sink,
            base
        ];
        this._base = base;
        this._sink = sink;
    }
    var _proto = RelayRecordSourceMutator.prototype;
    _proto.unstable_getRawRecordWithChanges = function unstable_getRawRecordWithChanges(dataID) {
        var baseRecord = this._base.get(dataID);
        var sinkRecord = this._sink.get(dataID);
        if (sinkRecord === undefined) {
            if (baseRecord == null) {
                return baseRecord;
            }
            var nextRecord = RelayModernRecord.clone(baseRecord);
            if ("TURBOPACK compile-time truthy", 1) {
                RelayModernRecord.freeze(nextRecord);
            }
            return nextRecord;
        } else if (sinkRecord === null) {
            return null;
        } else if (baseRecord != null) {
            var _nextRecord = RelayModernRecord.update(baseRecord, sinkRecord);
            if ("TURBOPACK compile-time truthy", 1) {
                if (_nextRecord !== baseRecord) {
                    RelayModernRecord.freeze(_nextRecord);
                }
            }
            return _nextRecord;
        } else {
            var _nextRecord2 = RelayModernRecord.clone(sinkRecord);
            if ("TURBOPACK compile-time truthy", 1) {
                RelayModernRecord.freeze(_nextRecord2);
            }
            return _nextRecord2;
        }
    };
    _proto._getSinkRecord = function _getSinkRecord(dataID) {
        var sinkRecord = this._sink.get(dataID);
        if (!sinkRecord) {
            var baseRecord = this._base.get(dataID);
            !baseRecord ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceMutator: Cannot modify non-existent record `%s`.', dataID) : "TURBOPACK unreachable" : void 0;
            sinkRecord = RelayModernRecord.create(dataID, RelayModernRecord.getType(baseRecord));
            this._sink.set(dataID, sinkRecord);
        }
        return sinkRecord;
    };
    _proto.copyFields = function copyFields(sourceID, sinkID) {
        var sinkSource = this._sink.get(sourceID);
        var baseSource = this._base.get(sourceID);
        !(sinkSource || baseSource) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceMutator#copyFields(): Cannot copy fields from ' + 'non-existent record `%s`.', sourceID) : "TURBOPACK unreachable" : void 0;
        var sink = this._getSinkRecord(sinkID);
        if (baseSource) {
            RelayModernRecord.copyFields(baseSource, sink);
        }
        if (sinkSource) {
            RelayModernRecord.copyFields(sinkSource, sink);
        }
    };
    _proto.copyFieldsFromRecord = function copyFieldsFromRecord(record, sinkID) {
        var sink = this._getSinkRecord(sinkID);
        RelayModernRecord.copyFields(record, sink);
    };
    _proto.create = function create(dataID, typeName) {
        !(this._base.getStatus(dataID) !== EXISTENT && this._sink.getStatus(dataID) !== EXISTENT) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceMutator#create(): Cannot create a record with id ' + '`%s`, this record already exists.', dataID) : "TURBOPACK unreachable" : void 0;
        var record = RelayModernRecord.create(dataID, typeName);
        this._sink.set(dataID, record);
    };
    _proto["delete"] = function _delete(dataID) {
        this._sink["delete"](dataID);
    };
    _proto.getStatus = function getStatus(dataID) {
        return this._sink.has(dataID) ? this._sink.getStatus(dataID) : this._base.getStatus(dataID);
    };
    _proto.getType = function getType(dataID) {
        for(var ii = 0; ii < this.__sources.length; ii++){
            var record = this.__sources[ii].get(dataID);
            if (record) {
                return RelayModernRecord.getType(record);
            } else if (record === null) {
                return null;
            }
        }
    };
    _proto.getValue = function getValue(dataID, storageKey) {
        for(var ii = 0; ii < this.__sources.length; ii++){
            var record = this.__sources[ii].get(dataID);
            if (record) {
                var value = RelayModernRecord.getValue(record, storageKey);
                if (value !== undefined) {
                    return value;
                }
            } else if (record === null) {
                return null;
            }
        }
    };
    _proto.setValue = function setValue(dataID, storageKey, value) {
        var sinkRecord = this._getSinkRecord(dataID);
        RelayModernRecord.setValue(sinkRecord, storageKey, value);
    };
    _proto.getErrors = function getErrors(dataID, storageKey) {
        for(var ii = 0; ii < this.__sources.length; ii++){
            var record = this.__sources[ii].get(dataID);
            if (record) {
                var value = RelayModernRecord.getErrors(record, storageKey);
                if (value !== undefined) {
                    return value;
                }
            } else if (record === null) {
                return null;
            }
        }
    };
    _proto.setErrors = function setErrors(dataID, storageKey, errors) {
        var sinkRecord = this._getSinkRecord(dataID);
        RelayModernRecord.setErrors(sinkRecord, storageKey, errors);
    };
    _proto.getLinkedRecordID = function getLinkedRecordID(dataID, storageKey) {
        for(var ii = 0; ii < this.__sources.length; ii++){
            var record = this.__sources[ii].get(dataID);
            if (record) {
                var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
                if (linkedID !== undefined) {
                    return linkedID;
                }
            } else if (record === null) {
                return null;
            }
        }
    };
    _proto.setLinkedRecordID = function setLinkedRecordID(dataID, storageKey, linkedID) {
        var sinkRecord = this._getSinkRecord(dataID);
        RelayModernRecord.setLinkedRecordID(sinkRecord, storageKey, linkedID);
    };
    _proto.getLinkedRecordIDs = function getLinkedRecordIDs(dataID, storageKey) {
        for(var ii = 0; ii < this.__sources.length; ii++){
            var record = this.__sources[ii].get(dataID);
            if (record) {
                var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);
                if (linkedIDs !== undefined) {
                    return linkedIDs;
                }
            } else if (record === null) {
                return null;
            }
        }
    };
    _proto.setLinkedRecordIDs = function setLinkedRecordIDs(dataID, storageKey, linkedIDs) {
        var sinkRecord = this._getSinkRecord(dataID);
        RelayModernRecord.setLinkedRecordIDs(sinkRecord, storageKey, linkedIDs);
    };
    return RelayRecordSourceMutator;
}();
module.exports = RelayRecordSourceMutator;
}),
"[project]/node_modules/relay-runtime/lib/mutations/createUpdatableProxy.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), getArgumentValues = _require.getArgumentValues;
var nonUpdatableKeys = [
    'id',
    '__id',
    '__typename',
    'js'
];
function createUpdatableProxy(updatableProxyRootRecord, variables, selections, recordSourceProxy, missingFieldHandlers) {
    var mutableUpdatableProxy = {};
    updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selections, recordSourceProxy, missingFieldHandlers);
    if ("TURBOPACK compile-time truthy", 1) {
        Object.freeze(mutableUpdatableProxy);
    }
    return mutableUpdatableProxy;
}
function updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selections, recordSourceProxy, missingFieldHandlers) {
    var _selection$alias3;
    var _iterator = (0, _createForOfIteratorHelper2["default"])(selections), _step;
    try {
        var _loop = function _loop() {
            var selection = _step.value;
            switch(selection.kind){
                case 'LinkedField':
                    if (selection.plural) {
                        Object.defineProperty(mutableUpdatableProxy, (_selection$alias = selection.alias) !== null && _selection$alias !== void 0 ? _selection$alias : selection.name, {
                            get: createGetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers),
                            set: createSetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy)
                        });
                    } else {
                        Object.defineProperty(mutableUpdatableProxy, (_selection$alias2 = selection.alias) !== null && _selection$alias2 !== void 0 ? _selection$alias2 : selection.name, {
                            get: createGetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers),
                            set: createSetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy)
                        });
                    }
                    break;
                case 'ScalarField':
                    var scalarFieldName = (_selection$alias3 = selection.alias) !== null && _selection$alias3 !== void 0 ? _selection$alias3 : selection.name;
                    Object.defineProperty(mutableUpdatableProxy, scalarFieldName, {
                        get: function get() {
                            var _selection$args;
                            var newVariables = getArgumentValues((_selection$args = selection.args) !== null && _selection$args !== void 0 ? _selection$args : [], variables);
                            var value = updatableProxyRootRecord.getValue(selection.name, newVariables);
                            if (value == null) {
                                value = getScalarUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers);
                            }
                            return value;
                        },
                        set: nonUpdatableKeys.includes(selection.name) ? undefined : function(newValue) {
                            var _selection$args2;
                            var newVariables = getArgumentValues((_selection$args2 = selection.args) !== null && _selection$args2 !== void 0 ? _selection$args2 : [], variables);
                            updatableProxyRootRecord.setValue__UNSAFE(newValue, selection.name, newVariables);
                        }
                    });
                    break;
                case 'InlineFragment':
                    if (updatableProxyRootRecord.getType() === selection.type) {
                        updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selection.selections, recordSourceProxy, missingFieldHandlers);
                    }
                    break;
                case 'ClientExtension':
                    updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selection.selections, recordSourceProxy, missingFieldHandlers);
                    break;
                case 'FragmentSpread':
                    break;
                case 'Condition':
                case 'ActorChange':
                case 'InlineDataFragmentSpread':
                case 'AliasedInlineFragmentSpread':
                case 'ClientEdgeToClientObject':
                case 'ClientEdgeToServerObject':
                case 'Defer':
                case 'ModuleImport':
                case 'RequiredField':
                case 'CatchField':
                case 'Stream':
                case 'RelayResolver':
                case 'RelayLiveResolver':
                    throw new Error('Encountered an unexpected ReaderSelection variant in RelayRecordSourceProxy. This indicates a bug in Relay.');
                default:
                    selection.kind;
                    throw new Error('Encountered an unexpected ReaderSelection variant in RelayRecordSourceProxy. This indicates a bug in Relay.');
            }
        };
        for(_iterator.s(); !(_step = _iterator.n()).done;){
            var _selection$alias;
            var _selection$alias2;
            _loop();
        }
    } catch (err) {
        _iterator.e(err);
    } finally{
        _iterator.f();
    }
}
function createSetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy) {
    return function set(newValue) {
        var _selection$args3;
        var newVariables = getArgumentValues((_selection$args3 = selection.args) !== null && _selection$args3 !== void 0 ? _selection$args3 : [], variables);
        if (newValue == null) {
            throw new Error('Do not assign null to plural linked fields; assign an empty array instead.');
        } else {
            var recordProxies = newValue.map(function(item) {
                if (item == null) {
                    throw new Error('When assigning an array of items, none of the items should be null or undefined.');
                }
                var __id = item.__id;
                if (__id == null) {
                    throw new Error('The __id field must be present on each item passed to the setter. This indicates a bug in Relay.');
                }
                var newValueRecord = recordSourceProxy.get(__id);
                if (newValueRecord == null) {
                    throw new Error("Did not find item with data id ".concat(__id, " in the store."));
                }
                return newValueRecord;
            });
            updatableProxyRootRecord.setLinkedRecords(recordProxies, selection.name, newVariables);
        }
    };
}
function createSetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy) {
    return function set(newValue) {
        var _selection$args4;
        var newVariables = getArgumentValues((_selection$args4 = selection.args) !== null && _selection$args4 !== void 0 ? _selection$args4 : [], variables);
        if (newValue == null) {
            updatableProxyRootRecord.setValue(newValue, selection.name, newVariables);
        } else {
            var __id = newValue.__id;
            if (__id == null) {
                throw new Error('The __id field must be present on the argument. This indicates a bug in Relay.');
            }
            var newValueRecord = recordSourceProxy.get(__id);
            if (newValueRecord == null) {
                throw new Error("Did not find item with data id ".concat(__id, " in the store."));
            }
            updatableProxyRootRecord.setLinkedRecord(newValueRecord, selection.name, newVariables);
        }
    };
}
function createGetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
    return function() {
        var _selection$args5;
        var newVariables = getArgumentValues((_selection$args5 = selection.args) !== null && _selection$args5 !== void 0 ? _selection$args5 : [], variables);
        var linkedRecords = updatableProxyRootRecord.getLinkedRecords(selection.name, newVariables);
        if (linkedRecords === undefined) {
            linkedRecords = getPluralLinkedRecordUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers);
        }
        if (linkedRecords != null) {
            return linkedRecords.map(function(linkedRecord) {
                if (linkedRecord != null) {
                    var updatableProxy = {};
                    updateProxyFromSelections(updatableProxy, linkedRecord, variables, selection.selections, recordSourceProxy, missingFieldHandlers);
                    if ("TURBOPACK compile-time truthy", 1) {
                        Object.freeze(updatableProxy);
                    }
                    return updatableProxy;
                } else {
                    return linkedRecord;
                }
            });
        } else {
            return linkedRecords;
        }
    };
}
function createGetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
    return function() {
        var _selection$args6;
        var newVariables = getArgumentValues((_selection$args6 = selection.args) !== null && _selection$args6 !== void 0 ? _selection$args6 : [], variables);
        var linkedRecord = updatableProxyRootRecord.getLinkedRecord(selection.name, newVariables);
        if (linkedRecord === undefined) {
            linkedRecord = getLinkedRecordUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers);
        }
        if (linkedRecord != null) {
            var updatableProxy = {};
            updateProxyFromSelections(updatableProxy, linkedRecord, variables, selection.selections, recordSourceProxy, missingFieldHandlers);
            if ("TURBOPACK compile-time truthy", 1) {
                Object.freeze(updatableProxy);
            }
            return updatableProxy;
        } else {
            return linkedRecord;
        }
    };
}
function getLinkedRecordUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(missingFieldHandlers), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var handler = _step2.value;
            if (handler.kind === 'linked') {
                var newId = handler.handle(selection, updatableProxyRootRecord, newVariables, recordSourceProxy);
                if (newId != null) {
                    return recordSourceProxy.get(newId);
                }
            }
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
}
function getPluralLinkedRecordUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
    var _iterator3 = (0, _createForOfIteratorHelper2["default"])(missingFieldHandlers), _step3;
    try {
        for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
            var handler = _step3.value;
            if (handler.kind === 'pluralLinked') {
                var newIds = handler.handle(selection, updatableProxyRootRecord, newVariables, recordSourceProxy);
                if (newIds != null) {
                    return newIds.map(function(newId) {
                        if (newId != null) {
                            return recordSourceProxy.get(newId);
                        }
                    });
                }
            }
        }
    } catch (err) {
        _iterator3.e(err);
    } finally{
        _iterator3.f();
    }
}
function getScalarUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
    var _iterator4 = (0, _createForOfIteratorHelper2["default"])(missingFieldHandlers), _step4;
    try {
        for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
            var handler = _step4.value;
            if (handler.kind === 'scalar') {
                var value = handler.handle(selection, updatableProxyRootRecord, newVariables, recordSourceProxy);
                if (value !== undefined) {
                    return value;
                }
            }
        }
    } catch (err) {
        _iterator4.e(err);
    } finally{
        _iterator4.f();
    }
}
module.exports = {
    createUpdatableProxy: createUpdatableProxy
};
}),
"[project]/node_modules/relay-runtime/lib/mutations/readUpdatableFragment.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-ssr] (ecmascript)"), getFragment = _require.getFragment;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-ssr] (ecmascript)"), getVariablesFromFragment = _require2.getVariablesFromFragment;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), ID_KEY = _require3.ID_KEY;
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/createUpdatableProxy.js [app-ssr] (ecmascript)"), createUpdatableProxy = _require4.createUpdatableProxy;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function readUpdatableFragment(fragment, fragmentReference, proxy, missingFieldHandlers) {
    var updatableFragment = getFragment(fragment);
    var fragmentVariables = getVariablesFromFragment(updatableFragment, fragmentReference);
    var id = fragmentReference[ID_KEY];
    var fragmentRoot = proxy.get(id);
    !(fragmentRoot != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, "No record with ".concat(id, " was found. This likely indicates a problem with Relay.")) : "TURBOPACK unreachable" : void 0;
    return {
        updatableData: createUpdatableProxy(fragmentRoot, fragmentVariables, updatableFragment.selections, proxy, missingFieldHandlers)
    };
}
module.exports = {
    readUpdatableFragment: readUpdatableFragment
};
}),
"[project]/node_modules/relay-runtime/lib/mutations/readUpdatableQuery.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-ssr] (ecmascript)"), getUpdatableQuery = _require.getUpdatableQuery;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/createUpdatableProxy.js [app-ssr] (ecmascript)"), createUpdatableProxy = _require2.createUpdatableProxy;
function readUpdatableQuery(query, variables, proxy, missingFieldHandlers) {
    var updatableQuery = getUpdatableQuery(query);
    return {
        updatableData: createUpdatableProxy(proxy.getRoot(), variables, updatableQuery.fragment.selections, proxy, missingFieldHandlers)
    };
}
module.exports = {
    readUpdatableQuery: readUpdatableQuery
};
}),
"[project]/node_modules/relay-runtime/lib/mutations/RelayRecordProxy.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-ssr] (ecmascript)"), generateClientID = _require.generateClientID;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), getStableStorageKey = _require2.getStableStorageKey;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var RelayRecordProxy = /*#__PURE__*/ function() {
    function RelayRecordProxy(source, mutator, dataID) {
        this._dataID = dataID;
        this._mutator = mutator;
        this._source = source;
    }
    var _proto = RelayRecordProxy.prototype;
    _proto.copyFieldsFrom = function copyFieldsFrom(source) {
        this._mutator.copyFields(source.getDataID(), this._dataID);
    };
    _proto.getDataID = function getDataID() {
        return this._dataID;
    };
    _proto.getType = function getType() {
        var type = this._mutator.getType(this._dataID);
        !(type != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordProxy: Cannot get the type of deleted record `%s`.', this._dataID) : "TURBOPACK unreachable" : void 0;
        return type;
    };
    _proto.getValue = function getValue(name, args) {
        var storageKey = getStableStorageKey(name, args);
        return this._mutator.getValue(this._dataID, storageKey);
    };
    _proto.setValue = function setValue(value, name, args, errors) {
        !isValidLeafValue(value) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordProxy#setValue(): Expected a scalar or array of scalars, ' + 'got `%s`.', JSON.stringify(value)) : "TURBOPACK unreachable" : void 0;
        return this.setValue__UNSAFE(value, name, args, errors);
    };
    _proto.getErrors = function getErrors(name, args) {
        var storageKey = getStableStorageKey(name, args);
        return this._mutator.getErrors(this._dataID, storageKey);
    };
    _proto.setValue__UNSAFE = function setValue__UNSAFE(value, name, args, errors) {
        var storageKey = getStableStorageKey(name, args);
        this._mutator.setValue(this._dataID, storageKey, value);
        if (errors != null) {
            if (errors.length === 0) {
                this._mutator.setErrors(this._dataID, storageKey);
            } else {
                this._mutator.setErrors(this._dataID, storageKey, errors);
            }
        }
        return this;
    };
    _proto.getLinkedRecord = function getLinkedRecord(name, args) {
        var storageKey = getStableStorageKey(name, args);
        var linkedID = this._mutator.getLinkedRecordID(this._dataID, storageKey);
        return linkedID != null ? this._source.get(linkedID) : linkedID;
    };
    _proto.setLinkedRecord = function setLinkedRecord(record, name, args) {
        !(record instanceof RelayRecordProxy) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordProxy#setLinkedRecord(): Expected a record, got `%s`.', record) : "TURBOPACK unreachable" : void 0;
        var storageKey = getStableStorageKey(name, args);
        var linkedID = record.getDataID();
        this._mutator.setLinkedRecordID(this._dataID, storageKey, linkedID);
        return this;
    };
    _proto.getOrCreateLinkedRecord = function getOrCreateLinkedRecord(name, typeName, args) {
        var linkedRecord = this.getLinkedRecord(name, args);
        if (!linkedRecord) {
            var _this$_source$get;
            var storageKey = getStableStorageKey(name, args);
            var clientID = generateClientID(this.getDataID(), storageKey);
            linkedRecord = (_this$_source$get = this._source.get(clientID)) !== null && _this$_source$get !== void 0 ? _this$_source$get : this._source.create(clientID, typeName);
            this.setLinkedRecord(linkedRecord, name, args);
        }
        return linkedRecord;
    };
    _proto.getLinkedRecords = function getLinkedRecords(name, args) {
        var _this = this;
        var storageKey = getStableStorageKey(name, args);
        var linkedIDs = this._mutator.getLinkedRecordIDs(this._dataID, storageKey);
        if (linkedIDs == null) {
            return linkedIDs;
        }
        return linkedIDs.map(function(linkedID) {
            return linkedID != null ? _this._source.get(linkedID) : linkedID;
        });
    };
    _proto.setLinkedRecords = function setLinkedRecords(records, name, args) {
        !Array.isArray(records) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordProxy#setLinkedRecords(): Expected records to be an array, got `%s`.', records) : "TURBOPACK unreachable" : void 0;
        var storageKey = getStableStorageKey(name, args);
        var linkedIDs = records.map(function(record) {
            return record && record.getDataID();
        });
        this._mutator.setLinkedRecordIDs(this._dataID, storageKey, linkedIDs);
        return this;
    };
    _proto.invalidateRecord = function invalidateRecord() {
        this._source.markIDForInvalidation(this._dataID);
    };
    return RelayRecordProxy;
}();
function isValidLeafValue(value) {
    return value == null || typeof value !== 'object' || Array.isArray(value) && value.every(isValidLeafValue);
}
module.exports = RelayRecordProxy;
}),
"[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceProxy.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordState.js [app-ssr] (ecmascript)"), EXISTENT = _require.EXISTENT, NONEXISTENT = _require.NONEXISTENT;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), ROOT_ID = _require2.ROOT_ID, ROOT_TYPE = _require2.ROOT_TYPE;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/readUpdatableFragment.js [app-ssr] (ecmascript)"), _readUpdatableFragment = _require3.readUpdatableFragment;
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/readUpdatableQuery.js [app-ssr] (ecmascript)"), _readUpdatableQuery = _require4.readUpdatableQuery;
var RelayRecordProxy = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayRecordProxy.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var RelayRecordSourceProxy = /*#__PURE__*/ function() {
    function RelayRecordSourceProxy(mutator, getDataID, handlerProvider, missingFieldHandlers, log) {
        this.__mutator = mutator;
        this._handlerProvider = handlerProvider || null;
        this._proxies = {};
        this._getDataID = getDataID;
        this._invalidatedStore = false;
        this._idsMarkedForInvalidation = new Set();
        this._missingFieldHandlers = missingFieldHandlers;
        this._log = log !== null && log !== void 0 ? log : function(LogEvent) {};
    }
    var _proto = RelayRecordSourceProxy.prototype;
    _proto.publishSource = function publishSource(source, fieldPayloads) {
        var _this = this;
        var dataIDs = source.getRecordIDs();
        dataIDs.forEach(function(dataID) {
            var status = source.getStatus(dataID);
            if (status === EXISTENT) {
                var sourceRecord = source.get(dataID);
                if (sourceRecord) {
                    if (_this.__mutator.getStatus(dataID) !== EXISTENT) {
                        _this.create(dataID, RelayModernRecord.getType(sourceRecord));
                    }
                    _this.__mutator.copyFieldsFromRecord(sourceRecord, dataID);
                }
            } else if (status === NONEXISTENT) {
                _this["delete"](dataID);
            }
        });
        if (fieldPayloads && fieldPayloads.length) {
            fieldPayloads.forEach(function(fieldPayload) {
                var handler = _this._handlerProvider && _this._handlerProvider(fieldPayload.handle);
                !handler ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernEnvironment: Expected a handler to be provided for handle `%s`.', fieldPayload.handle) : "TURBOPACK unreachable" : void 0;
                handler.update(_this, fieldPayload);
            });
        }
    };
    _proto.create = function create(dataID, typeName) {
        this.__mutator.create(dataID, typeName);
        delete this._proxies[dataID];
        var record = this.get(dataID);
        !record ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceProxy#create(): Expected the created record to exist.') : "TURBOPACK unreachable" : void 0;
        return record;
    };
    _proto["delete"] = function _delete(dataID) {
        !(dataID !== ROOT_ID) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceProxy#delete(): Cannot delete the root record.') : "TURBOPACK unreachable" : void 0;
        delete this._proxies[dataID];
        this.__mutator["delete"](dataID);
    };
    _proto.get = function get(dataID) {
        if (!this._proxies.hasOwnProperty(dataID)) {
            var status = this.__mutator.getStatus(dataID);
            if (status === EXISTENT) {
                this._proxies[dataID] = new RelayRecordProxy(this, this.__mutator, dataID);
            } else {
                this._proxies[dataID] = status === NONEXISTENT ? null : undefined;
            }
        }
        return this._proxies[dataID];
    };
    _proto.getRoot = function getRoot() {
        var root = this.get(ROOT_ID);
        if (!root) {
            root = this.create(ROOT_ID, ROOT_TYPE);
        }
        !(root && root.getType() === ROOT_TYPE) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceProxy#getRoot(): Expected the source to contain a ' + 'root record, %s.', root == null ? 'no root record found' : "found a root record of type `".concat(root.getType(), "`")) : "TURBOPACK unreachable" : void 0;
        return root;
    };
    _proto.invalidateStore = function invalidateStore() {
        this._invalidatedStore = true;
    };
    _proto.isStoreMarkedForInvalidation = function isStoreMarkedForInvalidation() {
        return this._invalidatedStore;
    };
    _proto.markIDForInvalidation = function markIDForInvalidation(dataID) {
        this._idsMarkedForInvalidation.add(dataID);
    };
    _proto.getIDsMarkedForInvalidation = function getIDsMarkedForInvalidation() {
        return this._idsMarkedForInvalidation;
    };
    _proto.readUpdatableQuery = function readUpdatableQuery(query, variables) {
        return _readUpdatableQuery(query, variables, this, this._missingFieldHandlers);
    };
    _proto.readUpdatableFragment = function readUpdatableFragment(fragment, fragmentReference) {
        return _readUpdatableFragment(fragment, fragmentReference, this, this._missingFieldHandlers);
    };
    return RelayRecordSourceProxy;
}();
module.exports = RelayRecordSourceProxy;
}),
"[project]/node_modules/relay-runtime/lib/store/cloneRelayHandleSourceField.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-ssr] (ecmascript)"), LINKED_FIELD = _require.LINKED_FIELD;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), getHandleStorageKey = _require2.getHandleStorageKey;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function cloneRelayHandleSourceField(handleField, selections, variables) {
    var sourceField = selections.find(function(source) {
        return source.kind === LINKED_FIELD && source.name === handleField.name && source.alias === handleField.alias && areEqual(source.args, handleField.args);
    });
    !(sourceField && sourceField.kind === LINKED_FIELD) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'cloneRelayHandleSourceField: Expected a corresponding source field for ' + 'handle `%s`.', handleField.handle) : "TURBOPACK unreachable" : void 0;
    var handleKey = getHandleStorageKey(handleField, variables);
    return {
        kind: 'LinkedField',
        alias: sourceField.alias,
        name: handleKey,
        storageKey: handleKey,
        args: null,
        concreteType: sourceField.concreteType,
        plural: sourceField.plural,
        selections: sourceField.selections
    };
}
module.exports = cloneRelayHandleSourceField;
}),
"[project]/node_modules/relay-runtime/lib/store/cloneRelayScalarHandleSourceField.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-ssr] (ecmascript)"), SCALAR_FIELD = _require.SCALAR_FIELD;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), getHandleStorageKey = _require2.getHandleStorageKey;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function cloneRelayScalarHandleSourceField(handleField, selections, variables) {
    var sourceField = selections.find(function(source) {
        return source.kind === SCALAR_FIELD && source.name === handleField.name && source.alias === handleField.alias && areEqual(source.args, handleField.args);
    });
    !(sourceField && sourceField.kind === SCALAR_FIELD) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'cloneRelayScalarHandleSourceField: Expected a corresponding source field for ' + 'handle `%s`.', handleField.handle) : "TURBOPACK unreachable" : void 0;
    var handleKey = getHandleStorageKey(handleField, variables);
    return {
        kind: 'ScalarField',
        alias: sourceField.alias,
        name: handleKey,
        storageKey: handleKey,
        args: null
    };
}
module.exports = cloneRelayScalarHandleSourceField;
}),
"[project]/node_modules/relay-runtime/lib/store/DataChecker.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var RelayRecordSourceMutator = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceMutator.js [app-ssr] (ecmascript)");
var RelayRecordSourceProxy = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceProxy.js [app-ssr] (ecmascript)");
var getOperation = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getOperation.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-ssr] (ecmascript)"), isClientID = _require.isClientID;
var cloneRelayHandleSourceField = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/cloneRelayHandleSourceField.js [app-ssr] (ecmascript)");
var cloneRelayScalarHandleSourceField = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/cloneRelayScalarHandleSourceField.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-ssr] (ecmascript)"), getLocalVariables = _require2.getLocalVariables;
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordState.js [app-ssr] (ecmascript)"), EXISTENT = _require3.EXISTENT, UNKNOWN = _require3.UNKNOWN;
var RelayStoreUtils = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)");
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/TypeID.js [app-ssr] (ecmascript)"), TYPE_SCHEMA_TYPE = _require4.TYPE_SCHEMA_TYPE, generateTypeID = _require4.generateTypeID;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var getModuleOperationKey = RelayStoreUtils.getModuleOperationKey, getStorageKey = RelayStoreUtils.getStorageKey, getArgumentValues = RelayStoreUtils.getArgumentValues;
function check(getSourceForActor, getTargetForActor, defaultActorIdentifier, selector, handlers, operationLoader, getDataID, shouldProcessClientComponents, log, useExecTimeResolvers) {
    if (log != null) {
        log({
            name: 'store.datachecker.start',
            selector: selector
        });
    }
    var dataID = selector.dataID, node = selector.node, variables = selector.variables;
    var checker = new DataChecker(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents, log, useExecTimeResolvers);
    var result = checker.check(node, dataID);
    if (log != null) {
        log({
            name: 'store.datachecker.end',
            selector: selector
        });
    }
    return result;
}
var DataChecker = /*#__PURE__*/ function() {
    function DataChecker(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents, log, useExecTimeResolvers) {
        this._getSourceForActor = getSourceForActor;
        this._getTargetForActor = getTargetForActor;
        this._getDataID = getDataID;
        this._source = getSourceForActor(defaultActorIdentifier);
        this._mutatorRecordSourceProxyCache = new Map();
        var _this$_getMutatorAndR = this._getMutatorAndRecordProxyForActor(defaultActorIdentifier), mutator = _this$_getMutatorAndR[0], recordSourceProxy = _this$_getMutatorAndR[1];
        this._useExecTimeResolvers = useExecTimeResolvers !== null && useExecTimeResolvers !== void 0 ? useExecTimeResolvers : false;
        this._mostRecentlyInvalidatedAt = null;
        this._handlers = handlers;
        this._mutator = mutator;
        this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;
        this._recordSourceProxy = recordSourceProxy;
        this._recordWasMissing = false;
        this._variables = variables;
        this._shouldProcessClientComponents = shouldProcessClientComponents;
        this._log = log;
    }
    var _proto = DataChecker.prototype;
    _proto._getMutatorAndRecordProxyForActor = function _getMutatorAndRecordProxyForActor(actorIdentifier) {
        var tuple = this._mutatorRecordSourceProxyCache.get(actorIdentifier);
        if (tuple == null) {
            var target = this._getTargetForActor(actorIdentifier);
            var mutator = new RelayRecordSourceMutator(this._getSourceForActor(actorIdentifier), target);
            var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID, undefined, this._handlers, this._log);
            tuple = [
                mutator,
                recordSourceProxy
            ];
            this._mutatorRecordSourceProxyCache.set(actorIdentifier, tuple);
        }
        return tuple;
    };
    _proto.check = function check(node, dataID) {
        this._assignClientAbstractTypes(node);
        this._traverse(node, dataID);
        return this._recordWasMissing === true ? {
            status: 'missing',
            mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt
        } : {
            status: 'available',
            mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt
        };
    };
    _proto._getVariableValue = function _getVariableValue(name) {
        !this._variables.hasOwnProperty(name) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayAsyncLoader(): Undefined variable `%s`.', name) : "TURBOPACK unreachable" : void 0;
        return this._variables[name];
    };
    _proto._handleMissing = function _handleMissing() {
        this._recordWasMissing = true;
    };
    _proto._handleMissingScalarField = function _handleMissingScalarField(field, dataID) {
        if (field.name === 'id' && field.alias == null && isClientID(dataID)) {
            return undefined;
        }
        var args = field.args != undefined ? getArgumentValues(field.args, this._variables) : {};
        var _iterator = (0, _createForOfIteratorHelper2["default"])(this._handlers), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var handler = _step.value;
                if (handler.kind === 'scalar') {
                    var newValue = handler.handle(field, this._recordSourceProxy.get(dataID), args, this._recordSourceProxy);
                    if (newValue !== undefined) {
                        return newValue;
                    }
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        this._handleMissing();
    };
    _proto._handleMissingLinkField = function _handleMissingLinkField(field, dataID) {
        var args = field.args != undefined ? getArgumentValues(field.args, this._variables) : {};
        var _iterator2 = (0, _createForOfIteratorHelper2["default"])(this._handlers), _step2;
        try {
            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                var handler = _step2.value;
                if (handler.kind === 'linked') {
                    var newValue = handler.handle(field, this._recordSourceProxy.get(dataID), args, this._recordSourceProxy);
                    if (newValue !== undefined && (newValue === null || this._mutator.getStatus(newValue) === EXISTENT)) {
                        return newValue;
                    }
                }
            }
        } catch (err) {
            _iterator2.e(err);
        } finally{
            _iterator2.f();
        }
        this._handleMissing();
    };
    _proto._handleMissingPluralLinkField = function _handleMissingPluralLinkField(field, dataID) {
        var _this = this;
        var args = field.args != undefined ? getArgumentValues(field.args, this._variables) : {};
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(this._handlers), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var handler = _step3.value;
                if (handler.kind === 'pluralLinked') {
                    var newValue = handler.handle(field, this._recordSourceProxy.get(dataID), args, this._recordSourceProxy);
                    if (newValue != null) {
                        var allItemsKnown = newValue.every(function(linkedID) {
                            return linkedID != null && _this._mutator.getStatus(linkedID) === EXISTENT;
                        });
                        if (allItemsKnown) {
                            return newValue;
                        }
                    } else if (newValue === null) {
                        return null;
                    }
                }
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
        this._handleMissing();
    };
    _proto._traverse = function _traverse(node, dataID) {
        var status = this._mutator.getStatus(dataID);
        if (status === UNKNOWN) {
            this._handleMissing();
        }
        if (status === EXISTENT) {
            var record = this._source.get(dataID);
            var invalidatedAt = RelayModernRecord.getInvalidationEpoch(record);
            if (invalidatedAt != null) {
                this._mostRecentlyInvalidatedAt = this._mostRecentlyInvalidatedAt != null ? Math.max(this._mostRecentlyInvalidatedAt, invalidatedAt) : invalidatedAt;
            }
            this._traverseSelections(node.selections, dataID);
        }
    };
    _proto._traverseSelections = function _traverseSelections(selections, dataID) {
        var _this2 = this;
        selections.forEach(function(selection) {
            switch(selection.kind){
                case 'ScalarField':
                    _this2._checkScalar(selection, dataID);
                    break;
                case 'LinkedField':
                    if (selection.plural) {
                        _this2._checkPluralLink(selection, dataID);
                    } else {
                        _this2._checkLink(selection, dataID);
                    }
                    break;
                case 'ActorChange':
                    _this2._checkActorChange(selection.linkedField, dataID);
                    break;
                case 'Condition':
                    var conditionValue = Boolean(_this2._getVariableValue(selection.condition));
                    if (conditionValue === selection.passingValue) {
                        _this2._traverseSelections(selection.selections, dataID);
                    }
                    break;
                case 'InlineFragment':
                    {
                        var _abstractKey = selection.abstractKey;
                        if (_abstractKey == null) {
                            var typeName = _this2._mutator.getType(dataID);
                            if (typeName === selection.type) {
                                _this2._traverseSelections(selection.selections, dataID);
                            }
                        } else {
                            var _recordType = _this2._mutator.getType(dataID);
                            !(_recordType != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : "TURBOPACK unreachable" : void 0;
                            var _typeID = generateTypeID(_recordType);
                            var _implementsInterface = _this2._mutator.getValue(_typeID, _abstractKey);
                            if (_implementsInterface === true) {
                                _this2._traverseSelections(selection.selections, dataID);
                            } else if (_implementsInterface == null) {
                                _this2._handleMissing();
                            }
                        }
                        break;
                    }
                case 'LinkedHandle':
                    {
                        var handleField = cloneRelayHandleSourceField(selection, selections, _this2._variables);
                        if (handleField.plural) {
                            _this2._checkPluralLink(handleField, dataID);
                        } else {
                            _this2._checkLink(handleField, dataID);
                        }
                        break;
                    }
                case 'ScalarHandle':
                    {
                        var _handleField = cloneRelayScalarHandleSourceField(selection, selections, _this2._variables);
                        _this2._checkScalar(_handleField, dataID);
                        break;
                    }
                case 'ModuleImport':
                    _this2._checkModuleImport(selection, dataID);
                    break;
                case 'Defer':
                case 'Stream':
                    _this2._traverseSelections(selection.selections, dataID);
                    break;
                case 'FragmentSpread':
                    var prevVariables = _this2._variables;
                    _this2._variables = getLocalVariables(_this2._variables, selection.fragment.argumentDefinitions, selection.args);
                    _this2._traverseSelections(selection.fragment.selections, dataID);
                    _this2._variables = prevVariables;
                    break;
                case 'ClientExtension':
                    var recordWasMissing = _this2._recordWasMissing;
                    _this2._traverseSelections(selection.selections, dataID);
                    _this2._recordWasMissing = recordWasMissing;
                    break;
                case 'TypeDiscriminator':
                    var abstractKey = selection.abstractKey;
                    var recordType = _this2._mutator.getType(dataID);
                    !(recordType != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : "TURBOPACK unreachable" : void 0;
                    var typeID = generateTypeID(recordType);
                    var implementsInterface = _this2._mutator.getValue(typeID, abstractKey);
                    if (implementsInterface == null) {
                        _this2._handleMissing();
                    }
                    break;
                case 'ClientComponent':
                    if (_this2._shouldProcessClientComponents === false) {
                        break;
                    }
                    _this2._traverseSelections(selection.fragment.selections, dataID);
                    break;
                case 'RelayResolver':
                case 'RelayLiveResolver':
                    if (!_this2._useExecTimeResolvers) {
                        _this2._checkResolver(selection, dataID);
                    }
                    break;
                case 'ClientEdgeToClientObject':
                    if (!_this2._useExecTimeResolvers) {
                        _this2._checkResolver(selection.backingField, dataID);
                    }
                    break;
                default:
                    selection;
                    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayAsyncLoader(): Unexpected ast kind `%s`.', selection.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
        });
    };
    _proto._checkResolver = function _checkResolver(resolver, dataID) {
        if (resolver.fragment) {
            this._traverseSelections([
                resolver.fragment
            ], dataID);
        }
    };
    _proto._checkModuleImport = function _checkModuleImport(moduleImport, dataID) {
        var operationLoader = this._operationLoader;
        !(operationLoader !== null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using `@module`.') : "TURBOPACK unreachable" : void 0;
        var operationKey = getModuleOperationKey(moduleImport.documentName);
        var operationReference = this._mutator.getValue(dataID, operationKey);
        if (operationReference == null) {
            if (operationReference === undefined) {
                this._handleMissing();
            }
            return;
        }
        var normalizationRootNode = operationLoader.get(operationReference);
        if (normalizationRootNode != null) {
            var operation = getOperation(normalizationRootNode);
            var prevVariables = this._variables;
            this._variables = getLocalVariables(this._variables, operation.argumentDefinitions, moduleImport.args);
            this._traverse(operation, dataID);
            this._variables = prevVariables;
        } else {
            this._handleMissing();
        }
    };
    _proto._checkScalar = function _checkScalar(field, dataID) {
        var storageKey = getStorageKey(field, this._variables);
        var fieldValue = this._mutator.getValue(dataID, storageKey);
        if (fieldValue === undefined) {
            fieldValue = this._handleMissingScalarField(field, dataID);
            if (fieldValue !== undefined) {
                this._mutator.setValue(dataID, storageKey, fieldValue);
            }
        }
    };
    _proto._checkLink = function _checkLink(field, dataID) {
        var storageKey = getStorageKey(field, this._variables);
        var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);
        if (linkedID === undefined) {
            linkedID = this._handleMissingLinkField(field, dataID);
            if (linkedID != null) {
                this._mutator.setLinkedRecordID(dataID, storageKey, linkedID);
            } else if (linkedID === null) {
                this._mutator.setValue(dataID, storageKey, null);
            }
        }
        if (linkedID != null) {
            this._traverse(field, linkedID);
        }
    };
    _proto._checkPluralLink = function _checkPluralLink(field, dataID) {
        var _this3 = this;
        var storageKey = getStorageKey(field, this._variables);
        var linkedIDs = this._mutator.getLinkedRecordIDs(dataID, storageKey);
        if (linkedIDs === undefined) {
            linkedIDs = this._handleMissingPluralLinkField(field, dataID);
            if (linkedIDs != null) {
                this._mutator.setLinkedRecordIDs(dataID, storageKey, linkedIDs);
            } else if (linkedIDs === null) {
                this._mutator.setValue(dataID, storageKey, null);
            }
        }
        if (linkedIDs) {
            linkedIDs.forEach(function(linkedID) {
                if (linkedID != null) {
                    _this3._traverse(field, linkedID);
                }
            });
        }
    };
    _proto._checkActorChange = function _checkActorChange(field, dataID) {
        var storageKey = getStorageKey(field, this._variables);
        var record = this._source.get(dataID);
        var tuple = record != null ? RelayModernRecord.getActorLinkedRecordID(record, storageKey) : record;
        if (tuple == null) {
            if (tuple === undefined) {
                this._handleMissing();
            }
        } else {
            var actorIdentifier = tuple[0], linkedID = tuple[1];
            var prevSource = this._source;
            var prevMutator = this._mutator;
            var prevRecordSourceProxy = this._recordSourceProxy;
            var _this$_getMutatorAndR2 = this._getMutatorAndRecordProxyForActor(actorIdentifier), mutator = _this$_getMutatorAndR2[0], recordSourceProxy = _this$_getMutatorAndR2[1];
            this._source = this._getSourceForActor(actorIdentifier);
            this._mutator = mutator;
            this._recordSourceProxy = recordSourceProxy;
            this._assignClientAbstractTypes(field);
            this._traverse(field, linkedID);
            this._source = prevSource;
            this._mutator = prevMutator;
            this._recordSourceProxy = prevRecordSourceProxy;
        }
    };
    _proto._assignClientAbstractTypes = function _assignClientAbstractTypes(node) {
        var clientAbstractTypes = node.clientAbstractTypes;
        if (clientAbstractTypes != null) {
            for(var _i = 0, _Object$keys = Object.keys(clientAbstractTypes); _i < _Object$keys.length; _i++){
                var abstractType = _Object$keys[_i];
                var _iterator4 = (0, _createForOfIteratorHelper2["default"])(clientAbstractTypes[abstractType]), _step4;
                try {
                    for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                        var concreteType = _step4.value;
                        var typeID = generateTypeID(concreteType);
                        if (this._source.get(typeID) == null) {
                            this._mutator.create(typeID, TYPE_SCHEMA_TYPE);
                        }
                        if (this._mutator.getValue(typeID, abstractType) == null) {
                            this._mutator.setValue(typeID, abstractType, true);
                        }
                    }
                } catch (err) {
                    _iterator4.e(err);
                } finally{
                    _iterator4.f();
                }
            }
        }
    };
    return DataChecker;
}();
module.exports = {
    check: check
};
}),
"[project]/node_modules/relay-runtime/lib/util/shallowFreeze.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function shallowFreeze(value) {
    if (typeof value === 'object' && value != null && (Array.isArray(value) || value.constructor === Object)) {
        Object.freeze(value);
    }
};
}),
"[project]/node_modules/relay-runtime/lib/store/live-resolvers/getOutputTypeRecordIDs.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS = _require.RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function getOutputTypeRecordIDs(record) {
    var maybeOutputTypeRecordIDs = RelayModernRecord.getValue(record, RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS);
    if (maybeOutputTypeRecordIDs == null) {
        return null;
    }
    !(maybeOutputTypeRecordIDs instanceof Set) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'getOutputTypeRecordIDs: Expected the `%s` field on record `%s` to be of type Set. Instead, it is a %s.', RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS, typeof maybeOutputTypeRecordIDs) : "TURBOPACK unreachable" : void 0;
    return maybeOutputTypeRecordIDs;
}
module.exports = getOutputTypeRecordIDs;
}),
"[project]/node_modules/relay-runtime/lib/store/live-resolvers/isLiveStateValue.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function isLiveStateValue(v) {
    return v != null && typeof v === 'object' && typeof v.read === 'function' && typeof v.subscribe === 'function';
}
module.exports = isLiveStateValue;
}),
"[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverCache.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var recycleNodesInto = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/recycleNodesInto.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-ssr] (ecmascript)"), RELAY_LIVE_RESOLVER = _require.RELAY_LIVE_RESOLVER;
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-ssr] (ecmascript)");
var shallowFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/shallowFreeze.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-ssr] (ecmascript)"), generateClientID = _require2.generateClientID, generateClientObjectClientID = _require2.generateClientObjectClientID;
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-ssr] (ecmascript)"), createNormalizationSelector = _require3.createNormalizationSelector;
var RelayRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-ssr] (ecmascript)");
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayResponseNormalizer.js [app-ssr] (ecmascript)"), normalize = _require4.normalize;
var _require5 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), RELAY_RESOLVER_ERROR_KEY = _require5.RELAY_RESOLVER_ERROR_KEY, RELAY_RESOLVER_INVALIDATION_KEY = _require5.RELAY_RESOLVER_INVALIDATION_KEY, RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS = _require5.RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS, RELAY_RESOLVER_SNAPSHOT_KEY = _require5.RELAY_RESOLVER_SNAPSHOT_KEY, RELAY_RESOLVER_VALUE_KEY = _require5.RELAY_RESOLVER_VALUE_KEY, getReadTimeResolverStorageKey = _require5.getReadTimeResolverStorageKey, getStorageKey = _require5.getStorageKey;
var getOutputTypeRecordIDs = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/getOutputTypeRecordIDs.js [app-ssr] (ecmascript)");
var isLiveStateValue = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/isLiveStateValue.js [app-ssr] (ecmascript)");
var _require6 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverSuspenseSentinel.js [app-ssr] (ecmascript)"), isSuspenseSentinel = _require6.isSuspenseSentinel;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
var RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY = '__resolverLiveStateSubscription';
var RELAY_RESOLVER_LIVE_STATE_VALUE = '__resolverLiveStateValue';
var RELAY_RESOLVER_LIVE_STATE_DIRTY = '__resolverLiveStateDirty';
var RELAY_RESOLVER_RECORD_TYPENAME = '__RELAY_RESOLVER__';
var MODEL_PROPERTY_NAME = '__relay_model_instance';
function addDependencyEdge(edges, from, to) {
    var set = edges.get(from);
    if (!set) {
        set = new Set();
        edges.set(from, set);
    }
    set.add(to);
}
var LiveResolverCache = /*#__PURE__*/ function() {
    function LiveResolverCache(getRecordSource, store) {
        this._resolverIDToRecordIDs = new Map();
        this._recordIDToResolverIDs = new Map();
        this._getRecordSource = getRecordSource;
        this._store = store;
        this._handlingBatch = false;
        this._liveResolverBatchRecordSource = null;
    }
    var _proto = LiveResolverCache.prototype;
    _proto.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(recordID, field, variables, evaluate, getDataForResolverFragment) {
        var recordSource = this._getRecordSource();
        var record = expectRecord(recordSource, recordID);
        var storageKey = getReadTimeResolverStorageKey(field, variables);
        var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
        var linkedRecord = linkedID == null ? null : recordSource.get(linkedID);
        var updatedDataIDs;
        if (linkedRecord == null || this._isInvalid(linkedRecord, getDataForResolverFragment)) {
            var _linkedID;
            if (linkedRecord != null) {
                maybeUnsubscribeFromLiveState(linkedRecord);
            }
            linkedID = (_linkedID = linkedID) !== null && _linkedID !== void 0 ? _linkedID : generateClientID(recordID, storageKey);
            linkedRecord = RelayModernRecord.create(linkedID, RELAY_RESOLVER_RECORD_TYPENAME);
            var evaluationResult = evaluate();
            RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_SNAPSHOT_KEY, evaluationResult.snapshot);
            RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_ERROR_KEY, evaluationResult.error);
            if (field.kind === RELAY_LIVE_RESOLVER) {
                if (evaluationResult.resolverResult != null) {
                    if ("TURBOPACK compile-time truthy", 1) {
                        !isLiveStateValue(evaluationResult.resolverResult) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected the @live Relay Resolver backing the field "%s" to return a value ' + 'that implements LiveState. Did you mean to remove the @live annotation on this resolver?', field.path) : "TURBOPACK unreachable" : void 0;
                    }
                    !(evaluationResult.error == null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Did not expect resolver to have both a value and an error.') : "TURBOPACK unreachable" : void 0;
                    var liveState = evaluationResult.resolverResult;
                    updatedDataIDs = this._setLiveStateValue(linkedRecord, linkedID, liveState, field, variables);
                } else {
                    if ("TURBOPACK compile-time truthy", 1) {
                        var _evaluationResult$sna;
                        !(evaluationResult.error != null || ((_evaluationResult$sna = evaluationResult.snapshot) === null || _evaluationResult$sna === void 0 ? void 0 : _evaluationResult$sna.isMissingData)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected the @live Relay Resolver backing the field "%s" to return a value ' + 'that implements LiveState interface. The result for this field is `%s`, we also did not detect any errors, ' + 'or missing data during resolver execution. Did you mean to remove the @live annotation on this ' + 'resolver, or was there unexpected early return in the function?', field.path, String(evaluationResult.resolverResult)) : "TURBOPACK unreachable" : void 0;
                    }
                }
            } else {
                if ("TURBOPACK compile-time truthy", 1) {
                    !!isLiveStateValue(evaluationResult.resolverResult) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unexpected LiveState value returned from the non-@live Relay Resolver backing the field "%s". Did you intend to add @live to this resolver?', field.path) : "TURBOPACK unreachable" : void 0;
                }
                updatedDataIDs = this._setResolverValue(linkedRecord, evaluationResult.resolverResult, field, variables);
            }
            recordSource.set(linkedID, linkedRecord);
            var currentRecord = expectRecord(recordSource, recordID);
            var nextRecord = RelayModernRecord.clone(currentRecord);
            RelayModernRecord.setLinkedRecordID(nextRecord, storageKey, linkedID);
            recordSource.set(recordID, nextRecord);
            if (field.fragment != null) {
                var _evaluationResult$sna2;
                var fragmentStorageKey = getStorageKey(field.fragment, variables);
                var resolverID = generateClientID(recordID, fragmentStorageKey);
                addDependencyEdge(this._resolverIDToRecordIDs, resolverID, linkedID);
                addDependencyEdge(this._recordIDToResolverIDs, recordID, resolverID);
                var seenRecordIds = (_evaluationResult$sna2 = evaluationResult.snapshot) === null || _evaluationResult$sna2 === void 0 ? void 0 : _evaluationResult$sna2.seenRecords;
                if (seenRecordIds != null) {
                    var _iterator = (0, _createForOfIteratorHelper2["default"])(seenRecordIds), _step;
                    try {
                        for(_iterator.s(); !(_step = _iterator.n()).done;){
                            var seenRecordID = _step.value;
                            addDependencyEdge(this._recordIDToResolverIDs, seenRecordID, resolverID);
                        }
                    } catch (err) {
                        _iterator.e(err);
                    } finally{
                        _iterator.f();
                    }
                }
            }
        } else if (field.kind === RELAY_LIVE_RESOLVER && RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY)) {
            var _linkedID2;
            linkedID = (_linkedID2 = linkedID) !== null && _linkedID2 !== void 0 ? _linkedID2 : generateClientID(recordID, storageKey);
            linkedRecord = RelayModernRecord.clone(linkedRecord);
            var _liveState = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_VALUE);
            if (!isLiveStateValue(_liveState)) {
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unexpected LiveState value returned from Relay Resolver internal field `RELAY_RESOLVER_LIVE_STATE_VALUE`. ' + 'It is likely a bug in Relay, or a corrupt state of the relay store state ' + 'Field Path `%s`. Record `%s`.', field.path, JSON.stringify(linkedRecord)) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
            updatedDataIDs = this._setLiveResolverValue(linkedRecord, _liveState, field, variables);
            RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY, false);
            recordSource.set(linkedID, linkedRecord);
        }
        var answer = this._getResolverValue(linkedRecord);
        var snapshot = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_SNAPSHOT_KEY);
        var error = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_ERROR_KEY);
        var suspenseID = null;
        if (isSuspenseSentinel(answer)) {
            var _linkedID3;
            suspenseID = (_linkedID3 = linkedID) !== null && _linkedID3 !== void 0 ? _linkedID3 : generateClientID(recordID, storageKey);
        }
        return [
            answer,
            linkedID,
            error,
            snapshot,
            suspenseID,
            updatedDataIDs
        ];
    };
    _proto.getLiveResolverPromise = function getLiveResolverPromise(liveStateID) {
        var recordSource = this._getRecordSource();
        var liveStateRecord = recordSource.get(liveStateID);
        !(liveStateRecord != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected to find record for live resolver.') : "TURBOPACK unreachable" : void 0;
        var liveState = RelayModernRecord.getValue(liveStateRecord, RELAY_RESOLVER_LIVE_STATE_VALUE);
        return new Promise(function(resolve) {
            var unsubscribe = liveState.subscribe(function() {
                unsubscribe();
                resolve();
            });
        });
    };
    _proto._setLiveStateValue = function _setLiveStateValue(linkedRecord, linkedID, liveState, field, variables) {
        var handler = this._makeLiveStateHandler(linkedID);
        var unsubscribe = liveState.subscribe(handler);
        RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_VALUE, liveState);
        var updatedDataIDs = this._setLiveResolverValue(linkedRecord, liveState, field, variables);
        RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY, false);
        RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY, unsubscribe);
        return updatedDataIDs;
    };
    _proto._makeLiveStateHandler = function _makeLiveStateHandler(linkedID) {
        var _this = this;
        return function() {
            var currentSource = _this._getRecordSource();
            var currentRecord = currentSource.get(linkedID);
            if (!currentRecord) {
                return;
            }
            if (!RelayModernRecord.hasValue(currentRecord, RELAY_RESOLVER_LIVE_STATE_VALUE)) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Unexpected callback for a incomplete live resolver record (__id: `%s`). The record has missing live state value. ' + 'This is a no-op and indicates a memory leak, and possible bug in Relay Live Resolvers. ' + 'Possible cause: The original record was GC-ed, or was created with the optimistic record source.' + ' Record details: `%s`.', linkedID, JSON.stringify(currentRecord)) : "TURBOPACK unreachable";
                return;
            }
            var nextRecord = RelayModernRecord.clone(currentRecord);
            RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY, true);
            _this._setLiveResolverUpdate(linkedID, nextRecord);
        };
    };
    _proto._setLiveResolverUpdate = function _setLiveResolverUpdate(linkedId, record) {
        if (this._handlingBatch) {
            if (this._liveResolverBatchRecordSource == null) {
                this._liveResolverBatchRecordSource = RelayRecordSource.create();
            }
            this._liveResolverBatchRecordSource.set(linkedId, record);
        } else {
            var nextSource = RelayRecordSource.create();
            nextSource.set(linkedId, record);
            this._store.publish(nextSource);
            this._store.notify();
        }
    };
    _proto.batchLiveStateUpdates = function batchLiveStateUpdates(callback) {
        !!this._handlingBatch ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unexpected nested call to batchLiveStateUpdates.') : "TURBOPACK unreachable" : void 0;
        this._handlingBatch = true;
        try {
            callback();
        } finally{
            if (this._liveResolverBatchRecordSource != null) {
                this._store.publish(this._liveResolverBatchRecordSource);
                this._store.notify();
            }
            this._liveResolverBatchRecordSource = null;
            this._handlingBatch = false;
        }
    };
    _proto._setLiveResolverValue = function _setLiveResolverValue(resolverRecord, liveValue, field, variables) {
        var value = null;
        var resolverError = null;
        try {
            value = liveValue.read();
        } catch (e) {
            resolverError = e;
        }
        RelayModernRecord.setValue(resolverRecord, RELAY_RESOLVER_ERROR_KEY, resolverError);
        return this._setResolverValue(resolverRecord, value, field, variables);
    };
    _proto._setResolverValue = function _setResolverValue(resolverRecord, value, field, variables) {
        var normalizationInfo = field.normalizationInfo;
        var updatedDataIDs = null;
        if (value != null && normalizationInfo != null && !isSuspenseSentinel(value)) {
            var resolverValue;
            var prevOutputTypeRecordIDs = getOutputTypeRecordIDs(resolverRecord);
            var nextOutputTypeRecordIDs = new Set();
            var currentSource = this._getRecordSource();
            if (normalizationInfo.plural) {
                !Array.isArray(value) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '_setResolverValue: Expected array value for plural @outputType resolver.') : "TURBOPACK unreachable" : void 0;
                resolverValue = [];
                var nextSource = RelayRecordSource.create();
                for(var ii = 0; ii < value.length; ii++){
                    var currentValue = value[ii];
                    if (currentValue == null) {
                        continue;
                    }
                    !(typeof currentValue === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '_setResolverValue: Expected object value as the payload for the @outputType resolver.') : "TURBOPACK unreachable" : void 0;
                    var typename = getConcreteTypename(normalizationInfo, currentValue);
                    var outputTypeDataID = generateClientObjectClientID(typename, RelayModernRecord.getDataID(resolverRecord), ii);
                    var source = this._normalizeOutputTypeValue(outputTypeDataID, currentValue, variables, normalizationInfo, [
                        field.path,
                        String(ii)
                    ], typename);
                    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(source.getRecordIDs()), _step2;
                    try {
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                            var recordID = _step2.value;
                            nextSource.set(recordID, expectRecord(source, recordID));
                            nextOutputTypeRecordIDs.add(recordID);
                        }
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                    resolverValue.push(outputTypeDataID);
                }
                updatedDataIDs = updateCurrentSource(currentSource, nextSource, prevOutputTypeRecordIDs);
            } else {
                !(typeof value === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '_setResolverValue: Expected object value as the payload for the @outputType resolver.') : "TURBOPACK unreachable" : void 0;
                var _typename = getConcreteTypename(normalizationInfo, value);
                var _outputTypeDataID = generateClientObjectClientID(_typename, RelayModernRecord.getDataID(resolverRecord));
                var _nextSource = this._normalizeOutputTypeValue(_outputTypeDataID, value, variables, normalizationInfo, [
                    field.path
                ], _typename);
                var _iterator3 = (0, _createForOfIteratorHelper2["default"])(_nextSource.getRecordIDs()), _step3;
                try {
                    for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                        var _recordID = _step3.value;
                        nextOutputTypeRecordIDs.add(_recordID);
                    }
                } catch (err) {
                    _iterator3.e(err);
                } finally{
                    _iterator3.f();
                }
                resolverValue = _outputTypeDataID;
                updatedDataIDs = updateCurrentSource(currentSource, _nextSource, prevOutputTypeRecordIDs);
            }
            RelayModernRecord.setValue(resolverRecord, RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS, nextOutputTypeRecordIDs);
            shallowFreeze(resolverValue);
            RelayModernRecord.setValue(resolverRecord, RELAY_RESOLVER_VALUE_KEY, resolverValue);
        } else {
            shallowFreeze(value);
            RelayModernRecord.setValue(resolverRecord, RELAY_RESOLVER_VALUE_KEY, value);
        }
        return updatedDataIDs;
    };
    _proto.notifyUpdatedSubscribers = function notifyUpdatedSubscribers(updatedDataIDs) {
        this._store.__notifyUpdatedSubscribers(updatedDataIDs);
    };
    _proto._getResolverValue = function _getResolverValue(resolverRecord) {
        return RelayModernRecord.getValue(resolverRecord, RELAY_RESOLVER_VALUE_KEY);
    };
    _proto.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {
        var recordSource = this._getRecordSource();
        var visited = new Set();
        var recordsToVisit = Array.from(updatedDataIDs);
        while(recordsToVisit.length){
            var recordID = recordsToVisit.pop();
            visited.add(recordID);
            updatedDataIDs.add(recordID);
            var fragmentSet = this._recordIDToResolverIDs.get(recordID);
            if (fragmentSet == null) {
                continue;
            }
            var _iterator4 = (0, _createForOfIteratorHelper2["default"])(fragmentSet), _step4;
            try {
                for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                    var fragment = _step4.value;
                    if (!visited.has(fragment)) {
                        visited.add(fragment);
                        var recordSet = this._resolverIDToRecordIDs.get(fragment);
                        if (recordSet == null) {
                            continue;
                        }
                        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(recordSet), _step5;
                        try {
                            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                                var anotherRecordID = _step5.value;
                                markInvalidatedResolverRecord(anotherRecordID, recordSource);
                                if (!visited.has(anotherRecordID)) {
                                    visited.add(anotherRecordID);
                                    recordsToVisit.push(anotherRecordID);
                                }
                            }
                        } catch (err) {
                            _iterator5.e(err);
                        } finally{
                            _iterator5.f();
                        }
                    }
                }
            } catch (err) {
                _iterator4.e(err);
            } finally{
                _iterator4.f();
            }
        }
    };
    _proto._isInvalid = function _isInvalid(record, getDataForResolverFragment) {
        if (!RelayModernRecord.getValue(record, RELAY_RESOLVER_INVALIDATION_KEY)) {
            return false;
        }
        var snapshot = RelayModernRecord.getValue(record, RELAY_RESOLVER_SNAPSHOT_KEY);
        var originalInputs = snapshot === null || snapshot === void 0 ? void 0 : snapshot.data;
        var readerSelector = snapshot === null || snapshot === void 0 ? void 0 : snapshot.selector;
        if (originalInputs == null || readerSelector == null) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Expected previous inputs and reader selector on resolver record with ID %s, but they were missing.', RelayModernRecord.getDataID(record)) : "TURBOPACK unreachable";
            return true;
        }
        var _getDataForResolverFr = getDataForResolverFragment(readerSelector), latestValues = _getDataForResolverFr.data;
        var recycled = recycleNodesInto(originalInputs, latestValues);
        if (recycled !== originalInputs) {
            return true;
        }
        if (RelayFeatureFlags.MARK_RESOLVER_VALUES_AS_CLEAN_AFTER_FRAGMENT_REREAD) {
            var nextRecord = RelayModernRecord.clone(record);
            RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, false);
            var recordSource = this._getRecordSource();
            recordSource.set(RelayModernRecord.getDataID(record), nextRecord);
        }
        return false;
    };
    _proto._normalizeOutputTypeValue = function _normalizeOutputTypeValue(outputTypeDataID, value, variables, normalizationInfo, fieldPath, typename) {
        var source = RelayRecordSource.create();
        switch(normalizationInfo.kind){
            case 'OutputType':
                {
                    var record = RelayModernRecord.create(outputTypeDataID, typename);
                    source.set(outputTypeDataID, record);
                    var selector = createNormalizationSelector(normalizationInfo.normalizationNode, outputTypeDataID, variables);
                    var useExecTimeResolvers = false;
                    var normalizationOptions = this._store.__getNormalizationOptions(fieldPath);
                    return normalize(source, selector, value, normalizationOptions, undefined, useExecTimeResolvers).source;
                }
            case 'WeakModel':
                {
                    var _record = RelayModernRecord.create(outputTypeDataID, typename);
                    RelayModernRecord.setValue(_record, MODEL_PROPERTY_NAME, value);
                    source.set(outputTypeDataID, _record);
                    return source;
                }
            default:
                normalizationInfo.kind;
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'LiveResolverCache: Unexpected normalization info kind `%s`.', normalizationInfo.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
    };
    _proto.ensureClientRecord = function ensureClientRecord(id, typeName) {
        var key = generateClientObjectClientID(typeName, id);
        var recordSource = this._getRecordSource();
        if (!recordSource.has(key)) {
            var newRecord = RelayModernRecord.create(key, typeName);
            RelayModernRecord.setValue(newRecord, 'id', id);
            recordSource.set(key, newRecord);
        }
        return key;
    };
    _proto.unsubscribeFromLiveResolverRecords = function unsubscribeFromLiveResolverRecords(invalidatedDataIDs) {
        return unsubscribeFromLiveResolverRecordsImpl(this._getRecordSource(), invalidatedDataIDs);
    };
    _proto.invalidateResolverRecords = function invalidateResolverRecords(invalidatedDataIDs) {
        if (invalidatedDataIDs.size === 0) {
            return;
        }
        var _iterator6 = (0, _createForOfIteratorHelper2["default"])(invalidatedDataIDs), _step6;
        try {
            for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){
                var dataID = _step6.value;
                var record = this._getRecordSource().get(dataID);
                if (record != null && isResolverRecord(record)) {
                    this._getRecordSource()["delete"](dataID);
                }
            }
        } catch (err) {
            _iterator6.e(err);
        } finally{
            _iterator6.f();
        }
    };
    return LiveResolverCache;
}();
function updateCurrentSource(currentSource, nextSource, prevOutputTypeRecordIDs) {
    var updatedDataIDs = new Set();
    if (prevOutputTypeRecordIDs != null) {
        var _iterator7 = (0, _createForOfIteratorHelper2["default"])(prevOutputTypeRecordIDs), _step7;
        try {
            for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){
                var recordID = _step7.value;
                if (!nextSource.has(recordID)) {
                    updatedDataIDs.add(recordID);
                    currentSource.remove(recordID);
                }
            }
        } catch (err) {
            _iterator7.e(err);
        } finally{
            _iterator7.f();
        }
    }
    var _iterator8 = (0, _createForOfIteratorHelper2["default"])(nextSource.getRecordIDs()), _step8;
    try {
        for(_iterator8.s(); !(_step8 = _iterator8.n()).done;){
            var _recordID2 = _step8.value;
            var nextRecord = expectRecord(nextSource, _recordID2);
            if (currentSource.has(_recordID2)) {
                var currentRecord = expectRecord(currentSource, _recordID2);
                var updatedRecord = RelayModernRecord.update(currentRecord, nextRecord);
                if (updatedRecord !== currentRecord) {
                    updatedDataIDs.add(_recordID2);
                    currentSource.set(_recordID2, updatedRecord);
                    markInvalidatedLinkedResolverRecords(currentRecord, currentSource);
                }
            } else {
                currentSource.set(_recordID2, nextRecord);
            }
        }
    } catch (err) {
        _iterator8.e(err);
    } finally{
        _iterator8.f();
    }
    return updatedDataIDs;
}
function getAllLinkedRecordIds(record) {
    var linkedRecordIDs = new Set();
    RelayModernRecord.getFields(record).forEach(function(field) {
        if (RelayModernRecord.hasLinkedRecordID(record, field)) {
            var linkedRecordID = RelayModernRecord.getLinkedRecordID(record, field);
            if (linkedRecordID != null) {
                linkedRecordIDs.add(linkedRecordID);
            }
        } else if (RelayModernRecord.hasLinkedRecordIDs(record, field)) {
            var _RelayModernRecord$ge;
            (_RelayModernRecord$ge = RelayModernRecord.getLinkedRecordIDs(record, field)) === null || _RelayModernRecord$ge === void 0 ? void 0 : _RelayModernRecord$ge.forEach(function(linkedRecordID) {
                if (linkedRecordID != null) {
                    linkedRecordIDs.add(linkedRecordID);
                }
            });
        }
    });
    return linkedRecordIDs;
}
function markInvalidatedResolverRecord(dataID, recordSource) {
    var record = recordSource.get(dataID);
    if (!record) {
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Expected a resolver record with ID %s, but it was missing.', dataID) : "TURBOPACK unreachable";
        return;
    }
    var nextRecord = RelayModernRecord.clone(record);
    RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, true);
    recordSource.set(dataID, nextRecord);
}
function markInvalidatedLinkedResolverRecords(record, recordSource) {
    var currentLinkedDataIDs = getAllLinkedRecordIds(record);
    var _iterator9 = (0, _createForOfIteratorHelper2["default"])(currentLinkedDataIDs), _step9;
    try {
        for(_iterator9.s(); !(_step9 = _iterator9.n()).done;){
            var recordID = _step9.value;
            var _record2 = recordSource.get(recordID);
            if (_record2 != null && isResolverRecord(_record2)) {
                markInvalidatedResolverRecord(recordID, recordSource);
            }
        }
    } catch (err) {
        _iterator9.e(err);
    } finally{
        _iterator9.f();
    }
}
function unsubscribeFromLiveResolverRecordsImpl(recordSource, invalidatedDataIDs) {
    if (invalidatedDataIDs.size === 0) {
        return;
    }
    var _iterator10 = (0, _createForOfIteratorHelper2["default"])(invalidatedDataIDs), _step10;
    try {
        for(_iterator10.s(); !(_step10 = _iterator10.n()).done;){
            var dataID = _step10.value;
            var record = recordSource.get(dataID);
            if (record != null && isResolverRecord(record)) {
                maybeUnsubscribeFromLiveState(record);
            }
        }
    } catch (err) {
        _iterator10.e(err);
    } finally{
        _iterator10.f();
    }
}
function isResolverRecord(record) {
    return RelayModernRecord.getType(record) === RELAY_RESOLVER_RECORD_TYPENAME;
}
function maybeUnsubscribeFromLiveState(linkedRecord) {
    var previousUnsubscribe = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY);
    if (previousUnsubscribe != null) {
        previousUnsubscribe();
    }
}
function expectRecord(source, recordID) {
    var record = source.get(recordID);
    !(record != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected a record with ID `%s` to exist in the record source.', recordID) : "TURBOPACK unreachable" : void 0;
    return record;
}
function getUpdatedDataIDs(updatedRecords) {
    return updatedRecords;
}
function getConcreteTypename(normalizationInfo, currentValue) {
    var _normalizationInfo$co;
    var typename = (_normalizationInfo$co = normalizationInfo.concreteType) !== null && _normalizationInfo$co !== void 0 ? _normalizationInfo$co : currentValue.__typename;
    !(typename != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'normalizationInfo.concreteType should not be null, or the value returned from the resolver should include a __typename field, ' + 'or the resolver should have a flow error. If not, this indicates a bug in Relay.') : "TURBOPACK unreachable" : void 0;
    return typename;
}
module.exports = {
    LiveResolverCache: LiveResolverCache,
    getUpdatedDataIDs: getUpdatedDataIDs,
    RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY: RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayOptimisticRecordSource.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)");
var RelayRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var UNPUBLISH_RECORD_SENTINEL = RelayModernRecord.fromObject(Object.freeze({
    __UNPUBLISH_RECORD_SENTINEL: true
}));
var RelayOptimisticRecordSource = /*#__PURE__*/ function() {
    function RelayOptimisticRecordSource(base) {
        this._base = base;
        this._sink = RelayRecordSource.create();
    }
    var _proto = RelayOptimisticRecordSource.prototype;
    _proto.has = function has(dataID) {
        if (this._sink.has(dataID)) {
            var sinkRecord = this._sink.get(dataID);
            return sinkRecord !== UNPUBLISH_RECORD_SENTINEL;
        } else {
            return this._base.has(dataID);
        }
    };
    _proto.get = function get(dataID) {
        if (this._sink.has(dataID)) {
            var sinkRecord = this._sink.get(dataID);
            if (sinkRecord === UNPUBLISH_RECORD_SENTINEL) {
                return undefined;
            } else {
                return sinkRecord;
            }
        } else {
            return this._base.get(dataID);
        }
    };
    _proto.getStatus = function getStatus(dataID) {
        var record = this.get(dataID);
        if (record === undefined) {
            return 'UNKNOWN';
        } else if (record === null) {
            return 'NONEXISTENT';
        } else {
            return 'EXISTENT';
        }
    };
    _proto.clear = function clear() {
        this._base = RelayRecordSource.create();
        this._sink.clear();
    };
    _proto["delete"] = function _delete(dataID) {
        this._sink["delete"](dataID);
    };
    _proto.remove = function remove(dataID) {
        this._sink.set(dataID, UNPUBLISH_RECORD_SENTINEL);
    };
    _proto.set = function set(dataID, record) {
        this._sink.set(dataID, record);
    };
    _proto.getRecordIDs = function getRecordIDs() {
        return Object.keys(this.toJSON());
    };
    _proto.size = function size() {
        return Object.keys(this.toJSON()).length;
    };
    _proto.toJSON = function toJSON() {
        var _this = this;
        var merged = (0, _objectSpread2["default"])({}, this._base.toJSON());
        this._sink.getRecordIDs().forEach(function(dataID) {
            var record = _this.get(dataID);
            if (record === undefined) {
                delete merged[dataID];
            } else {
                merged[dataID] = RelayModernRecord.toJSON(record);
            }
        });
        return merged;
    };
    _proto.getOptimisticRecordIDs = function getOptimisticRecordIDs() {
        return new Set(this._sink.getRecordIDs());
    };
    return RelayOptimisticRecordSource;
}();
function create(base) {
    return new RelayOptimisticRecordSource(base);
}
function getOptimisticRecordIDs(source) {
    !(source instanceof RelayOptimisticRecordSource) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'getOptimisticRecordIDs: Instance of RelayOptimisticRecordSource is expected') : "TURBOPACK unreachable" : void 0;
    return source.getOptimisticRecordIDs();
}
module.exports = {
    create: create,
    getOptimisticRecordIDs: getOptimisticRecordIDs
};
}),
"[project]/node_modules/relay-runtime/lib/store/ResolverCache.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-ssr] (ecmascript)"), RELAY_LIVE_RESOLVER = _require.RELAY_LIVE_RESOLVER;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var NoopResolverCache = /*#__PURE__*/ function() {
    function NoopResolverCache() {}
    var _proto = NoopResolverCache.prototype;
    _proto.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(recordID, field, variables, evaluate, getDataForResolverFragment) {
        !(field.kind !== RELAY_LIVE_RESOLVER) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'This store does not support Live Resolvers') : "TURBOPACK unreachable" : void 0;
        var _evaluate = evaluate(), resolverResult = _evaluate.resolverResult, snapshot = _evaluate.snapshot, error = _evaluate.error;
        return [
            resolverResult,
            undefined,
            error,
            snapshot,
            undefined,
            undefined
        ];
    };
    _proto.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {};
    _proto.ensureClientRecord = function ensureClientRecord(id, typeName) {
        ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Client Edges to Client Objects are not supported in this version of Relay Store') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
    };
    _proto.notifyUpdatedSubscribers = function notifyUpdatedSubscribers(updatedDataIDs) {};
    return NoopResolverCache;
}();
module.exports = {
    NoopResolverCache: NoopResolverCache
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayReader.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js [app-ssr] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-ssr] (ecmascript)"));
var _excluded = [
    "message"
];
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverSuspenseSentinel.js [app-ssr] (ecmascript)"), isSuspenseSentinel = _require.isSuspenseSentinel;
var RelayConcreteVariables = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-ssr] (ecmascript)");
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), CLIENT_EDGE_TRAVERSAL_PATH = _require2.CLIENT_EDGE_TRAVERSAL_PATH, FRAGMENT_OWNER_KEY = _require2.FRAGMENT_OWNER_KEY, FRAGMENT_PROP_NAME_KEY = _require2.FRAGMENT_PROP_NAME_KEY, FRAGMENTS_KEY = _require2.FRAGMENTS_KEY, ID_KEY = _require2.ID_KEY, MODULE_COMPONENT_KEY = _require2.MODULE_COMPONENT_KEY, ROOT_ID = _require2.ROOT_ID, getArgumentValues = _require2.getArgumentValues, getModuleComponentKey = _require2.getModuleComponentKey, getStorageKey = _require2.getStorageKey;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ResolverCache.js [app-ssr] (ecmascript)"), NoopResolverCache = _require3.NoopResolverCache;
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ResolverFragments.js [app-ssr] (ecmascript)"), RESOLVER_FRAGMENT_ERRORED_SENTINEL = _require4.RESOLVER_FRAGMENT_ERRORED_SENTINEL, withResolverContext = _require4.withResolverContext;
var _require5 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/TypeID.js [app-ssr] (ecmascript)"), generateTypeID = _require5.generateTypeID;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function read(recordSource, selector, resolverCache, resolverContext) {
    var reader = new RelayReader(recordSource, selector, resolverCache !== null && resolverCache !== void 0 ? resolverCache : new NoopResolverCache(), resolverContext);
    return reader.read();
}
var RelayReader = /*#__PURE__*/ function() {
    function RelayReader(recordSource, selector, resolverCache, resolverContext) {
        var _selector$clientEdgeT, _ref, _this$_owner$node$ope, _this$_owner$node$ope2;
        this._clientEdgeTraversalPath = (_selector$clientEdgeT = selector.clientEdgeTraversalPath) !== null && _selector$clientEdgeT !== void 0 && _selector$clientEdgeT.length ? (0, _toConsumableArray2["default"])(selector.clientEdgeTraversalPath) : [];
        this._missingClientEdges = [];
        this._missingLiveResolverFields = [];
        this._isMissingData = false;
        this._isWithinUnmatchedTypeRefinement = false;
        this._fieldErrors = null;
        this._owner = selector.owner;
        this._useExecTimeResolvers = (_ref = (_this$_owner$node$ope = this._owner.node.operation.use_exec_time_resolvers) !== null && _this$_owner$node$ope !== void 0 ? _this$_owner$node$ope : ((_this$_owner$node$ope2 = this._owner.node.operation.exec_time_resolvers_enabled_provider) === null || _this$_owner$node$ope2 === void 0 ? void 0 : _this$_owner$node$ope2.get()) === true) !== null && _ref !== void 0 ? _ref : false;
        this._recordSource = recordSource;
        this._seenRecords = new Set();
        this._selector = selector;
        this._variables = selector.variables;
        this._resolverCache = resolverCache;
        this._fragmentName = selector.node.name;
        this._updatedDataIDs = new Set();
        this._resolverContext = resolverContext;
    }
    var _proto = RelayReader.prototype;
    _proto.read = function read() {
        var _this$_selector$node$;
        var _this$_selector = this._selector, node = _this$_selector.node, dataID = _this$_selector.dataID, isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;
        var abstractKey = node.abstractKey;
        var record = this._recordSource.get(dataID);
        var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement;
        if (isDataExpectedToBePresent && abstractKey == null && record != null) {
            if (!this._recordMatchesTypeCondition(record, node.type)) {
                isDataExpectedToBePresent = false;
            }
        }
        if (isDataExpectedToBePresent && abstractKey != null && record != null) {
            var implementsInterface = this._implementsInterface(record, abstractKey);
            if (implementsInterface === false) {
                isDataExpectedToBePresent = false;
            }
        }
        this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;
        var data = this._traverse(node, dataID, null);
        var catchTo = (_this$_selector$node$ = this._selector.node.metadata) === null || _this$_selector$node$ === void 0 ? void 0 : _this$_selector$node$.catchTo;
        if (catchTo != null) {
            data = this._catchErrors(data, catchTo, null);
        }
        if (this._updatedDataIDs.size > 0) {
            this._resolverCache.notifyUpdatedSubscribers(this._updatedDataIDs);
            this._updatedDataIDs.clear();
        }
        return {
            data: data,
            isMissingData: this._isMissingData && isDataExpectedToBePresent,
            missingClientEdges: this._missingClientEdges.length ? this._missingClientEdges : null,
            missingLiveResolverFields: this._missingLiveResolverFields,
            seenRecords: this._seenRecords,
            selector: this._selector,
            fieldErrors: this._fieldErrors
        };
    };
    _proto._maybeAddFieldErrors = function _maybeAddFieldErrors(record, storageKey) {
        var errors = RelayModernRecord.getErrors(record, storageKey);
        if (errors == null) {
            return;
        }
        var owner = this._fragmentName;
        if (this._fieldErrors == null) {
            this._fieldErrors = [];
        }
        for(var i = 0; i < errors.length; i++){
            var _error$path, _this$_selector$node$2, _this$_selector$node$3;
            var error = errors[i];
            this._fieldErrors.push({
                kind: 'relay_field_payload.error',
                owner: owner,
                fieldPath: ((_error$path = error.path) !== null && _error$path !== void 0 ? _error$path : []).join('.'),
                error: error,
                shouldThrow: (_this$_selector$node$2 = (_this$_selector$node$3 = this._selector.node.metadata) === null || _this$_selector$node$3 === void 0 ? void 0 : _this$_selector$node$3.throwOnFieldError) !== null && _this$_selector$node$2 !== void 0 ? _this$_selector$node$2 : false,
                handled: false,
                uiContext: undefined
            });
        }
    };
    _proto._markDataAsMissing = function _markDataAsMissing(fieldName) {
        var _this$_selector$node$4, _this$_selector$node$5;
        if (this._isWithinUnmatchedTypeRefinement) {
            return;
        }
        if (this._fieldErrors == null) {
            this._fieldErrors = [];
        }
        var owner = this._fragmentName;
        this._fieldErrors.push(((_this$_selector$node$4 = (_this$_selector$node$5 = this._selector.node.metadata) === null || _this$_selector$node$5 === void 0 ? void 0 : _this$_selector$node$5.throwOnFieldError) !== null && _this$_selector$node$4 !== void 0 ? _this$_selector$node$4 : false) ? {
            kind: 'missing_expected_data.throw',
            owner: owner,
            fieldPath: fieldName,
            handled: false,
            uiContext: undefined
        } : {
            kind: 'missing_expected_data.log',
            owner: owner,
            fieldPath: fieldName,
            uiContext: undefined
        });
        this._isMissingData = true;
        if (this._clientEdgeTraversalPath.length) {
            var top = this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1];
            if (top !== null) {
                this._missingClientEdges.push({
                    request: top.readerClientEdge.operation,
                    clientEdgeDestinationID: top.clientEdgeDestinationID
                });
            }
        }
    };
    _proto._traverse = function _traverse(node, dataID, prevData) {
        var record = this._recordSource.get(dataID);
        this._seenRecords.add(dataID);
        if (record == null) {
            if (record === undefined) {
                this._markDataAsMissing('<record>');
            }
            return record;
        }
        var data = prevData || {};
        var hadRequiredData = this._traverseSelections(node.selections, record, data);
        return hadRequiredData ? data : null;
    };
    _proto._getVariableValue = function _getVariableValue(name) {
        !this._variables.hasOwnProperty(name) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Undefined variable `%s`.', name) : "TURBOPACK unreachable" : void 0;
        return this._variables[name];
    };
    _proto._maybeReportUnexpectedNull = function _maybeReportUnexpectedNull(selection) {
        if (selection.action === 'NONE') {
            return;
        }
        var owner = this._fragmentName;
        if (this._fieldErrors == null) {
            this._fieldErrors = [];
        }
        var fieldName;
        if (selection.field.linkedField != null) {
            var _selection$field$link;
            fieldName = (_selection$field$link = selection.field.linkedField.alias) !== null && _selection$field$link !== void 0 ? _selection$field$link : selection.field.linkedField.name;
        } else {
            var _selection$field$alia;
            fieldName = (_selection$field$alia = selection.field.alias) !== null && _selection$field$alia !== void 0 ? _selection$field$alia : selection.field.name;
        }
        switch(selection.action){
            case 'THROW':
                this._fieldErrors.push({
                    kind: 'missing_required_field.throw',
                    fieldPath: fieldName,
                    owner: owner,
                    handled: false,
                    uiContext: undefined
                });
                return;
            case 'LOG':
                this._fieldErrors.push({
                    kind: 'missing_required_field.log',
                    fieldPath: fieldName,
                    owner: owner,
                    uiContext: undefined
                });
                return;
            default:
                selection.action;
        }
    };
    _proto._handleRequiredFieldValue = function _handleRequiredFieldValue(selection, value) {
        if (value == null) {
            this._maybeReportUnexpectedNull(selection);
            return false;
        }
        return true;
    };
    _proto._catchErrors = function _catchErrors(_value, to, previousResponseFields) {
        var value = _value;
        switch(to){
            case 'RESULT':
                value = this._asResult(_value);
                break;
            case 'NULL':
                if (this._fieldErrors != null && this._fieldErrors.length > 0) {
                    value = null;
                }
                break;
            default:
                to;
        }
        var childrenFieldErrors = this._fieldErrors;
        this._fieldErrors = previousResponseFields;
        if (childrenFieldErrors != null) {
            if (this._fieldErrors == null) {
                this._fieldErrors = [];
            }
            for(var i = 0; i < childrenFieldErrors.length; i++){
                this._fieldErrors.push(markFieldErrorHasHandled(childrenFieldErrors[i]));
            }
        }
        return value;
    };
    _proto._asResult = function _asResult(value) {
        if (this._fieldErrors == null || this._fieldErrors.length === 0) {
            return {
                ok: true,
                value: value
            };
        }
        var errors = this._fieldErrors.map(function(error) {
            switch(error.kind){
                case 'relay_field_payload.error':
                    var _error$error = error.error, message = _error$error.message, displayError = (0, _objectWithoutPropertiesLoose2["default"])(_error$error, _excluded);
                    return displayError;
                case 'missing_expected_data.throw':
                case 'missing_expected_data.log':
                    return {
                        path: error.fieldPath.split('.')
                    };
                case 'relay_resolver.error':
                    return {
                        message: "Relay: Error in resolver for field at ".concat(error.fieldPath, " in ").concat(error.owner)
                    };
                case 'missing_required_field.throw':
                    return {
                        message: "Relay: Missing @required value at path '".concat(error.fieldPath, "' in '").concat(error.owner, "'.")
                    };
                case 'missing_required_field.log':
                    return null;
                default:
                    error.kind;
                    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unexpected error fieldError kind: %s', error.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
        }).filter(Boolean);
        return {
            ok: false,
            errors: errors
        };
    };
    _proto._traverseSelections = function _traverseSelections(selections, record, data) {
        for(var i = 0; i < selections.length; i++){
            var selection = selections[i];
            switch(selection.kind){
                case 'RequiredField':
                    var requiredFieldValue = this._readClientSideDirectiveField(selection, record, data);
                    if (!this._handleRequiredFieldValue(selection, requiredFieldValue)) {
                        return false;
                    }
                    break;
                case 'CatchField':
                    {
                        var _selection$field$back, _selection$field, _field$alias;
                        var previousResponseFields = this._fieldErrors;
                        this._fieldErrors = null;
                        var catchFieldValue = this._readClientSideDirectiveField(selection, record, data);
                        var field = (_selection$field$back = (_selection$field = selection.field) === null || _selection$field === void 0 ? void 0 : _selection$field.backingField) !== null && _selection$field$back !== void 0 ? _selection$field$back : selection.field;
                        var fieldName = (_field$alias = field === null || field === void 0 ? void 0 : field.alias) !== null && _field$alias !== void 0 ? _field$alias : field === null || field === void 0 ? void 0 : field.name;
                        !(fieldName != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, "Couldn't determine field name for this field. It might be a ReaderClientExtension - which is not yet supported.") : "TURBOPACK unreachable" : void 0;
                        data[fieldName] = this._catchErrors(catchFieldValue, selection.to, previousResponseFields);
                        break;
                    }
                case 'ScalarField':
                    this._readScalar(selection, record, data);
                    break;
                case 'LinkedField':
                    if (selection.plural) {
                        this._readPluralLink(selection, record, data);
                    } else {
                        this._readLink(selection, record, data);
                    }
                    break;
                case 'Condition':
                    var conditionValue = Boolean(this._getVariableValue(selection.condition));
                    if (conditionValue === selection.passingValue) {
                        var hasExpectedData = this._traverseSelections(selection.selections, record, data);
                        if (!hasExpectedData) {
                            return false;
                        }
                    }
                    break;
                case 'InlineFragment':
                    {
                        var _hasExpectedData = this._readInlineFragment(selection, record, data, false);
                        if (_hasExpectedData === false) {
                            return false;
                        }
                        break;
                    }
                case 'RelayLiveResolver':
                case 'RelayResolver':
                    {
                        if (this._useExecTimeResolvers) {
                            this._readScalar(selection, record, data);
                        } else {
                            this._readResolverField(selection, record, data);
                        }
                        break;
                    }
                case 'FragmentSpread':
                    this._createFragmentPointer(selection, record, data);
                    break;
                case 'AliasedInlineFragmentSpread':
                    {
                        this._readAliasedInlineFragment(selection, record, data);
                        break;
                    }
                case 'ModuleImport':
                    this._readModuleImport(selection, record, data);
                    break;
                case 'InlineDataFragmentSpread':
                    this._createInlineDataOrResolverFragmentPointer(selection, record, data);
                    break;
                case 'Defer':
                case 'ClientExtension':
                    {
                        var isMissingData = this._isMissingData;
                        var alreadyMissingClientEdges = this._missingClientEdges.length;
                        this._clientEdgeTraversalPath.push(null);
                        var _hasExpectedData2 = this._traverseSelections(selection.selections, record, data);
                        this._isMissingData = isMissingData || this._missingClientEdges.length > alreadyMissingClientEdges || this._missingLiveResolverFields.length > 0;
                        this._clientEdgeTraversalPath.pop();
                        if (!_hasExpectedData2) {
                            return false;
                        }
                        break;
                    }
                case 'Stream':
                    {
                        var _hasExpectedData3 = this._traverseSelections(selection.selections, record, data);
                        if (!_hasExpectedData3) {
                            return false;
                        }
                        break;
                    }
                case 'ActorChange':
                    this._readActorChange(selection, record, data);
                    break;
                case 'ClientEdgeToClientObject':
                case 'ClientEdgeToServerObject':
                    if (this._useExecTimeResolvers && (selection.backingField.kind === 'RelayResolver' || selection.backingField.kind === 'RelayLiveResolver')) {
                        var linkedField = selection.linkedField;
                        if (linkedField.plural) {
                            this._readPluralLink(linkedField, record, data);
                        } else {
                            this._readLink(linkedField, record, data);
                        }
                    } else {
                        this._readClientEdge(selection, record, data);
                    }
                    break;
                default:
                    selection;
                    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
        }
        return true;
    };
    _proto._readClientSideDirectiveField = function _readClientSideDirectiveField(selection, record, data) {
        switch(selection.field.kind){
            case 'ScalarField':
                return this._readScalar(selection.field, record, data);
            case 'LinkedField':
                if (selection.field.plural) {
                    return this._readPluralLink(selection.field, record, data);
                } else {
                    return this._readLink(selection.field, record, data);
                }
            case 'RelayResolver':
            case 'RelayLiveResolver':
                {
                    if (this._useExecTimeResolvers) {
                        return this._readScalar(selection.field, record, data);
                    } else {
                        return this._readResolverField(selection.field, record, data);
                    }
                }
            case 'ClientEdgeToClientObject':
            case 'ClientEdgeToServerObject':
                if (this._useExecTimeResolvers && (selection.field.backingField.kind === 'RelayResolver' || selection.field.backingField.kind === 'RelayLiveResolver')) {
                    var field = selection.field;
                    if (field.linkedField.plural) {
                        return this._readPluralLink(field.linkedField, record, data);
                    } else {
                        return this._readLink(field.linkedField, record, data);
                    }
                } else {
                    return this._readClientEdge(selection.field, record, data);
                }
            case 'AliasedInlineFragmentSpread':
                return this._readAliasedInlineFragment(selection.field, record, data);
            default:
                selection.field.kind;
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.field.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
    };
    _proto._readResolverField = function _readResolverField(field, record, data) {
        var _field$alias2;
        var parentRecordID = RelayModernRecord.getDataID(record);
        var prevErrors = this._fieldErrors;
        this._fieldErrors = null;
        var result = this._readResolverFieldImpl(field, parentRecordID);
        var fieldName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;
        this._prependPreviousErrors(prevErrors, fieldName);
        data[fieldName] = result;
        return result;
    };
    _proto._readResolverFieldImpl = function _readResolverFieldImpl(field, parentRecordID) {
        var _this = this;
        var fragment = field.fragment;
        var snapshot;
        var getDataForResolverFragment = function getDataForResolverFragment(singularReaderSelector) {
            if (snapshot != null) {
                return {
                    data: snapshot.data,
                    isMissingData: snapshot.isMissingData,
                    fieldErrors: snapshot.fieldErrors
                };
            }
            snapshot = read(_this._recordSource, singularReaderSelector, _this._resolverCache);
            return {
                data: snapshot.data,
                isMissingData: snapshot.isMissingData,
                fieldErrors: snapshot.fieldErrors
            };
        };
        var evaluate = function evaluate() {
            if (fragment != null) {
                var key = {
                    __id: parentRecordID,
                    __fragmentOwner: _this._owner,
                    __fragments: (0, _defineProperty2["default"])({}, fragment.name, fragment.args ? getArgumentValues(fragment.args, _this._variables) : {})
                };
                if (_this._clientEdgeTraversalPath.length > 0 && _this._clientEdgeTraversalPath[_this._clientEdgeTraversalPath.length - 1] !== null) {
                    key[CLIENT_EDGE_TRAVERSAL_PATH] = (0, _toConsumableArray2["default"])(_this._clientEdgeTraversalPath);
                }
                var resolverContext = {
                    getDataForResolverFragment: getDataForResolverFragment
                };
                return withResolverContext(resolverContext, function() {
                    var _getResolverValue = getResolverValue(field, _this._variables, key, _this._resolverContext), resolverResult = _getResolverValue[0], resolverError = _getResolverValue[1];
                    return {
                        resolverResult: resolverResult,
                        snapshot: snapshot,
                        error: resolverError
                    };
                });
            } else {
                var _getResolverValue2 = getResolverValue(field, _this._variables, null, _this._resolverContext), resolverResult = _getResolverValue2[0], _resolverError = _getResolverValue2[1];
                return {
                    resolverResult: resolverResult,
                    snapshot: undefined,
                    error: _resolverError
                };
            }
        };
        var _this$_resolverCache$ = this._resolverCache.readFromCacheOrEvaluate(parentRecordID, field, this._variables, evaluate, getDataForResolverFragment), result = _this$_resolverCache$[0], seenRecord = _this$_resolverCache$[1], resolverError = _this$_resolverCache$[2], cachedSnapshot = _this$_resolverCache$[3], suspenseID = _this$_resolverCache$[4], updatedDataIDs = _this$_resolverCache$[5];
        this._propagateResolverMetadata(field.path, cachedSnapshot, resolverError, seenRecord, suspenseID, updatedDataIDs);
        return result;
    };
    _proto._propagateResolverMetadata = function _propagateResolverMetadata(fieldPath, cachedSnapshot, resolverError, seenRecord, suspenseID, updatedDataIDs) {
        var _this2 = this;
        if (cachedSnapshot != null) {
            if (cachedSnapshot.missingClientEdges != null) {
                for(var i = 0; i < cachedSnapshot.missingClientEdges.length; i++){
                    var missing = cachedSnapshot.missingClientEdges[i];
                    this._missingClientEdges.push(missing);
                }
            }
            if (cachedSnapshot.missingLiveResolverFields != null) {
                this._isMissingData = this._isMissingData || cachedSnapshot.missingLiveResolverFields.length > 0;
                for(var _i = 0; _i < cachedSnapshot.missingLiveResolverFields.length; _i++){
                    var missingResolverField = cachedSnapshot.missingLiveResolverFields[_i];
                    this._missingLiveResolverFields.push(missingResolverField);
                }
            }
            if (cachedSnapshot.fieldErrors != null) {
                if (this._fieldErrors == null) {
                    this._fieldErrors = [];
                }
                for(var _i2 = 0; _i2 < cachedSnapshot.fieldErrors.length; _i2++){
                    var _this$_selector$node$6;
                    var error = cachedSnapshot.fieldErrors[_i2];
                    if (((_this$_selector$node$6 = this._selector.node.metadata) === null || _this$_selector$node$6 === void 0 ? void 0 : _this$_selector$node$6.throwOnFieldError) === true) {
                        this._fieldErrors.push(error);
                    } else {
                        this._fieldErrors.push(markFieldErrorHasHandled(error));
                    }
                }
            }
            this._isMissingData = this._isMissingData || cachedSnapshot.isMissingData;
        }
        if (resolverError) {
            var _this$_selector$node$7, _this$_selector$node$8;
            var errorEvent = {
                kind: 'relay_resolver.error',
                fieldPath: fieldPath,
                owner: this._fragmentName,
                error: resolverError,
                shouldThrow: (_this$_selector$node$7 = (_this$_selector$node$8 = this._selector.node.metadata) === null || _this$_selector$node$8 === void 0 ? void 0 : _this$_selector$node$8.throwOnFieldError) !== null && _this$_selector$node$7 !== void 0 ? _this$_selector$node$7 : false,
                handled: false,
                uiContext: undefined
            };
            if (this._fieldErrors == null) {
                this._fieldErrors = [
                    errorEvent
                ];
            } else {
                this._fieldErrors.push(errorEvent);
            }
        }
        if (seenRecord != null) {
            this._seenRecords.add(seenRecord);
        }
        if (suspenseID != null) {
            this._isMissingData = true;
            this._missingLiveResolverFields.push(suspenseID);
        }
        if (updatedDataIDs != null) {
            updatedDataIDs.forEach(function(recordID) {
                _this2._updatedDataIDs.add(recordID);
            });
        }
    };
    _proto._readClientEdge = function _readClientEdge(field, record, data) {
        var _this3 = this;
        var _backingField$alias;
        var backingField = field.backingField;
        !(backingField.kind !== 'ClientExtension') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Client extension client edges are not yet implemented.') : "TURBOPACK unreachable" : void 0;
        var fieldName = (_backingField$alias = backingField.alias) !== null && _backingField$alias !== void 0 ? _backingField$alias : backingField.name;
        var backingFieldData = {};
        this._traverseSelections([
            backingField
        ], record, backingFieldData);
        var clientEdgeResolverResponse = backingFieldData[fieldName];
        if (clientEdgeResolverResponse == null || isSuspenseSentinel(clientEdgeResolverResponse)) {
            data[fieldName] = clientEdgeResolverResponse;
            return clientEdgeResolverResponse;
        }
        if (field.linkedField.plural) {
            !Array.isArray(clientEdgeResolverResponse) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected plural Client Edge Relay Resolver at `%s` in `%s` to return an array containing IDs or objects with shape {id}.', backingField.path, this._owner.identifier) : "TURBOPACK unreachable" : void 0;
            var storeIDs;
            !(field.kind === 'ClientEdgeToClientObject') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unexpected Client Edge to plural server type `%s`. This should be prevented by the compiler.', field.kind) : "TURBOPACK unreachable" : void 0;
            if (field.backingField.normalizationInfo == null) {
                storeIDs = clientEdgeResolverResponse.map(function(itemResponse) {
                    var _field$concreteType;
                    var concreteType = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : itemResponse.__typename;
                    !(typeof concreteType === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected resolver for field at `%s` in `%s` modeling an edge to an abstract type to return an object with a `__typename` property.', backingField.path, _this3._owner.identifier) : "TURBOPACK unreachable" : void 0;
                    var localId = extractIdFromResponse(itemResponse, backingField.path, _this3._owner.identifier);
                    var id = _this3._resolverCache.ensureClientRecord(localId, concreteType);
                    var modelResolvers = field.modelResolvers;
                    if (modelResolvers != null) {
                        var modelResolver = modelResolvers[concreteType];
                        !(modelResolver !== undefined) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Invalid `__typename` returned by resolver at `%s` in `%s`. Expected one of %s but got `%s`.', backingField.path, _this3._owner.identifier, Object.keys(modelResolvers).join(', '), concreteType) : "TURBOPACK unreachable" : void 0;
                        var model = _this3._readResolverFieldImpl(modelResolver, id);
                        return model != null ? id : null;
                    }
                    return id;
                });
            } else {
                storeIDs = clientEdgeResolverResponse.map(function(obj) {
                    return extractIdFromResponse(obj, backingField.path, _this3._owner.identifier);
                });
            }
            this._clientEdgeTraversalPath.push(null);
            var edgeValues = this._readLinkedIds(field.linkedField, storeIDs, record, data);
            this._clientEdgeTraversalPath.pop();
            data[fieldName] = edgeValues;
            return edgeValues;
        } else {
            var _field$concreteType2;
            var id = extractIdFromResponse(clientEdgeResolverResponse, backingField.path, this._owner.identifier);
            var storeID;
            var concreteType = (_field$concreteType2 = field.concreteType) !== null && _field$concreteType2 !== void 0 ? _field$concreteType2 : clientEdgeResolverResponse.__typename;
            var traversalPathSegment;
            if (field.kind === 'ClientEdgeToClientObject') {
                if (field.backingField.normalizationInfo == null) {
                    !(typeof concreteType === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected resolver for field at `%s` in `%s` modeling an edge to an abstract type to return an object with a `__typename` property.', backingField.path, this._owner.identifier) : "TURBOPACK unreachable" : void 0;
                    storeID = this._resolverCache.ensureClientRecord(id, concreteType);
                    traversalPathSegment = null;
                } else {
                    storeID = id;
                    traversalPathSegment = null;
                }
            } else {
                storeID = id;
                traversalPathSegment = {
                    readerClientEdge: field,
                    clientEdgeDestinationID: id
                };
            }
            var modelResolvers = field.modelResolvers;
            if (modelResolvers != null) {
                !(typeof concreteType === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected resolver for field at `%s` in `%s` modeling an edge to an abstract type to return an object with a `__typename` property.', backingField.path, this._owner.identifier) : "TURBOPACK unreachable" : void 0;
                var modelResolver = modelResolvers[concreteType];
                !(modelResolver !== undefined) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Invalid `__typename` returned by resolver at `%s` in `%s`. Expected one of %s but got `%s`.', backingField.path, this._owner.identifier, Object.keys(modelResolvers).join(', '), concreteType) : "TURBOPACK unreachable" : void 0;
                var model = this._readResolverFieldImpl(modelResolver, storeID);
                if (model == null) {
                    data[fieldName] = null;
                    return null;
                }
            }
            this._clientEdgeTraversalPath.push(traversalPathSegment);
            var prevData = data[fieldName];
            !(prevData == null || typeof prevData === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Expected data for field at `%s` in `%s` on record `%s` ' + 'to be an object, got `%s`.', backingField.path, this._owner.identifier, RelayModernRecord.getDataID(record), prevData) : "TURBOPACK unreachable" : void 0;
            var prevErrors = this._fieldErrors;
            this._fieldErrors = null;
            var edgeValue = this._traverse(field.linkedField, storeID, prevData);
            this._prependPreviousErrors(prevErrors, fieldName);
            this._clientEdgeTraversalPath.pop();
            data[fieldName] = edgeValue;
            return edgeValue;
        }
    };
    _proto._readScalar = function _readScalar(field, record, data) {
        var _field$alias3;
        var fieldName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;
        var storageKey = getStorageKey(field, this._variables);
        var value = RelayModernRecord.getValue(record, storageKey);
        if (value === null || RelayFeatureFlags.ENABLE_NONCOMPLIANT_ERROR_HANDLING_ON_LISTS && Array.isArray(value) && value.length === 0) {
            this._maybeAddFieldErrors(record, storageKey);
        } else if (value === undefined) {
            this._markDataAsMissing(fieldName);
        }
        data[fieldName] = value;
        return value;
    };
    _proto._readLink = function _readLink(field, record, data) {
        var _field$alias4;
        var fieldName = (_field$alias4 = field.alias) !== null && _field$alias4 !== void 0 ? _field$alias4 : field.name;
        var storageKey = getStorageKey(field, this._variables);
        var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
        if (linkedID == null) {
            data[fieldName] = linkedID;
            if (linkedID === null) {
                this._maybeAddFieldErrors(record, storageKey);
            } else if (linkedID === undefined) {
                this._markDataAsMissing(fieldName);
            }
            return linkedID;
        }
        var prevData = data[fieldName];
        !(prevData == null || typeof prevData === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Expected data for field `%s` at `%s` on record `%s` ' + 'to be an object, got `%s`.', fieldName, this._owner.identifier, RelayModernRecord.getDataID(record), prevData) : "TURBOPACK unreachable" : void 0;
        var prevErrors = this._fieldErrors;
        this._fieldErrors = null;
        var value = this._traverse(field, linkedID, prevData);
        this._prependPreviousErrors(prevErrors, fieldName);
        data[fieldName] = value;
        return value;
    };
    _proto._prependPreviousErrors = function _prependPreviousErrors(prevErrors, fieldNameOrIndex) {
        if (this._fieldErrors != null) {
            for(var i = 0; i < this._fieldErrors.length; i++){
                var event = this._fieldErrors[i];
                if (event.owner === this._fragmentName && (event.kind === 'missing_expected_data.throw' || event.kind === 'missing_expected_data.log' || event.kind === 'missing_required_field.throw' || event.kind === 'missing_required_field.log')) {
                    event.fieldPath = "".concat(fieldNameOrIndex, ".").concat(event.fieldPath);
                }
            }
            if (prevErrors != null) {
                for(var _i3 = this._fieldErrors.length - 1; _i3 >= 0; _i3--){
                    prevErrors.push(this._fieldErrors[_i3]);
                }
                this._fieldErrors = prevErrors;
            }
        } else {
            this._fieldErrors = prevErrors;
        }
    };
    _proto._readActorChange = function _readActorChange(field, record, data) {
        var _field$alias5;
        var fieldName = (_field$alias5 = field.alias) !== null && _field$alias5 !== void 0 ? _field$alias5 : field.name;
        var storageKey = getStorageKey(field, this._variables);
        var externalRef = RelayModernRecord.getActorLinkedRecordID(record, storageKey);
        if (externalRef == null) {
            data[fieldName] = externalRef;
            if (externalRef === undefined) {
                this._markDataAsMissing(fieldName);
            } else if (externalRef === null) {
                this._maybeAddFieldErrors(record, storageKey);
            }
            return data[fieldName];
        }
        var actorIdentifier = externalRef[0], dataID = externalRef[1];
        var fragmentRef = {};
        this._createFragmentPointer(field.fragmentSpread, RelayModernRecord.fromObject({
            __id: dataID
        }), fragmentRef);
        data[fieldName] = {
            __fragmentRef: fragmentRef,
            __viewer: actorIdentifier
        };
        return data[fieldName];
    };
    _proto._readPluralLink = function _readPluralLink(field, record, data) {
        var storageKey = getStorageKey(field, this._variables);
        var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);
        if (linkedIDs === null || RelayFeatureFlags.ENABLE_NONCOMPLIANT_ERROR_HANDLING_ON_LISTS && Array.isArray(linkedIDs) && linkedIDs.length === 0) {
            this._maybeAddFieldErrors(record, storageKey);
        }
        return this._readLinkedIds(field, linkedIDs, record, data);
    };
    _proto._readLinkedIds = function _readLinkedIds(field, linkedIDs, record, data) {
        var _this4 = this;
        var _field$alias6;
        var fieldName = (_field$alias6 = field.alias) !== null && _field$alias6 !== void 0 ? _field$alias6 : field.name;
        if (linkedIDs == null) {
            data[fieldName] = linkedIDs;
            if (linkedIDs === undefined) {
                this._markDataAsMissing(fieldName);
            }
            return linkedIDs;
        }
        var prevData = data[fieldName];
        !(prevData == null || Array.isArray(prevData)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an array, got `%s`.', fieldName, RelayModernRecord.getDataID(record), prevData) : "TURBOPACK unreachable" : void 0;
        var prevErrors = this._fieldErrors;
        this._fieldErrors = null;
        var linkedArray = prevData || [];
        linkedIDs.forEach(function(linkedID, nextIndex) {
            if (linkedID == null) {
                if (linkedID === undefined) {
                    _this4._markDataAsMissing(String(nextIndex));
                }
                linkedArray[nextIndex] = linkedID;
                return;
            }
            var prevItem = linkedArray[nextIndex];
            !(prevItem == null || typeof prevItem === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', fieldName, RelayModernRecord.getDataID(record), prevItem) : "TURBOPACK unreachable" : void 0;
            var prevErrors = _this4._fieldErrors;
            _this4._fieldErrors = null;
            linkedArray[nextIndex] = _this4._traverse(field, linkedID, prevItem);
            _this4._prependPreviousErrors(prevErrors, nextIndex);
        });
        this._prependPreviousErrors(prevErrors, fieldName);
        data[fieldName] = linkedArray;
        return linkedArray;
    };
    _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {
        var componentKey = getModuleComponentKey(moduleImport.documentName);
        var relayStoreComponent = RelayModernRecord.getValue(record, componentKey);
        var component = relayStoreComponent !== undefined ? relayStoreComponent : moduleImport.componentModuleProvider;
        if (component == null) {
            if (component === undefined) {
                this._markDataAsMissing('<module-import>');
            }
            return;
        }
        this._createFragmentPointer({
            kind: 'FragmentSpread',
            name: moduleImport.fragmentName,
            args: moduleImport.args
        }, record, data);
        data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;
        data[MODULE_COMPONENT_KEY] = component;
    };
    _proto._readAliasedInlineFragment = function _readAliasedInlineFragment(aliasedInlineFragment, record, data) {
        var prevErrors = this._fieldErrors;
        this._fieldErrors = null;
        var fieldValue = this._readInlineFragment(aliasedInlineFragment.fragment, record, {}, true);
        this._prependPreviousErrors(prevErrors, aliasedInlineFragment.name);
        if (fieldValue === false) {
            fieldValue = null;
        }
        data[aliasedInlineFragment.name] = fieldValue;
    };
    _proto._readInlineFragment = function _readInlineFragment(inlineFragment, record, data, skipUnmatchedAbstractTypes) {
        if (inlineFragment.type == null) {
            var hasExpectedData = this._traverseSelections(inlineFragment.selections, record, data);
            if (hasExpectedData === false) {
                return false;
            }
            return data;
        }
        var abstractKey = inlineFragment.abstractKey;
        if (abstractKey == null) {
            if (!this._recordMatchesTypeCondition(record, inlineFragment.type)) {
                return null;
            } else {
                var hasExpectedData = this._traverseSelections(inlineFragment.selections, record, data);
                if (!hasExpectedData) {
                    return false;
                }
            }
        } else {
            var implementsInterface = this._implementsInterface(record, abstractKey);
            if (implementsInterface === false && skipUnmatchedAbstractTypes) {
                return null;
            }
            var parentIsMissingData = this._isMissingData;
            var parentIsWithinUnmatchedTypeRefinement = this._isWithinUnmatchedTypeRefinement;
            this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement || implementsInterface === false;
            var hasMissingData = this._traverseSelections(inlineFragment.selections, record, data);
            this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement;
            if (implementsInterface === false) {
                this._isMissingData = parentIsMissingData;
                return null;
            } else if (implementsInterface == null) {
                return undefined;
            } else if (hasMissingData === false) {
                return false;
            }
        }
        return data;
    };
    _proto._recordMatchesTypeCondition = function _recordMatchesTypeCondition(record, type) {
        var typeName = RelayModernRecord.getType(record);
        return typeName != null && typeName === type || RelayModernRecord.getDataID(record) === ROOT_ID;
    };
    _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {
        var fragmentPointers = data[FRAGMENTS_KEY];
        if (fragmentPointers == null) {
            fragmentPointers = data[FRAGMENTS_KEY] = {};
        }
        !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : "TURBOPACK unreachable" : void 0;
        if (data[ID_KEY] == null) {
            data[ID_KEY] = RelayModernRecord.getDataID(record);
        }
        fragmentPointers[fragmentSpread.name] = getArgumentValues(fragmentSpread.args, this._variables, this._isWithinUnmatchedTypeRefinement);
        data[FRAGMENT_OWNER_KEY] = this._owner;
        if (this._clientEdgeTraversalPath.length > 0 && this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1] !== null) {
            data[CLIENT_EDGE_TRAVERSAL_PATH] = (0, _toConsumableArray2["default"])(this._clientEdgeTraversalPath);
        }
    };
    _proto._createInlineDataOrResolverFragmentPointer = function _createInlineDataOrResolverFragmentPointer(fragmentSpreadOrFragment, record, data) {
        var fragmentPointers = data[FRAGMENTS_KEY];
        if (fragmentPointers == null) {
            fragmentPointers = data[FRAGMENTS_KEY] = {};
        }
        !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : "TURBOPACK unreachable" : void 0;
        if (data[ID_KEY] == null) {
            data[ID_KEY] = RelayModernRecord.getDataID(record);
        }
        var inlineData = {};
        var parentFragmentName = this._fragmentName;
        this._fragmentName = fragmentSpreadOrFragment.name;
        var parentVariables = this._variables;
        var argumentVariables = fragmentSpreadOrFragment.args ? getArgumentValues(fragmentSpreadOrFragment.args, this._variables) : {};
        this._variables = RelayConcreteVariables.getFragmentVariables(fragmentSpreadOrFragment, this._owner.variables, argumentVariables);
        this._traverseSelections(fragmentSpreadOrFragment.selections, record, inlineData);
        this._variables = parentVariables;
        this._fragmentName = parentFragmentName;
        fragmentPointers[fragmentSpreadOrFragment.name] = inlineData;
    };
    _proto._implementsInterface = function _implementsInterface(record, abstractKey) {
        var typeName = RelayModernRecord.getType(record);
        var typeRecord = this._recordSource.get(generateTypeID(typeName));
        var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;
        if (implementsInterface == null) {
            this._markDataAsMissing('<abstract-type-hint>');
        }
        return implementsInterface;
    };
    return RelayReader;
}();
function markFieldErrorHasHandled(event) {
    switch(event.kind){
        case 'missing_expected_data.throw':
        case 'missing_required_field.throw':
        case 'relay_field_payload.error':
        case 'relay_resolver.error':
            return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, event), {}, {
                handled: true
            });
        case 'missing_expected_data.log':
        case 'missing_required_field.log':
            return event;
        default:
            event.kind;
            ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unexpected error response field kind: %s', event.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
    }
}
function getResolverValue(field, variables, fragmentKey, resolverContext) {
    var resolverFunction = typeof field.resolverModule === 'function' ? field.resolverModule : field.resolverModule["default"];
    var resolverResult = null;
    var resolverError = null;
    try {
        var resolverFunctionArgs = [];
        if (field.fragment != null) {
            resolverFunctionArgs.push(fragmentKey);
        }
        var args = field.args ? getArgumentValues(field.args, variables) : undefined;
        resolverFunctionArgs.push(args);
        resolverFunctionArgs.push(resolverContext);
        resolverResult = resolverFunction.apply(null, resolverFunctionArgs);
    } catch (e) {
        resolverResult = null;
        if (e !== RESOLVER_FRAGMENT_ERRORED_SENTINEL) {
            resolverError = e;
        }
    }
    return [
        resolverResult,
        resolverError
    ];
}
function extractIdFromResponse(individualResponse, path, owner) {
    if (typeof individualResponse === 'string') {
        return individualResponse;
    } else if (typeof individualResponse === 'object' && individualResponse != null && typeof individualResponse.id === 'string') {
        return individualResponse.id;
    }
    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected object returned from edge resolver to be a string or an object with an `id` property at path %s in %s,', path, owner) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
}
module.exports = {
    read: read
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayReferenceMarker.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var getOperation = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getOperation.js [app-ssr] (ecmascript)");
var cloneRelayHandleSourceField = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/cloneRelayHandleSourceField.js [app-ssr] (ecmascript)");
var getOutputTypeRecordIDs = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/getOutputTypeRecordIDs.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-ssr] (ecmascript)"), getLocalVariables = _require.getLocalVariables;
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)");
var RelayStoreUtils = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/TypeID.js [app-ssr] (ecmascript)"), generateTypeID = _require2.generateTypeID;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var getReadTimeResolverStorageKey = RelayStoreUtils.getReadTimeResolverStorageKey, getStorageKey = RelayStoreUtils.getStorageKey, getModuleOperationKey = RelayStoreUtils.getModuleOperationKey;
function mark(recordSource, selector, references, operationLoader, shouldProcessClientComponents, useExecTimeResolvers) {
    var dataID = selector.dataID, node = selector.node, variables = selector.variables;
    var marker = new RelayReferenceMarker(recordSource, variables, references, operationLoader, shouldProcessClientComponents, useExecTimeResolvers);
    marker.mark(node, dataID);
}
var RelayReferenceMarker = /*#__PURE__*/ function() {
    function RelayReferenceMarker(recordSource, variables, references, operationLoader, shouldProcessClientComponents, useExecTimeResolvers) {
        this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;
        this._operationName = null;
        this._useExecTimeResolvers = useExecTimeResolvers !== null && useExecTimeResolvers !== void 0 ? useExecTimeResolvers : false;
        this._recordSource = recordSource;
        this._references = references;
        this._variables = variables;
        this._shouldProcessClientComponents = shouldProcessClientComponents;
    }
    var _proto = RelayReferenceMarker.prototype;
    _proto.mark = function mark(node, dataID) {
        if (node.kind === 'Operation' || node.kind === 'SplitOperation') {
            this._operationName = node.name;
        }
        this._traverse(node, dataID);
    };
    _proto._traverse = function _traverse(node, dataID) {
        this._references.add(dataID);
        var record = this._recordSource.get(dataID);
        if (record == null) {
            return;
        }
        this._traverseSelections(node.selections, record);
    };
    _proto._getVariableValue = function _getVariableValue(name) {
        !this._variables.hasOwnProperty(name) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReferenceMarker(): Undefined variable `%s`.', name) : "TURBOPACK unreachable" : void 0;
        return this._variables[name];
    };
    _proto._traverseSelections = function _traverseSelections(selections, record) {
        var _this = this;
        selections.forEach(function(selection) {
            switch(selection.kind){
                case 'ActorChange':
                    _this._traverseLink(selection.linkedField, record);
                    break;
                case 'LinkedField':
                    if (selection.plural) {
                        _this._traversePluralLink(selection, record);
                    } else {
                        _this._traverseLink(selection, record);
                    }
                    break;
                case 'Condition':
                    var conditionValue = Boolean(_this._getVariableValue(selection.condition));
                    if (conditionValue === selection.passingValue) {
                        _this._traverseSelections(selection.selections, record);
                    }
                    break;
                case 'InlineFragment':
                    if (selection.abstractKey == null) {
                        var typeName = RelayModernRecord.getType(record);
                        if (typeName != null && typeName === selection.type || typeName === RelayStoreUtils.ROOT_TYPE) {
                            _this._traverseSelections(selection.selections, record);
                        }
                    } else {
                        var _typeName = RelayModernRecord.getType(record);
                        var typeID = generateTypeID(_typeName);
                        _this._references.add(typeID);
                        _this._traverseSelections(selection.selections, record);
                    }
                    break;
                case 'FragmentSpread':
                    var prevVariables = _this._variables;
                    _this._variables = getLocalVariables(_this._variables, selection.fragment.argumentDefinitions, selection.args);
                    _this._traverseSelections(selection.fragment.selections, record);
                    _this._variables = prevVariables;
                    break;
                case 'LinkedHandle':
                    var handleField = cloneRelayHandleSourceField(selection, selections, _this._variables);
                    if (handleField.plural) {
                        _this._traversePluralLink(handleField, record);
                    } else {
                        _this._traverseLink(handleField, record);
                    }
                    break;
                case 'Defer':
                case 'Stream':
                    _this._traverseSelections(selection.selections, record);
                    break;
                case 'ScalarField':
                case 'ScalarHandle':
                    break;
                case 'TypeDiscriminator':
                    {
                        var _typeName2 = RelayModernRecord.getType(record);
                        var _typeID = generateTypeID(_typeName2);
                        _this._references.add(_typeID);
                        break;
                    }
                case 'ModuleImport':
                    _this._traverseModuleImport(selection, record);
                    break;
                case 'ClientExtension':
                    _this._traverseSelections(selection.selections, record);
                    break;
                case 'ClientComponent':
                    if (_this._shouldProcessClientComponents === false) {
                        break;
                    }
                    _this._traverseSelections(selection.fragment.selections, record);
                    break;
                case 'RelayResolver':
                case 'RelayLiveResolver':
                    _this._traverseResolverField(selection, record);
                    break;
                case 'ClientEdgeToClientObject':
                    _this._traverseClientEdgeToClientObject(selection, record);
                    break;
                default:
                    selection;
                    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReferenceMarker: Unknown AST node `%s`.', selection) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
        });
    };
    _proto._traverseClientEdgeToClientObject = function _traverseClientEdgeToClientObject(field, record) {
        if (this._useExecTimeResolvers) {
            this._traverseLink(field.linkedField, record);
            return;
        }
        var dataID = this._traverseResolverField(field.backingField, record);
        if (dataID == null) {
            return;
        }
        var resolverRecord = this._recordSource.get(dataID);
        if (resolverRecord == null) {
            return;
        }
        if (field.backingField.isOutputType) {
            var outputTypeRecordIDs = getOutputTypeRecordIDs(resolverRecord);
            if (outputTypeRecordIDs != null) {
                var _iterator = (0, _createForOfIteratorHelper2["default"])(outputTypeRecordIDs), _step;
                try {
                    for(_iterator.s(); !(_step = _iterator.n()).done;){
                        var _dataID = _step.value;
                        this._references.add(_dataID);
                    }
                } catch (err) {
                    _iterator.e(err);
                } finally{
                    _iterator.f();
                }
            }
        } else {
            var linkedField = field.linkedField;
            var concreteType = linkedField.concreteType;
            if (concreteType == null) {
                return;
            }
            if (linkedField.plural) {
                var dataIDs = RelayModernRecord.getResolverLinkedRecordIDs(resolverRecord, concreteType);
                if (dataIDs != null) {
                    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(dataIDs), _step2;
                    try {
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                            var _dataID2 = _step2.value;
                            if (_dataID2 != null) {
                                this._traverse(linkedField, _dataID2);
                            }
                        }
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                }
            } else {
                var _dataID3 = RelayModernRecord.getResolverLinkedRecordID(resolverRecord, concreteType);
                if (_dataID3 != null) {
                    this._traverse(linkedField, _dataID3);
                }
            }
        }
    };
    _proto._traverseResolverField = function _traverseResolverField(field, record) {
        if (this._useExecTimeResolvers) {
            return;
        }
        var storageKey = getReadTimeResolverStorageKey(field, this._variables);
        var dataID = RelayModernRecord.getLinkedRecordID(record, storageKey);
        if (dataID != null) {
            this._references.add(dataID);
        }
        var fragment = field.fragment;
        if (fragment != null) {
            this._traverseSelections([
                fragment
            ], record);
        }
        return dataID;
    };
    _proto._traverseModuleImport = function _traverseModuleImport(moduleImport, record) {
        var _this$_operationName;
        var operationLoader = this._operationLoader;
        !(operationLoader !== null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReferenceMarker: Expected an operationLoader to be configured when using `@module`. ' + 'Could not load fragment `%s` in operation `%s`.', moduleImport.fragmentName, (_this$_operationName = this._operationName) !== null && _this$_operationName !== void 0 ? _this$_operationName : '(unknown)') : "TURBOPACK unreachable" : void 0;
        var operationKey = getModuleOperationKey(moduleImport.documentName);
        var operationReference = RelayModernRecord.getValue(record, operationKey);
        if (operationReference == null) {
            return;
        }
        var normalizationRootNode = operationLoader.get(operationReference);
        if (normalizationRootNode != null) {
            var operation = getOperation(normalizationRootNode);
            var prevVariables = this._variables;
            this._variables = getLocalVariables(this._variables, operation.argumentDefinitions, moduleImport.args);
            this._traverseSelections(operation.selections, record);
            this._variables = prevVariables;
        }
    };
    _proto._traverseLink = function _traverseLink(field, record) {
        var storageKey = getStorageKey(field, this._variables);
        var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
        if (linkedID == null) {
            return;
        }
        this._traverse(field, linkedID);
    };
    _proto._traversePluralLink = function _traversePluralLink(field, record) {
        var _this2 = this;
        var storageKey = getStorageKey(field, this._variables);
        var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);
        if (linkedIDs == null) {
            return;
        }
        linkedIDs.forEach(function(linkedID) {
            if (linkedID != null) {
                _this2._traverse(field, linkedID);
            }
        });
    };
    return RelayReferenceMarker;
}();
module.exports = {
    mark: mark
};
}),
"[project]/node_modules/relay-runtime/lib/store/hasOverlappingIDs.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ITERATOR_KEY = Symbol.iterator;
function hasOverlappingIDs(seenRecords, updatedRecordIDs) {
    var iterator = seenRecords[ITERATOR_KEY]();
    var next = iterator.next();
    while(!next.done){
        var key = next.value;
        if (updatedRecordIDs.has(key)) {
            return true;
        }
        next = iterator.next();
    }
    return false;
}
module.exports = hasOverlappingIDs;
}),
"[project]/node_modules/relay-runtime/lib/store/hasSignificantOverlappingIDs.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), ROOT_ID = _require.ROOT_ID;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ViewerPattern.js [app-ssr] (ecmascript)"), VIEWER_ID = _require2.VIEWER_ID;
var ITERATOR_KEY = Symbol.iterator;
function hasSignificantOverlappingIDs(seenRecords, updatedRecordIDs) {
    var iterator = seenRecords[ITERATOR_KEY]();
    var next = iterator.next();
    while(!next.done){
        var key = next.value;
        if (updatedRecordIDs.has(key) && key !== ROOT_ID && key !== VIEWER_ID) {
            return true;
        }
        next = iterator.next();
    }
    return false;
}
module.exports = hasSignificantOverlappingIDs;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayStoreSubscriptions.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var deepFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-ssr] (ecmascript)");
var recycleNodesInto = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/recycleNodesInto.js [app-ssr] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-ssr] (ecmascript)");
var hasOverlappingIDs = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/hasOverlappingIDs.js [app-ssr] (ecmascript)");
var hasSignificantOverlappingIDs = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/hasSignificantOverlappingIDs.js [app-ssr] (ecmascript)");
var RelayReader = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayReader.js [app-ssr] (ecmascript)");
var RelayStoreSubscriptions = /*#__PURE__*/ function() {
    function RelayStoreSubscriptions(log, resolverCache, resolverContext) {
        this._subscriptions = new Set();
        this.__log = log;
        this._resolverCache = resolverCache;
        this._resolverContext = resolverContext;
    }
    var _proto = RelayStoreSubscriptions.prototype;
    _proto.subscribe = function subscribe(snapshot, callback) {
        var _this = this;
        var subscription = {
            backup: null,
            callback: callback,
            snapshot: snapshot,
            stale: false
        };
        var dispose = function dispose() {
            _this._subscriptions["delete"](subscription);
        };
        this._subscriptions.add(subscription);
        return {
            dispose: dispose
        };
    };
    _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {
        var _this2 = this;
        this._subscriptions.forEach(function(subscription) {
            if (!subscription.stale) {
                subscription.backup = subscription.snapshot;
                return;
            }
            var snapshot = subscription.snapshot;
            var backup = RelayReader.read(source, snapshot.selector, _this2._resolverCache, _this2._resolverContext);
            var nextData = recycleNodesInto(snapshot.data, backup.data);
            backup.data = nextData;
            subscription.backup = backup;
        });
    };
    _proto.restoreSubscriptions = function restoreSubscriptions() {
        this._subscriptions.forEach(function(subscription) {
            var backup = subscription.backup;
            subscription.backup = null;
            if (backup) {
                if (backup.data !== subscription.snapshot.data) {
                    subscription.stale = true;
                }
                subscription.snapshot = {
                    data: subscription.snapshot.data,
                    isMissingData: backup.isMissingData,
                    missingClientEdges: backup.missingClientEdges,
                    missingLiveResolverFields: backup.missingLiveResolverFields,
                    seenRecords: backup.seenRecords,
                    selector: backup.selector,
                    fieldErrors: backup.fieldErrors
                };
            } else {
                subscription.stale = true;
            }
        });
    };
    _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {
        var _this3 = this;
        var hasUpdatedRecords = updatedRecordIDs.size !== 0;
        this._subscriptions.forEach(function(subscription) {
            var owner = _this3._updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation);
            if (owner != null) {
                updatedOwners.push(owner);
            }
        });
    };
    _proto._updateSubscription = function _updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation) {
        var backup = subscription.backup, callback = subscription.callback, snapshot = subscription.snapshot, stale = subscription.stale;
        var hasOverlappingUpdates = hasUpdatedRecords && hasOverlappingIDs(snapshot.seenRecords, updatedRecordIDs);
        if (!stale && !hasOverlappingUpdates) {
            return;
        }
        var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector, this._resolverCache, this._resolverContext) : backup;
        var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);
        nextSnapshot = {
            data: nextData,
            isMissingData: nextSnapshot.isMissingData,
            missingClientEdges: nextSnapshot.missingClientEdges,
            missingLiveResolverFields: nextSnapshot.missingLiveResolverFields,
            seenRecords: nextSnapshot.seenRecords,
            selector: nextSnapshot.selector,
            fieldErrors: nextSnapshot.fieldErrors
        };
        if ("TURBOPACK compile-time truthy", 1) {
            deepFreeze(nextSnapshot);
        }
        subscription.snapshot = nextSnapshot;
        subscription.stale = false;
        if (nextSnapshot.data !== snapshot.data) {
            if (this.__log && RelayFeatureFlags.ENABLE_NOTIFY_SUBSCRIPTION) {
                this.__log({
                    name: 'store.notify.subscription',
                    sourceOperation: sourceOperation,
                    snapshot: snapshot,
                    nextSnapshot: nextSnapshot
                });
            }
            callback(nextSnapshot);
            return snapshot.selector.owner;
        }
        if (RelayFeatureFlags.ENABLE_LOOSE_SUBSCRIPTION_ATTRIBUTION && (stale || hasSignificantOverlappingIDs(snapshot.seenRecords, updatedRecordIDs))) {
            return snapshot.selector.owner;
        }
    };
    _proto.size = function size() {
        return this._subscriptions.size;
    };
    return RelayStoreSubscriptions;
}();
module.exports = RelayStoreSubscriptions;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayModernStore.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/multi-actor-environment/ActorIdentifier.js [app-ssr] (ecmascript)"), INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE = _require.INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE, assertInternalActorIdentifier = _require.assertInternalActorIdentifier;
var deepFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-ssr] (ecmascript)");
var resolveImmediate = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/resolveImmediate.js [app-ssr] (ecmascript)");
var DataChecker = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/DataChecker.js [app-ssr] (ecmascript)");
var defaultGetDataID = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/defaultGetDataID.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverCache.js [app-ssr] (ecmascript)"), LiveResolverCache = _require2.LiveResolverCache, RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY = _require2.RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY, getUpdatedDataIDs = _require2.getUpdatedDataIDs;
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)");
var RelayOptimisticRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayOptimisticRecordSource.js [app-ssr] (ecmascript)");
var RelayReader = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayReader.js [app-ssr] (ecmascript)");
var RelayReferenceMarker = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayReferenceMarker.js [app-ssr] (ecmascript)");
var RelayStoreSubscriptions = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreSubscriptions.js [app-ssr] (ecmascript)");
var RelayStoreUtils = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), ROOT_ID = _require3.ROOT_ID, ROOT_TYPE = _require3.ROOT_TYPE;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var DEFAULT_RELEASE_BUFFER_SIZE = 10;
var RelayModernStore = /*#__PURE__*/ function() {
    function RelayModernStore(source, options) {
        var _this = this;
        var _options$gcReleaseBuf, _options$shouldRetain, _options$gcScheduler, _options$getDataID, _options$log, _options$operationLoa, _options$shouldProces, _options$treatMissing;
        (0, _defineProperty2["default"])(this, "_gcStep", function() {
            if (_this._gcRun) {
                if (_this._gcRun.next().done) {
                    _this._gcRun = null;
                } else {
                    _this._gcScheduler(_this._gcStep);
                }
            }
        });
        if ("TURBOPACK compile-time truthy", 1) {
            var storeIDs = source.getRecordIDs();
            for(var ii = 0; ii < storeIDs.length; ii++){
                var record = source.get(storeIDs[ii]);
                if (record) {
                    RelayModernRecord.freeze(record);
                }
            }
        }
        this._currentWriteEpoch = 0;
        this._gcHoldCounter = 0;
        this._gcReleaseBufferSize = (_options$gcReleaseBuf = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _options$gcReleaseBuf !== void 0 ? _options$gcReleaseBuf : DEFAULT_RELEASE_BUFFER_SIZE;
        this._shouldRetainWithinTTL_EXPERIMENTAL = (_options$shouldRetain = options === null || options === void 0 ? void 0 : options.shouldRetainWithinTTL_EXPERIMENTAL) !== null && _options$shouldRetain !== void 0 ? _options$shouldRetain : false;
        this._gcRun = null;
        this._gcScheduler = (_options$gcScheduler = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _options$gcScheduler !== void 0 ? _options$gcScheduler : resolveImmediate;
        this._getDataID = (_options$getDataID = options === null || options === void 0 ? void 0 : options.getDataID) !== null && _options$getDataID !== void 0 ? _options$getDataID : defaultGetDataID;
        this._globalInvalidationEpoch = null;
        this._invalidationSubscriptions = new Set();
        this._invalidatedRecordIDs = new Set();
        this.__log = (_options$log = options === null || options === void 0 ? void 0 : options.log) !== null && _options$log !== void 0 ? _options$log : null;
        this._queryCacheExpirationTime = options === null || options === void 0 ? void 0 : options.queryCacheExpirationTime;
        this._operationLoader = (_options$operationLoa = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _options$operationLoa !== void 0 ? _options$operationLoa : null;
        this._optimisticSource = null;
        this._recordSource = source;
        this._releaseBuffer = [];
        this._roots = new Map();
        this._shouldScheduleGC = false;
        this._resolverCache = new LiveResolverCache(function() {
            return _this._getMutableRecordSource();
        }, this);
        this._resolverContext = options === null || options === void 0 ? void 0 : options.resolverContext;
        this._storeSubscriptions = new RelayStoreSubscriptions(options === null || options === void 0 ? void 0 : options.log, this._resolverCache, this._resolverContext);
        this._updatedRecordIDs = new Set();
        this._shouldProcessClientComponents = (_options$shouldProces = options === null || options === void 0 ? void 0 : options.shouldProcessClientComponents) !== null && _options$shouldProces !== void 0 ? _options$shouldProces : false;
        this._treatMissingFieldsAsNull = (_options$treatMissing = options === null || options === void 0 ? void 0 : options.treatMissingFieldsAsNull) !== null && _options$treatMissing !== void 0 ? _options$treatMissing : false;
        this._actorIdentifier = options === null || options === void 0 ? void 0 : options.actorIdentifier;
        initializeRecordSource(this._recordSource);
    }
    var _proto = RelayModernStore.prototype;
    _proto.getSource = function getSource() {
        var _this$_optimisticSour;
        return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;
    };
    _proto.getOperationLoader = function getOperationLoader() {
        return this._operationLoader;
    };
    _proto._getMutableRecordSource = function _getMutableRecordSource() {
        var _this$_optimisticSour2;
        return (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;
    };
    _proto.getLiveResolverPromise = function getLiveResolverPromise(recordID) {
        return this._resolverCache.getLiveResolverPromise(recordID);
    };
    _proto.batchLiveStateUpdates = function batchLiveStateUpdates(callback) {
        if (this.__log != null) {
            this.__log({
                name: 'liveresolver.batch.start'
            });
        }
        try {
            this._resolverCache.batchLiveStateUpdates(callback);
        } finally{
            if (this.__log != null) {
                this.__log({
                    name: 'liveresolver.batch.end'
                });
            }
        }
    };
    _proto.check = function check(operation, options) {
        var _ref, _operation$request$no, _operation$request$no2, _options$handlers, _options$getSourceFor, _options$getTargetFor, _options$defaultActor;
        var selector = operation.root;
        var source = this._getMutableRecordSource();
        var globalInvalidationEpoch = this._globalInvalidationEpoch;
        var useExecTimeResolvers = (_ref = (_operation$request$no = operation.request.node.operation.use_exec_time_resolvers) !== null && _operation$request$no !== void 0 ? _operation$request$no : ((_operation$request$no2 = operation.request.node.operation.exec_time_resolvers_enabled_provider) === null || _operation$request$no2 === void 0 ? void 0 : _operation$request$no2.get()) === true) !== null && _ref !== void 0 ? _ref : false;
        var rootEntry = this._roots.get(operation.request.identifier);
        var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null;
        if (globalInvalidationEpoch != null) {
            if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {
                return {
                    status: 'stale'
                };
            }
        }
        var handlers = (_options$handlers = options === null || options === void 0 ? void 0 : options.handlers) !== null && _options$handlers !== void 0 ? _options$handlers : [];
        var getSourceForActor = (_options$getSourceFor = options === null || options === void 0 ? void 0 : options.getSourceForActor) !== null && _options$getSourceFor !== void 0 ? _options$getSourceFor : function(actorIdentifier) {
            assertInternalActorIdentifier(actorIdentifier);
            return source;
        };
        var getTargetForActor = (_options$getTargetFor = options === null || options === void 0 ? void 0 : options.getTargetForActor) !== null && _options$getTargetFor !== void 0 ? _options$getTargetFor : function(actorIdentifier) {
            assertInternalActorIdentifier(actorIdentifier);
            return source;
        };
        var operationAvailability = DataChecker.check(getSourceForActor, getTargetForActor, (_options$defaultActor = options === null || options === void 0 ? void 0 : options.defaultActorIdentifier) !== null && _options$defaultActor !== void 0 ? _options$defaultActor : INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE, selector, handlers, this._operationLoader, this._getDataID, this._shouldProcessClientComponents, this.__log, useExecTimeResolvers);
        return getAvailabilityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime, this._queryCacheExpirationTime);
    };
    _proto.retain = function retain(operation) {
        var _this2 = this;
        var id = operation.request.identifier;
        var disposed = false;
        var dispose = function dispose() {
            if (disposed) {
                return;
            }
            disposed = true;
            var rootEntry = _this2._roots.get(id);
            if (rootEntry == null) {
                return;
            }
            rootEntry.refCount--;
            if (rootEntry.refCount === 0) {
                var _queryCacheExpirationTime = _this2._queryCacheExpirationTime;
                var rootEntryIsStale = rootEntry.fetchTime != null && _queryCacheExpirationTime != null && rootEntry.fetchTime <= Date.now() - _queryCacheExpirationTime;
                if (rootEntryIsStale) {
                    if (!_this2._shouldRetainWithinTTL_EXPERIMENTAL) {
                        _this2._roots["delete"](id);
                    }
                    _this2.scheduleGC();
                } else {
                    _this2._releaseBuffer.push(id);
                    if (_this2._releaseBuffer.length > _this2._gcReleaseBufferSize) {
                        var _id = _this2._releaseBuffer.shift();
                        if (!_this2._shouldRetainWithinTTL_EXPERIMENTAL) {
                            _this2._roots["delete"](_id);
                        }
                        _this2.scheduleGC();
                    }
                }
            }
        };
        var rootEntry = this._roots.get(id);
        if (rootEntry != null) {
            if (rootEntry.refCount === 0) {
                this._releaseBuffer = this._releaseBuffer.filter(function(_id) {
                    return _id !== id;
                });
            }
            rootEntry.refCount += 1;
        } else {
            this._roots.set(id, {
                operation: operation,
                refCount: 1,
                epoch: null,
                fetchTime: null
            });
        }
        return {
            dispose: dispose
        };
    };
    _proto.lookup = function lookup(selector) {
        var log = this.__log;
        if (log != null) {
            log({
                name: 'store.lookup.start',
                selector: selector
            });
        }
        var source = this.getSource();
        var snapshot = RelayReader.read(source, selector, this._resolverCache, this._resolverContext);
        if ("TURBOPACK compile-time truthy", 1) {
            deepFreeze(snapshot);
        }
        if (log != null) {
            log({
                name: 'store.lookup.end',
                selector: selector
            });
        }
        return snapshot;
    };
    _proto.notify = function notify(sourceOperation, invalidateStore) {
        var _this3 = this;
        var log = this.__log;
        if (log != null) {
            log({
                name: 'store.notify.start',
                sourceOperation: sourceOperation
            });
        }
        this._currentWriteEpoch++;
        if (invalidateStore === true) {
            this._globalInvalidationEpoch = this._currentWriteEpoch;
        }
        this._resolverCache.invalidateDataIDs(this._updatedRecordIDs);
        var source = this.getSource();
        var updatedOwners = [];
        this._storeSubscriptions.updateSubscriptions(source, this._updatedRecordIDs, updatedOwners, sourceOperation);
        this._invalidationSubscriptions.forEach(function(subscription) {
            _this3._updateInvalidationSubscription(subscription, invalidateStore === true);
        });
        if (sourceOperation != null) {
            var id = sourceOperation.request.identifier;
            var rootEntry = this._roots.get(id);
            if (rootEntry != null) {
                rootEntry.epoch = this._currentWriteEpoch;
                rootEntry.fetchTime = Date.now();
            } else if (sourceOperation.request.node.params.operationKind === 'query' && this._gcReleaseBufferSize > 0 && this._releaseBuffer.length < this._gcReleaseBufferSize) {
                var temporaryRootEntry = {
                    operation: sourceOperation,
                    refCount: 0,
                    epoch: this._currentWriteEpoch,
                    fetchTime: Date.now()
                };
                this._releaseBuffer.push(id);
                this._roots.set(id, temporaryRootEntry);
            }
        }
        if (log != null) {
            log({
                name: 'store.notify.complete',
                sourceOperation: sourceOperation,
                updatedRecordIDs: this._updatedRecordIDs,
                invalidatedRecordIDs: this._invalidatedRecordIDs,
                subscriptionsSize: this._storeSubscriptions.size(),
                updatedOwners: updatedOwners
            });
        }
        this._updatedRecordIDs.clear();
        this._invalidatedRecordIDs.clear();
        return updatedOwners;
    };
    _proto.publish = function publish(source, idsMarkedForInvalidation) {
        var target = this._getMutableRecordSource();
        updateTargetFromSource(target, source, this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs);
        var log = this.__log;
        if (log != null) {
            log({
                name: 'store.publish',
                source: source,
                optimistic: target === this._optimisticSource
            });
        }
    };
    _proto.subscribe = function subscribe(snapshot, callback) {
        return this._storeSubscriptions.subscribe(snapshot, callback);
    };
    _proto.holdGC = function holdGC() {
        var _this4 = this;
        if (this._gcRun) {
            this._gcRun = null;
            this._shouldScheduleGC = true;
        }
        this._gcHoldCounter++;
        var dispose = function dispose() {
            if (_this4._gcHoldCounter > 0) {
                _this4._gcHoldCounter--;
                if (_this4._gcHoldCounter === 0 && _this4._shouldScheduleGC) {
                    _this4.scheduleGC();
                    _this4._shouldScheduleGC = false;
                }
            }
        };
        return {
            dispose: dispose
        };
    };
    _proto.toJSON = function toJSON() {
        return 'RelayModernStore()';
    };
    _proto.getEpoch = function getEpoch() {
        return this._currentWriteEpoch;
    };
    _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {
        return this._updatedRecordIDs;
    };
    _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {
        var _this5 = this;
        var invalidations = new Map();
        dataIDs.forEach(function(dataID) {
            var _RelayModernRecord$ge;
            var record = _this5.getSource().get(dataID);
            invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);
        });
        invalidations.set('global', this._globalInvalidationEpoch);
        return {
            dataIDs: dataIDs,
            invalidations: invalidations
        };
    };
    _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {
        var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);
        var currentInvalidations = latestInvalidationState.invalidations;
        var prevInvalidations = prevInvalidationState.invalidations;
        if (currentInvalidations.get('global') !== prevInvalidations.get('global')) {
            return true;
        }
        var _iterator = (0, _createForOfIteratorHelper2["default"])(prevInvalidationState.dataIDs), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var dataID = _step.value;
                if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {
                    return true;
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        return false;
    };
    _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {
        var _this6 = this;
        var subscription = {
            callback: callback,
            invalidationState: invalidationState
        };
        var dispose = function dispose() {
            _this6._invalidationSubscriptions["delete"](subscription);
        };
        this._invalidationSubscriptions.add(subscription);
        return {
            dispose: dispose
        };
    };
    _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {
        var _this7 = this;
        var callback = subscription.callback, invalidationState = subscription.invalidationState;
        var dataIDs = invalidationState.dataIDs;
        var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function(dataID) {
            return _this7._invalidatedRecordIDs.has(dataID);
        });
        if (!isSubscribedToInvalidatedIDs) {
            return;
        }
        callback();
    };
    _proto.snapshot = function snapshot() {
        !(this._optimisticSource == null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : "TURBOPACK unreachable" : void 0;
        var log = this.__log;
        if (log != null) {
            log({
                name: 'store.snapshot'
            });
        }
        this._storeSubscriptions.snapshotSubscriptions(this.getSource());
        if (this._gcRun) {
            this._gcRun = null;
            this._shouldScheduleGC = true;
        }
        this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());
    };
    _proto.restore = function restore() {
        var optimisticSource = this._optimisticSource;
        !optimisticSource ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : "TURBOPACK unreachable" : void 0;
        var log = this.__log;
        if (log != null) {
            log({
                name: 'store.restore'
            });
        }
        var optimisticIDs = RelayOptimisticRecordSource.getOptimisticRecordIDs(optimisticSource);
        this._resolverCache.unsubscribeFromLiveResolverRecords(optimisticIDs);
        this._optimisticSource = null;
        if (this._shouldScheduleGC) {
            this.scheduleGC();
        }
        this._storeSubscriptions.restoreSubscriptions();
        this._resolverCache.invalidateResolverRecords(optimisticIDs);
    };
    _proto.scheduleGC = function scheduleGC() {
        if (this._gcHoldCounter > 0) {
            this._shouldScheduleGC = true;
            return;
        }
        if (this._gcRun) {
            return;
        }
        this._gcRun = this._collect();
        this._gcScheduler(this._gcStep);
    };
    _proto.__gc = function __gc() {
        if (this._optimisticSource != null) {
            return;
        }
        var gcRun = this._collect();
        while(!gcRun.next().done){}
    };
    _proto._collect = function* _collect() {
        if (this._shouldRetainWithinTTL_EXPERIMENTAL && this._queryCacheExpirationTime == null) {
            return;
        }
        var log = this.__log;
        top: while(true){
            if (log != null) {
                log({
                    name: 'store.gc.start'
                });
            }
            var startEpoch = this._currentWriteEpoch;
            var references = new Set();
            var _iterator2 = (0, _createForOfIteratorHelper2["default"])(this._roots.entries()), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var _ref2, _operation$request$no3, _operation$request$no4;
                    var _step2$value = _step2.value, _dataID = _step2$value[0], _step2$value$ = _step2$value[1], operation = _step2$value$.operation, refCount = _step2$value$.refCount, fetchTime = _step2$value$.fetchTime;
                    if (this._shouldRetainWithinTTL_EXPERIMENTAL) {
                        var _queryCacheExpirationTime = this._queryCacheExpirationTime;
                        !(_queryCacheExpirationTime != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Query cache expiration time should be non-null if executing GC') : "TURBOPACK unreachable" : void 0;
                        var recordHasExpired = fetchTime == null || fetchTime <= Date.now() - _queryCacheExpirationTime;
                        var recordShouldBeCollected = recordHasExpired && refCount === 0 && !this._releaseBuffer.includes(_dataID);
                        if (recordShouldBeCollected) {
                            continue;
                        }
                    }
                    var selector = operation.root;
                    var useExecTimeResolvers = (_ref2 = (_operation$request$no3 = operation.request.node.operation.use_exec_time_resolvers) !== null && _operation$request$no3 !== void 0 ? _operation$request$no3 : ((_operation$request$no4 = operation.request.node.operation.exec_time_resolvers_enabled_provider) === null || _operation$request$no4 === void 0 ? void 0 : _operation$request$no4.get()) === true) !== null && _ref2 !== void 0 ? _ref2 : false;
                    RelayReferenceMarker.mark(this._recordSource, selector, references, this._operationLoader, this._shouldProcessClientComponents, useExecTimeResolvers);
                    yield;
                    if (startEpoch !== this._currentWriteEpoch) {
                        if (log != null) {
                            log({
                                name: 'store.gc.interrupted'
                            });
                        }
                        continue top;
                    }
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
            var storeIDs = this._recordSource.getRecordIDs();
            for(var ii = 0; ii < storeIDs.length; ii++){
                var dataID = storeIDs[ii];
                if (!references.has(dataID)) {
                    var record = this._recordSource.get(dataID);
                    if (record != null) {
                        var maybeResolverSubscription = RelayModernRecord.getValue(record, RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY);
                        if (maybeResolverSubscription != null) {
                            maybeResolverSubscription();
                        }
                    }
                    this._recordSource.remove(dataID);
                    if (this._shouldRetainWithinTTL_EXPERIMENTAL) {
                        this._roots["delete"](dataID);
                    }
                }
            }
            if (log != null) {
                log({
                    name: 'store.gc.end',
                    references: references
                });
            }
            return;
        }
    };
    _proto.__getNormalizationOptions = function __getNormalizationOptions(path) {
        return {
            path: path,
            getDataID: this._getDataID,
            log: this.__log,
            treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
            shouldProcessClientComponents: this._shouldProcessClientComponents,
            actorIdentifier: this._actorIdentifier
        };
    };
    _proto.__notifyUpdatedSubscribers = function __notifyUpdatedSubscribers(updatedRecords) {
        var nextUpdatedRecordIDs = getUpdatedDataIDs(updatedRecords);
        var prevUpdatedRecordIDs = this._updatedRecordIDs;
        this._updatedRecordIDs = nextUpdatedRecordIDs;
        this.notify();
        this._updatedRecordIDs = prevUpdatedRecordIDs;
    };
    return RelayModernStore;
}();
function initializeRecordSource(target) {
    if (!target.has(ROOT_ID)) {
        var rootRecord = RelayModernRecord.create(ROOT_ID, ROOT_TYPE);
        target.set(ROOT_ID, rootRecord);
    }
}
function updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {
    if (idsMarkedForInvalidation) {
        idsMarkedForInvalidation.forEach(function(dataID) {
            var targetRecord = target.get(dataID);
            var sourceRecord = source.get(dataID);
            if (sourceRecord === null) {
                return;
            }
            var nextRecord;
            if (targetRecord != null) {
                nextRecord = RelayModernRecord.clone(targetRecord);
            } else {
                nextRecord = sourceRecord != null ? RelayModernRecord.clone(sourceRecord) : null;
            }
            if (!nextRecord) {
                return;
            }
            RelayModernRecord.setValue(nextRecord, RelayStoreUtils.INVALIDATED_AT_KEY, currentWriteEpoch);
            invalidatedRecordIDs.add(dataID);
            target.set(dataID, nextRecord);
        });
    }
    var dataIDs = source.getRecordIDs();
    for(var ii = 0; ii < dataIDs.length; ii++){
        var dataID = dataIDs[ii];
        var sourceRecord = source.get(dataID);
        var targetRecord = target.get(dataID);
        if ("TURBOPACK compile-time truthy", 1) {
            if (sourceRecord) {
                RelayModernRecord.freeze(sourceRecord);
            }
        }
        if (sourceRecord && targetRecord) {
            var nextRecord = RelayModernRecord.update(targetRecord, sourceRecord);
            if (nextRecord !== targetRecord) {
                if ("TURBOPACK compile-time truthy", 1) {
                    RelayModernRecord.freeze(nextRecord);
                }
                updatedRecordIDs.add(dataID);
                target.set(dataID, nextRecord);
            }
        } else if (sourceRecord === null) {
            target["delete"](dataID);
            if (targetRecord !== null) {
                updatedRecordIDs.add(dataID);
            }
        } else if (sourceRecord) {
            target.set(dataID, sourceRecord);
            updatedRecordIDs.add(dataID);
        }
    }
}
function getAvailabilityStatus(operationAvailability, operationLastWrittenAt, operationFetchTime, queryCacheExpirationTime) {
    var mostRecentlyInvalidatedAt = operationAvailability.mostRecentlyInvalidatedAt, status = operationAvailability.status;
    if (typeof mostRecentlyInvalidatedAt === 'number') {
        if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {
            return {
                status: 'stale'
            };
        }
    }
    if (status === 'missing') {
        return {
            status: 'missing'
        };
    }
    if (operationFetchTime != null && queryCacheExpirationTime != null) {
        var isStale = operationFetchTime <= Date.now() - queryCacheExpirationTime;
        if (isStale) {
            return {
                status: 'stale'
            };
        }
    }
    return {
        status: 'available',
        fetchTime: operationFetchTime !== null && operationFetchTime !== void 0 ? operationFetchTime : null
    };
}
module.exports = RelayModernStore;
}),
"[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceSelectorProxy.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), ROOT_TYPE = _require.ROOT_TYPE, getStorageKey = _require.getStorageKey;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/readUpdatableFragment.js [app-ssr] (ecmascript)"), _readUpdatableFragment = _require2.readUpdatableFragment;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/readUpdatableQuery.js [app-ssr] (ecmascript)"), _readUpdatableQuery = _require3.readUpdatableQuery;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var RelayRecordSourceSelectorProxy = /*#__PURE__*/ function() {
    function RelayRecordSourceSelectorProxy(mutator, recordSource, readSelector, missingFieldHandlers) {
        this.__mutator = mutator;
        this.__recordSource = recordSource;
        this._readSelector = readSelector;
        this._missingFieldHandlers = missingFieldHandlers;
    }
    var _proto = RelayRecordSourceSelectorProxy.prototype;
    _proto.create = function create(dataID, typeName) {
        return this.__recordSource.create(dataID, typeName);
    };
    _proto["delete"] = function _delete(dataID) {
        this.__recordSource["delete"](dataID);
    };
    _proto.get = function get(dataID) {
        return this.__recordSource.get(dataID);
    };
    _proto.getRoot = function getRoot() {
        return this.__recordSource.getRoot();
    };
    _proto.getOperationRoot = function getOperationRoot() {
        var root = this.__recordSource.get(this._readSelector.dataID);
        if (!root) {
            root = this.__recordSource.create(this._readSelector.dataID, ROOT_TYPE);
        }
        return root;
    };
    _proto._getRootField = function _getRootField(selector, fieldName, plural) {
        var field = selector.node.selections.find(function(selection) {
            return selection.kind === 'LinkedField' && selection.name === fieldName || selection.kind === 'RequiredField' && selection.field.name === fieldName;
        });
        if (field && field.kind === 'RequiredField') {
            field = field.field;
        }
        !(field && field.kind === 'LinkedField') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceSelectorProxy#getRootField(): Cannot find root ' + 'field `%s`, no such field is defined on GraphQL document `%s`.', fieldName, selector.node.name) : "TURBOPACK unreachable" : void 0;
        !(field.plural === plural) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceSelectorProxy#getRootField(): Expected root field ' + '`%s` to be %s.', fieldName, plural ? 'plural' : 'singular') : "TURBOPACK unreachable" : void 0;
        return field;
    };
    _proto.getRootField = function getRootField(fieldName) {
        var field = this._getRootField(this._readSelector, fieldName, false);
        var storageKey = getStorageKey(field, this._readSelector.variables);
        return this.getOperationRoot().getLinkedRecord(storageKey);
    };
    _proto.getPluralRootField = function getPluralRootField(fieldName) {
        var field = this._getRootField(this._readSelector, fieldName, true);
        var storageKey = getStorageKey(field, this._readSelector.variables);
        return this.getOperationRoot().getLinkedRecords(storageKey);
    };
    _proto.invalidateStore = function invalidateStore() {
        this.__recordSource.invalidateStore();
    };
    _proto.readUpdatableQuery = function readUpdatableQuery(query, variables) {
        return _readUpdatableQuery(query, variables, this, this._missingFieldHandlers);
    };
    _proto.readUpdatableFragment = function readUpdatableFragment(fragment, fragmentReference) {
        return _readUpdatableFragment(fragment, fragmentReference, this, this._missingFieldHandlers);
    };
    return RelayRecordSourceSelectorProxy;
}();
module.exports = RelayRecordSourceSelectorProxy;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayPublishQueue.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _global$ErrorUtils$ap, _global$ErrorUtils;
var RelayRecordSourceMutator = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceMutator.js [app-ssr] (ecmascript)");
var RelayRecordSourceProxy = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceProxy.js [app-ssr] (ecmascript)");
var RelayRecordSourceSelectorProxy = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceSelectorProxy.js [app-ssr] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-ssr] (ecmascript)");
var RelayReader = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayReader.js [app-ssr] (ecmascript)");
var RelayRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
var _global = ("TURBOPACK compile-time truthy", 1) ? /*TURBOPACK member replacement*/ __turbopack_context__.g : "TURBOPACK unreachable";
var applyWithGuard = (_global$ErrorUtils$ap = _global === null || _global === void 0 ? void 0 : (_global$ErrorUtils = _global.ErrorUtils) === null || _global$ErrorUtils === void 0 ? void 0 : _global$ErrorUtils.applyWithGuard) !== null && _global$ErrorUtils$ap !== void 0 ? _global$ErrorUtils$ap : function(callback, context, args, onError, name) {
    return callback.apply(context, args);
};
var RelayPublishQueue = /*#__PURE__*/ function() {
    function RelayPublishQueue(store, handlerProvider, getDataID, missingFieldHandlers, log) {
        this._hasStoreSnapshot = false;
        this._handlerProvider = handlerProvider || null;
        this._pendingBackupRebase = false;
        this._pendingData = new Set();
        this._pendingOptimisticUpdates = new Set();
        this._store = store;
        this._appliedOptimisticUpdates = new Set();
        this._gcHold = null;
        this._getDataID = getDataID;
        this._missingFieldHandlers = missingFieldHandlers;
        this._log = log;
    }
    var _proto = RelayPublishQueue.prototype;
    _proto.applyUpdate = function applyUpdate(updater) {
        !(!this._appliedOptimisticUpdates.has(updater) && !this._pendingOptimisticUpdates.has(updater)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayPublishQueue: Cannot apply the same update function more than ' + 'once concurrently.') : "TURBOPACK unreachable" : void 0;
        this._pendingOptimisticUpdates.add(updater);
    };
    _proto.revertUpdate = function revertUpdate(updater) {
        if (this._pendingOptimisticUpdates.has(updater)) {
            this._pendingOptimisticUpdates["delete"](updater);
        } else if (this._appliedOptimisticUpdates.has(updater)) {
            this._pendingBackupRebase = true;
            this._appliedOptimisticUpdates["delete"](updater);
        }
    };
    _proto.revertAll = function revertAll() {
        this._pendingBackupRebase = true;
        this._pendingOptimisticUpdates.clear();
        this._appliedOptimisticUpdates.clear();
    };
    _proto.commitPayload = function commitPayload(operation, payload, updater) {
        this._pendingBackupRebase = true;
        this._pendingData.add({
            kind: 'payload',
            operation: operation,
            payload: payload,
            updater: updater
        });
    };
    _proto.commitUpdate = function commitUpdate(updater) {
        this._pendingBackupRebase = true;
        this._pendingData.add({
            kind: 'updater',
            updater: updater
        });
    };
    _proto.commitSource = function commitSource(source) {
        this._pendingBackupRebase = true;
        this._pendingData.add({
            kind: 'source',
            source: source
        });
    };
    _proto.run = function run(sourceOperation) {
        var runWillClearGcHold = this._appliedOptimisticUpdates === 0 && !!this._gcHold;
        var runIsANoop = !this._pendingBackupRebase && this._pendingOptimisticUpdates.size === 0 && !runWillClearGcHold;
        ("TURBOPACK compile-time truthy", 1) ? warning(!runIsANoop, 'RelayPublishQueue.run was called, but the call would have been a noop.') : "TURBOPACK unreachable";
        RelayFeatureFlags.DISALLOW_NESTED_UPDATES ? !(this._isRunning !== true) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'A store update was detected within another store update. Please ' + "make sure new store updates aren't being executed within an " + 'updater function for a different update.') : "TURBOPACK unreachable" : void 0 : ("TURBOPACK compile-time truthy", 1) ? warning(this._isRunning !== true, 'A store update was detected within another store update. Please ' + "make sure new store updates aren't being executed within an " + 'updater function for a different update.') : "TURBOPACK unreachable";
        this._isRunning = true;
        if (runIsANoop) {
            this._isRunning = false;
            return [];
        }
        if (this._pendingBackupRebase) {
            if (this._hasStoreSnapshot) {
                this._store.restore();
                this._hasStoreSnapshot = false;
            }
        }
        var invalidatedStore = this._commitData();
        if (this._pendingOptimisticUpdates.size || this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {
            if (!this._hasStoreSnapshot) {
                this._store.snapshot();
                this._hasStoreSnapshot = true;
            }
            this._applyUpdates();
        }
        this._pendingBackupRebase = false;
        if (this._appliedOptimisticUpdates.size > 0) {
            if (!this._gcHold) {
                this._gcHold = this._store.holdGC();
            }
        } else {
            if (this._gcHold) {
                this._gcHold.dispose();
                this._gcHold = null;
            }
        }
        this._isRunning = false;
        return this._store.notify(sourceOperation, invalidatedStore);
    };
    _proto._publishSourceFromPayload = function _publishSourceFromPayload(pendingPayload) {
        var _this = this;
        var payload = pendingPayload.payload, operation = pendingPayload.operation, updater = pendingPayload.updater;
        var source = payload.source, fieldPayloads = payload.fieldPayloads;
        var mutator = new RelayRecordSourceMutator(this._store.getSource(), source);
        var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID, this._handlerProvider, this._missingFieldHandlers, this._log);
        if (fieldPayloads && fieldPayloads.length) {
            fieldPayloads.forEach(function(fieldPayload) {
                var handler = _this._handlerProvider && _this._handlerProvider(fieldPayload.handle);
                !handler ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernEnvironment: Expected a handler to be provided for ' + 'handle `%s`.', fieldPayload.handle) : "TURBOPACK unreachable" : void 0;
                handler.update(recordSourceProxy, fieldPayload);
            });
        }
        if (updater) {
            var selector = operation.fragment;
            !(selector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernEnvironment: Expected a selector to be provided with updater function.') : "TURBOPACK unreachable" : void 0;
            var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, selector, this._missingFieldHandlers);
            var selectorData = lookupSelector(source, selector);
            updater(recordSourceSelectorProxy, selectorData);
        }
        var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();
        this._store.publish(source, idsMarkedForInvalidation);
        return recordSourceProxy.isStoreMarkedForInvalidation();
    };
    _proto._commitData = function _commitData() {
        var _this2 = this;
        if (!this._pendingData.size) {
            return false;
        }
        var invalidatedStore = false;
        this._pendingData.forEach(function(data) {
            if (data.kind === 'payload') {
                var payloadInvalidatedStore = _this2._publishSourceFromPayload(data);
                invalidatedStore = invalidatedStore || payloadInvalidatedStore;
            } else if (data.kind === 'source') {
                var source = data.source;
                _this2._store.publish(source);
            } else {
                var updater = data.updater;
                var sink = RelayRecordSource.create();
                var mutator = new RelayRecordSourceMutator(_this2._store.getSource(), sink);
                var recordSourceProxy = new RelayRecordSourceProxy(mutator, _this2._getDataID, _this2._handlerProvider, _this2._missingFieldHandlers, _this2._log);
                applyWithGuard(updater, null, [
                    recordSourceProxy
                ], null, 'RelayPublishQueue:commitData');
                invalidatedStore = invalidatedStore || recordSourceProxy.isStoreMarkedForInvalidation();
                var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();
                _this2._store.publish(sink, idsMarkedForInvalidation);
            }
        });
        this._pendingData.clear();
        return invalidatedStore;
    };
    _proto._applyUpdates = function _applyUpdates() {
        var _this3 = this;
        var sink = RelayRecordSource.create();
        var mutator = new RelayRecordSourceMutator(this._store.getSource(), sink);
        var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID, this._handlerProvider, this._missingFieldHandlers, this._log);
        var processUpdate = function processUpdate(optimisticUpdate) {
            if (optimisticUpdate.storeUpdater) {
                var storeUpdater = optimisticUpdate.storeUpdater;
                applyWithGuard(storeUpdater, null, [
                    recordSourceProxy
                ], null, 'RelayPublishQueue:applyUpdates');
            } else {
                var operation = optimisticUpdate.operation, payload = optimisticUpdate.payload, updater = optimisticUpdate.updater;
                var source = payload.source, fieldPayloads = payload.fieldPayloads;
                if (source) {
                    recordSourceProxy.publishSource(source, fieldPayloads);
                }
                if (updater) {
                    var selectorData;
                    if (source) {
                        selectorData = lookupSelector(source, operation.fragment);
                    }
                    var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, operation.fragment, _this3._missingFieldHandlers);
                    applyWithGuard(updater, null, [
                        recordSourceSelectorProxy,
                        selectorData
                    ], null, 'RelayPublishQueue:applyUpdates');
                }
            }
        };
        if (this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {
            this._appliedOptimisticUpdates.forEach(processUpdate);
        }
        if (this._pendingOptimisticUpdates.size) {
            this._pendingOptimisticUpdates.forEach(function(optimisticUpdate) {
                processUpdate(optimisticUpdate);
                _this3._appliedOptimisticUpdates.add(optimisticUpdate);
            });
            this._pendingOptimisticUpdates.clear();
        }
        this._store.publish(sink);
    };
    return RelayPublishQueue;
}();
function lookupSelector(source, selector) {
    var selectorData = RelayReader.read(source, selector).data;
    if ("TURBOPACK compile-time truthy", 1) {
        var deepFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-ssr] (ecmascript)");
        if (selectorData) {
            deepFreeze(selectorData);
        }
    }
    return selectorData;
}
module.exports = RelayPublishQueue;
}),
"[project]/node_modules/relay-runtime/lib/store/StoreInspector.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-ssr] (ecmascript)"));
var inspect = function inspect() {};
if ("TURBOPACK compile-time truthy", 1) {
    var formattersInstalled = false;
    var installDevtoolFormatters = function installDevtoolFormatters() {
        var _window$devtoolsForma;
        if (formattersInstalled) {
            return;
        }
        formattersInstalled = true;
        if (window.devtoolsFormatters == null) {
            window.devtoolsFormatters = [];
        }
        if (!Array.isArray(window.devtoolsFormatters)) {
            return;
        }
        console.info('Make sure to select "Enable custom formatters" in the Chrome ' + 'Developer Tools settings, tab "Preferences" under the "Console" ' + 'section.');
        (_window$devtoolsForma = window.devtoolsFormatters).push.apply(_window$devtoolsForma, (0, _toConsumableArray2["default"])(createFormatters()));
    };
    var createFormatters = function createFormatters() {
        var listStyle = {
            style: 'list-style-type: none; padding: 0; margin: 0 0 0 12px; font-style: normal'
        };
        var keyStyle = {
            style: 'rgb(136, 19, 145)'
        };
        var nullStyle = {
            style: 'color: #777'
        };
        var reference = function reference(object, config) {
            return object == null ? [
                'span',
                nullStyle,
                'undefined'
            ] : [
                'object',
                {
                    object: object,
                    config: config
                }
            ];
        };
        var renderRecordHeader = function renderRecordHeader(record) {
            return [
                'span',
                {
                    style: 'font-style: italic'
                },
                record.__typename,
                [
                    'span',
                    nullStyle,
                    ' {id: "',
                    record.__id,
                    '", }'
                ]
            ];
        };
        var isRecord = function isRecord(o) {
            return o != null && typeof o.__id === 'string';
        };
        var RecordEntry = function RecordEntry(key, value) {
            this.key = key;
            this.value = value;
        };
        var renderRecordEntries = function renderRecordEntries(record) {
            var children = Object.keys(record).map(function(key) {
                return [
                    'li',
                    {},
                    [
                        'object',
                        {
                            object: new RecordEntry(key, record[key])
                        }
                    ]
                ];
            });
            return [
                'ol',
                listStyle
            ].concat((0, _toConsumableArray2["default"])(children));
        };
        var recordFormatter = {
            header: function header(obj) {
                if (!isRecord(obj)) {
                    return null;
                }
                return renderRecordHeader(obj);
            },
            hasBody: function hasBody(obj) {
                return true;
            },
            body: function body(obj) {
                return renderRecordEntries(obj);
            }
        };
        var recordEntryFormatter = {
            header: function header(obj) {
                if (obj instanceof RecordEntry) {
                    var value = isRecord(obj.value) ? renderRecordHeader(obj.value) : reference(obj.value);
                    return [
                        'span',
                        keyStyle,
                        obj.key,
                        ': ',
                        value
                    ];
                }
                return null;
            },
            hasBody: function hasBody(obj) {
                return isRecord(obj.value);
            },
            body: function body(obj) {
                return renderRecordEntries(obj.value);
            }
        };
        return [
            recordFormatter,
            recordEntryFormatter
        ];
    };
    var getWrappedRecord = function getWrappedRecord(source, dataID) {
        var record = source.get(dataID);
        if (record == null) {
            return record;
        }
        return new Proxy((0, _objectSpread2["default"])({}, record), {
            get: function get(target, prop) {
                var value = target[prop];
                if (value == null) {
                    return value;
                }
                if (typeof value === 'object') {
                    if (typeof value.__ref === 'string') {
                        return getWrappedRecord(source, value.__ref);
                    }
                    if (Array.isArray(value.__refs)) {
                        return value.__refs.map(function(ref) {
                            return getWrappedRecord(source, ref);
                        });
                    }
                }
                return value;
            }
        });
    };
    inspect = function inspect(environment, dataID) {
        installDevtoolFormatters();
        return getWrappedRecord(environment.getStore().getSource(), dataID !== null && dataID !== void 0 ? dataID : 'client:root');
    };
}
module.exports = {
    inspect: inspect
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayModernEnvironment.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var RelayDefaultHandlerProvider = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/RelayDefaultHandlerProvider.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/multi-actor-environment/ActorIdentifier.js [app-ssr] (ecmascript)"), INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE = _require.INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE, assertInternalActorIdentifier = _require.assertInternalActorIdentifier;
var RelayObservable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-ssr] (ecmascript)");
var wrapNetworkWithLogObserver = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/wrapNetworkWithLogObserver.js [app-ssr] (ecmascript)");
var RelayOperationTracker = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayOperationTracker.js [app-ssr] (ecmascript)");
var registerEnvironmentWithDevTools = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/registerEnvironmentWithDevTools.js [app-ssr] (ecmascript)");
var defaultGetDataID = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/defaultGetDataID.js [app-ssr] (ecmascript)");
var defaultRelayFieldLogger = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/defaultRelayFieldLogger.js [app-ssr] (ecmascript)");
var normalizeResponse = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/normalizeResponse.js [app-ssr] (ecmascript)");
var OperationExecutor = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/OperationExecutor.js [app-ssr] (ecmascript)");
var RelayModernStore = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernStore.js [app-ssr] (ecmascript)");
var RelayPublishQueue = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayPublishQueue.js [app-ssr] (ecmascript)");
var RelayRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var RelayModernEnvironment = /*#__PURE__*/ function() {
    function RelayModernEnvironment(config) {
        var _this = this;
        var _config$store, _config$log, _config$relayFieldLog, _config$UNSTABLE_defa, _config$getDataID, _config$missingFieldH, _config$handlerProvid, _config$scheduler, _config$isServer, _config$normalizeResp, _config$operationTrac;
        this.configName = config.configName;
        this._treatMissingFieldsAsNull = config.treatMissingFieldsAsNull === true;
        var operationLoader = config.operationLoader;
        if ("TURBOPACK compile-time truthy", 1) {
            if (operationLoader != null) {
                !(typeof operationLoader === 'object' && typeof operationLoader.get === 'function' && typeof operationLoader.load === 'function') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernEnvironment: Expected `operationLoader` to be an object ' + 'with get() and load() functions, got `%s`.', operationLoader) : "TURBOPACK unreachable" : void 0;
            }
        }
        var store = (_config$store = config.store) !== null && _config$store !== void 0 ? _config$store : new RelayModernStore(new RelayRecordSource(), {
            log: config.log,
            operationLoader: config.operationLoader,
            getDataID: config.getDataID,
            shouldProcessClientComponents: config.shouldProcessClientComponents
        });
        this.__log = (_config$log = config.log) !== null && _config$log !== void 0 ? _config$log : emptyFunction;
        this.relayFieldLogger = (_config$relayFieldLog = config.relayFieldLogger) !== null && _config$relayFieldLog !== void 0 ? _config$relayFieldLog : defaultRelayFieldLogger;
        this._defaultRenderPolicy = (_config$UNSTABLE_defa = config.UNSTABLE_defaultRenderPolicy) !== null && _config$UNSTABLE_defa !== void 0 ? _config$UNSTABLE_defa : 'partial';
        this._operationLoader = operationLoader;
        this._operationExecutions = new Map();
        this._network = wrapNetworkWithLogObserver(this, config.network);
        this._getDataID = (_config$getDataID = config.getDataID) !== null && _config$getDataID !== void 0 ? _config$getDataID : defaultGetDataID;
        this._missingFieldHandlers = (_config$missingFieldH = config.missingFieldHandlers) !== null && _config$missingFieldH !== void 0 ? _config$missingFieldH : [];
        this._publishQueue = new RelayPublishQueue(store, (_config$handlerProvid = config.handlerProvider) !== null && _config$handlerProvid !== void 0 ? _config$handlerProvid : RelayDefaultHandlerProvider, this._getDataID, this._missingFieldHandlers, this.__log);
        this._scheduler = (_config$scheduler = config.scheduler) !== null && _config$scheduler !== void 0 ? _config$scheduler : null;
        this._store = store;
        this.options = config.options;
        this._isServer = (_config$isServer = config.isServer) !== null && _config$isServer !== void 0 ? _config$isServer : false;
        this._normalizeResponse = (_config$normalizeResp = config.normalizeResponse) !== null && _config$normalizeResp !== void 0 ? _config$normalizeResp : normalizeResponse;
        this.__setNet = function(newNet) {
            return _this._network = wrapNetworkWithLogObserver(_this, newNet);
        };
        if ("TURBOPACK compile-time truthy", 1) {
            var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/StoreInspector.js [app-ssr] (ecmascript)"), inspect = _require2.inspect;
            this.DEBUG_inspect = function(dataID) {
                return inspect(_this, dataID);
            };
        }
        this._operationTracker = (_config$operationTrac = config.operationTracker) !== null && _config$operationTrac !== void 0 ? _config$operationTrac : new RelayOperationTracker();
        this._shouldProcessClientComponents = config.shouldProcessClientComponents;
        registerEnvironmentWithDevTools(this);
    }
    var _proto = RelayModernEnvironment.prototype;
    _proto.getStore = function getStore() {
        return this._store;
    };
    _proto.getNetwork = function getNetwork() {
        return this._network;
    };
    _proto.getOperationTracker = function getOperationTracker() {
        return this._operationTracker;
    };
    _proto.getScheduler = function getScheduler() {
        return this._scheduler;
    };
    _proto.isRequestActive = function isRequestActive(requestIdentifier) {
        var activeState = this._operationExecutions.get(requestIdentifier);
        return activeState === 'active';
    };
    _proto.UNSTABLE_getDefaultRenderPolicy = function UNSTABLE_getDefaultRenderPolicy() {
        return this._defaultRenderPolicy;
    };
    _proto.applyUpdate = function applyUpdate(optimisticUpdate) {
        var _this2 = this;
        var dispose = function dispose() {
            _this2._scheduleUpdates(function() {
                _this2._publishQueue.revertUpdate(optimisticUpdate);
                _this2._publishQueue.run();
            });
        };
        this._scheduleUpdates(function() {
            _this2._publishQueue.applyUpdate(optimisticUpdate);
            _this2._publishQueue.run();
        });
        return {
            dispose: dispose
        };
    };
    _proto.revertUpdate = function revertUpdate(update) {
        var _this3 = this;
        this._scheduleUpdates(function() {
            _this3._publishQueue.revertUpdate(update);
            _this3._publishQueue.run();
        });
    };
    _proto.replaceUpdate = function replaceUpdate(update, newUpdate) {
        var _this4 = this;
        this._scheduleUpdates(function() {
            _this4._publishQueue.revertUpdate(update);
            _this4._publishQueue.applyUpdate(newUpdate);
            _this4._publishQueue.run();
        });
    };
    _proto.applyMutation = function applyMutation(optimisticConfig) {
        var subscription = this._execute({
            createSource: function createSource() {
                return RelayObservable.create(function(_sink) {});
            },
            isClientPayload: false,
            operation: optimisticConfig.operation,
            optimisticConfig: optimisticConfig,
            updater: null
        }).subscribe({});
        return {
            dispose: function dispose() {
                return subscription.unsubscribe();
            }
        };
    };
    _proto.check = function check(operation) {
        if (this._missingFieldHandlers.length === 0 && !operationHasClientAbstractTypes(operation)) {
            return this._store.check(operation);
        }
        return this._checkSelectorAndHandleMissingFields(operation, this._missingFieldHandlers);
    };
    _proto.commitPayload = function commitPayload(operation, payload) {
        this._execute({
            createSource: function createSource() {
                return RelayObservable.from({
                    data: payload
                });
            },
            isClientPayload: true,
            operation: operation,
            optimisticConfig: null,
            updater: null
        }).subscribe({});
    };
    _proto.commitUpdate = function commitUpdate(updater) {
        var _this5 = this;
        this._scheduleUpdates(function() {
            _this5._publishQueue.commitUpdate(updater);
            _this5._publishQueue.run();
        });
    };
    _proto.lookup = function lookup(readSelector) {
        return this._store.lookup(readSelector);
    };
    _proto.subscribe = function subscribe(snapshot, callback) {
        return this._store.subscribe(snapshot, callback);
    };
    _proto.retain = function retain(operation) {
        return this._store.retain(operation);
    };
    _proto.isServer = function isServer() {
        return this._isServer;
    };
    _proto._checkSelectorAndHandleMissingFields = function _checkSelectorAndHandleMissingFields(operation, handlers) {
        var _this6 = this;
        var target = RelayRecordSource.create();
        var source = this._store.getSource();
        var result = this._store.check(operation, {
            handlers: handlers,
            defaultActorIdentifier: INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE,
            getSourceForActor: function getSourceForActor(actorIdentifier) {
                assertInternalActorIdentifier(actorIdentifier);
                return source;
            },
            getTargetForActor: function getTargetForActor(actorIdentifier) {
                assertInternalActorIdentifier(actorIdentifier);
                return target;
            }
        });
        if (target.size() > 0) {
            this._scheduleUpdates(function() {
                _this6._publishQueue.commitSource(target);
                _this6._publishQueue.run();
            });
        }
        return result;
    };
    _proto._scheduleUpdates = function _scheduleUpdates(task) {
        var scheduler = this._scheduler;
        if (scheduler != null) {
            scheduler.schedule(task);
        } else {
            task();
        }
    };
    _proto.execute = function execute(_ref) {
        var _this7 = this;
        var operation = _ref.operation;
        return this._execute({
            createSource: function createSource() {
                return _this7.getNetwork().execute(operation.request.node.params, operation.request.variables, operation.request.cacheConfig || {}, null, undefined, undefined, undefined, function() {
                    return _this7.check(operation);
                });
            },
            isClientPayload: false,
            operation: operation,
            optimisticConfig: null,
            updater: null
        });
    };
    _proto.executeSubscription = function executeSubscription(_ref2) {
        var _this8 = this;
        var operation = _ref2.operation, updater = _ref2.updater;
        return this._execute({
            createSource: function createSource() {
                return _this8.getNetwork().execute(operation.request.node.params, operation.request.variables, operation.request.cacheConfig || {}, null);
            },
            isClientPayload: false,
            operation: operation,
            optimisticConfig: null,
            updater: updater
        });
    };
    _proto.executeMutation = function executeMutation(_ref3) {
        var _this9 = this;
        var operation = _ref3.operation, optimisticResponse = _ref3.optimisticResponse, optimisticUpdater = _ref3.optimisticUpdater, updater = _ref3.updater, uploadables = _ref3.uploadables;
        var optimisticConfig;
        if (optimisticResponse || optimisticUpdater) {
            optimisticConfig = {
                operation: operation,
                response: optimisticResponse,
                updater: optimisticUpdater
            };
        }
        return this._execute({
            createSource: function createSource() {
                return _this9.getNetwork().execute(operation.request.node.params, operation.request.variables, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, operation.request.cacheConfig), {}, {
                    force: true
                }), uploadables);
            },
            isClientPayload: false,
            operation: operation,
            optimisticConfig: optimisticConfig,
            updater: updater
        });
    };
    _proto.executeWithSource = function executeWithSource(_ref4) {
        var operation = _ref4.operation, source = _ref4.source;
        return this._execute({
            createSource: function createSource() {
                return source;
            },
            isClientPayload: false,
            operation: operation,
            optimisticConfig: null,
            updater: null
        });
    };
    _proto.toJSON = function toJSON() {
        var _this$configName;
        return "RelayModernEnvironment(".concat((_this$configName = this.configName) !== null && _this$configName !== void 0 ? _this$configName : '', ")");
    };
    _proto._execute = function _execute(_ref5) {
        var _this10 = this;
        var createSource = _ref5.createSource, isClientPayload = _ref5.isClientPayload, operation = _ref5.operation, optimisticConfig = _ref5.optimisticConfig, updater = _ref5.updater;
        var publishQueue = this._publishQueue;
        var store = this._store;
        return RelayObservable.create(function(sink) {
            var executor = OperationExecutor.execute({
                actorIdentifier: INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE,
                getDataID: _this10._getDataID,
                isClientPayload: isClientPayload,
                log: _this10.__log,
                operation: operation,
                operationExecutions: _this10._operationExecutions,
                operationLoader: _this10._operationLoader,
                operationTracker: _this10._operationTracker,
                optimisticConfig: optimisticConfig,
                getPublishQueue: function getPublishQueue(actorIdentifier) {
                    assertInternalActorIdentifier(actorIdentifier);
                    return publishQueue;
                },
                scheduler: _this10._scheduler,
                shouldProcessClientComponents: _this10._shouldProcessClientComponents,
                sink: sink,
                source: createSource(),
                getStore: function getStore(actorIdentifier) {
                    assertInternalActorIdentifier(actorIdentifier);
                    return store;
                },
                treatMissingFieldsAsNull: _this10._treatMissingFieldsAsNull,
                updater: updater,
                normalizeResponse: _this10._normalizeResponse
            });
            return function() {
                return executor.cancel();
            };
        });
    };
    return RelayModernEnvironment;
}();
function operationHasClientAbstractTypes(operation) {
    return operation.root.node.kind === 'Operation' && operation.root.node.clientAbstractTypes != null;
}
RelayModernEnvironment.prototype['@@RelayModernEnvironment'] = true;
function emptyFunction() {}
module.exports = RelayModernEnvironment;
}),
"[project]/node_modules/relay-runtime/lib/subscription/requestSubscription.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayDeclarativeMutationConfig = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayDeclarativeMutationConfig.js [app-ssr] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-ssr] (ecmascript)"), getRequest = _require.getRequest;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-ssr] (ecmascript)"), createOperationDescriptor = _require2.createOperationDescriptor;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-ssr] (ecmascript)"), createReaderSelector = _require3.createReaderSelector;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function requestSubscription(environment, config) {
    var subscription = getRequest(config.subscription);
    if (subscription.params.operationKind !== 'subscription') {
        throw new Error('requestSubscription: Must use Subscription operation');
    }
    var configs = config.configs, onCompleted = config.onCompleted, onError = config.onError, onNext = config.onNext, variables = config.variables, cacheConfig = config.cacheConfig;
    var operation = createOperationDescriptor(subscription, variables, cacheConfig);
    ("TURBOPACK compile-time truthy", 1) ? warning(!(config.updater && configs), 'requestSubscription: Expected only one of `updater` and `configs` to be provided') : "TURBOPACK unreachable";
    var _ref = configs ? RelayDeclarativeMutationConfig.convert(configs, subscription, null, config.updater) : config, updater = _ref.updater;
    var sub = environment.executeSubscription({
        operation: operation,
        updater: updater
    }).subscribe({
        next: function next(responses) {
            if (onNext != null) {
                var selector = operation.fragment;
                var nextID;
                if (Array.isArray(responses)) {
                    var _responses$, _responses$$extension;
                    nextID = (_responses$ = responses[0]) === null || _responses$ === void 0 ? void 0 : (_responses$$extension = _responses$.extensions) === null || _responses$$extension === void 0 ? void 0 : _responses$$extension.__relay_subscription_root_id;
                } else {
                    var _responses$extensions;
                    nextID = (_responses$extensions = responses.extensions) === null || _responses$extensions === void 0 ? void 0 : _responses$extensions.__relay_subscription_root_id;
                }
                if (typeof nextID === 'string') {
                    selector = createReaderSelector(selector.node, nextID, selector.variables, selector.owner);
                }
                var data = environment.lookup(selector).data;
                onNext(data);
            }
        },
        error: onError,
        complete: onCompleted
    });
    return {
        dispose: sub.unsubscribe
    };
}
module.exports = requestSubscription;
}),
"[project]/node_modules/relay-runtime/lib/util/createPayloadFor3DField.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)"), getModuleComponentKey = _require.getModuleComponentKey, getModuleOperationKey = _require.getModuleOperationKey;
function createPayloadFor3DField(name, operation, component, response) {
    var data = (0, _objectSpread2["default"])({}, response);
    data[getModuleComponentKey(name)] = component;
    data[getModuleOperationKey(name)] = operation;
    return data;
}
module.exports = createPayloadFor3DField;
}),
"[project]/node_modules/relay-runtime/lib/util/isEmptyObject.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var hasOwnProperty = Object.prototype.hasOwnProperty;
function isEmptyObject(obj) {
    for(var _key in obj){
        if (hasOwnProperty.call(obj, _key)) {
            return false;
        }
    }
    return true;
}
module.exports = isEmptyObject;
}),
"[project]/node_modules/relay-runtime/lib/util/getFragmentIdentifier.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-ssr] (ecmascript)"), getDataIDsFromFragment = _require.getDataIDsFromFragment, getSelector = _require.getSelector, getVariablesFromFragment = _require.getVariablesFromFragment;
var isEmptyObject = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/isEmptyObject.js [app-ssr] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-ssr] (ecmascript)"), stableCopy = _require2.stableCopy;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/StringInterner.js [app-ssr] (ecmascript)"), intern = _require3.intern;
function getFragmentIdentifier(fragmentNode, fragmentRef) {
    var selector = getSelector(fragmentNode, fragmentRef);
    var fragmentOwnerIdentifier = selector == null ? 'null' : selector.kind === 'SingularReaderSelector' ? selector.owner.identifier : '[' + selector.selectors.map(function(sel) {
        return sel.owner.identifier;
    }).join(',') + ']';
    var fragmentVariables = getVariablesFromFragment(fragmentNode, fragmentRef);
    var dataIDs = getDataIDsFromFragment(fragmentNode, fragmentRef);
    if (RelayFeatureFlags.ENABLE_GETFRAGMENTIDENTIFIER_OPTIMIZATION) {
        var ids = typeof dataIDs === 'undefined' ? 'missing' : dataIDs == null ? 'null' : Array.isArray(dataIDs) ? '[' + dataIDs.join(',') + ']' : dataIDs;
        ids = RelayFeatureFlags.STRING_INTERN_LEVEL <= 1 ? ids : intern(ids, RelayFeatureFlags.MAX_DATA_ID_LENGTH);
        return fragmentOwnerIdentifier + '/' + fragmentNode.name + '/' + (fragmentVariables == null || isEmptyObject(fragmentVariables) ? '{}' : JSON.stringify(stableCopy(fragmentVariables))) + '/' + ids;
    } else {
        var _JSON$stringify;
        var _ids = (_JSON$stringify = JSON.stringify(dataIDs)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'missing';
        _ids = RelayFeatureFlags.STRING_INTERN_LEVEL <= 1 ? _ids : intern(_ids, RelayFeatureFlags.MAX_DATA_ID_LENGTH);
        return fragmentOwnerIdentifier + '/' + fragmentNode.name + '/' + JSON.stringify(stableCopy(fragmentVariables)) + '/' + _ids;
    }
}
module.exports = getFragmentIdentifier;
}),
"[project]/node_modules/relay-runtime/lib/util/getRefetchMetadata.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function getRefetchMetadata(fragmentNode, componentDisplayName) {
    var _fragmentNode$metadat, _fragmentNode$metadat2;
    !(((_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) !== true) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getRefetchMetadata(): Expected fragment `%s` not to be plural when using ' + '`%s`. Remove `@relay(plural: true)` from fragment `%s` ' + 'in order to use it with `%s`.', fragmentNode.name, componentDisplayName, fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable" : void 0;
    var refetchMetadata = (_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.refetch;
    !(refetchMetadata != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getRefetchMetadata(): Expected fragment `%s` to be refetchable when using `%s`. ' + 'Did you forget to add a @refetchable directive to the fragment?', componentDisplayName, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    var refetchableRequest = refetchMetadata.operation["default"] ? refetchMetadata.operation["default"] : refetchMetadata.operation;
    var fragmentRefPathInResponse = refetchMetadata.fragmentPathInResult;
    !(typeof refetchableRequest !== 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getRefetchMetadata(): Expected refetch query to be an ' + "operation and not a string when using `%s`. If you're seeing this, " + 'this is likely a bug in Relay.', componentDisplayName) : "TURBOPACK unreachable" : void 0;
    var identifierInfo = refetchMetadata.identifierInfo;
    if (identifierInfo != null) {
        !(identifierInfo.identifierField == null || typeof identifierInfo.identifierField === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getRefetchMetadata(): Expected `identifierField` to be a string.') : "TURBOPACK unreachable" : void 0;
        !(identifierInfo.identifierQueryVariableName == null || typeof identifierInfo.identifierQueryVariableName === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getRefetchMetadata(): Expected `identifierQueryVariableName` to be a string.') : "TURBOPACK unreachable" : void 0;
    }
    return {
        fragmentRefPathInResponse: fragmentRefPathInResponse,
        identifierInfo: identifierInfo,
        refetchableRequest: refetchableRequest,
        refetchMetadata: refetchMetadata
    };
}
module.exports = getRefetchMetadata;
}),
"[project]/node_modules/relay-runtime/lib/util/getPaginationMetadata.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var getRefetchMetadata = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRefetchMetadata.js [app-ssr] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function getPaginationMetadata(fragmentNode, componentDisplayName) {
    var _fragmentNode$metadat, _fragmentNode$metadat2;
    var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName), paginationRequest = _getRefetchMetadata.refetchableRequest, refetchMetadata = _getRefetchMetadata.refetchMetadata;
    var paginationMetadata = refetchMetadata.connection;
    !(paginationMetadata != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getPaginationMetadata(): Expected fragment `%s` to include a ' + 'connection when using `%s`. Did you forget to add a @connection ' + 'directive to the connection field in the fragment?', componentDisplayName, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    var connectionPathInFragmentData = paginationMetadata.path;
    var connectionMetadata = ((_fragmentNode$metadat = (_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.connection) !== null && _fragmentNode$metadat !== void 0 ? _fragmentNode$metadat : [])[0];
    !(connectionMetadata != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getPaginationMetadata(): Expected fragment `%s` to include a ' + 'connection when using `%s`. Did you forget to add a @connection ' + 'directive to the connection field in the fragment?', componentDisplayName, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    var identifierInfo = refetchMetadata.identifierInfo;
    !((identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField) == null || typeof identifierInfo.identifierField === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getRefetchMetadata(): Expected `identifierField` to be a string.') : "TURBOPACK unreachable" : void 0;
    return {
        connectionPathInFragmentData: connectionPathInFragmentData,
        identifierField: identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField,
        paginationRequest: paginationRequest,
        paginationMetadata: paginationMetadata,
        stream: connectionMetadata.stream === true
    };
}
module.exports = getPaginationMetadata;
}),
"[project]/node_modules/relay-runtime/lib/util/getPaginationVariables.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)"));
var _objectSpread4 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)"));
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-ssr] (ecmascript)");
function getPaginationVariables(direction, count, cursor, baseVariables, extraVariables, paginationMetadata) {
    var _objectSpread3;
    var backwardMetadata = paginationMetadata.backward, forwardMetadata = paginationMetadata.forward;
    if (direction === 'backward') {
        var _objectSpread2;
        !(backwardMetadata != null && backwardMetadata.count != null && backwardMetadata.cursor != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected backward pagination metadata to be available. ' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable" : void 0;
        ("TURBOPACK compile-time truthy", 1) ? warning(!extraVariables.hasOwnProperty(backwardMetadata.cursor), 'Relay: `UNSTABLE_extraVariables` provided by caller should not ' + 'contain cursor variable `%s`. This variable is automatically ' + 'determined by Relay.', backwardMetadata.cursor) : "TURBOPACK unreachable";
        ("TURBOPACK compile-time truthy", 1) ? warning(!extraVariables.hasOwnProperty(backwardMetadata.count), 'Relay: `UNSTABLE_extraVariables` provided by caller should not ' + 'contain count variable `%s`. This variable is automatically ' + 'determined by Relay.', backwardMetadata.count) : "TURBOPACK unreachable";
        var _paginationVariables = (0, _objectSpread4["default"])((0, _objectSpread4["default"])((0, _objectSpread4["default"])({}, baseVariables), extraVariables), {}, (_objectSpread2 = {}, (0, _defineProperty2["default"])(_objectSpread2, backwardMetadata.cursor, cursor), (0, _defineProperty2["default"])(_objectSpread2, backwardMetadata.count, count), _objectSpread2));
        if (forwardMetadata && forwardMetadata.cursor) {
            _paginationVariables[forwardMetadata.cursor] = null;
        }
        if (forwardMetadata && forwardMetadata.count) {
            _paginationVariables[forwardMetadata.count] = null;
        }
        return _paginationVariables;
    }
    !(forwardMetadata != null && forwardMetadata.count != null && forwardMetadata.cursor != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected forward pagination metadata to be available. ' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable" : void 0;
    ("TURBOPACK compile-time truthy", 1) ? warning(!extraVariables.hasOwnProperty(forwardMetadata.cursor), 'Relay: `UNSTABLE_extraVariables` provided by caller should not ' + 'contain cursor variable `%s`. This variable is automatically ' + 'determined by Relay.', forwardMetadata.cursor) : "TURBOPACK unreachable";
    ("TURBOPACK compile-time truthy", 1) ? warning(!extraVariables.hasOwnProperty(forwardMetadata.count), 'Relay: `UNSTABLE_extraVariables` provided by caller should not ' + 'contain count variable `%s`. This variable is automatically ' + 'determined by Relay.', forwardMetadata.count) : "TURBOPACK unreachable";
    var paginationVariables = (0, _objectSpread4["default"])((0, _objectSpread4["default"])((0, _objectSpread4["default"])({}, baseVariables), extraVariables), {}, (_objectSpread3 = {}, (0, _defineProperty2["default"])(_objectSpread3, forwardMetadata.cursor, cursor), (0, _defineProperty2["default"])(_objectSpread3, forwardMetadata.count, count), _objectSpread3));
    if (backwardMetadata && backwardMetadata.cursor) {
        paginationVariables[backwardMetadata.cursor] = null;
    }
    if (backwardMetadata && backwardMetadata.count) {
        paginationVariables[backwardMetadata.count] = null;
    }
    return paginationVariables;
}
module.exports = getPaginationVariables;
}),
"[project]/node_modules/relay-runtime/lib/util/getValueAtPath.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-ssr] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-ssr] (ecmascript)"));
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-ssr] (ecmascript)");
function getValueAtPath(data, path) {
    var result = data;
    var _iterator = (0, _createForOfIteratorHelper2["default"])(path), _step;
    try {
        for(_iterator.s(); !(_step = _iterator.n()).done;){
            var key = _step.value;
            if (result == null) {
                return null;
            }
            if (typeof key === 'number') {
                !Array.isArray(result) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected an array when extracting value at path. ' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable" : void 0;
                result = result[key];
            } else {
                !(typeof result === 'object' && !Array.isArray(result)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected an object when extracting value at path. ' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable" : void 0;
                result = result[key];
            }
        }
    } catch (err) {
        _iterator.e(err);
    } finally{
        _iterator.f();
    }
    return result;
}
module.exports = getValueAtPath;
}),
"[project]/node_modules/relay-runtime/lib/util/RelayProfiler.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var profileHandlersByName = {};
var defaultProfiler = {
    stop: function stop() {}
};
var RelayProfiler = {
    profile: function profile(name, state) {
        var handlers = profileHandlersByName[name];
        if (handlers && handlers.length > 0) {
            var stopHandlers = [];
            for(var ii = handlers.length - 1; ii >= 0; ii--){
                var stopHandler = handlers[ii](name, state);
                stopHandlers.unshift(stopHandler);
            }
            return {
                stop: function stop(error) {
                    stopHandlers.forEach(function(stopHandler) {
                        return stopHandler(error);
                    });
                }
            };
        }
        return defaultProfiler;
    },
    attachProfileHandler: function attachProfileHandler(name, handler) {
        if (!profileHandlersByName.hasOwnProperty(name)) {
            profileHandlersByName[name] = [];
        }
        profileHandlersByName[name].push(handler);
    },
    detachProfileHandler: function detachProfileHandler(name, handler) {
        if (profileHandlersByName.hasOwnProperty(name)) {
            removeFromArray(profileHandlersByName[name], handler);
        }
    }
};
function removeFromArray(array, element) {
    var index = array.indexOf(element);
    if (index !== -1) {
        array.splice(index, 1);
    }
}
module.exports = RelayProfiler;
}),
"[project]/node_modules/relay-runtime/lib/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/experimental.js [app-ssr] (ecmascript)"), isErrorResult = _require.isErrorResult, isValueResult = _require.isValueResult;
var ConnectionHandler = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js [app-ssr] (ecmascript)");
var ConnectionInterface = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionInterface.js [app-ssr] (ecmascript)");
var MutationHandlers = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/MutationHandlers.js [app-ssr] (ecmascript)");
var RelayDefaultHandlerProvider = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/RelayDefaultHandlerProvider.js [app-ssr] (ecmascript)");
var applyOptimisticMutation = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/applyOptimisticMutation.js [app-ssr] (ecmascript)");
var commitLocalUpdate = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/commitLocalUpdate.js [app-ssr] (ecmascript)");
var commitMutation = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/commitMutation.js [app-ssr] (ecmascript)");
var RelayDeclarativeMutationConfig = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayDeclarativeMutationConfig.js [app-ssr] (ecmascript)");
var RelayNetwork = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayNetwork.js [app-ssr] (ecmascript)");
var RelayObservable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-ssr] (ecmascript)");
var RelayQueryResponseCache = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayQueryResponseCache.js [app-ssr] (ecmascript)");
var fetchQuery = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/fetchQuery.js [app-ssr] (ecmascript)");
var fetchQuery_DEPRECATED = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/fetchQuery_DEPRECATED.js [app-ssr] (ecmascript)");
var fetchQueryInternal = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/fetchQueryInternal.js [app-ssr] (ecmascript)");
var GraphQLTag = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-ssr] (ecmascript)");
var PreloadableQueryRegistry = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/PreloadableQueryRegistry.js [app-ssr] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-ssr] (ecmascript)"), generateClientID = _require2.generateClientID, generateUniqueClientID = _require2.generateUniqueClientID, isClientID = _require2.isClientID;
var createFragmentSpecResolver = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/createFragmentSpecResolver.js [app-ssr] (ecmascript)");
var createRelayContext = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/createRelayContext.js [app-ssr] (ecmascript)");
var createRelayLoggingContext = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/createRelayLoggingContext.js [app-ssr] (ecmascript)");
var isRelayModernEnvironment = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/isRelayModernEnvironment.js [app-ssr] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverSuspenseSentinel.js [app-ssr] (ecmascript)"), isSuspenseSentinel = _require3.isSuspenseSentinel, suspenseSentinel = _require3.suspenseSentinel;
var normalizeResponse = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/normalizeResponse.js [app-ssr] (ecmascript)");
var readInlineData = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/readInlineData.js [app-ssr] (ecmascript)");
var RelayConcreteVariables = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-ssr] (ecmascript)");
var RelayModernEnvironment = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernEnvironment.js [app-ssr] (ecmascript)");
var RelayModernOperationDescriptor = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-ssr] (ecmascript)");
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-ssr] (ecmascript)");
var RelayModernSelector = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-ssr] (ecmascript)");
var RelayModernStore = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernStore.js [app-ssr] (ecmascript)");
var RelayOperationTracker = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayOperationTracker.js [app-ssr] (ecmascript)");
var RelayRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-ssr] (ecmascript)");
var RelayStoreUtils = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-ssr] (ecmascript)");
var ResolverFragments = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ResolverFragments.js [app-ssr] (ecmascript)");
var ViewerPattern = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ViewerPattern.js [app-ssr] (ecmascript)");
var requestSubscription = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/subscription/requestSubscription.js [app-ssr] (ecmascript)");
var createPayloadFor3DField = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/createPayloadFor3DField.js [app-ssr] (ecmascript)");
var deepFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-ssr] (ecmascript)");
var getFragmentIdentifier = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getFragmentIdentifier.js [app-ssr] (ecmascript)");
var getPaginationMetadata = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getPaginationMetadata.js [app-ssr] (ecmascript)");
var getPaginationVariables = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getPaginationVariables.js [app-ssr] (ecmascript)");
var getPendingOperationsForFragment = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getPendingOperationsForFragment.js [app-ssr] (ecmascript)");
var getRefetchMetadata = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRefetchMetadata.js [app-ssr] (ecmascript)");
var getRelayHandleKey = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRelayHandleKey.js [app-ssr] (ecmascript)");
var getRequestIdentifier = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRequestIdentifier.js [app-ssr] (ecmascript)");
var getValueAtPath = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getValueAtPath.js [app-ssr] (ecmascript)");
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js [app-ssr] (ecmascript)"), handlePotentialSnapshotErrors = _require4.handlePotentialSnapshotErrors;
var isPromise = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/isPromise.js [app-ssr] (ecmascript)");
var isScalarAndEqual = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/isScalarAndEqual.js [app-ssr] (ecmascript)");
var recycleNodesInto = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/recycleNodesInto.js [app-ssr] (ecmascript)");
var RelayConcreteNode = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-ssr] (ecmascript)");
var RelayDefaultHandleKey = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayDefaultHandleKey.js [app-ssr] (ecmascript)");
var RelayError = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayError.js [app-ssr] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-ssr] (ecmascript)");
var RelayProfiler = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayProfiler.js [app-ssr] (ecmascript)");
var RelayReplaySubject = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayReplaySubject.js [app-ssr] (ecmascript)");
var _require5 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-ssr] (ecmascript)"), hasCycle = _require5.hasCycle, stableCopy = _require5.stableCopy;
var withProvidedVariables = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/withProvidedVariables.js [app-ssr] (ecmascript)");
if ("TURBOPACK compile-time truthy", 1) {
    var mapStr = typeof Map !== 'function' ? 'Map' : null;
    var setStr = typeof Set !== 'function' ? 'Set' : null;
    var promiseStr = typeof Promise !== 'function' ? 'Promise' : null;
    var objStr = typeof Object.assign !== 'function' ? 'Object.assign' : null;
    if (mapStr || setStr || promiseStr || objStr) {
        throw new Error("relay-runtime requires ".concat([
            mapStr,
            setStr,
            promiseStr,
            objStr
        ].filter(Boolean).join(', and '), " to exist. ") + 'Use a polyfill to provide these for older browsers.');
    }
}
module.exports = {
    Environment: RelayModernEnvironment,
    Network: RelayNetwork,
    Observable: RelayObservable,
    QueryResponseCache: RelayQueryResponseCache,
    RecordSource: RelayRecordSource,
    Record: RelayModernRecord,
    ReplaySubject: RelayReplaySubject,
    Store: RelayModernStore,
    areEqualSelectors: RelayModernSelector.areEqualSelectors,
    createFragmentSpecResolver: createFragmentSpecResolver,
    createNormalizationSelector: RelayModernSelector.createNormalizationSelector,
    createOperationDescriptor: RelayModernOperationDescriptor.createOperationDescriptor,
    createReaderSelector: RelayModernSelector.createReaderSelector,
    createRequestDescriptor: RelayModernOperationDescriptor.createRequestDescriptor,
    getArgumentValues: RelayStoreUtils.getArgumentValues,
    getDataIDsFromFragment: RelayModernSelector.getDataIDsFromFragment,
    getDataIDsFromObject: RelayModernSelector.getDataIDsFromObject,
    getNode: GraphQLTag.getNode,
    getFragment: GraphQLTag.getFragment,
    getInlineDataFragment: GraphQLTag.getInlineDataFragment,
    getModuleComponentKey: RelayStoreUtils.getModuleComponentKey,
    getModuleOperationKey: RelayStoreUtils.getModuleOperationKey,
    getPaginationFragment: GraphQLTag.getPaginationFragment,
    getPluralSelector: RelayModernSelector.getPluralSelector,
    getRefetchableFragment: GraphQLTag.getRefetchableFragment,
    getRequest: GraphQLTag.getRequest,
    getRequestIdentifier: getRequestIdentifier,
    getSelector: RelayModernSelector.getSelector,
    getSelectorsFromObject: RelayModernSelector.getSelectorsFromObject,
    getSingularSelector: RelayModernSelector.getSingularSelector,
    getStorageKey: RelayStoreUtils.getStorageKey,
    getVariablesFromFragment: RelayModernSelector.getVariablesFromFragment,
    getVariablesFromObject: RelayModernSelector.getVariablesFromObject,
    getVariablesFromPluralFragment: RelayModernSelector.getVariablesFromPluralFragment,
    getVariablesFromSingularFragment: RelayModernSelector.getVariablesFromSingularFragment,
    handlePotentialSnapshotErrors: handlePotentialSnapshotErrors,
    graphql: GraphQLTag.graphql,
    isErrorResult: isErrorResult,
    isValueResult: isValueResult,
    isFragment: GraphQLTag.isFragment,
    isInlineDataFragment: GraphQLTag.isInlineDataFragment,
    isSuspenseSentinel: isSuspenseSentinel,
    suspenseSentinel: suspenseSentinel,
    isRequest: GraphQLTag.isRequest,
    readInlineData: readInlineData,
    readFragment: ResolverFragments.readFragment,
    MutationTypes: RelayDeclarativeMutationConfig.MutationTypes,
    RangeOperations: RelayDeclarativeMutationConfig.RangeOperations,
    DefaultHandlerProvider: RelayDefaultHandlerProvider,
    ConnectionHandler: ConnectionHandler,
    MutationHandlers: MutationHandlers,
    VIEWER_ID: ViewerPattern.VIEWER_ID,
    VIEWER_TYPE: ViewerPattern.VIEWER_TYPE,
    applyOptimisticMutation: applyOptimisticMutation,
    commitLocalUpdate: commitLocalUpdate,
    commitMutation: commitMutation,
    fetchQuery: fetchQuery,
    fetchQuery_DEPRECATED: fetchQuery_DEPRECATED,
    isRelayModernEnvironment: isRelayModernEnvironment,
    requestSubscription: requestSubscription,
    ConnectionInterface: ConnectionInterface,
    PreloadableQueryRegistry: PreloadableQueryRegistry,
    RelayProfiler: RelayProfiler,
    createPayloadFor3DField: createPayloadFor3DField,
    RelayConcreteNode: RelayConcreteNode,
    RelayError: RelayError,
    RelayFeatureFlags: RelayFeatureFlags,
    DEFAULT_HANDLE_KEY: RelayDefaultHandleKey.DEFAULT_HANDLE_KEY,
    FRAGMENTS_KEY: RelayStoreUtils.FRAGMENTS_KEY,
    FRAGMENT_OWNER_KEY: RelayStoreUtils.FRAGMENT_OWNER_KEY,
    ID_KEY: RelayStoreUtils.ID_KEY,
    REF_KEY: RelayStoreUtils.REF_KEY,
    REFS_KEY: RelayStoreUtils.REFS_KEY,
    ROOT_ID: RelayStoreUtils.ROOT_ID,
    ROOT_TYPE: RelayStoreUtils.ROOT_TYPE,
    TYPENAME_KEY: RelayStoreUtils.TYPENAME_KEY,
    deepFreeze: deepFreeze,
    generateClientID: generateClientID,
    generateUniqueClientID: generateUniqueClientID,
    getRelayHandleKey: getRelayHandleKey,
    isClientID: isClientID,
    isPromise: isPromise,
    isScalarAndEqual: isScalarAndEqual,
    recycleNodesInto: recycleNodesInto,
    stableCopy: stableCopy,
    hasCycle: hasCycle,
    getFragmentIdentifier: getFragmentIdentifier,
    getRefetchMetadata: getRefetchMetadata,
    getPaginationMetadata: getPaginationMetadata,
    getPaginationVariables: getPaginationVariables,
    getPendingOperationsForFragment: getPendingOperationsForFragment,
    getValueAtPath: getValueAtPath,
    __internal: {
        ResolverFragments: ResolverFragments,
        OperationTracker: RelayOperationTracker,
        createRelayContext: createRelayContext,
        createRelayLoggingContext: createRelayLoggingContext,
        getOperationVariables: RelayConcreteVariables.getOperationVariables,
        getLocalVariables: RelayConcreteVariables.getLocalVariables,
        fetchQuery: fetchQueryInternal.fetchQuery,
        fetchQueryDeduped: fetchQueryInternal.fetchQueryDeduped,
        getPromiseForActiveRequest: fetchQueryInternal.getPromiseForActiveRequest,
        getObservableForActiveRequest: fetchQueryInternal.getObservableForActiveRequest,
        normalizeResponse: normalizeResponse,
        withProvidedVariables: withProvidedVariables
    }
};
}),
"[project]/node_modules/relay-runtime/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Relay v20.1.1
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ module.exports = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/index.js [app-ssr] (ecmascript)");
}),
];

//# sourceMappingURL=node_modules_relay-runtime_e0bfb4ad._.js.map