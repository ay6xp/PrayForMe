module.exports = [
"[project]/node_modules/next/dist/esm/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {

if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        if ("TURBOPACK compile-time truthy", 1) {
            if ("TURBOPACK compile-time truthy", 1) {
                module.exports = __turbopack_context__.r("[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)");
            } else //TURBOPACK unreachable
            ;
        } else //TURBOPACK unreachable
        ;
    }
} //# sourceMappingURL=module.compiled.js.map
}),
"[project]/node_modules/next/dist/esm/server/route-kind.js [app-rsc] (ecmascript, Next.js server utility)", ((__turbopack_context__) => {

__turbopack_context__.n(__turbopack_context__.i("[project]/node_modules/next/dist/esm/server/route-kind.js [app-rsc] (ecmascript)"));}),
"[project]/node_modules/next/dist/esm/server/instrumentation/utils.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getRevalidateReason",
    ()=>getRevalidateReason
]);
function getRevalidateReason(params) {
    if (params.isOnDemandRevalidate) {
        return 'on-demand';
    }
    if (params.isStaticGeneration) {
        return 'stale';
    }
    return undefined;
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/esm/server/app-render/interop-default.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Interop between "export default" and "module.exports".
 */ __turbopack_context__.s([
    "interopDefault",
    ()=>interopDefault
]);
function interopDefault(mod) {
    return mod.default || mod;
} //# sourceMappingURL=interop-default.js.map
}),
"[project]/node_modules/next/dist/esm/server/app-render/strip-flight-headers.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "stripFlightHeaders",
    ()=>stripFlightHeaders
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/app-router-headers.js [app-rsc] (ecmascript)");
;
function stripFlightHeaders(headers) {
    for (const header of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FLIGHT_HEADERS"]){
        delete headers[header];
    }
} //# sourceMappingURL=strip-flight-headers.js.map
}),
"[project]/node_modules/next/dist/esm/server/web/spec-extension/adapters/headers.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HeadersAdapter",
    ()=>HeadersAdapter,
    "ReadonlyHeadersError",
    ()=>ReadonlyHeadersError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/spec-extension/adapters/reflect.js [app-rsc] (ecmascript)");
;
class ReadonlyHeadersError extends Error {
    constructor(){
        super('Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers');
    }
    static callable() {
        throw new ReadonlyHeadersError();
    }
}
class HeadersAdapter extends Headers {
    constructor(headers){
        // We've already overridden the methods that would be called, so we're just
        // calling the super constructor to ensure that the instanceof check works.
        super();
        this.headers = new Proxy(headers, {
            get (target, prop, receiver) {
                // Because this is just an object, we expect that all "get" operations
                // are for properties. If it's a "get" for a symbol, we'll just return
                // the symbol.
                if (typeof prop === 'symbol') {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
                }
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return undefined.
                if (typeof original === 'undefined') return;
                // If the original casing exists, return the value.
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, original, receiver);
            },
            set (target, prop, value, receiver) {
                if (typeof prop === 'symbol') {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].set(target, prop, value, receiver);
                }
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, use the prop as the key.
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].set(target, original ?? prop, value, receiver);
            },
            has (target, prop) {
                if (typeof prop === 'symbol') return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].has(target, prop);
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return false.
                if (typeof original === 'undefined') return false;
                // If the original casing exists, return true.
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].has(target, original);
            },
            deleteProperty (target, prop) {
                if (typeof prop === 'symbol') return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].deleteProperty(target, prop);
                const lowercased = prop.toLowerCase();
                // Let's find the original casing of the key. This assumes that there is
                // no mixed case keys (e.g. "Content-Type" and "content-type") in the
                // headers object.
                const original = Object.keys(headers).find((o)=>o.toLowerCase() === lowercased);
                // If the original casing doesn't exist, return true.
                if (typeof original === 'undefined') return true;
                // If the original casing exists, delete the property.
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].deleteProperty(target, original);
            }
        });
    }
    /**
   * Seals a Headers instance to prevent modification by throwing an error when
   * any mutating method is called.
   */ static seal(headers) {
        return new Proxy(headers, {
            get (target, prop, receiver) {
                switch(prop){
                    case 'append':
                    case 'delete':
                    case 'set':
                        return ReadonlyHeadersError.callable;
                    default:
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$reflect$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ReflectAdapter"].get(target, prop, receiver);
                }
            }
        });
    }
    /**
   * Merges a header value into a string. This stores multiple values as an
   * array, so we need to merge them into a string.
   *
   * @param value a header value
   * @returns a merged header value (a string)
   */ merge(value) {
        if (Array.isArray(value)) return value.join(', ');
        return value;
    }
    /**
   * Creates a Headers instance from a plain object or a Headers instance.
   *
   * @param headers a plain object or a Headers instance
   * @returns a headers instance
   */ static from(headers) {
        if (headers instanceof Headers) return headers;
        return new HeadersAdapter(headers);
    }
    append(name, value) {
        const existing = this.headers[name];
        if (typeof existing === 'string') {
            this.headers[name] = [
                existing,
                value
            ];
        } else if (Array.isArray(existing)) {
            existing.push(value);
        } else {
            this.headers[name] = value;
        }
    }
    delete(name) {
        delete this.headers[name];
    }
    get(name) {
        const value = this.headers[name];
        if (typeof value !== 'undefined') return this.merge(value);
        return null;
    }
    has(name) {
        return typeof this.headers[name] !== 'undefined';
    }
    set(name, value) {
        this.headers[name] = value;
    }
    forEach(callbackfn, thisArg) {
        for (const [name, value] of this.entries()){
            callbackfn.call(thisArg, value, name, this);
        }
    }
    *entries() {
        for (const key of Object.keys(this.headers)){
            const name = key.toLowerCase();
            // We assert here that this is a string because we got it from the
            // Object.keys() call above.
            const value = this.get(name);
            yield [
                name,
                value
            ];
        }
    }
    *keys() {
        for (const key of Object.keys(this.headers)){
            const name = key.toLowerCase();
            yield name;
        }
    }
    *values() {
        for (const key of Object.keys(this.headers)){
            // We assert here that this is a string because we got it from the
            // Object.keys() call above.
            const value = this.get(key);
            yield value;
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
} //# sourceMappingURL=headers.js.map
}),
"[project]/node_modules/next/dist/compiled/cookie/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

(()=>{
    "use strict";
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/cookie") + "/";
    var e = {};
    (()=>{
        var r = e;
        /*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ r.parse = parse;
        r.serialize = serialize;
        var i = decodeURIComponent;
        var t = encodeURIComponent;
        var a = /; */;
        var n = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
        function parse(e, r) {
            if (typeof e !== "string") {
                throw new TypeError("argument str must be a string");
            }
            var t = {};
            var n = r || {};
            var o = e.split(a);
            var s = n.decode || i;
            for(var p = 0; p < o.length; p++){
                var f = o[p];
                var u = f.indexOf("=");
                if (u < 0) {
                    continue;
                }
                var v = f.substr(0, u).trim();
                var c = f.substr(++u, f.length).trim();
                if ('"' == c[0]) {
                    c = c.slice(1, -1);
                }
                if (undefined == t[v]) {
                    t[v] = tryDecode(c, s);
                }
            }
            return t;
        }
        function serialize(e, r, i) {
            var a = i || {};
            var o = a.encode || t;
            if (typeof o !== "function") {
                throw new TypeError("option encode is invalid");
            }
            if (!n.test(e)) {
                throw new TypeError("argument name is invalid");
            }
            var s = o(r);
            if (s && !n.test(s)) {
                throw new TypeError("argument val is invalid");
            }
            var p = e + "=" + s;
            if (null != a.maxAge) {
                var f = a.maxAge - 0;
                if (isNaN(f) || !isFinite(f)) {
                    throw new TypeError("option maxAge is invalid");
                }
                p += "; Max-Age=" + Math.floor(f);
            }
            if (a.domain) {
                if (!n.test(a.domain)) {
                    throw new TypeError("option domain is invalid");
                }
                p += "; Domain=" + a.domain;
            }
            if (a.path) {
                if (!n.test(a.path)) {
                    throw new TypeError("option path is invalid");
                }
                p += "; Path=" + a.path;
            }
            if (a.expires) {
                if (typeof a.expires.toUTCString !== "function") {
                    throw new TypeError("option expires is invalid");
                }
                p += "; Expires=" + a.expires.toUTCString();
            }
            if (a.httpOnly) {
                p += "; HttpOnly";
            }
            if (a.secure) {
                p += "; Secure";
            }
            if (a.sameSite) {
                var u = typeof a.sameSite === "string" ? a.sameSite.toLowerCase() : a.sameSite;
                switch(u){
                    case true:
                        p += "; SameSite=Strict";
                        break;
                    case "lax":
                        p += "; SameSite=Lax";
                        break;
                    case "strict":
                        p += "; SameSite=Strict";
                        break;
                    case "none":
                        p += "; SameSite=None";
                        break;
                    default:
                        throw new TypeError("option sameSite is invalid");
                }
            }
            return p;
        }
        function tryDecode(e, r) {
            try {
                return r(e);
            } catch (r) {
                return e;
            }
        }
    })();
    module.exports = e;
})();
}),
"[project]/node_modules/next/dist/esm/server/api-utils/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApiError",
    ()=>ApiError,
    "COOKIE_NAME_PRERENDER_BYPASS",
    ()=>COOKIE_NAME_PRERENDER_BYPASS,
    "COOKIE_NAME_PRERENDER_DATA",
    ()=>COOKIE_NAME_PRERENDER_DATA,
    "RESPONSE_LIMIT_DEFAULT",
    ()=>RESPONSE_LIMIT_DEFAULT,
    "SYMBOL_CLEARED_COOKIES",
    ()=>SYMBOL_CLEARED_COOKIES,
    "SYMBOL_PREVIEW_DATA",
    ()=>SYMBOL_PREVIEW_DATA,
    "checkIsOnDemandRevalidate",
    ()=>checkIsOnDemandRevalidate,
    "clearPreviewData",
    ()=>clearPreviewData,
    "redirect",
    ()=>redirect,
    "sendError",
    ()=>sendError,
    "sendStatusCode",
    ()=>sendStatusCode,
    "setLazyProp",
    ()=>setLazyProp,
    "wrapApiHandler",
    ()=>wrapApiHandler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/web/spec-extension/adapters/headers.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/constants.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/tracer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/constants.js [app-rsc] (ecmascript)");
;
;
;
;
function wrapApiHandler(page, handler) {
    return (...args)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTracer"])().setRootSpanAttribute('next.route', page);
        // Call API route method
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTracer"])().trace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NodeSpan"].runHandler, {
            spanName: `executing api route (pages) ${page}`
        }, ()=>handler(...args));
    };
}
function sendStatusCode(res, statusCode) {
    res.statusCode = statusCode;
    return res;
}
function redirect(res, statusOrUrl, url) {
    if (typeof statusOrUrl === 'string') {
        url = statusOrUrl;
        statusOrUrl = 307;
    }
    if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {
        throw Object.defineProperty(new Error(`Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`), "__NEXT_ERROR_CODE", {
            value: "E389",
            enumerable: false,
            configurable: true
        });
    }
    res.writeHead(statusOrUrl, {
        Location: url
    });
    res.write(url);
    res.end();
    return res;
}
function checkIsOnDemandRevalidate(req, previewProps) {
    const headers = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$web$2f$spec$2d$extension$2f$adapters$2f$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["HeadersAdapter"].from(req.headers);
    const previewModeId = headers.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PRERENDER_REVALIDATE_HEADER"]);
    const isOnDemandRevalidate = previewModeId === previewProps.previewModeId;
    const revalidateOnlyGenerated = headers.has(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER"]);
    return {
        isOnDemandRevalidate,
        revalidateOnlyGenerated
    };
}
const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`;
const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`;
const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024;
const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA);
const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS);
function clearPreviewData(res, options = {}) {
    if (SYMBOL_CLEARED_COOKIES in res) {
        return res;
    }
    const { serialize } = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/cookie/index.js [app-rsc] (ecmascript)");
    const previous = res.getHeader('Set-Cookie');
    res.setHeader(`Set-Cookie`, [
        ...typeof previous === 'string' ? [
            previous
        ] : Array.isArray(previous) ? previous : [],
        serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {
            // To delete a cookie, set `expires` to a date in the past:
            // https://tools.ietf.org/html/rfc6265#section-4.1.1
            // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
            expires: new Date(0),
            httpOnly: true,
            sameSite: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'lax',
            secure: ("TURBOPACK compile-time value", "development") !== 'development',
            path: '/',
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        }),
        serialize(COOKIE_NAME_PRERENDER_DATA, '', {
            // To delete a cookie, set `expires` to a date in the past:
            // https://tools.ietf.org/html/rfc6265#section-4.1.1
            // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
            expires: new Date(0),
            httpOnly: true,
            sameSite: ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'lax',
            secure: ("TURBOPACK compile-time value", "development") !== 'development',
            path: '/',
            ...options.path !== undefined ? {
                path: options.path
            } : undefined
        })
    ]);
    Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {
        value: true,
        enumerable: false
    });
    return res;
}
class ApiError extends Error {
    constructor(statusCode, message){
        super(message);
        this.statusCode = statusCode;
    }
}
function sendError(res, statusCode, message) {
    res.statusCode = statusCode;
    res.statusMessage = message;
    res.end(message);
}
function setLazyProp({ req }, prop, getter) {
    const opts = {
        configurable: true,
        enumerable: true
    };
    const optsReset = {
        ...opts,
        writable: true
    };
    Object.defineProperty(req, prop, {
        ...opts,
        get: ()=>{
            const value = getter();
            // we set the property on the object to avoid recalculating it
            Object.defineProperty(req, prop, {
                ...optsReset,
                value
            });
            return value;
        },
        set: (value)=>{
            Object.defineProperty(req, prop, {
                ...optsReset,
                value
            });
        }
    });
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/next/dist/esm/server/api-utils/get-cookie-parser.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Parse cookies from the `headers` of request
 * @param req request object
 */ __turbopack_context__.s([
    "getCookieParser",
    ()=>getCookieParser
]);
function getCookieParser(headers) {
    return function parseCookie() {
        const { cookie } = headers;
        if (!cookie) {
            return {};
        }
        const { parse: parseCookieFn } = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/cookie/index.js [app-rsc] (ecmascript)");
        return parseCookieFn(Array.isArray(cookie) ? cookie.join('; ') : cookie);
    };
} //# sourceMappingURL=get-cookie-parser.js.map
}),
"[project]/node_modules/next/dist/esm/server/base-http/index.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BaseNextRequest",
    ()=>BaseNextRequest,
    "BaseNextResponse",
    ()=>BaseNextResponse
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$redirect$2d$status$2d$code$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/redirect-status-code.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$api$2d$utils$2f$get$2d$cookie$2d$parser$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/api-utils/get-cookie-parser.js [app-rsc] (ecmascript)");
;
;
class BaseNextRequest {
    constructor(method, url, body){
        this.method = method;
        this.url = url;
        this.body = body;
    }
    // Utils implemented using the abstract methods above
    get cookies() {
        if (this._cookies) return this._cookies;
        return this._cookies = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$api$2d$utils$2f$get$2d$cookie$2d$parser$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getCookieParser"])(this.headers)();
    }
}
class BaseNextResponse {
    constructor(destination){
        this.destination = destination;
    }
    // Utils implemented using the abstract methods above
    redirect(destination, statusCode) {
        this.setHeader('Location', destination);
        this.statusCode = statusCode;
        // Since IE11 doesn't support the 308 header add backwards
        // compatibility using refresh header
        if (statusCode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$redirect$2d$status$2d$code$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RedirectStatusCode"].PermanentRedirect) {
            this.setHeader('Refresh', `0;url=${destination}`);
        }
        return this;
    }
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/next/dist/esm/server/base-http/node.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NodeNextRequest",
    ()=>NodeNextRequest,
    "NodeNextResponse",
    ()=>NodeNextResponse
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$api$2d$utils$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/api-utils/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request-meta.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$base$2d$http$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/base-http/index.js [app-rsc] (ecmascript)");
;
;
;
let prop;
class NodeNextRequest extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$base$2d$http$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BaseNextRequest"] {
    static #_ = prop = _NEXT_REQUEST_META = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_REQUEST_META"];
    constructor(_req){
        var _this__req;
        super(_req.method.toUpperCase(), _req.url, _req), this._req = _req, this.headers = this._req.headers, this.fetchMetrics = (_this__req = this._req) == null ? void 0 : _this__req.fetchMetrics, this[_NEXT_REQUEST_META] = this._req[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_REQUEST_META"]] || {}, this.streaming = false;
    }
    get originalRequest() {
        // Need to mimic these changes to the original req object for places where we use it:
        // render.tsx, api/ssg requests
        this._req[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_REQUEST_META"]] = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_REQUEST_META"]];
        this._req.url = this.url;
        this._req.cookies = this.cookies;
        return this._req;
    }
    set originalRequest(value) {
        this._req = value;
    }
    /**
   * Returns the request body as a Web Readable Stream. The body here can only
   * be read once as the body will start flowing as soon as the data handler
   * is attached.
   *
   * @internal
   */ stream() {
        if (this.streaming) {
            throw Object.defineProperty(new Error('Invariant: NodeNextRequest.stream() can only be called once'), "__NEXT_ERROR_CODE", {
                value: "E467",
                enumerable: false,
                configurable: true
            });
        }
        this.streaming = true;
        return new ReadableStream({
            start: (controller)=>{
                this._req.on('data', (chunk)=>{
                    controller.enqueue(new Uint8Array(chunk));
                });
                this._req.on('end', ()=>{
                    controller.close();
                });
                this._req.on('error', (err)=>{
                    controller.error(err);
                });
            }
        });
    }
}
class NodeNextResponse extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$base$2d$http$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BaseNextResponse"] {
    get originalResponse() {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$api$2d$utils$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SYMBOL_CLEARED_COOKIES"] in this) {
            this._res[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$api$2d$utils$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SYMBOL_CLEARED_COOKIES"]] = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$api$2d$utils$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SYMBOL_CLEARED_COOKIES"]];
        }
        return this._res;
    }
    constructor(_res){
        super(_res), this._res = _res, this.textBody = undefined;
    }
    get sent() {
        return this._res.finished || this._res.headersSent;
    }
    get statusCode() {
        return this._res.statusCode;
    }
    set statusCode(value) {
        this._res.statusCode = value;
    }
    get statusMessage() {
        return this._res.statusMessage;
    }
    set statusMessage(value) {
        this._res.statusMessage = value;
    }
    setHeader(name, value) {
        this._res.setHeader(name, value);
        return this;
    }
    removeHeader(name) {
        this._res.removeHeader(name);
        return this;
    }
    getHeaderValues(name) {
        const values = this._res.getHeader(name);
        if (values === undefined) return undefined;
        return (Array.isArray(values) ? values : [
            values
        ]).map((value)=>value.toString());
    }
    hasHeader(name) {
        return this._res.hasHeader(name);
    }
    getHeader(name) {
        const values = this.getHeaderValues(name);
        return Array.isArray(values) ? values.join(',') : undefined;
    }
    getHeaders() {
        return this._res.getHeaders();
    }
    appendHeader(name, value) {
        const currentValues = this.getHeaderValues(name) ?? [];
        if (!currentValues.includes(value)) {
            this._res.setHeader(name, [
                ...currentValues,
                value
            ]);
        }
        return this;
    }
    body(value) {
        this.textBody = value;
        return this;
    }
    send() {
        this._res.end(this.textBody);
    }
    onClose(callback) {
        this.originalResponse.on('close', callback);
    }
}
var _NEXT_REQUEST_META; //# sourceMappingURL=node.js.map
}),
"[project]/node_modules/next/dist/esm/server/lib/experimental/ppr.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * If set to `incremental`, only those leaf pages that export
 * `experimental_ppr = true` will have partial prerendering enabled. If any
 * page exports this value as `false` or does not export it at all will not
 * have partial prerendering enabled. If set to a boolean, the options for
 * `experimental_ppr` will be ignored.
 */ /**
 * Returns true if partial prerendering is enabled for the application. It does
 * not tell you if a given route has PPR enabled, as that requires analysis of
 * the route's configuration.
 *
 * @see {@link checkIsRoutePPREnabled} - for checking if a specific route has PPR enabled.
 */ __turbopack_context__.s([
    "checkIsAppPPREnabled",
    ()=>checkIsAppPPREnabled,
    "checkIsRoutePPREnabled",
    ()=>checkIsRoutePPREnabled
]);
function checkIsAppPPREnabled(config) {
    // If the config is undefined, partial prerendering is disabled.
    if (typeof config === 'undefined') return false;
    // If the config is a boolean, use it directly.
    if (typeof config === 'boolean') return config;
    // If the config is a string, it must be 'incremental' to enable partial
    // prerendering.
    if (config === 'incremental') return true;
    return false;
}
function checkIsRoutePPREnabled(config) {
    // If the config is undefined, partial prerendering is disabled.
    if (typeof config === 'undefined') return false;
    // If the config is a boolean, use it directly.
    if (typeof config === 'boolean') return config;
    return false;
} //# sourceMappingURL=ppr.js.map
}),
"[project]/node_modules/next/dist/esm/server/route-modules/checks.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isAppPageRouteModule",
    ()=>isAppPageRouteModule,
    "isAppRouteRouteModule",
    ()=>isAppRouteRouteModule,
    "isPagesAPIRouteModule",
    ()=>isPagesAPIRouteModule,
    "isPagesRouteModule",
    ()=>isPagesRouteModule
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/route-kind.js [app-rsc] (ecmascript)");
;
function isAppRouteRouteModule(routeModule) {
    return routeModule.definition.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RouteKind"].APP_ROUTE;
}
function isAppPageRouteModule(routeModule) {
    return routeModule.definition.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RouteKind"].APP_PAGE;
}
function isPagesRouteModule(routeModule) {
    return routeModule.definition.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RouteKind"].PAGES;
}
function isPagesAPIRouteModule(routeModule) {
    return routeModule.definition.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RouteKind"].PAGES_API;
} //# sourceMappingURL=checks.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/page-path/ensure-leading-slash.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * For a given page path, this function ensures that there is a leading slash.
 * If there is not a leading slash, one is added, otherwise it is noop.
 */ __turbopack_context__.s([
    "ensureLeadingSlash",
    ()=>ensureLeadingSlash
]);
function ensureLeadingSlash(path) {
    return path.startsWith('/') ? path : `/${path}`;
} //# sourceMappingURL=ensure-leading-slash.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/app-paths.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "normalizeAppPath",
    ()=>normalizeAppPath,
    "normalizeRscURL",
    ()=>normalizeRscURL
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$page$2d$path$2f$ensure$2d$leading$2d$slash$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/page-path/ensure-leading-slash.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/segment.js [app-rsc] (ecmascript)");
;
;
function normalizeAppPath(route) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$page$2d$path$2f$ensure$2d$leading$2d$slash$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ensureLeadingSlash"])(route.split('/').reduce((pathname, segment, index, segments)=>{
        // Empty segments are ignored.
        if (!segment) {
            return pathname;
        }
        // Groups are ignored.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isGroupSegment"])(segment)) {
            return pathname;
        }
        // Parallel segments are ignored.
        if (segment[0] === '@') {
            return pathname;
        }
        // The last segment (if it's a leaf) should be ignored.
        if ((segment === 'page' || segment === 'route') && index === segments.length - 1) {
            return pathname;
        }
        return `${pathname}/${segment}`;
    }, ''));
}
function normalizeRscURL(url) {
    return url.replace(/\.rsc($|\?)/, '$1');
} //# sourceMappingURL=app-paths.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/interception-routes.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "INTERCEPTION_ROUTE_MARKERS",
    ()=>INTERCEPTION_ROUTE_MARKERS,
    "extractInterceptionRouteInformation",
    ()=>extractInterceptionRouteInformation,
    "isInterceptionRouteAppPath",
    ()=>isInterceptionRouteAppPath
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$app$2d$paths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/app-paths.js [app-rsc] (ecmascript)");
;
const INTERCEPTION_ROUTE_MARKERS = [
    '(..)(..)',
    '(.)',
    '(..)',
    '(...)'
];
function isInterceptionRouteAppPath(path) {
    // TODO-APP: add more serious validation
    return path.split('/').find((segment)=>INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m))) !== undefined;
}
function extractInterceptionRouteInformation(path) {
    let interceptingRoute;
    let marker;
    let interceptedRoute;
    for (const segment of path.split('/')){
        marker = INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));
        if (marker) {
            ;
            [interceptingRoute, interceptedRoute] = path.split(marker, 2);
            break;
        }
    }
    if (!interceptingRoute || !marker || !interceptedRoute) {
        throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`), "__NEXT_ERROR_CODE", {
            value: "E269",
            enumerable: false,
            configurable: true
        });
    }
    interceptingRoute = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$app$2d$paths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["normalizeAppPath"])(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed
    ;
    switch(marker){
        case '(.)':
            // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route
            if (interceptingRoute === '/') {
                interceptedRoute = `/${interceptedRoute}`;
            } else {
                interceptedRoute = interceptingRoute + '/' + interceptedRoute;
            }
            break;
        case '(..)':
            // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route
            if (interceptingRoute === '/') {
                throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`), "__NEXT_ERROR_CODE", {
                    value: "E207",
                    enumerable: false,
                    configurable: true
                });
            }
            interceptedRoute = interceptingRoute.split('/').slice(0, -1).concat(interceptedRoute).join('/');
            break;
        case '(...)':
            // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route
            interceptedRoute = '/' + interceptedRoute;
            break;
        case '(..)(..)':
            // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route
            const splitInterceptingRoute = interceptingRoute.split('/');
            if (splitInterceptingRoute.length <= 2) {
                throw Object.defineProperty(new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`), "__NEXT_ERROR_CODE", {
                    value: "E486",
                    enumerable: false,
                    configurable: true
                });
            }
            interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join('/');
            break;
        default:
            throw Object.defineProperty(new Error('Invariant: unexpected marker'), "__NEXT_ERROR_CODE", {
                value: "E112",
                enumerable: false,
                configurable: true
            });
    }
    return {
        interceptingRoute,
        interceptedRoute
    };
} //# sourceMappingURL=interception-routes.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/get-segment-param.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getParamProperties",
    ()=>getParamProperties,
    "getSegmentParam",
    ()=>getSegmentParam,
    "isCatchAll",
    ()=>isCatchAll
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$interception$2d$routes$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/interception-routes.js [app-rsc] (ecmascript)");
;
function getSegmentParam(segment) {
    const interceptionMarker = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$interception$2d$routes$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INTERCEPTION_ROUTE_MARKERS"].find((marker)=>segment.startsWith(marker));
    // if an interception marker is part of the path segment, we need to jump ahead
    // to the relevant portion for param parsing
    if (interceptionMarker) {
        segment = segment.slice(interceptionMarker.length);
    }
    if (segment.startsWith('[[...') && segment.endsWith(']]')) {
        return {
            // TODO-APP: Optional catchall does not currently work with parallel routes,
            // so for now aren't handling a potential interception marker.
            paramType: 'optional-catchall',
            paramName: segment.slice(5, -2)
        };
    }
    if (segment.startsWith('[...') && segment.endsWith(']')) {
        return {
            paramType: interceptionMarker ? `catchall-intercepted-${interceptionMarker}` : 'catchall',
            paramName: segment.slice(4, -1)
        };
    }
    if (segment.startsWith('[') && segment.endsWith(']')) {
        return {
            paramType: interceptionMarker ? `dynamic-intercepted-${interceptionMarker}` : 'dynamic',
            paramName: segment.slice(1, -1)
        };
    }
    return null;
}
function isCatchAll(type) {
    return type === 'catchall' || type === 'catchall-intercepted-(..)(..)' || type === 'catchall-intercepted-(.)' || type === 'catchall-intercepted-(..)' || type === 'catchall-intercepted-(...)' || type === 'optional-catchall';
}
function getParamProperties(paramType) {
    let repeat = false;
    let optional = false;
    switch(paramType){
        case 'catchall':
        case 'catchall-intercepted-(..)(..)':
        case 'catchall-intercepted-(.)':
        case 'catchall-intercepted-(..)':
        case 'catchall-intercepted-(...)':
            repeat = true;
            break;
        case 'optional-catchall':
            repeat = true;
            optional = true;
            break;
        case 'dynamic':
        case 'dynamic-intercepted-(..)(..)':
        case 'dynamic-intercepted-(.)':
        case 'dynamic-intercepted-(..)':
        case 'dynamic-intercepted-(...)':
            break;
        default:
            paramType;
    }
    return {
        repeat,
        optional
    };
} //# sourceMappingURL=get-segment-param.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/routes/app.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isInterceptionAppRoute",
    ()=>isInterceptionAppRoute,
    "isNormalizedAppRoute",
    ()=>isNormalizedAppRoute,
    "parseAppRoute",
    ()=>parseAppRoute,
    "parseAppRouteSegment",
    ()=>parseAppRouteSegment
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$get$2d$segment$2d$param$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/get-segment-param.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$interception$2d$routes$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/interception-routes.js [app-rsc] (ecmascript)");
;
;
;
function parseAppRouteSegment(segment) {
    if (segment === '') {
        return null;
    }
    // Check if the segment starts with an interception marker
    const interceptionMarker = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$interception$2d$routes$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["INTERCEPTION_ROUTE_MARKERS"].find((m)=>segment.startsWith(m));
    const param = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$get$2d$segment$2d$param$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getSegmentParam"])(segment);
    if (param) {
        return {
            type: 'dynamic',
            name: segment,
            param,
            interceptionMarker
        };
    } else if (segment.startsWith('(') && segment.endsWith(')')) {
        return {
            type: 'route-group',
            name: segment,
            interceptionMarker
        };
    } else if (segment.startsWith('@')) {
        return {
            type: 'parallel-route',
            name: segment,
            interceptionMarker
        };
    } else {
        return {
            type: 'static',
            name: segment,
            interceptionMarker
        };
    }
}
function isNormalizedAppRoute(route) {
    return route.normalized;
}
function isInterceptionAppRoute(route) {
    return route.interceptionMarker !== undefined && route.interceptingRoute !== undefined && route.interceptedRoute !== undefined;
}
function parseAppRoute(pathname, normalized) {
    const pathnameSegments = pathname.split('/').filter(Boolean);
    // Build segments array with static and dynamic segments
    const segments = [];
    // Parse if this is an interception route.
    let interceptionMarker;
    let interceptingRoute;
    let interceptedRoute;
    for (const segment of pathnameSegments){
        // Parse the segment into an AppSegment.
        const appSegment = parseAppRouteSegment(segment);
        if (!appSegment) {
            continue;
        }
        if (normalized && (appSegment.type === 'route-group' || appSegment.type === 'parallel-route')) {
            throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["InvariantError"](`${pathname} is being parsed as a normalized route, but it has a route group or parallel route segment.`), "__NEXT_ERROR_CODE", {
                value: "E923",
                enumerable: false,
                configurable: true
            });
        }
        segments.push(appSegment);
        if (appSegment.interceptionMarker) {
            const parts = pathname.split(appSegment.interceptionMarker);
            if (parts.length !== 2) {
                throw Object.defineProperty(new Error(`Invalid interception route: ${pathname}`), "__NEXT_ERROR_CODE", {
                    value: "E924",
                    enumerable: false,
                    configurable: true
                });
            }
            interceptingRoute = normalized ? parseAppRoute(parts[0], true) : parseAppRoute(parts[0], false);
            interceptedRoute = normalized ? parseAppRoute(parts[1], true) : parseAppRoute(parts[1], false);
            interceptionMarker = appSegment.interceptionMarker;
        }
    }
    const dynamicSegments = segments.filter((segment)=>segment.type === 'dynamic');
    return {
        normalized,
        pathname,
        segments,
        dynamicSegments,
        interceptionMarker,
        interceptingRoute,
        interceptedRoute
    };
} //# sourceMappingURL=app.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/parse-loader-tree.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseLoaderTree",
    ()=>parseLoaderTree
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/segment.js [app-rsc] (ecmascript)");
;
function parseLoaderTree(tree) {
    const [segment, parallelRoutes, modules] = tree;
    const { layout, template } = modules;
    let { page } = modules;
    // a __DEFAULT__ segment means that this route didn't match any of the
    // segments in the route, so we should use the default page
    page = segment === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$segment$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["DEFAULT_SEGMENT_KEY"] ? modules.defaultPage : page;
    const conventionPath = layout?.[1] || template?.[1] || page?.[1];
    return {
        page,
        segment,
        modules,
        /* it can be either layout / template / page */ conventionPath,
        parallelRoutes
    };
} //# sourceMappingURL=parse-loader-tree.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/interception-prefix-from-param-type.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "interceptionPrefixFromParamType",
    ()=>interceptionPrefixFromParamType
]);
function interceptionPrefixFromParamType(paramType) {
    switch(paramType){
        case 'catchall-intercepted-(..)(..)':
        case 'dynamic-intercepted-(..)(..)':
            return '(..)(..)';
        case 'catchall-intercepted-(.)':
        case 'dynamic-intercepted-(.)':
            return '(.)';
        case 'catchall-intercepted-(..)':
        case 'dynamic-intercepted-(..)':
            return '(..)';
        case 'catchall-intercepted-(...)':
        case 'dynamic-intercepted-(...)':
            return '(...)';
        case 'catchall':
        case 'dynamic':
        case 'optional-catchall':
        default:
            return null;
    }
} //# sourceMappingURL=interception-prefix-from-param-type.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/resolve-param-value.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "resolveParamValue",
    ()=>resolveParamValue
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$interception$2d$prefix$2d$from$2d$param$2d$type$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/interception-prefix-from-param-type.js [app-rsc] (ecmascript)");
;
;
/**
 * Extracts the param value from a path segment, handling interception markers
 * based on the expected param type.
 *
 * @param pathSegment - The path segment to extract the value from
 * @param params - The current params object for resolving dynamic param references
 * @param paramType - The expected param type which may include interception marker info
 * @returns The extracted param value
 */ function getParamValueFromSegment(pathSegment, params, paramType) {
    // If the segment is dynamic, resolve it from the params object
    if (pathSegment.type === 'dynamic') {
        return params[pathSegment.param.paramName];
    }
    // If the paramType indicates this is an intercepted param, strip the marker
    // that matches the interception marker in the param type
    const interceptionPrefix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$interception$2d$prefix$2d$from$2d$param$2d$type$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["interceptionPrefixFromParamType"])(paramType);
    if (interceptionPrefix === pathSegment.interceptionMarker) {
        return pathSegment.name.replace(pathSegment.interceptionMarker, '');
    }
    // For static segments, use the name
    return pathSegment.name;
}
function resolveParamValue(paramName, paramType, depth, route, params) {
    switch(paramType){
        case 'catchall':
        case 'optional-catchall':
        case 'catchall-intercepted-(..)(..)':
        case 'catchall-intercepted-(.)':
        case 'catchall-intercepted-(..)':
        case 'catchall-intercepted-(...)':
            // For catchall routes, derive from pathname using depth to determine
            // which segments to use
            const processedSegments = [];
            // Process segments to handle any embedded dynamic params
            for(let index = depth; index < route.segments.length; index++){
                const pathSegment = route.segments[index];
                if (pathSegment.type === 'static') {
                    let value = pathSegment.name;
                    // For intercepted catch-all params, strip the marker from the first segment
                    const interceptionPrefix = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$interception$2d$prefix$2d$from$2d$param$2d$type$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["interceptionPrefixFromParamType"])(paramType);
                    if (interceptionPrefix && index === depth && interceptionPrefix === pathSegment.interceptionMarker) {
                        // Strip the interception marker from the value
                        value = value.replace(pathSegment.interceptionMarker, '');
                    }
                    processedSegments.push(value);
                } else {
                    // If the segment is a param placeholder, check if we have its value
                    if (!params.hasOwnProperty(pathSegment.param.paramName)) {
                        // If the segment is an optional catchall, we can break out of the
                        // loop because it's optional!
                        if (pathSegment.param.paramType === 'optional-catchall') {
                            break;
                        }
                        // Unknown param placeholder in pathname - can't derive full value
                        return undefined;
                    }
                    // If the segment matches a param, use the param value
                    // We don't encode values here as that's handled during retrieval.
                    const paramValue = params[pathSegment.param.paramName];
                    if (Array.isArray(paramValue)) {
                        processedSegments.push(...paramValue);
                    } else {
                        processedSegments.push(paramValue);
                    }
                }
            }
            if (processedSegments.length > 0) {
                return processedSegments;
            } else if (paramType === 'optional-catchall') {
                return undefined;
            } else {
                // We shouldn't be able to match a catchall segment without any path
                // segments if it's not an optional catchall
                throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["InvariantError"](`Unexpected empty path segments match for a route "${route.pathname}" with param "${paramName}" of type "${paramType}"`), "__NEXT_ERROR_CODE", {
                    value: "E931",
                    enumerable: false,
                    configurable: true
                });
            }
        case 'dynamic':
        case 'dynamic-intercepted-(..)(..)':
        case 'dynamic-intercepted-(.)':
        case 'dynamic-intercepted-(..)':
        case 'dynamic-intercepted-(...)':
            // For regular dynamic parameters, take the segment at this depth
            if (depth < route.segments.length) {
                const pathSegment = route.segments[depth];
                // Check if the segment at this depth is a placeholder for an unknown param
                if (pathSegment.type === 'dynamic' && !params.hasOwnProperty(pathSegment.param.paramName)) {
                    // The segment is a placeholder like [category] and we don't have the value
                    return undefined;
                }
                // If the segment matches a param, use the param value from params object
                // Otherwise it's a static segment, just use it directly
                // We don't encode values here as that's handled during retrieval
                return getParamValueFromSegment(pathSegment, params, paramType);
            }
            return undefined;
        default:
            paramType;
    }
} //# sourceMappingURL=resolve-param-value.js.map
}),
"[project]/node_modules/next/dist/esm/build/static-paths/app/extract-pathname-route-param-segments-from-loader-tree.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "extractPathnameRouteParamSegmentsFromLoaderTree",
    ()=>extractPathnameRouteParamSegmentsFromLoaderTree
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$routes$2f$app$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/routes/app.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$loader$2d$tree$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/parse-loader-tree.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$resolve$2d$param$2d$value$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/resolve-param-value.js [app-rsc] (ecmascript)");
;
;
;
/**
 * Validates that the static segments in currentPath match the corresponding
 * segments in targetSegments. This ensures we only extract dynamic parameters
 * that are part of the target pathname structure.
 *
 * Segments are compared literally - interception markers like "(.)photo" are
 * part of the pathname and must match exactly.
 *
 * @example
 * // Matching paths
 * currentPath: ['blog', '(.)photo']
 * targetSegments: ['blog', '(.)photo', '[id]']
 *  Returns true (both static segments match exactly)
 *
 * @example
 * // Non-matching paths
 * currentPath: ['blog', '(.)photo']
 * targetSegments: ['blog', 'photo', '[id]']
 *  Returns false (segments don't match - marker is part of pathname)
 *
 * @param currentPath - The accumulated path segments from the loader tree
 * @param targetSegments - The target pathname split into segments
 * @returns true if all static segments match, false otherwise
 */ function validatePrefixMatch(currentPath, route) {
    for(let i = 0; i < currentPath.length; i++){
        const pathSegment = currentPath[i];
        const targetPathSegment = route.segments[i];
        // Type mismatch - one is static, one is dynamic
        if (pathSegment.type !== targetPathSegment.type) {
            return false;
        }
        // One has an interception marker, the other doesn't.
        if (pathSegment.interceptionMarker !== targetPathSegment.interceptionMarker) {
            return false;
        }
        // Both are static but names don't match
        if (pathSegment.type === 'static' && targetPathSegment.type === 'static' && pathSegment.name !== targetPathSegment.name) {
            return false;
        } else if (pathSegment.type === 'dynamic' && targetPathSegment.type === 'dynamic' && pathSegment.param.paramType !== targetPathSegment.param.paramType && pathSegment.param.paramName !== targetPathSegment.param.paramName) {
            return false;
        }
    }
    return true;
}
function extractPathnameRouteParamSegmentsFromLoaderTree(loaderTree, route) {
    const pathnameRouteParamSegments = [];
    const params = {};
    // BFS traversal with depth and path tracking
    const queue = [
        {
            tree: loaderTree,
            depth: 0,
            currentPath: []
        }
    ];
    while(queue.length > 0){
        const { tree, depth, currentPath } = queue.shift();
        const { segment, parallelRoutes } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$loader$2d$tree$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parseLoaderTree"])(tree);
        // Build the path for the current node
        let updatedPath = currentPath;
        let nextDepth = depth;
        const appSegment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$routes$2f$app$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parseAppRouteSegment"])(segment);
        // Only add to path if it's a real segment that appears in the URL
        // Route groups and parallel markers don't contribute to URL pathname
        if (appSegment && appSegment.type !== 'route-group' && appSegment.type !== 'parallel-route') {
            updatedPath = [
                ...currentPath,
                appSegment
            ];
            nextDepth = depth + 1;
        }
        // Check if this segment has a param and matches the target pathname at this depth
        if ((appSegment == null ? void 0 : appSegment.type) === 'dynamic') {
            const { paramName, paramType } = appSegment.param;
            // Check if this segment is at the correct depth in the target pathname
            // A segment matches if:
            // 1. There's a dynamic segment at this depth in the pathname
            // 2. The parameter names match (e.g., [id] matches [id], not [category])
            // 3. The static segments leading up to this point match (prefix check)
            if (depth < route.segments.length) {
                const targetSegment = route.segments[depth];
                // Match if the target pathname has a dynamic segment at this depth
                if (targetSegment.type === 'dynamic') {
                    // Check that parameter names match exactly
                    // This prevents [category] from matching against /[id]
                    if (paramName !== targetSegment.param.paramName) {
                        continue; // Different param names, skip this segment
                    }
                    // Validate that the path leading up to this dynamic segment matches
                    // the target pathname. This prevents false matches like extracting
                    // [slug] from "/news/[slug]" when the tree has "/blog/[slug]"
                    if (validatePrefixMatch(currentPath, route)) {
                        pathnameRouteParamSegments.push({
                            name: segment,
                            paramName,
                            paramType
                        });
                    }
                }
            }
            // Resolve parameter value if it's not already known.
            if (!params.hasOwnProperty(paramName)) {
                const paramValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$resolve$2d$param$2d$value$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveParamValue"])(paramName, paramType, depth, route, params);
                if (paramValue !== undefined) {
                    params[paramName] = paramValue;
                }
            }
        }
        // Continue traversing all parallel routes to find matching segments
        for (const parallelRoute of Object.values(parallelRoutes)){
            queue.push({
                tree: parallelRoute,
                depth: nextDepth,
                currentPath: updatedPath
            });
        }
    }
    return {
        pathnameRouteParamSegments,
        params
    };
} //# sourceMappingURL=extract-pathname-route-param-segments-from-loader-tree.js.map
}),
"[project]/node_modules/next/dist/esm/build/static-paths/utils.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "encodeParam",
    ()=>encodeParam,
    "extractPathnameRouteParamSegments",
    ()=>extractPathnameRouteParamSegments,
    "extractPathnameRouteParamSegmentsFromSegments",
    ()=>extractPathnameRouteParamSegmentsFromSegments,
    "normalizePathname",
    ()=>normalizePathname,
    "resolveRouteParamsFromTree",
    ()=>resolveRouteParamsFromTree
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$modules$2f$checks$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/route-modules/checks.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$routes$2f$app$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/routes/app.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$loader$2d$tree$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/parse-loader-tree.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$static$2d$paths$2f$app$2f$extract$2d$pathname$2d$route$2d$param$2d$segments$2d$from$2d$loader$2d$tree$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/build/static-paths/app/extract-pathname-route-param-segments-from-loader-tree.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$resolve$2d$param$2d$value$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/resolve-param-value.js [app-rsc] (ecmascript)");
;
;
;
;
;
function encodeParam(value, encoder) {
    let replaceValue;
    if (Array.isArray(value)) {
        replaceValue = value.map(encoder).join('/');
    } else {
        replaceValue = encoder(value);
    }
    return replaceValue;
}
function normalizePathname(pathname) {
    return pathname.replace(/\\/g, '/').replace(/(?!^)\/$/, '');
}
function extractPathnameRouteParamSegments(routeModule, segments, route) {
    // For AppPageRouteModule, use the loaderTree traversal approach
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$modules$2f$checks$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isAppPageRouteModule"])(routeModule)) {
        const { pathnameRouteParamSegments } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$static$2d$paths$2f$app$2f$extract$2d$pathname$2d$route$2d$param$2d$segments$2d$from$2d$loader$2d$tree$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["extractPathnameRouteParamSegmentsFromLoaderTree"])(routeModule.userland.loaderTree, route);
        return pathnameRouteParamSegments;
    }
    return extractPathnameRouteParamSegmentsFromSegments(segments);
}
function extractPathnameRouteParamSegmentsFromSegments(segments) {
    // TODO: should we consider what values are already present in the page?
    // For AppRouteRouteModule, filter the segments array to get the route params
    // that contribute to the pathname.
    const result = [];
    for (const segment of segments){
        // Skip segments without param info.
        if (!segment.paramName || !segment.paramType) continue;
        // Collect all the route param keys that contribute to the pathname.
        result.push({
            name: segment.name,
            paramName: segment.paramName,
            paramType: segment.paramType
        });
    }
    return result;
}
function resolveRouteParamsFromTree(loaderTree, params, route, fallbackRouteParams) {
    // Stack-based traversal with depth tracking
    const stack = [
        {
            tree: loaderTree,
            depth: 0
        }
    ];
    while(stack.length > 0){
        const { tree, depth } = stack.pop();
        const { segment, parallelRoutes } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$parse$2d$loader$2d$tree$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parseLoaderTree"])(tree);
        const appSegment = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$routes$2f$app$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parseAppRouteSegment"])(segment);
        // If this segment is a route parameter, then we should process it if it's
        // not already known and is not already marked as a fallback route param.
        if ((appSegment == null ? void 0 : appSegment.type) === 'dynamic' && !params.hasOwnProperty(appSegment.param.paramName) && !fallbackRouteParams.some((param)=>param.paramName === appSegment.param.paramName)) {
            const { paramName, paramType } = appSegment.param;
            const paramValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$resolve$2d$param$2d$value$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveParamValue"])(paramName, paramType, depth, route, params);
            if (paramValue !== undefined) {
                params[paramName] = paramValue;
            } else if (paramType !== 'optional-catchall') {
                // If we couldn't resolve the param, mark it as a fallback
                fallbackRouteParams.push({
                    paramName,
                    paramType
                });
            }
        }
        // Calculate next depth - increment if this is not a route group and not empty
        let nextDepth = depth;
        if (appSegment && appSegment.type !== 'route-group' && appSegment.type !== 'parallel-route') {
            nextDepth++;
        }
        // Add all parallel routes to the stack for processing.
        for (const parallelRoute of Object.values(parallelRoutes)){
            stack.push({
                tree: parallelRoute,
                depth: nextDepth
            });
        }
    }
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/esm/server/app-render/get-short-dynamic-param-type.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "dynamicParamTypes",
    ()=>dynamicParamTypes
]);
const dynamicParamTypes = {
    catchall: 'c',
    'catchall-intercepted-(..)(..)': 'ci(..)(..)',
    'catchall-intercepted-(.)': 'ci(.)',
    'catchall-intercepted-(..)': 'ci(..)',
    'catchall-intercepted-(...)': 'ci(...)',
    'optional-catchall': 'oc',
    dynamic: 'd',
    'dynamic-intercepted-(..)(..)': 'di(..)(..)',
    'dynamic-intercepted-(.)': 'di(.)',
    'dynamic-intercepted-(..)': 'di(..)',
    'dynamic-intercepted-(...)': 'di(...)'
}; //# sourceMappingURL=get-short-dynamic-param-type.js.map
}),
"[project]/node_modules/next/dist/esm/server/request/fallback-params.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createOpaqueFallbackRouteParams",
    ()=>createOpaqueFallbackRouteParams,
    "getFallbackRouteParams",
    ()=>getFallbackRouteParams
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$static$2d$paths$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/build/static-paths/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$get$2d$short$2d$dynamic$2d$param$2d$type$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/get-short-dynamic-param-type.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$routes$2f$app$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/routes/app.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$static$2d$paths$2f$app$2f$extract$2d$pathname$2d$route$2d$param$2d$segments$2d$from$2d$loader$2d$tree$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/build/static-paths/app/extract-pathname-route-param-segments-from-loader-tree.js [app-rsc] (ecmascript)");
;
;
;
;
function createOpaqueFallbackRouteParams(fallbackRouteParams) {
    // If there are no fallback route params, we can return early.
    if (fallbackRouteParams.length === 0) return null;
    // As we're creating unique keys for each of the dynamic route params, we only
    // need to generate a unique ID once per request because each of the keys will
    // be also be unique.
    const uniqueID = Math.random().toString(16).slice(2);
    const keys = new Map();
    // Generate a unique key for the fallback route param, if this key is found
    // in the static output, it represents a bug in cache components.
    for (const { paramName, paramType } of fallbackRouteParams){
        keys.set(paramName, [
            `%%drp:${paramName}:${uniqueID}%%`,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$get$2d$short$2d$dynamic$2d$param$2d$type$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["dynamicParamTypes"][paramType]
        ]);
    }
    return keys;
}
function getFallbackRouteParams(page, routeModule) {
    const route = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$routes$2f$app$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parseAppRoute"])(page, true);
    // Extract the pathname-contributing segments from the loader tree. This
    // mirrors the logic in buildAppStaticPaths where we determine which segments
    // actually contribute to the pathname.
    const { pathnameRouteParamSegments, params } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$static$2d$paths$2f$app$2f$extract$2d$pathname$2d$route$2d$param$2d$segments$2d$from$2d$loader$2d$tree$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["extractPathnameRouteParamSegmentsFromLoaderTree"])(routeModule.userland.loaderTree, route);
    // Create fallback route params for the pathname segments.
    const fallbackRouteParams = pathnameRouteParamSegments.map(({ paramName, paramType })=>({
            paramName,
            paramType
        }));
    // Resolve route params from the loader tree. This mutates the
    // fallbackRouteParams array to add any route params that are
    // unknown at request time.
    //
    // The page parameter contains placeholders like [slug], which helps
    // resolveRouteParamsFromTree determine which params are unknown.
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$static$2d$paths$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["resolveRouteParamsFromTree"])(routeModule.userland.loaderTree, params, route, fallbackRouteParams // Will be mutated to add route params
    );
    // Convert the fallback route params to an opaque format that can be safely
    // used in the postponed state without exposing implementation details.
    return createOpaqueFallbackRouteParams(fallbackRouteParams);
} //# sourceMappingURL=fallback-params.js.map
}),
"[project]/node_modules/next/dist/esm/server/app-render/manifests-singleton.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getClientReferenceManifest",
    ()=>getClientReferenceManifest,
    "getServerActionsManifest",
    ()=>getServerActionsManifest,
    "getServerModuleMap",
    ()=>getServerModuleMap,
    "selectWorkerForForwarding",
    ()=>selectWorkerForForwarding,
    "setManifestsSingleton",
    ()=>setManifestsSingleton
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$app$2d$paths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/app-paths.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/path-has-prefix.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$path$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/remove-path-prefix.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)");
;
;
;
;
;
// This is a global singleton that is, among other things, also used to
// encode/decode bound args of server function closures. This can't be using a
// AsyncLocalStorage as it might happen at the module level.
const MANIFESTS_SINGLETON = Symbol.for('next.server.manifests');
const globalThisWithManifests = globalThis;
function createProxiedClientReferenceManifest(clientReferenceManifestsPerRoute) {
    const createMappingProxy = (prop)=>{
        return new Proxy({}, {
            get (_, id) {
                const workStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workAsyncStorage"].getStore();
                if (workStore) {
                    const currentManifest = clientReferenceManifestsPerRoute.get(workStore.route);
                    if (currentManifest == null ? void 0 : currentManifest[prop][id]) {
                        return currentManifest[prop][id];
                    }
                    // In development, we also check all other manifests to see if the
                    // module exists there. This is to support a scenario where React's
                    // I/O tracking (dev-only) creates a connection from one page to
                    // another through an emitted async I/O node that references client
                    // components from the other page, e.g. in owner props.
                    // TODO: Maybe we need to add a `debugBundlerConfig` option to React
                    // to avoid this workaround. The current workaround has the
                    // disadvantage that one might accidentally or intentionally share
                    // client references across pages (e.g. by storing them in a global
                    // variable), which would then only be caught in production.
                    if ("TURBOPACK compile-time truthy", 1) {
                        for (const [route, manifest] of clientReferenceManifestsPerRoute){
                            if (route === workStore.route) {
                                continue;
                            }
                            const entry = manifest[prop][id];
                            if (entry !== undefined) {
                                return entry;
                            }
                        }
                    }
                } else {
                    // If there's no work store defined, we can assume that a client
                    // reference manifest is needed during module evaluation, e.g. to
                    // create a server function using a higher-order function. This
                    // might also use client components which need to be serialized by
                    // Flight, and therefore client references need to be resolvable. In
                    // that case we search all page manifests to find the module.
                    for (const manifest of clientReferenceManifestsPerRoute.values()){
                        const entry = manifest[prop][id];
                        if (entry !== undefined) {
                            return entry;
                        }
                    }
                }
                return undefined;
            }
        });
    };
    const mappingProxies = new Map();
    return new Proxy({}, {
        get (_, prop) {
            const workStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workAsyncStorage"].getStore();
            switch(prop){
                case 'moduleLoading':
                case 'entryCSSFiles':
                case 'entryJSFiles':
                    {
                        if (!workStore) {
                            throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["InvariantError"](`Cannot access "${prop}" without a work store.`), "__NEXT_ERROR_CODE", {
                                value: "E952",
                                enumerable: false,
                                configurable: true
                            });
                        }
                        const currentManifest = clientReferenceManifestsPerRoute.get(workStore.route);
                        if (!currentManifest) {
                            throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["InvariantError"](`The client reference manifest for route "${workStore.route}" does not exist.`), "__NEXT_ERROR_CODE", {
                                value: "E951",
                                enumerable: false,
                                configurable: true
                            });
                        }
                        return currentManifest[prop];
                    }
                case 'clientModules':
                case 'rscModuleMapping':
                case 'edgeRscModuleMapping':
                case 'ssrModuleMapping':
                case 'edgeSSRModuleMapping':
                    {
                        let proxy = mappingProxies.get(prop);
                        if (!proxy) {
                            proxy = createMappingProxy(prop);
                            mappingProxies.set(prop, proxy);
                        }
                        return proxy;
                    }
                default:
                    {
                        throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["InvariantError"](`This is a proxied client reference manifest. The property "${String(prop)}" is not handled.`), "__NEXT_ERROR_CODE", {
                            value: "E953",
                            enumerable: false,
                            configurable: true
                        });
                    }
            }
        }
    });
}
/**
 * This function creates a Flight-acceptable server module map proxy from our
 * Server Reference Manifest similar to our client module map. This is because
 * our manifest contains a lot of internal Next.js data that are relevant to the
 * runtime, workers, etc. that React doesn't need to know.
 */ function createServerModuleMap() {
    return new Proxy({}, {
        get: (_, id)=>{
            var _getServerActionsManifest__id, _getServerActionsManifest_;
            const workers = (_getServerActionsManifest_ = getServerActionsManifest()[("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'node']) == null ? void 0 : (_getServerActionsManifest__id = _getServerActionsManifest_[id]) == null ? void 0 : _getServerActionsManifest__id.workers;
            if (!workers) {
                return undefined;
            }
            const workStore = __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$server$2f$app$2d$render$2f$work$2d$async$2d$storage$2e$external$2e$js$2c$__cjs$29$__["workAsyncStorage"].getStore();
            let workerEntry;
            if (workStore) {
                workerEntry = workers[normalizeWorkerPageName(workStore.page)];
            } else {
                // If there's no work store defined, we can assume that a server
                // module map is needed during module evaluation, e.g. to create a
                // server action using a higher-order function. Therefore it should be
                // safe to return any entry from the manifest that matches the action
                // ID. They all refer to the same module ID, which must also exist in
                // the current page bundle. TODO: This is currently not guaranteed in
                // Turbopack, and needs to be fixed.
                workerEntry = Object.values(workers).at(0);
            }
            if (!workerEntry) {
                return undefined;
            }
            const { moduleId, async } = workerEntry;
            return {
                id: moduleId,
                name: id,
                chunks: [],
                async
            };
        }
    });
}
/**
 * The flight entry loader keys actions by bundlePath. bundlePath corresponds
 * with the relative path (including 'app') to the page entrypoint.
 */ function normalizeWorkerPageName(pageName) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$path$2d$has$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["pathHasPrefix"])(pageName, 'app')) {
        return pageName;
    }
    return 'app' + pageName;
}
/**
 * Converts a bundlePath (relative path to the entrypoint) to a routable page
 * name.
 */ function denormalizeWorkerPageName(bundlePath) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$app$2d$paths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["normalizeAppPath"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$remove$2d$path$2d$prefix$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["removePathPrefix"])(bundlePath, 'app'));
}
function selectWorkerForForwarding(actionId, pageName) {
    var _serverActionsManifest__actionId;
    const serverActionsManifest = getServerActionsManifest();
    const workers = (_serverActionsManifest__actionId = serverActionsManifest[("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'node'][actionId]) == null ? void 0 : _serverActionsManifest__actionId.workers;
    // There are no workers to handle this action, nothing to forward to.
    if (!workers) {
        return;
    }
    // If there is an entry for the current page, we don't need to forward.
    if (workers[normalizeWorkerPageName(pageName)]) {
        return;
    }
    // Otherwise, grab the first worker that has a handler for this action id.
    return denormalizeWorkerPageName(Object.keys(workers)[0]);
}
function setManifestsSingleton({ page, clientReferenceManifest, serverActionsManifest }) {
    const existingSingleton = globalThisWithManifests[MANIFESTS_SINGLETON];
    if (existingSingleton) {
        existingSingleton.clientReferenceManifestsPerRoute.set((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$app$2d$paths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["normalizeAppPath"])(page), clientReferenceManifest);
        existingSingleton.serverActionsManifest = serverActionsManifest;
    } else {
        const clientReferenceManifestsPerRoute = new Map([
            [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$app$2d$paths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["normalizeAppPath"])(page),
                clientReferenceManifest
            ]
        ]);
        const proxiedClientReferenceManifest = createProxiedClientReferenceManifest(clientReferenceManifestsPerRoute);
        globalThisWithManifests[MANIFESTS_SINGLETON] = {
            clientReferenceManifestsPerRoute,
            proxiedClientReferenceManifest,
            serverActionsManifest,
            serverModuleMap: createServerModuleMap()
        };
    }
}
function getManifestsSingleton() {
    const manifestSingleton = globalThisWithManifests[MANIFESTS_SINGLETON];
    if (!manifestSingleton) {
        throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["InvariantError"]('The manifests singleton was not initialized.'), "__NEXT_ERROR_CODE", {
            value: "E950",
            enumerable: false,
            configurable: true
        });
    }
    return manifestSingleton;
}
function getClientReferenceManifest() {
    return getManifestsSingleton().proxiedClientReferenceManifest;
}
function getServerActionsManifest() {
    return getManifestsSingleton().serverActionsManifest;
}
function getServerModuleMap() {
    return getManifestsSingleton().serverModuleMap;
} //# sourceMappingURL=manifests-singleton.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/html-bots.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// This regex contains the bots that we need to do a blocking render for and can't safely stream the response
// due to how they parse the DOM. For example, they might explicitly check for metadata in the `head` tag, so we can't stream metadata tags after the `head` was sent.
// Note: The pattern [\w-]+-Google captures all Google crawlers with "-Google" suffix (e.g., Mediapartners-Google, AdsBot-Google, Storebot-Google)
// as well as crawlers starting with "Google-" (e.g., Google-PageRenderer, Google-InspectionTool)
__turbopack_context__.s([
    "HTML_LIMITED_BOT_UA_RE",
    ()=>HTML_LIMITED_BOT_UA_RE
]);
const HTML_LIMITED_BOT_UA_RE = /[\w-]+-Google|Google-[\w-]+|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti|googleweblight/i; //# sourceMappingURL=html-bots.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HTML_LIMITED_BOT_UA_RE_STRING",
    ()=>HTML_LIMITED_BOT_UA_RE_STRING,
    "getBotType",
    ()=>getBotType,
    "isBot",
    ()=>isBot
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$html$2d$bots$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/html-bots.js [app-rsc] (ecmascript)");
;
// Bot crawler that will spin up a headless browser and execute JS.
// Only the main Googlebot search crawler executes JavaScript, not other Google crawlers.
// x-ref: https://developers.google.com/search/docs/crawling-indexing/google-common-crawlers
// This regex specifically matches "Googlebot" but NOT "Mediapartners-Google", "AdsBot-Google", etc.
const HEADLESS_BROWSER_BOT_UA_RE = /Googlebot(?!-)|Googlebot$/i;
const HTML_LIMITED_BOT_UA_RE_STRING = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$html$2d$bots$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["HTML_LIMITED_BOT_UA_RE"].source;
;
function isDomBotUA(userAgent) {
    return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent);
}
function isHtmlLimitedBotUA(userAgent) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$html$2d$bots$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["HTML_LIMITED_BOT_UA_RE"].test(userAgent);
}
function isBot(userAgent) {
    return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent);
}
function getBotType(userAgent) {
    if (isDomBotUA(userAgent)) {
        return 'dom';
    }
    if (isHtmlLimitedBotUA(userAgent)) {
        return 'html';
    }
    return undefined;
} //# sourceMappingURL=is-bot.js.map
}),
"[project]/node_modules/next/dist/esm/server/lib/streaming-metadata.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isHtmlBotRequest",
    ()=>isHtmlBotRequest,
    "shouldServeStreamingMetadata",
    ()=>shouldServeStreamingMetadata
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$is$2d$bot$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js [app-rsc] (ecmascript) <locals>");
;
function shouldServeStreamingMetadata(userAgent, htmlLimitedBots) {
    const blockingMetadataUARegex = new RegExp(htmlLimitedBots || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$is$2d$bot$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["HTML_LIMITED_BOT_UA_RE_STRING"], 'i');
    // Only block metadata for HTML-limited bots
    if (userAgent && blockingMetadataUARegex.test(userAgent)) {
        return false;
    }
    return true;
}
function isHtmlBotRequest(req) {
    const ua = req.headers['user-agent'] || '';
    const botType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$is$2d$bot$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getBotType"])(ua);
    return botType === 'html';
} //# sourceMappingURL=streaming-metadata.js.map
}),
"[project]/node_modules/next/dist/esm/server/lib/server-action-request-meta.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getIsPossibleServerAction",
    ()=>getIsPossibleServerAction,
    "getServerActionRequestMetadata",
    ()=>getServerActionRequestMetadata
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/app-router-headers.js [app-rsc] (ecmascript)");
;
function getServerActionRequestMetadata(req) {
    let actionId;
    let contentType;
    if (req.headers instanceof Headers) {
        actionId = req.headers.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ACTION_HEADER"]) ?? null;
        contentType = req.headers.get('content-type');
    } else {
        actionId = req.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ACTION_HEADER"]] ?? null;
        contentType = req.headers['content-type'] ?? null;
    }
    // We don't actually support URL encoded actions, and the action handler will bail out if it sees one.
    // But we still want it to flow through to the action handler, to prevent changes in behavior when a regular
    // page component tries to handle a POST.
    const isURLEncodedAction = Boolean(req.method === 'POST' && contentType === 'application/x-www-form-urlencoded');
    const isMultipartAction = Boolean(req.method === 'POST' && (contentType == null ? void 0 : contentType.startsWith('multipart/form-data')));
    const isFetchAction = Boolean(actionId !== undefined && typeof actionId === 'string' && req.method === 'POST');
    const isPossibleServerAction = Boolean(isFetchAction || isURLEncodedAction || isMultipartAction);
    return {
        actionId,
        isURLEncodedAction,
        isMultipartAction,
        isFetchAction,
        isPossibleServerAction
    };
}
function getIsPossibleServerAction(req) {
    return getServerActionRequestMetadata(req).isPossibleServerAction;
} //# sourceMappingURL=server-action-request-meta.js.map
}),
"[project]/node_modules/next/dist/esm/lib/fallback.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Describes the different fallback modes that a given page can have.
 */ __turbopack_context__.s([
    "FallbackMode",
    ()=>FallbackMode,
    "fallbackModeToFallbackField",
    ()=>fallbackModeToFallbackField,
    "parseFallbackField",
    ()=>parseFallbackField,
    "parseStaticPathsResult",
    ()=>parseStaticPathsResult
]);
var FallbackMode = /*#__PURE__*/ function(FallbackMode) {
    /**
   * A BLOCKING_STATIC_RENDER fallback will block the request until the page is
   * generated. No fallback page will be rendered, and users will have to wait
   * to render the page.
   */ FallbackMode["BLOCKING_STATIC_RENDER"] = "BLOCKING_STATIC_RENDER";
    /**
   * When set to PRERENDER, a fallback page will be sent to users in place of
   * forcing them to wait for the page to be generated. This allows the user to
   * see a rendered page earlier.
   */ FallbackMode["PRERENDER"] = "PRERENDER";
    /**
   * When set to NOT_FOUND, pages that are not already prerendered will result
   * in a not found response.
   */ FallbackMode["NOT_FOUND"] = "NOT_FOUND";
    return FallbackMode;
}({});
function parseFallbackField(fallbackField) {
    if (typeof fallbackField === 'string') {
        return "PRERENDER";
    } else if (fallbackField === null) {
        return "BLOCKING_STATIC_RENDER";
    } else if (fallbackField === false) {
        return "NOT_FOUND";
    } else if (fallbackField === undefined) {
        return undefined;
    } else {
        throw Object.defineProperty(new Error(`Invalid fallback option: ${fallbackField}. Fallback option must be a string, null, undefined, or false.`), "__NEXT_ERROR_CODE", {
            value: "E285",
            enumerable: false,
            configurable: true
        });
    }
}
function fallbackModeToFallbackField(fallback, page) {
    switch(fallback){
        case "BLOCKING_STATIC_RENDER":
            return null;
        case "NOT_FOUND":
            return false;
        case "PRERENDER":
            if (!page) {
                throw Object.defineProperty(new Error(`Invariant: expected a page to be provided when fallback mode is "${fallback}"`), "__NEXT_ERROR_CODE", {
                    value: "E422",
                    enumerable: false,
                    configurable: true
                });
            }
            return page;
        default:
            throw Object.defineProperty(new Error(`Invalid fallback mode: ${fallback}`), "__NEXT_ERROR_CODE", {
                value: "E254",
                enumerable: false,
                configurable: true
            });
    }
}
function parseStaticPathsResult(result) {
    if (result === true) {
        return "PRERENDER";
    } else if (result === 'blocking') {
        return "BLOCKING_STATIC_RENDER";
    } else {
        return "NOT_FOUND";
    }
} //# sourceMappingURL=fallback.js.map
}),
"[project]/node_modules/next/dist/esm/shared/lib/utils.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.
 * https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting
 */ __turbopack_context__.s([
    "DecodeError",
    ()=>DecodeError,
    "MiddlewareNotFoundError",
    ()=>MiddlewareNotFoundError,
    "MissingStaticPage",
    ()=>MissingStaticPage,
    "NormalizeError",
    ()=>NormalizeError,
    "PageNotFoundError",
    ()=>PageNotFoundError,
    "SP",
    ()=>SP,
    "ST",
    ()=>ST,
    "WEB_VITALS",
    ()=>WEB_VITALS,
    "execOnce",
    ()=>execOnce,
    "getDisplayName",
    ()=>getDisplayName,
    "getLocationOrigin",
    ()=>getLocationOrigin,
    "getURL",
    ()=>getURL,
    "isAbsoluteUrl",
    ()=>isAbsoluteUrl,
    "isResSent",
    ()=>isResSent,
    "loadGetInitialProps",
    ()=>loadGetInitialProps,
    "normalizeRepeatedSlashes",
    ()=>normalizeRepeatedSlashes,
    "stringifyError",
    ()=>stringifyError
]);
const WEB_VITALS = [
    'CLS',
    'FCP',
    'FID',
    'INP',
    'LCP',
    'TTFB'
];
function execOnce(fn) {
    let used = false;
    let result;
    return (...args)=>{
        if (!used) {
            used = true;
            result = fn(...args);
        }
        return result;
    };
}
// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1
// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3
const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
const isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);
function getLocationOrigin() {
    const { protocol, hostname, port } = window.location;
    return `${protocol}//${hostname}${port ? ':' + port : ''}`;
}
function getURL() {
    const { href } = window.location;
    const origin = getLocationOrigin();
    return href.substring(origin.length);
}
function getDisplayName(Component) {
    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}
function isResSent(res) {
    return res.finished || res.headersSent;
}
function normalizeRepeatedSlashes(url) {
    const urlParts = url.split('?');
    const urlNoQuery = urlParts[0];
    return urlNoQuery // first we replace any non-encoded backslashes with forward
    // then normalize repeated forward slashes
    .replace(/\\/g, '/').replace(/\/\/+/g, '/') + (urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '');
}
async function loadGetInitialProps(App, ctx) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (App.prototype?.getInitialProps) {
            const message = `"${getDisplayName(App)}.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`;
            throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
                value: "E394",
                enumerable: false,
                configurable: true
            });
        }
    }
    // when called from _app `ctx` is nested in `ctx`
    const res = ctx.res || ctx.ctx && ctx.ctx.res;
    if (!App.getInitialProps) {
        if (ctx.ctx && ctx.Component) {
            // @ts-ignore pageProps default
            return {
                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
            };
        }
        return {};
    }
    const props = await App.getInitialProps(ctx);
    if (res && isResSent(res)) {
        return props;
    }
    if (!props) {
        const message = `"${getDisplayName(App)}.getInitialProps()" should resolve to an object. But found "${props}" instead.`;
        throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (Object.keys(props).length === 0 && !ctx.ctx) {
            console.warn(`${getDisplayName(App)} returned an empty object from \`getInitialProps\`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`);
        }
    }
    return props;
}
const SP = typeof performance !== 'undefined';
const ST = SP && [
    'mark',
    'measure',
    'getEntriesByName'
].every((method)=>typeof performance[method] === 'function');
class DecodeError extends Error {
}
class NormalizeError extends Error {
}
class PageNotFoundError extends Error {
    constructor(page){
        super();
        this.code = 'ENOENT';
        this.name = 'PageNotFoundError';
        this.message = `Cannot find module for page: ${page}`;
    }
}
class MissingStaticPage extends Error {
    constructor(page, message){
        super();
        this.message = `Failed to load static file for page: ${page} ${message}`;
    }
}
class MiddlewareNotFoundError extends Error {
    constructor(){
        super();
        this.code = 'ENOENT';
        this.message = `Cannot find the middleware module`;
    }
}
function stringifyError(error) {
    return JSON.stringify({
        message: error.message,
        stack: error.stack
    });
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/next/dist/esm/server/lib/etag.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * FNV-1a Hash implementation
 * @author Travis Webb (tjwebb) <me@traviswebb.com>
 *
 * Ported from https://github.com/tjwebb/fnv-plus/blob/master/index.js
 *
 * Simplified, optimized and add modified for 52 bit, which provides a larger hash space
 * and still making use of Javascript's 53-bit integer space.
 */ __turbopack_context__.s([
    "fnv1a52",
    ()=>fnv1a52,
    "generateETag",
    ()=>generateETag
]);
const fnv1a52 = (str)=>{
    const len = str.length;
    let i = 0, t0 = 0, v0 = 0x2325, t1 = 0, v1 = 0x8422, t2 = 0, v2 = 0x9ce4, t3 = 0, v3 = 0xcbf2;
    while(i < len){
        v0 ^= str.charCodeAt(i++);
        t0 = v0 * 435;
        t1 = v1 * 435;
        t2 = v2 * 435;
        t3 = v3 * 435;
        t2 += v0 << 8;
        t3 += v1 << 8;
        t1 += t0 >>> 16;
        v0 = t0 & 65535;
        t2 += t1 >>> 16;
        v1 = t1 & 65535;
        v3 = t3 + (t2 >>> 16) & 65535;
        v2 = t2 & 65535;
    }
    return (v3 & 15) * 281474976710656 + v2 * 4294967296 + v1 * 65536 + (v0 ^ v3 >> 4);
};
const generateETag = (payload, weak = false)=>{
    const prefix = weak ? 'W/"' : '"';
    return prefix + fnv1a52(payload).toString(36) + payload.length.toString(36) + '"';
}; //# sourceMappingURL=etag.js.map
}),
"[project]/node_modules/next/dist/compiled/fresh/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

(()=>{
    "use strict";
    var e = {
        695: (e)=>{
            /*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var r = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
            e.exports = fresh;
            function fresh(e, a) {
                var t = e["if-modified-since"];
                var s = e["if-none-match"];
                if (!t && !s) {
                    return false;
                }
                var i = e["cache-control"];
                if (i && r.test(i)) {
                    return false;
                }
                if (s && s !== "*") {
                    var f = a["etag"];
                    if (!f) {
                        return false;
                    }
                    var n = true;
                    var u = parseTokenList(s);
                    for(var _ = 0; _ < u.length; _++){
                        var o = u[_];
                        if (o === f || o === "W/" + f || "W/" + o === f) {
                            n = false;
                            break;
                        }
                    }
                    if (n) {
                        return false;
                    }
                }
                if (t) {
                    var p = a["last-modified"];
                    var v = !p || !(parseHttpDate(p) <= parseHttpDate(t));
                    if (v) {
                        return false;
                    }
                }
                return true;
            }
            function parseHttpDate(e) {
                var r = e && Date.parse(e);
                return typeof r === "number" ? r : NaN;
            }
            function parseTokenList(e) {
                var r = 0;
                var a = [];
                var t = 0;
                for(var s = 0, i = e.length; s < i; s++){
                    switch(e.charCodeAt(s)){
                        case 32:
                            if (t === r) {
                                t = r = s + 1;
                            }
                            break;
                        case 44:
                            a.push(e.substring(t, r));
                            t = r = s + 1;
                            break;
                        default:
                            r = s + 1;
                            break;
                    }
                }
                a.push(e.substring(t, r));
                return a;
            }
        }
    };
    var r = {};
    function __nccwpck_require__(a) {
        var t = r[a];
        if (t !== undefined) {
            return t.exports;
        }
        var s = r[a] = {
            exports: {}
        };
        var i = true;
        try {
            e[a](s, s.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[a];
        }
        return s.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = ("TURBOPACK compile-time value", "/ROOT/node_modules/next/dist/compiled/fresh") + "/";
    var a = __nccwpck_require__(695);
    module.exports = a;
})();
}),
"[project]/node_modules/next/dist/esm/server/lib/cache-control.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getCacheControlHeader",
    ()=>getCacheControlHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/constants.js [app-rsc] (ecmascript)");
;
function getCacheControlHeader({ revalidate, expire }) {
    const swrHeader = typeof revalidate === 'number' && expire !== undefined && revalidate < expire ? `, stale-while-revalidate=${expire - revalidate}` : '';
    if (revalidate === 0) {
        return 'private, no-cache, no-store, max-age=0, must-revalidate';
    } else if (typeof revalidate === 'number') {
        return `s-maxage=${revalidate}${swrHeader}`;
    }
    return `s-maxage=${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CACHE_ONE_YEAR"]}${swrHeader}`;
} //# sourceMappingURL=cache-control.js.map
}),
"[project]/node_modules/next/dist/esm/server/send-payload.js [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sendEtagResponse",
    ()=>sendEtagResponse,
    "sendRenderResult",
    ()=>sendRenderResult
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$etag$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/etag.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$fresh$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/fresh/index.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$cache$2d$control$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/cache-control.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/constants.js [app-rsc] (ecmascript)");
;
;
;
;
;
function sendEtagResponse(req, res, etag) {
    if (etag) {
        /**
     * The server generating a 304 response MUST generate any of the
     * following header fields that would have been sent in a 200 (OK)
     * response to the same request: Cache-Control, Content-Location, Date,
     * ETag, Expires, and Vary. https://tools.ietf.org/html/rfc7232#section-4.1
     */ res.setHeader('ETag', etag);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$fresh$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"])(req.headers, {
        etag
    })) {
        res.statusCode = 304;
        res.end();
        return true;
    }
    return false;
}
async function sendRenderResult({ req, res, result, generateEtags, poweredByHeader, cacheControl }) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isResSent"])(res)) {
        return;
    }
    if (poweredByHeader && result.contentType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["HTML_CONTENT_TYPE_HEADER"]) {
        res.setHeader('X-Powered-By', 'Next.js');
    }
    // If cache control is already set on the response we don't
    // override it to allow users to customize it via next.config
    if (cacheControl && !res.getHeader('Cache-Control')) {
        res.setHeader('Cache-Control', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$cache$2d$control$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getCacheControlHeader"])(cacheControl));
    }
    const payload = result.isDynamic ? null : result.toUnchunkedString();
    if (generateEtags && payload !== null) {
        const etag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$etag$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["generateETag"])(payload);
        if (sendEtagResponse(req, res, etag)) {
            return;
        }
    }
    if (!res.getHeader('Content-Type') && result.contentType) {
        res.setHeader('Content-Type', result.contentType);
    }
    if (payload) {
        res.setHeader('Content-Length', Buffer.byteLength(payload));
    }
    if (req.method === 'HEAD') {
        res.end(null);
        return;
    }
    if (payload !== null) {
        res.end(payload);
        return;
    }
    // Pipe the render result to the response after we get a writer for it.
    await result.pipeToNodeResponse(res);
} //# sourceMappingURL=send-payload.js.map
}),
"[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-rsc] (ecmascript, Next.js Server Component)", ((__turbopack_context__) => {

__turbopack_context__.n(__turbopack_context__.i("[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-rsc] (ecmascript)"));
}),
"[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript, Next.js server utility) <locals>", ((__turbopack_context__) => {

__turbopack_context__.n(__turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript) <locals>"));}),
"[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript, Next.js server utility)", ((__turbopack_context__) => {

__turbopack_context__.n(__turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript)"));}),
"[project]/node_modules/next/dist/client/components/builtin/not-found.js [app-rsc] (ecmascript, Next.js Server Component)", ((__turbopack_context__) => {

__turbopack_context__.n(__turbopack_context__.i("[project]/node_modules/next/dist/client/components/builtin/not-found.js [app-rsc] (ecmascript)"));
}),
"[project]/node_modules/next/dist/client/components/builtin/forbidden.js [app-rsc] (ecmascript, Next.js Server Component)", ((__turbopack_context__) => {

__turbopack_context__.n(__turbopack_context__.i("[project]/node_modules/next/dist/client/components/builtin/forbidden.js [app-rsc] (ecmascript)"));
}),
"[project]/node_modules/next/dist/client/components/builtin/unauthorized.js [app-rsc] (ecmascript, Next.js Server Component)", ((__turbopack_context__) => {

__turbopack_context__.n(__turbopack_context__.i("[project]/node_modules/next/dist/client/components/builtin/unauthorized.js [app-rsc] (ecmascript)"));
}),
"[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayConcreteNode = {
    ACTOR_CHANGE: 'ActorChange',
    CATCH_FIELD: 'CatchField',
    CONDITION: 'Condition',
    CLIENT_COMPONENT: 'ClientComponent',
    CLIENT_EDGE_TO_SERVER_OBJECT: 'ClientEdgeToServerObject',
    CLIENT_EDGE_TO_CLIENT_OBJECT: 'ClientEdgeToClientObject',
    CLIENT_EXTENSION: 'ClientExtension',
    DEFER: 'Defer',
    CONNECTION: 'Connection',
    FRAGMENT: 'Fragment',
    FRAGMENT_SPREAD: 'FragmentSpread',
    INLINE_DATA_FRAGMENT_SPREAD: 'InlineDataFragmentSpread',
    INLINE_DATA_FRAGMENT: 'InlineDataFragment',
    INLINE_FRAGMENT: 'InlineFragment',
    LINKED_FIELD: 'LinkedField',
    LINKED_HANDLE: 'LinkedHandle',
    LITERAL: 'Literal',
    LIST_VALUE: 'ListValue',
    LOCAL_ARGUMENT: 'LocalArgument',
    MODULE_IMPORT: 'ModuleImport',
    ALIASED_FRAGMENT_SPREAD: 'AliasedFragmentSpread',
    ALIASED_INLINE_FRAGMENT_SPREAD: 'AliasedInlineFragmentSpread',
    RELAY_RESOLVER: 'RelayResolver',
    RELAY_LIVE_RESOLVER: 'RelayLiveResolver',
    REQUIRED_FIELD: 'RequiredField',
    OBJECT_VALUE: 'ObjectValue',
    OPERATION: 'Operation',
    REQUEST: 'Request',
    ROOT_ARGUMENT: 'RootArgument',
    SCALAR_FIELD: 'ScalarField',
    SCALAR_HANDLE: 'ScalarHandle',
    SPLIT_OPERATION: 'SplitOperation',
    STREAM: 'Stream',
    TYPE_DISCRIMINATOR: 'TypeDiscriminator',
    UPDATABLE_QUERY: 'UpdatableQuery',
    VARIABLE: 'Variable'
};
module.exports = RelayConcreteNode;
}),
"[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ /**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */ var NODE_ENV = ("TURBOPACK compile-time value", "development");
var invariant = function(condition, format, a, b, c, d, e, f) {
    if ("TURBOPACK compile-time truthy", 1) {
        if (format === undefined) {
            throw new Error('invariant requires an error message argument');
        }
    }
    if (!condition) {
        var error;
        if (format === undefined) {
            error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
            var args = [
                a,
                b,
                c,
                d,
                e,
                f
            ];
            var argIndex = 0;
            error = new Error(format.replace(/%s/g, function() {
                return args[argIndex++];
            }));
            error.name = 'Invariant Violation';
        }
        error.framesToPop = 1; // we don't care about invariant's own frame
        throw error;
    }
};
module.exports = invariant;
}),
"[project]/node_modules/fbjs/lib/emptyFunction.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */ function makeEmptyFunction(arg) {
    return function() {
        return arg;
    };
}
/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */ var emptyFunction = function emptyFunction() {};
emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function() {
    return this;
};
emptyFunction.thatReturnsArgument = function(arg) {
    return arg;
};
module.exports = emptyFunction;
}),
"[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */ var emptyFunction = __turbopack_context__.r("[project]/node_modules/fbjs/lib/emptyFunction.js [app-rsc] (ecmascript)");
/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */ function printWarning(format) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        args[_key - 1] = arguments[_key];
    }
    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function() {
        return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
        console.error(message);
    }
    try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
    } catch (x) {}
}
var warning = ("TURBOPACK compile-time truthy", 1) ? function(condition, format) {
    if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
        for(var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++){
            args[_key2 - 2] = arguments[_key2];
        }
        printWarning.apply(void 0, [
            format
        ].concat(args));
    }
} : "TURBOPACK unreachable";
module.exports = warning;
}),
"[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayConcreteNode = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function graphql(strings) {
    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'graphql: Unexpected invocation at runtime. Either the Babel transform ' + 'was not set up, or it failed to identify this call site. Make sure it ' + 'is being used verbatim as `graphql`. Note also that there cannot be ' + 'a space between graphql and the backtick that follows.') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
}
function getNode(taggedNode) {
    var node = taggedNode;
    if (typeof node === 'function') {
        node = node();
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayGraphQLTag: node `%s` unexpectedly wrapped in a function.', node.kind === 'Fragment' ? node.name : node.operation.name) : "TURBOPACK unreachable";
    } else if (node["default"]) {
        node = node["default"];
    }
    return node;
}
function isFragment(node) {
    var fragment = getNode(node);
    return typeof fragment === 'object' && fragment !== null && fragment.kind === RelayConcreteNode.FRAGMENT;
}
function isRequest(node) {
    var request = getNode(node);
    return typeof request === 'object' && request !== null && request.kind === RelayConcreteNode.REQUEST;
}
function isUpdatableQuery(node) {
    var updatableQuery = getNode(node);
    return typeof updatableQuery === 'object' && updatableQuery !== null && updatableQuery.kind === RelayConcreteNode.UPDATABLE_QUERY;
}
function isInlineDataFragment(node) {
    var fragment = getNode(node);
    return typeof fragment === 'object' && fragment !== null && fragment.kind === RelayConcreteNode.INLINE_DATA_FRAGMENT;
}
function getFragment(taggedNode) {
    var fragment = getNode(taggedNode);
    !isFragment(fragment) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'GraphQLTag: Expected a fragment, got `%s`.', JSON.stringify(fragment)) : "TURBOPACK unreachable" : void 0;
    return fragment;
}
function getPaginationFragment(taggedNode) {
    var _fragment$metadata;
    var fragment = getFragment(taggedNode);
    var refetch = (_fragment$metadata = fragment.metadata) === null || _fragment$metadata === void 0 ? void 0 : _fragment$metadata.refetch;
    var connection = refetch === null || refetch === void 0 ? void 0 : refetch.connection;
    if (refetch === null || typeof refetch !== 'object' || connection === null || typeof connection !== 'object') {
        return null;
    }
    return fragment;
}
function getRefetchableFragment(taggedNode) {
    var _fragment$metadata2;
    var fragment = getFragment(taggedNode);
    var refetch = (_fragment$metadata2 = fragment.metadata) === null || _fragment$metadata2 === void 0 ? void 0 : _fragment$metadata2.refetch;
    if (refetch === null || typeof refetch !== 'object') {
        return null;
    }
    return fragment;
}
function getRequest(taggedNode) {
    var request = getNode(taggedNode);
    !isRequest(request) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'GraphQLTag: Expected a request, got `%s`.', JSON.stringify(request)) : "TURBOPACK unreachable" : void 0;
    return request;
}
function getUpdatableQuery(taggedNode) {
    var updatableQuery = getNode(taggedNode);
    !isUpdatableQuery(updatableQuery) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'GraphQLTag: Expected a request, got `%s`.', JSON.stringify(updatableQuery)) : "TURBOPACK unreachable" : void 0;
    return updatableQuery;
}
function getInlineDataFragment(taggedNode) {
    var fragment = getNode(taggedNode);
    !isInlineDataFragment(fragment) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'GraphQLTag: Expected an inline data fragment, got `%s`.', JSON.stringify(fragment)) : "TURBOPACK unreachable" : void 0;
    return fragment;
}
module.exports = {
    getFragment: getFragment,
    getNode: getNode,
    getPaginationFragment: getPaginationFragment,
    getRefetchableFragment: getRefetchableFragment,
    getRequest: getRequest,
    getUpdatableQuery: getUpdatableQuery,
    getInlineDataFragment: getInlineDataFragment,
    graphql: graphql,
    isFragment: isFragment,
    isRequest: isRequest,
    isUpdatableQuery: isUpdatableQuery,
    isInlineDataFragment: isInlineDataFragment
};
}),
"[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/typeof.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

function _typeof(o) {
    "@babel/helpers - typeof";
    return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
        return typeof o;
    } : function(o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/toPrimitive.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var _typeof = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/typeof.js [app-rsc] (ecmascript)")["default"];
function toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/toPropertyKey.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var _typeof = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/typeof.js [app-rsc] (ecmascript)")["default"];
var toPrimitive = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toPrimitive.js [app-rsc] (ecmascript)");
function toPropertyKey(t) {
    var i = toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var toPropertyKey = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toPropertyKey.js [app-rsc] (ecmascript)");
function _defineProperty(e, r, t) {
    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[r] = t, e;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var defineProperty = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)");
function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r) {
            return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
    }
    return t;
}
function _objectSpread2(e) {
    for(var r = 1; r < arguments.length; r++){
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), !0).forEach(function(r) {
            defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r) {
            Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
    }
    return e;
}
module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/arrayLikeToArray.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
    return n;
}
module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var arrayLikeToArray = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/arrayLikeToArray.js [app-rsc] (ecmascript)");
function _unsupportedIterableToArray(r, a) {
    if (r) {
        if ("string" == typeof r) return arrayLikeToArray(r, a);
        var t = ({}).toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;
    }
}
module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var unsupportedIterableToArray = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js [app-rsc] (ecmascript)");
function _createForOfIteratorHelper(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
        if (Array.isArray(r) || (t = unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
            t && (r = t);
            var _n = 0, F = function F() {};
            return {
                s: F,
                n: function n() {
                    return _n >= r.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: r[_n++]
                    };
                },
                e: function e(r) {
                    throw r;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a = !0, u = !1;
    return {
        s: function s() {
            t = t.call(r);
        },
        n: function n() {
            var r = t.next();
            return a = r.done, r;
        },
        e: function e(r) {
            u = !0, o = r;
        },
        f: function f() {
            try {
                a || null == t["return"] || t["return"]();
            } finally{
                if (u) throw o;
            }
        }
    };
}
module.exports = _createForOfIteratorHelper, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function handleFieldErrors(environment, fieldErrors, loggingContext) {
    var _iterator = (0, _createForOfIteratorHelper2["default"])(fieldErrors), _step;
    try {
        for(_iterator.s(); !(_step = _iterator.n()).done;){
            var fieldError = _step.value;
            environment.relayFieldLogger((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, fieldError), {}, {
                uiContext: loggingContext
            }));
        }
    } catch (err) {
        _iterator.e(err);
    } finally{
        _iterator.f();
    }
    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(fieldErrors), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var _fieldError = _step2.value;
            if (eventShouldThrow(_fieldError)) {
                switch(_fieldError.kind){
                    case 'relay_resolver.error':
                        throw new Error("Relay: Resolver error at path '".concat(_fieldError.fieldPath, "' in '").concat(_fieldError.owner, "'. Message: ").concat(_fieldError.error.message));
                    case 'relay_field_payload.error':
                        throw new Error("Relay: Unexpected response payload - check server logs for details.");
                    case 'missing_expected_data.throw':
                        throw new Error("Relay: Missing expected data at path '".concat(_fieldError.fieldPath, "' in '").concat(_fieldError.owner, "'."));
                    case 'missing_required_field.throw':
                        throw new Error("Relay: Missing @required value at path '".concat(_fieldError.fieldPath, "' in '").concat(_fieldError.owner, "'."));
                    case 'missing_required_field.log':
                    case 'missing_expected_data.log':
                        break;
                    default:
                        _fieldError.kind;
                        ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Unexpected event kind: %s', _fieldError.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
                }
            }
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
}
function eventShouldThrow(event) {
    switch(event.kind){
        case 'relay_resolver.error':
        case 'relay_field_payload.error':
            return event.shouldThrow && !event.handled;
        case 'missing_expected_data.throw':
        case 'missing_required_field.throw':
            return !event.handled;
        case 'missing_required_field.log':
        case 'missing_expected_data.log':
            return false;
        default:
            event.kind;
            throw new Error('Relay: Unexpected event kind');
    }
}
function handlePotentialSnapshotErrors(environment, fieldErrors, loggingContext) {
    if (fieldErrors != null) {
        handleFieldErrors(environment, fieldErrors, loggingContext);
    }
}
module.exports = {
    handlePotentialSnapshotErrors: handlePotentialSnapshotErrors,
    eventShouldThrow: eventShouldThrow
};
}),
"[project]/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var arrayLikeToArray = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/arrayLikeToArray.js [app-rsc] (ecmascript)");
function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return arrayLikeToArray(r);
}
module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/iterableToArray.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/nonIterableSpread.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var arrayWithoutHoles = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js [app-rsc] (ecmascript)");
var iterableToArray = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/iterableToArray.js [app-rsc] (ecmascript)");
var unsupportedIterableToArray = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js [app-rsc] (ecmascript)");
var nonIterableSpread = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/nonIterableSpread.js [app-rsc] (ecmascript)");
function _toConsumableArray(r) {
    return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();
}
module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/relay-runtime/lib/util/RelayDefaultHandleKey.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    DEFAULT_HANDLE_KEY: ''
};
}),
"[project]/node_modules/relay-runtime/lib/util/getRelayHandleKey.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayDefaultHandleKey.js [app-rsc] (ecmascript)"), DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function getRelayHandleKey(handleName, key, fieldName) {
    if (key && key !== DEFAULT_HANDLE_KEY) {
        return "__".concat(key, "_").concat(handleName);
    }
    !(fieldName != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'getRelayHandleKey: Expected either `fieldName` or `key` in `handle` to be provided') : "TURBOPACK unreachable" : void 0;
    return "__".concat(fieldName, "_").concat(handleName);
}
module.exports = getRelayHandleKey;
}),
"[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayFeatureFlags = {
    ENABLE_VARIABLE_CONNECTION_KEY: false,
    ENABLE_RELAY_RESOLVERS: false,
    ENABLE_GETFRAGMENTIDENTIFIER_OPTIMIZATION: false,
    ENABLE_FRIENDLY_QUERY_NAME_GQL_URL: false,
    ENABLE_DO_NOT_WRAP_LIVE_QUERY: false,
    ENABLE_NOTIFY_SUBSCRIPTION: false,
    BATCH_ASYNC_MODULE_UPDATES_FN: null,
    ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT: false,
    MAX_DATA_ID_LENGTH: null,
    STRING_INTERN_LEVEL: 0,
    LOG_MISSING_RECORDS_IN_PROD: false,
    ENABLE_STORE_ID_COLLISION_LOGGING: false,
    ENABLE_NONCOMPLIANT_ERROR_HANDLING_ON_LISTS: false,
    ENABLE_LOOSE_SUBSCRIPTION_ATTRIBUTION: false,
    ENABLE_OPERATION_TRACKER_OPTIMISTIC_UPDATES: false,
    ENABLE_RELAY_OPERATION_TRACKER_SUSPENSE: false,
    PROCESS_OPTIMISTIC_UPDATE_BEFORE_SUBSCRIPTION: false,
    MARK_RESOLVER_VALUES_AS_CLEAN_AFTER_FRAGMENT_REREAD: false,
    ENABLE_CYLE_DETECTION_IN_VARIABLES: false,
    ENABLE_ACTIVITY_COMPATIBILITY: false,
    ENABLE_READ_TIME_RESOLVER_STORAGE_KEY_PREFIX: true,
    ENABLE_USE_PAGINATION_IS_LOADING_FIX: false,
    DISALLOW_NESTED_UPDATES: false,
    ENABLE_TYPENAME_PREFIXED_DATA_ID: false,
    ENABLE_UI_CONTEXT_ON_RELAY_LOGGER: false,
    CHECK_ALL_FRAGMENTS_FOR_MISSING_CLIENT_EDGES: false
};
module.exports = RelayFeatureFlags;
}),
"[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function stableCopy(value) {
    if (!value || typeof value !== 'object') {
        return value;
    }
    if (Array.isArray(value)) {
        return value.map(stableCopy);
    }
    var keys = Object.keys(value).sort();
    var stable = {};
    for(var i = 0; i < keys.length; i++){
        stable[keys[i]] = stableCopy(value[keys[i]]);
    }
    return stable;
}
function hasCycle(value) {
    var parents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
    if (!value || typeof value !== 'object') {
        return false;
    }
    if (parents.has(value)) {
        return true;
    }
    var newParents = new Set(parents);
    newParents.add(value);
    var children = Array.isArray(value) ? value : Object.values(value);
    return children.some(function(v) {
        return hasCycle(v, newParents);
    });
}
module.exports = {
    stableCopy: stableCopy,
    hasCycle: hasCycle
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-rsc] (ecmascript)"));
var getRelayHandleKey = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRelayHandleKey.js [app-rsc] (ecmascript)");
var RelayConcreteNode = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-rsc] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-rsc] (ecmascript)"), stableCopy = _require.stableCopy;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var VARIABLE = RelayConcreteNode.VARIABLE, LITERAL = RelayConcreteNode.LITERAL, OBJECT_VALUE = RelayConcreteNode.OBJECT_VALUE, LIST_VALUE = RelayConcreteNode.LIST_VALUE;
var ERRORS_KEY = '__errors';
var MODULE_COMPONENT_KEY_PREFIX = '__module_component_';
var MODULE_OPERATION_KEY_PREFIX = '__module_operation_';
var RELAY_READ_TIME_RESOLVER_KEY_PREFIX = '$r:';
function getArgumentValue(arg, variables) {
    if (arg.kind === VARIABLE) {
        return getStableVariableValue(arg.variableName, variables);
    } else if (arg.kind === LITERAL) {
        return arg.value;
    } else if (arg.kind === OBJECT_VALUE) {
        var value = {};
        arg.fields.forEach(function(field) {
            value[field.name] = getArgumentValue(field, variables);
        });
        return value;
    } else if (arg.kind === LIST_VALUE) {
        var _value = [];
        arg.items.forEach(function(item) {
            item != null ? _value.push(getArgumentValue(item, variables)) : null;
        });
        return _value;
    }
}
function getArgumentValues(args, variables, isWithinUnmatchedTypeRefinement) {
    var values = {};
    if (isWithinUnmatchedTypeRefinement) {
        values[RelayStoreUtils.FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] = true;
    }
    if (args) {
        args.forEach(function(arg) {
            values[arg.name] = getArgumentValue(arg, variables);
        });
    }
    return values;
}
function getHandleStorageKey(handleField, variables) {
    var dynamicKey = handleField.dynamicKey, handle = handleField.handle, key = handleField.key, name = handleField.name, args = handleField.args, filters = handleField.filters;
    var handleName = getRelayHandleKey(handle, key, name);
    var filterArgs = null;
    if (args && filters && args.length !== 0 && filters.length !== 0) {
        filterArgs = args.filter(function(arg) {
            return filters.indexOf(arg.name) > -1;
        });
    }
    if (dynamicKey) {
        filterArgs = filterArgs != null ? [
            dynamicKey
        ].concat((0, _toConsumableArray2["default"])(filterArgs)) : [
            dynamicKey
        ];
    }
    if (filterArgs === null) {
        return handleName;
    } else {
        return formatStorageKey(handleName, getArgumentValues(filterArgs, variables));
    }
}
function getStorageKey(field, variables) {
    if (field.storageKey) {
        return field.storageKey;
    }
    var args = getArguments(field);
    var name = field.name;
    return args && args.length !== 0 ? formatStorageKey(name, getArgumentValues(args, variables)) : name;
}
function getReadTimeResolverStorageKey(field, variables) {
    var storageKey = getStorageKey(field, variables);
    return RelayFeatureFlags.ENABLE_READ_TIME_RESOLVER_STORAGE_KEY_PREFIX ? '$r:' + storageKey : storageKey;
}
function getArguments(field) {
    if (field.kind === 'RelayResolver' || field.kind === 'RelayLiveResolver') {
        var _field$fragment2;
        if (field.args == null) {
            var _field$fragment;
            return (_field$fragment = field.fragment) === null || _field$fragment === void 0 ? void 0 : _field$fragment.args;
        }
        if (((_field$fragment2 = field.fragment) === null || _field$fragment2 === void 0 ? void 0 : _field$fragment2.args) == null) {
            return field.args;
        }
        return field.args.concat(field.fragment.args);
    }
    var args = typeof field.args === 'undefined' ? undefined : field.args;
    return args;
}
function getStableStorageKey(name, args) {
    return formatStorageKey(name, stableCopy(args));
}
function formatStorageKey(name, argValues) {
    if (!argValues) {
        return name;
    }
    var values = [];
    for(var argName in argValues){
        if (argValues.hasOwnProperty(argName)) {
            var value = argValues[argName];
            if (value != null) {
                var _JSON$stringify;
                values.push(argName + ':' + ((_JSON$stringify = JSON.stringify(value)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'undefined'));
            }
        }
    }
    return values.length === 0 ? name : name + "(".concat(values.join(','), ")");
}
function getStableVariableValue(name, variables) {
    !variables.hasOwnProperty(name) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'getVariableValue(): Undefined variable `%s`.', name) : "TURBOPACK unreachable" : void 0;
    return stableCopy(variables[name]);
}
function getModuleComponentKey(documentName) {
    return "".concat(MODULE_COMPONENT_KEY_PREFIX).concat(documentName);
}
function getModuleOperationKey(documentName) {
    return "".concat(MODULE_OPERATION_KEY_PREFIX).concat(documentName);
}
var RelayStoreUtils = {
    ACTOR_IDENTIFIER_KEY: '__actorIdentifier',
    CLIENT_EDGE_TRAVERSAL_PATH: '__clientEdgeTraversalPath',
    FRAGMENTS_KEY: '__fragments',
    FRAGMENT_OWNER_KEY: '__fragmentOwner',
    FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT: '$isWithinUnmatchedTypeRefinement',
    FRAGMENT_PROP_NAME_KEY: '__fragmentPropName',
    MODULE_COMPONENT_KEY: '__module_component',
    ERRORS_KEY: ERRORS_KEY,
    ID_KEY: '__id',
    REF_KEY: '__ref',
    REFS_KEY: '__refs',
    ROOT_ID: 'client:root',
    ROOT_TYPE: '__Root',
    TYPENAME_KEY: '__typename',
    INVALIDATED_AT_KEY: '__invalidated_at',
    RELAY_RESOLVER_VALUE_KEY: '__resolverValue',
    RELAY_RESOLVER_INVALIDATION_KEY: '__resolverValueMayBeInvalid',
    RELAY_RESOLVER_SNAPSHOT_KEY: '__resolverSnapshot',
    RELAY_RESOLVER_ERROR_KEY: '__resolverError',
    RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS: '__resolverOutputTypeRecordIDs',
    RELAY_READ_TIME_RESOLVER_KEY_PREFIX: RELAY_READ_TIME_RESOLVER_KEY_PREFIX,
    formatStorageKey: formatStorageKey,
    getArgumentValue: getArgumentValue,
    getArgumentValues: getArgumentValues,
    getHandleStorageKey: getHandleStorageKey,
    getStorageKey: getStorageKey,
    getReadTimeResolverStorageKey: getReadTimeResolverStorageKey,
    getStableStorageKey: getStableStorageKey,
    getModuleComponentKey: getModuleComponentKey,
    getModuleOperationKey: getModuleOperationKey
};
module.exports = RelayStoreUtils;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), getArgumentValues = _require.getArgumentValues;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function getFragmentVariables(fragment, rootVariables, argumentVariables) {
    if (fragment.argumentDefinitions == null) {
        return argumentVariables;
    }
    var variables;
    fragment.argumentDefinitions.forEach(function(definition) {
        if (argumentVariables.hasOwnProperty(definition.name)) {
            return;
        }
        variables = variables || (0, _objectSpread2["default"])({}, argumentVariables);
        switch(definition.kind){
            case 'LocalArgument':
                variables[definition.name] = definition.defaultValue;
                break;
            case 'RootArgument':
                if (!rootVariables.hasOwnProperty(definition.name)) {
                    variables[definition.name] = undefined;
                    break;
                }
                variables[definition.name] = rootVariables[definition.name];
                break;
            default:
                definition;
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayConcreteVariables: Unexpected node kind `%s` in fragment `%s`.', definition.kind, fragment.name) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
    });
    return variables || argumentVariables;
}
function getOperationVariables(operation, providedVariables, variables) {
    var operationVariables = {};
    operation.argumentDefinitions.forEach(function(def) {
        var value = def.defaultValue;
        if (variables[def.name] != null) {
            value = variables[def.name];
        }
        operationVariables[def.name] = value;
    });
    if (providedVariables != null) {
        Object.keys(providedVariables).forEach(function(varName) {
            operationVariables[varName] = providedVariables[varName].get();
        });
    }
    return operationVariables;
}
function getLocalVariables(currentVariables, argumentDefinitions, args) {
    if (argumentDefinitions == null) {
        return currentVariables;
    }
    var nextVariables = (0, _objectSpread2["default"])({}, currentVariables);
    var nextArgs = args ? getArgumentValues(args, currentVariables) : {};
    argumentDefinitions.forEach(function(def) {
        var _nextArgs$def$name;
        var value = (_nextArgs$def$name = nextArgs[def.name]) !== null && _nextArgs$def$name !== void 0 ? _nextArgs$def$name : def.defaultValue;
        nextVariables[def.name] = value;
    });
    return nextVariables;
}
module.exports = {
    getLocalVariables: getLocalVariables,
    getFragmentVariables: getFragmentVariables,
    getOperationVariables: getOperationVariables
};
}),
"[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */ var aStackPool = [];
var bStackPool = [];
/**
 * Checks if two values are equal. Values may be primitives, arrays, or objects.
 * Returns true if both arguments have the same keys and values.
 *
 * @see http://underscorejs.org
 * @copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * @license MIT
 */ function areEqual(a, b) {
    var aStack = aStackPool.length ? aStackPool.pop() : [];
    var bStack = bStackPool.length ? bStackPool.pop() : [];
    var result = eq(a, b, aStack, bStack);
    aStack.length = 0;
    bStack.length = 0;
    aStackPool.push(aStack);
    bStackPool.push(bStack);
    return result;
}
function eq(a, b, aStack, bStack) {
    if (a === b) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        return a !== 0 || 1 / a == 1 / b;
    }
    if (a == null || b == null) {
        // a or b can be `null` or `undefined`
        return false;
    }
    if (typeof a != 'object' || typeof b != 'object') {
        return false;
    }
    var objToStr = Object.prototype.toString;
    var className = objToStr.call(a);
    if (className != objToStr.call(b)) {
        return false;
    }
    switch(className){
        case '[object String]':
            return a == String(b);
        case '[object Number]':
            return isNaN(a) || isNaN(b) ? false : a == Number(b);
        case '[object Date]':
        case '[object Boolean]':
            return +a == +b;
        case '[object RegExp]':
            return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
    } // Assume equality for cyclic structures.
    var length = aStack.length;
    while(length--){
        if (aStack[length] == a) {
            return bStack[length] == b;
        }
    }
    aStack.push(a);
    bStack.push(b);
    var size = 0; // Recursively compare objects and arrays.
    if (className === '[object Array]') {
        size = a.length;
        if (size !== b.length) {
            return false;
        } // Deep compare the contents, ignoring non-numeric properties.
        while(size--){
            if (!eq(a[size], b[size], aStack, bStack)) {
                return false;
            }
        }
    } else {
        if (a.constructor !== b.constructor) {
            return false;
        }
        if (a.hasOwnProperty('valueOf') && b.hasOwnProperty('valueOf')) {
            return a.valueOf() == b.valueOf();
        }
        var keys = Object.keys(a);
        if (keys.length != Object.keys(b).length) {
            return false;
        }
        for(var i = 0; i < keys.length; i++){
            if (!eq(a[keys[i]], b[keys[i]], aStack, bStack)) {
                return false;
            }
        }
    }
    aStack.pop();
    bStack.pop();
    return true;
}
module.exports = areEqual;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-rsc] (ecmascript)"), getFragmentVariables = _require.getFragmentVariables;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), CLIENT_EDGE_TRAVERSAL_PATH = _require2.CLIENT_EDGE_TRAVERSAL_PATH, FRAGMENT_OWNER_KEY = _require2.FRAGMENT_OWNER_KEY, FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = _require2.FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT, FRAGMENTS_KEY = _require2.FRAGMENTS_KEY, ID_KEY = _require2.ID_KEY;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function getSingularSelector(fragment, item) {
    !(typeof item === 'object' && item !== null && !Array.isArray(item)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernSelector: Expected value for fragment `%s` to be an object, got ' + '`%s`.', fragment.name, JSON.stringify(item)) : "TURBOPACK unreachable" : void 0;
    var dataID = item[ID_KEY];
    var fragments = item[FRAGMENTS_KEY];
    var mixedOwner = item[FRAGMENT_OWNER_KEY];
    var mixedClientEdgeTraversalPath = item[CLIENT_EDGE_TRAVERSAL_PATH];
    if (typeof dataID === 'string' && typeof fragments === 'object' && fragments !== null && typeof fragments[fragment.name] === 'object' && fragments[fragment.name] !== null && typeof mixedOwner === 'object' && mixedOwner !== null && (mixedClientEdgeTraversalPath == null || Array.isArray(mixedClientEdgeTraversalPath))) {
        var owner = mixedOwner;
        var clientEdgeTraversalPath = mixedClientEdgeTraversalPath;
        var argumentVariables = fragments[fragment.name];
        var fragmentVariables = getFragmentVariables(fragment, owner.variables, argumentVariables);
        var isWithinUnmatchedTypeRefinement = argumentVariables[FRAGMENT_POINTER_IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] === true;
        return createReaderSelector(fragment, dataID, fragmentVariables, owner, isWithinUnmatchedTypeRefinement, clientEdgeTraversalPath);
    }
    if ("TURBOPACK compile-time truthy", 1) {
        var stringifiedItem = JSON.stringify(item);
        if (stringifiedItem.length > 499) {
            stringifiedItem = stringifiedItem.substr(0, 498) + "\u2026";
        }
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayModernSelector: Expected object to contain data for fragment `%s`, got ' + '`%s`. Make sure that the parent operation/fragment included fragment ' + '`...%s` without `@relay(mask: false)`.', fragment.name, stringifiedItem, fragment.name) : "TURBOPACK unreachable";
    }
    return null;
}
function getPluralSelector(fragment, items) {
    var selectors = null;
    items.forEach(function(item, ii) {
        var selector = item != null ? getSingularSelector(fragment, item) : null;
        if (selector != null) {
            selectors = selectors || [];
            selectors.push(selector);
        }
    });
    if (selectors == null) {
        return null;
    } else {
        return {
            kind: 'PluralReaderSelector',
            selectors: selectors
        };
    }
}
function getSelector(fragment, item) {
    if (item == null) {
        return item;
    } else if (fragment.metadata && fragment.metadata.plural === true) {
        !Array.isArray(item) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernSelector: Expected value for fragment `%s` to be an array, got `%s`. ' + 'Remove `@relay(plural: true)` from fragment `%s` to allow the prop to be an object.', fragment.name, JSON.stringify(item), fragment.name) : "TURBOPACK unreachable" : void 0;
        return getPluralSelector(fragment, item);
    } else {
        !!Array.isArray(item) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernSelector: Expected value for fragment `%s` to be an object, got `%s`. ' + 'Add `@relay(plural: true)` to fragment `%s` to allow the prop to be an array of items.', fragment.name, JSON.stringify(item), fragment.name) : "TURBOPACK unreachable" : void 0;
        return getSingularSelector(fragment, item);
    }
}
function getSelectorsFromObject(fragments, object) {
    var selectors = {};
    for(var key in fragments){
        if (fragments.hasOwnProperty(key)) {
            var fragment = fragments[key];
            var item = object[key];
            selectors[key] = getSelector(fragment, item);
        }
    }
    return selectors;
}
function getDataIDsFromObject(fragments, object) {
    var ids = {};
    for(var key in fragments){
        if (fragments.hasOwnProperty(key)) {
            var fragment = fragments[key];
            var item = object[key];
            ids[key] = getDataIDsFromFragment(fragment, item);
        }
    }
    return ids;
}
function getDataIDsFromFragment(fragment, item) {
    if (item == null) {
        return item;
    } else if (fragment.metadata && fragment.metadata.plural === true) {
        !Array.isArray(item) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernSelector: Expected value for fragment `%s` to be an array, got `%s`. ' + 'Remove `@relay(plural: true)` from fragment `%s` to allow the prop to be an object.', fragment.name, JSON.stringify(item), fragment.name) : "TURBOPACK unreachable" : void 0;
        return getDataIDs(fragment, item);
    } else {
        !!Array.isArray(item) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernFragmentSpecResolver: Expected value for fragment `%s` to be an object, got `%s`. ' + 'Add `@relay(plural: true)` to fragment `%s` to allow the prop to be an array of items.', fragment.name, JSON.stringify(item), fragment.name) : "TURBOPACK unreachable" : void 0;
        return getDataID(fragment, item);
    }
}
function getDataIDs(fragment, items) {
    var ids = null;
    items.forEach(function(item) {
        var id = item != null ? getDataID(fragment, item) : null;
        if (id != null) {
            ids = ids || [];
            ids.push(id);
        }
    });
    return ids;
}
function getDataID(fragment, item) {
    !(typeof item === 'object' && item !== null && !Array.isArray(item)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernSelector: Expected value for fragment `%s` to be an object, got ' + '`%s`.', fragment.name, JSON.stringify(item)) : "TURBOPACK unreachable" : void 0;
    var dataID = item[ID_KEY];
    if (typeof dataID === 'string') {
        return dataID;
    }
    ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayModernSelector: Expected object to contain data for fragment `%s`, got ' + '`%s`. Make sure that the parent operation/fragment included fragment ' + '`...%s` without `@relay(mask: false)`, or `null` is passed as the fragment ' + "reference for `%s` if it's conditonally included and the condition isn't met.", fragment.name, JSON.stringify(item), fragment.name, fragment.name) : "TURBOPACK unreachable";
    return null;
}
function getVariablesFromObject(fragments, object) {
    var variables = {};
    for(var key in fragments){
        if (fragments.hasOwnProperty(key)) {
            var fragment = fragments[key];
            var item = object[key];
            var itemVariables = getVariablesFromFragment(fragment, item);
            Object.assign(variables, itemVariables);
        }
    }
    return variables;
}
function getVariablesFromFragment(fragment, item) {
    var _fragment$metadata;
    if (item == null) {
        return {};
    } else if (((_fragment$metadata = fragment.metadata) === null || _fragment$metadata === void 0 ? void 0 : _fragment$metadata.plural) === true) {
        !Array.isArray(item) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernSelector: Expected value for fragment `%s` to be an array, got `%s`. ' + 'Remove `@relay(plural: true)` from fragment `%s` to allow the prop to be an object.', fragment.name, JSON.stringify(item), fragment.name) : "TURBOPACK unreachable" : void 0;
        return getVariablesFromPluralFragment(fragment, item);
    } else {
        !!Array.isArray(item) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernFragmentSpecResolver: Expected value for fragment `%s` to be an object, got `%s`. ' + 'Add `@relay(plural: true)` to fragment `%s` to allow the prop to be an array of items.', fragment.name, JSON.stringify(item), fragment.name) : "TURBOPACK unreachable" : void 0;
        return getVariablesFromSingularFragment(fragment, item) || {};
    }
}
function getVariablesFromSingularFragment(fragment, item) {
    var selector = getSingularSelector(fragment, item);
    if (!selector) {
        return null;
    }
    return selector.variables;
}
function getVariablesFromPluralFragment(fragment, items) {
    var variables = {};
    items.forEach(function(value, ii) {
        if (value != null) {
            var itemVariables = getVariablesFromSingularFragment(fragment, value);
            if (itemVariables != null) {
                Object.assign(variables, itemVariables);
            }
        }
    });
    return variables;
}
function areEqualSingularSelectors(thisSelector, thatSelector) {
    return thisSelector.dataID === thatSelector.dataID && thisSelector.node === thatSelector.node && areEqual(thisSelector.variables, thatSelector.variables) && areEqualOwners(thisSelector.owner, thatSelector.owner) && thisSelector.isWithinUnmatchedTypeRefinement === thatSelector.isWithinUnmatchedTypeRefinement && areEqualClientEdgeTraversalPaths(thisSelector.clientEdgeTraversalPath, thatSelector.clientEdgeTraversalPath);
}
function areEqualOwners(thisOwner, thatOwner) {
    if (thisOwner === thatOwner) {
        return true;
    } else {
        return thisOwner.identifier === thatOwner.identifier && areEqual(thisOwner.cacheConfig, thatOwner.cacheConfig);
    }
}
function areEqualClientEdgeTraversalPaths(thisPath, thatPath) {
    if (thisPath === thatPath) {
        return true;
    }
    if (thisPath == null || thatPath == null || thisPath.length !== thatPath.length) {
        return false;
    }
    var idx = thisPath.length;
    while(idx--){
        var a = thisPath[idx];
        var b = thatPath[idx];
        if (a === b) {
            continue;
        }
        if (a == null || b == null || a.clientEdgeDestinationID !== b.clientEdgeDestinationID || a.readerClientEdge !== b.readerClientEdge) {
            return false;
        }
    }
    return true;
}
function areEqualSelectors(a, b) {
    if (a === b) {
        return true;
    } else if (a == null) {
        return b == null;
    } else if (b == null) {
        return a == null;
    } else if (a.kind === 'SingularReaderSelector' && b.kind === 'SingularReaderSelector') {
        return areEqualSingularSelectors(a, b);
    } else if (a.kind === 'PluralReaderSelector' && b.kind === 'PluralReaderSelector') {
        return a.selectors.length === b.selectors.length && a.selectors.every(function(s, i) {
            return areEqualSingularSelectors(s, b.selectors[i]);
        });
    } else {
        return false;
    }
}
function createReaderSelector(fragment, dataID, variables, request) {
    var isWithinUnmatchedTypeRefinement = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var clientEdgeTraversalPath = arguments.length > 5 ? arguments[5] : undefined;
    return {
        kind: 'SingularReaderSelector',
        dataID: dataID,
        isWithinUnmatchedTypeRefinement: isWithinUnmatchedTypeRefinement,
        clientEdgeTraversalPath: clientEdgeTraversalPath !== null && clientEdgeTraversalPath !== void 0 ? clientEdgeTraversalPath : null,
        node: fragment,
        variables: variables,
        owner: request
    };
}
function createNormalizationSelector(node, dataID, variables) {
    return {
        dataID: dataID,
        node: node,
        variables: variables
    };
}
module.exports = {
    areEqualSelectors: areEqualSelectors,
    createReaderSelector: createReaderSelector,
    createNormalizationSelector: createNormalizationSelector,
    getDataIDsFromFragment: getDataIDsFromFragment,
    getDataIDsFromObject: getDataIDsFromObject,
    getSingularSelector: getSingularSelector,
    getPluralSelector: getPluralSelector,
    getSelector: getSelector,
    getSelectorsFromObject: getSelectorsFromObject,
    getVariablesFromSingularFragment: getVariablesFromSingularFragment,
    getVariablesFromPluralFragment: getVariablesFromPluralFragment,
    getVariablesFromFragment: getVariablesFromFragment,
    getVariablesFromObject: getVariablesFromObject
};
}),
"[project]/node_modules/relay-runtime/lib/store/ResolverFragments.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-rsc] (ecmascript)"), getFragment = _require.getFragment;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js [app-rsc] (ecmascript)"), eventShouldThrow = _require2.eventShouldThrow;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-rsc] (ecmascript)"), getSelector = _require3.getSelector;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var contextStack = [];
function withResolverContext(context, cb) {
    contextStack.push(context);
    try {
        return cb();
    } finally{
        contextStack.pop();
    }
}
function readFragment(fragmentInput, fragmentKey) {
    if (!contextStack.length) {
        throw new Error('readFragment should be called only from within a Relay Resolver function.');
    }
    var context = contextStack[contextStack.length - 1];
    var fragmentNode = getFragment(fragmentInput);
    var fragmentSelector = getSelector(fragmentNode, fragmentKey);
    !(fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, "Expected a selector for the fragment of the resolver ".concat(fragmentNode.name, ", but got null.")) : "TURBOPACK unreachable" : void 0;
    !(fragmentSelector.kind === 'SingularReaderSelector') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, "Expected a singular reader selector for the fragment of the resolver ".concat(fragmentNode.name, ", but it was plural.")) : "TURBOPACK unreachable" : void 0;
    var _context$getDataForRe = context.getDataForResolverFragment(fragmentSelector, fragmentKey), data = _context$getDataForRe.data, isMissingData = _context$getDataForRe.isMissingData, fieldErrors = _context$getDataForRe.fieldErrors;
    if (isMissingData || fieldErrors != null && fieldErrors.some(eventShouldThrow)) {
        throw RESOLVER_FRAGMENT_ERRORED_SENTINEL;
    }
    return data;
}
var RESOLVER_FRAGMENT_ERRORED_SENTINEL = {};
module.exports = {
    readFragment: readFragment,
    withResolverContext: withResolverContext,
    RESOLVER_FRAGMENT_ERRORED_SENTINEL: RESOLVER_FRAGMENT_ERRORED_SENTINEL
};
}),
"[project]/node_modules/relay-runtime/lib/store/live-resolvers/resolverDataInjector.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ResolverFragments.js [app-rsc] (ecmascript)"), readFragment = _require.readFragment;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function resolverDataInjector(fragment, _resolverFn, fieldName, isRequiredField) {
    var resolverFn = _resolverFn;
    return function(fragmentKey, args, resolverContext) {
        var data = readFragment(fragment, fragmentKey);
        if (fieldName != null) {
            if (data == null) {
                if (isRequiredField === true) {
                    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected required resolver field `%s` in fragment `%s` to be present. But resolvers fragment data is null/undefined.', fieldName, fragment.name) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
                } else {
                    return resolverFn(null, args, resolverContext);
                }
            }
            if (fieldName in data) {
                if (isRequiredField === true) {
                    !(data[fieldName] != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected required resolver field `%s` in fragment `%s` to be non-null.', fieldName, fragment.name) : "TURBOPACK unreachable" : void 0;
                }
                return resolverFn(data[fieldName], args, resolverContext);
            } else {
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Missing field `%s` in fragment `%s` in resolver response.', fieldName, fragment.name) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
        } else {
            return resolverFn(null, args, resolverContext);
        }
    };
}
module.exports = resolverDataInjector;
}),
"[project]/node_modules/@babel/runtime/helpers/asyncToGenerator.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

function asyncGeneratorStep(n, t, e, r, o, a, c) {
    try {
        var i = n[a](c), u = i.value;
    } catch (n) {
        return void e(n);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
    return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
            var a = n.apply(t, e);
            function _next(n) {
                asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
            }
            function _throw(n) {
                asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
            }
            _next(void 0);
        });
    };
}
module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/relay-runtime/lib/util/isPromise.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function isPromise(p) {
    return p != null && typeof p === 'object' && typeof p.then === 'function';
}
module.exports = isPromise;
}),
"[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isPromise = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/isPromise.js [app-rsc] (ecmascript)");
var hostReportError = swallowError;
var RelayObservable = /*#__PURE__*/ function() {
    RelayObservable.create = function create(source) {
        return new RelayObservable(source);
    };
    function RelayObservable(source) {
        if ("TURBOPACK compile-time truthy", 1) {
            if (!source || typeof source !== 'function') {
                throw new Error('Source must be a Function: ' + String(source));
            }
        }
        this._source = source;
    }
    RelayObservable.onUnhandledError = function onUnhandledError(callback) {
        hostReportError = callback;
    };
    RelayObservable.from = function from(obj) {
        return isObservable(obj) ? fromObservable(obj) : isPromise(obj) ? fromPromise(obj) : fromValue(obj);
    };
    var _proto = RelayObservable.prototype;
    _proto["catch"] = function _catch(fn) {
        var _this = this;
        return RelayObservable.create(function(sink) {
            var subscription;
            _this.subscribe({
                start: function start(sub) {
                    subscription = sub;
                },
                next: sink.next,
                complete: sink.complete,
                error: function error(_error2) {
                    try {
                        fn(_error2).subscribe({
                            start: function start(sub) {
                                subscription = sub;
                            },
                            next: sink.next,
                            complete: sink.complete,
                            error: sink.error
                        });
                    } catch (error2) {
                        sink.error(error2, true);
                    }
                }
            });
            return function() {
                return subscription.unsubscribe();
            };
        });
    };
    _proto.concat = function concat(next) {
        var _this2 = this;
        return RelayObservable.create(function(sink) {
            var current;
            _this2.subscribe({
                start: function start(subscription) {
                    current = subscription;
                },
                next: sink.next,
                error: sink.error,
                complete: function complete() {
                    current = next.subscribe(sink);
                }
            });
            return function() {
                current && current.unsubscribe();
            };
        });
    };
    _proto["do"] = function _do(observer) {
        var _this3 = this;
        return RelayObservable.create(function(sink) {
            var both = function both(action) {
                return function() {
                    try {
                        observer[action] && observer[action].apply(observer, arguments);
                    } catch (error) {
                        hostReportError(error, true);
                    }
                    sink[action] && sink[action].apply(sink, arguments);
                };
            };
            return _this3.subscribe({
                start: both('start'),
                next: both('next'),
                error: both('error'),
                complete: both('complete'),
                unsubscribe: both('unsubscribe')
            });
        });
    };
    _proto["finally"] = function _finally(fn) {
        var _this4 = this;
        return RelayObservable.create(function(sink) {
            var subscription = _this4.subscribe(sink);
            return function() {
                subscription.unsubscribe();
                fn();
            };
        });
    };
    _proto.ifEmpty = function ifEmpty(alternate) {
        var _this5 = this;
        return RelayObservable.create(function(sink) {
            var hasValue = false;
            var current;
            current = _this5.subscribe({
                next: function next(value) {
                    hasValue = true;
                    sink.next(value);
                },
                error: sink.error,
                complete: function complete() {
                    if (hasValue) {
                        sink.complete();
                    } else {
                        current = alternate.subscribe(sink);
                    }
                }
            });
            return function() {
                current && current.unsubscribe();
            };
        });
    };
    _proto.subscribe = function subscribe(observer) {
        if ("TURBOPACK compile-time truthy", 1) {
            if (!observer || typeof observer !== 'object') {
                throw new Error('Observer must be an Object with callbacks: ' + String(observer));
            }
        }
        return _subscribe(this._source, observer);
    };
    _proto.map = function map(fn) {
        var _this6 = this;
        return RelayObservable.create(function(sink) {
            var subscription = _this6.subscribe({
                complete: sink.complete,
                error: sink.error,
                next: function next(value) {
                    try {
                        var mapValue = fn(value);
                        sink.next(mapValue);
                    } catch (error) {
                        sink.error(error, true);
                    }
                }
            });
            return function() {
                subscription.unsubscribe();
            };
        });
    };
    _proto.mergeMap = function mergeMap(fn) {
        var _this7 = this;
        return RelayObservable.create(function(sink) {
            var subscriptions = [];
            function start(subscription) {
                this._sub = subscription;
                subscriptions.push(subscription);
            }
            function complete() {
                subscriptions.splice(subscriptions.indexOf(this._sub), 1);
                if (subscriptions.length === 0) {
                    sink.complete();
                }
            }
            _this7.subscribe({
                start: start,
                next: function next(value) {
                    try {
                        if (!sink.closed) {
                            RelayObservable.from(fn(value)).subscribe({
                                start: start,
                                next: sink.next,
                                error: sink.error,
                                complete: complete
                            });
                        }
                    } catch (error) {
                        sink.error(error, true);
                    }
                },
                error: sink.error,
                complete: complete
            });
            return function() {
                subscriptions.forEach(function(sub) {
                    return sub.unsubscribe();
                });
                subscriptions.length = 0;
            };
        });
    };
    _proto.poll = function poll(pollInterval) {
        var _this8 = this;
        if ("TURBOPACK compile-time truthy", 1) {
            if (typeof pollInterval !== 'number' || pollInterval <= 0) {
                throw new Error('RelayObservable: Expected pollInterval to be positive, got: ' + pollInterval);
            }
        }
        return RelayObservable.create(function(sink) {
            var subscription;
            var timeout;
            var poll = function poll() {
                subscription = _this8.subscribe({
                    next: sink.next,
                    error: sink.error,
                    complete: function complete() {
                        timeout = setTimeout(poll, pollInterval);
                    }
                });
            };
            poll();
            return function() {
                clearTimeout(timeout);
                subscription.unsubscribe();
            };
        });
    };
    _proto.toPromise = function toPromise() {
        var _this9 = this;
        return new Promise(function(resolve, reject) {
            var resolved = false;
            _this9.subscribe({
                next: function next(val) {
                    if (!resolved) {
                        resolved = true;
                        resolve(val);
                    }
                },
                error: reject,
                complete: resolve
            });
        });
    };
    return RelayObservable;
}();
function isObservable(obj) {
    return typeof obj === 'object' && obj !== null && typeof obj.subscribe === 'function';
}
function fromObservable(obj) {
    return obj instanceof RelayObservable ? obj : RelayObservable.create(function(sink) {
        return obj.subscribe(sink);
    });
}
function fromPromise(promise) {
    return RelayObservable.create(function(sink) {
        promise.then(function(value) {
            sink.next(value);
            sink.complete();
        }, sink.error);
    });
}
function fromValue(value) {
    return RelayObservable.create(function(sink) {
        sink.next(value);
        sink.complete();
    });
}
function _subscribe(source, observer) {
    var closed = false;
    var cleanup;
    var withClosed = function withClosed(obj) {
        return Object.defineProperty(obj, 'closed', {
            get: function get() {
                return closed;
            }
        });
    };
    function doCleanup() {
        if (cleanup) {
            if (cleanup.unsubscribe) {
                cleanup.unsubscribe();
            } else {
                try {
                    cleanup();
                } catch (error) {
                    hostReportError(error, true);
                }
            }
            cleanup = undefined;
        }
    }
    var subscription = withClosed({
        unsubscribe: function unsubscribe() {
            if (!closed) {
                closed = true;
                try {
                    observer.unsubscribe && observer.unsubscribe(subscription);
                } catch (error) {
                    hostReportError(error, true);
                } finally{
                    doCleanup();
                }
            }
        }
    });
    try {
        observer.start && observer.start(subscription);
    } catch (error) {
        hostReportError(error, true);
    }
    if (closed) {
        return subscription;
    }
    var sink = withClosed({
        next: function next(value) {
            if (!closed && observer.next) {
                try {
                    observer.next(value);
                } catch (error) {
                    hostReportError(error, true);
                }
            }
        },
        error: function error(_error3, isUncaughtThrownError) {
            if (closed || !observer.error) {
                closed = true;
                hostReportError(_error3, isUncaughtThrownError || false);
                doCleanup();
            } else {
                closed = true;
                try {
                    observer.error(_error3);
                } catch (error2) {
                    hostReportError(error2, true);
                } finally{
                    doCleanup();
                }
            }
        },
        complete: function complete() {
            if (!closed) {
                closed = true;
                try {
                    observer.complete && observer.complete();
                } catch (error) {
                    hostReportError(error, true);
                } finally{
                    doCleanup();
                }
            }
        }
    });
    try {
        cleanup = source(sink);
    } catch (error) {
        sink.error(error, true);
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (cleanup !== undefined && typeof cleanup !== 'function' && (!cleanup || typeof cleanup.unsubscribe !== 'function')) {
            throw new Error('Returned cleanup function which cannot be called: ' + String(cleanup));
        }
    }
    if (closed) {
        doCleanup();
    }
    return subscription;
}
function swallowError(_error, _isUncaughtThrownError) {}
if ("TURBOPACK compile-time truthy", 1) {
    RelayObservable.onUnhandledError(function(error, isUncaughtThrownError) {
        if (isUncaughtThrownError) {
            setTimeout(function() {
                throw error;
            });
        } else if (typeof console !== 'undefined') {
            console.error('RelayObservable: Unhandled Error', error);
        }
    });
}
module.exports = RelayObservable;
}),
"[project]/node_modules/relay-runtime/lib/util/RelayReplaySubject.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var RelayObservable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var RelayReplaySubject = /*#__PURE__*/ function() {
    function RelayReplaySubject() {
        var _this = this;
        (0, _defineProperty2["default"])(this, "_complete", false);
        (0, _defineProperty2["default"])(this, "_events", []);
        (0, _defineProperty2["default"])(this, "_sinks", new Set());
        (0, _defineProperty2["default"])(this, "_subscription", []);
        this._observable = RelayObservable.create(function(sink) {
            _this._sinks.add(sink);
            var events = _this._events;
            for(var i = 0; i < events.length; i++){
                if (sink.closed) {
                    break;
                }
                var event = events[i];
                switch(event.kind){
                    case 'complete':
                        sink.complete();
                        break;
                    case 'error':
                        sink.error(event.error);
                        break;
                    case 'next':
                        sink.next(event.data);
                        break;
                    default:
                        event.kind;
                        ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReplaySubject: Unknown event kind `%s`.', event.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
                }
            }
            return function() {
                _this._sinks["delete"](sink);
            };
        });
    }
    var _proto = RelayReplaySubject.prototype;
    _proto.complete = function complete() {
        if (this._complete === true) {
            return;
        }
        this._complete = true;
        this._events.push({
            kind: 'complete'
        });
        this._sinks.forEach(function(sink) {
            return sink.complete();
        });
    };
    _proto.error = function error(_error) {
        if (this._complete === true) {
            return;
        }
        this._complete = true;
        this._events.push({
            kind: 'error',
            error: _error
        });
        this._sinks.forEach(function(sink) {
            return sink.error(_error);
        });
    };
    _proto.next = function next(data) {
        if (this._complete === true) {
            return;
        }
        this._events.push({
            kind: 'next',
            data: data
        });
        this._sinks.forEach(function(sink) {
            return sink.next(data);
        });
    };
    _proto.subscribe = function subscribe(observer) {
        var subscription = this._observable.subscribe(observer);
        this._subscription.push(subscription);
        return subscription;
    };
    _proto.unsubscribe = function unsubscribe() {
        var _iterator = (0, _createForOfIteratorHelper2["default"])(this._subscription), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var subscription = _step.value;
                subscription.unsubscribe();
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        this._subscription = [];
    };
    _proto.getObserverCount = function getObserverCount() {
        return this._sinks.size;
    };
    return RelayReplaySubject;
}();
module.exports = RelayReplaySubject;
}),
"[project]/node_modules/relay-runtime/lib/query/fetchQueryInternal.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var Observable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-rsc] (ecmascript)");
var RelayReplaySubject = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayReplaySubject.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var WEAKMAP_SUPPORTED = typeof WeakMap === 'function';
var requestCachesByEnvironment = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();
function fetchQuery(environment, operation) {
    return fetchQueryDeduped(environment, operation.request.identifier, function() {
        return environment.execute({
            operation: operation
        });
    });
}
function fetchQueryDeduped(environment, identifier, fetchFn) {
    return Observable.create(function(sink) {
        var requestCache = getRequestCache(environment);
        var cachedRequest = requestCache.get(identifier);
        if (!cachedRequest) {
            fetchFn()["finally"](function() {
                return requestCache["delete"](identifier);
            }).subscribe({
                start: function start(subscription) {
                    cachedRequest = {
                        identifier: identifier,
                        subject: new RelayReplaySubject(),
                        subjectForInFlightStatus: new RelayReplaySubject(),
                        subscription: subscription,
                        promise: null
                    };
                    requestCache.set(identifier, cachedRequest);
                },
                next: function next(response) {
                    var cachedReq = getCachedRequest(requestCache, identifier);
                    cachedReq.subject.next(response);
                    cachedReq.subjectForInFlightStatus.next(response);
                },
                error: function error(_error) {
                    var cachedReq = getCachedRequest(requestCache, identifier);
                    cachedReq.subject.error(_error);
                    cachedReq.subjectForInFlightStatus.error(_error);
                },
                complete: function complete() {
                    var cachedReq = getCachedRequest(requestCache, identifier);
                    cachedReq.subject.complete();
                    cachedReq.subjectForInFlightStatus.complete();
                },
                unsubscribe: function unsubscribe(subscription) {
                    var cachedReq = getCachedRequest(requestCache, identifier);
                    cachedReq.subject.unsubscribe();
                    cachedReq.subjectForInFlightStatus.unsubscribe();
                }
            });
        }
        !(cachedRequest != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '[fetchQueryInternal] fetchQueryDeduped: Expected `start` to be ' + 'called synchronously') : "TURBOPACK unreachable" : void 0;
        return getObservableForCachedRequest(requestCache, cachedRequest).subscribe(sink);
    });
}
function getObservableForCachedRequest(requestCache, cachedRequest) {
    return Observable.create(function(sink) {
        var subscription = cachedRequest.subject.subscribe(sink);
        return function() {
            subscription.unsubscribe();
            var cachedRequestInstance = requestCache.get(cachedRequest.identifier);
            if (cachedRequestInstance) {
                var requestSubscription = cachedRequestInstance.subscription;
                if (requestSubscription != null && cachedRequestInstance.subject.getObserverCount() === 0) {
                    requestSubscription.unsubscribe();
                    requestCache["delete"](cachedRequest.identifier);
                }
            }
        };
    });
}
function getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest) {
    return Observable.create(function(sink) {
        var subscription = cachedRequest.subjectForInFlightStatus.subscribe({
            error: sink.error,
            next: function next(response) {
                if (!environment.isRequestActive(cachedRequest.identifier)) {
                    sink.complete();
                    return;
                }
                sink.next();
            },
            complete: sink.complete,
            unsubscribe: sink.complete
        });
        return function() {
            subscription.unsubscribe();
        };
    });
}
function getPromiseForActiveRequest(environment, request) {
    var requestCache = getRequestCache(environment);
    var cachedRequest = requestCache.get(request.identifier);
    if (!cachedRequest) {
        return null;
    }
    if (!environment.isRequestActive(cachedRequest.identifier)) {
        return null;
    }
    var promise = new Promise(function(resolve, reject) {
        var resolveOnNext = false;
        getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest).subscribe({
            complete: resolve,
            error: reject,
            next: function next(response) {
                if (resolveOnNext) {
                    resolve(response);
                }
            }
        });
        resolveOnNext = true;
    });
    return promise;
}
function getObservableForActiveRequest(environment, request) {
    var requestCache = getRequestCache(environment);
    var cachedRequest = requestCache.get(request.identifier);
    if (!cachedRequest) {
        return null;
    }
    if (!environment.isRequestActive(cachedRequest.identifier)) {
        return null;
    }
    return getActiveStatusObservableForCachedRequest(environment, requestCache, cachedRequest);
}
function getRequestCache(environment) {
    var cached = requestCachesByEnvironment.get(environment);
    if (cached != null) {
        return cached;
    }
    var requestCache = new Map();
    requestCachesByEnvironment.set(environment, requestCache);
    return requestCache;
}
function getCachedRequest(requestCache, identifier) {
    var cached = requestCache.get(identifier);
    !(cached != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '[fetchQueryInternal] getCachedRequest: Expected request to be cached') : "TURBOPACK unreachable" : void 0;
    return cached;
}
module.exports = {
    fetchQuery: fetchQuery,
    fetchQueryDeduped: fetchQueryDeduped,
    getPromiseForActiveRequest: getPromiseForActiveRequest,
    getObservableForActiveRequest: getObservableForActiveRequest
};
}),
"[project]/node_modules/relay-runtime/lib/store/observeFragmentExperimental.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _asyncToGenerator = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/asyncToGenerator.js [app-rsc] (ecmascript)").default;
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var Observable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/fetchQueryInternal.js [app-rsc] (ecmascript)"), getObservableForActiveRequest = _require.getObservableForActiveRequest;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-rsc] (ecmascript)"), getFragment = _require2.getFragment;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js [app-rsc] (ecmascript)"), handlePotentialSnapshotErrors = _require3.handlePotentialSnapshotErrors;
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-rsc] (ecmascript)"), getSelector = _require4.getSelector;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function waitForFragmentData(_x, _x2, _x3) {
    return _waitForFragmentData.apply(this, arguments);
}
function _waitForFragmentData() {
    _waitForFragmentData = _asyncToGenerator(function*(environment, fragment, fragmentRef) {
        var subscription;
        try {
            var _subscription;
            var data = yield new Promise(function(resolve, reject) {
                subscription = observeFragment(environment, fragment, fragmentRef).subscribe({
                    next: function next(val) {
                        if (val.state === 'ok') {
                            resolve(val.value);
                        } else if (val.state === 'error') {
                            reject(val.error);
                        }
                    }
                });
            });
            (_subscription = subscription) === null || _subscription === void 0 ? void 0 : _subscription.unsubscribe();
            return data;
        } catch (e) {
            var _subscription2;
            (_subscription2 = subscription) === null || _subscription2 === void 0 ? void 0 : _subscription2.unsubscribe();
            throw e;
        }
    });
    return _waitForFragmentData.apply(this, arguments);
}
function observeFragment(environment, fragment, fragmentRef) {
    var _fragmentNode$metadat;
    var fragmentNode = getFragment(fragment);
    var fragmentSelector = getSelector(fragmentNode, fragmentRef);
    !(((_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.hasClientEdges) == null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, "Client edges aren't supported yet.") : "TURBOPACK unreachable" : void 0;
    !(fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected a selector, got null.') : "TURBOPACK unreachable" : void 0;
    switch(fragmentSelector.kind){
        case 'SingularReaderSelector':
            return observeSingularSelector(environment, fragment, fragmentSelector);
        case 'PluralReaderSelector':
            {
                return observePluralSelector(environment, fragment, fragmentSelector);
            }
    }
    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unsupported fragment selector kind') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
}
function observeSingularSelector(environment, fragmentNode, fragmentSelector) {
    var snapshot = environment.lookup(fragmentSelector);
    return Observable.create(function(sink) {
        sink.next(snapshotToFragmentState(environment, fragmentNode, fragmentSelector.owner, snapshot));
        var subscription = environment.subscribe(snapshot, function(nextSnapshot) {
            sink.next(snapshotToFragmentState(environment, fragmentNode, fragmentSelector.owner, nextSnapshot));
        });
        return function() {
            return subscription.dispose();
        };
    });
}
function observePluralSelector(environment, fragmentNode, fragmentSelector) {
    var snapshots = fragmentSelector.selectors.map(function(selector) {
        return environment.lookup(selector);
    });
    return Observable.create(function(sink) {
        var states = snapshots.map(function(snapshot, index) {
            return snapshotToFragmentState(environment, fragmentNode, fragmentSelector.selectors[index].owner, snapshot);
        });
        sink.next(mergeFragmentStates(states));
        var subscriptions = snapshots.map(function(snapshot, index) {
            return environment.subscribe(snapshot, function(latestSnapshot) {
                states[index] = snapshotToFragmentState(environment, fragmentNode, fragmentSelector.selectors[index].owner, latestSnapshot);
                sink.next(mergeFragmentStates(states));
            });
        });
        return function() {
            return subscriptions.forEach(function(subscription) {
                return subscription.dispose();
            });
        };
    });
}
function snapshotToFragmentState(environment, fragmentNode, owner, snapshot) {
    var missingLiveResolverFields = snapshot.missingLiveResolverFields != null && snapshot.missingLiveResolverFields.length > 0;
    var missingClientEdges = snapshot.missingClientEdges != null && snapshot.missingClientEdges.length > 0;
    if (missingLiveResolverFields || missingClientEdges) {
        return {
            state: 'loading'
        };
    }
    if (snapshot.isMissingData) {
        if (getObservableForActiveRequest(environment, owner) != null || environment.getOperationTracker().getPendingOperationsAffectingOwner(owner) != null) {
            return {
                state: 'loading'
            };
        }
    }
    try {
        handlePotentialSnapshotErrors(environment, snapshot.fieldErrors);
    } catch (error) {
        return {
            error: error,
            state: 'error'
        };
    }
    !(snapshot.data != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected data to be non-null.') : "TURBOPACK unreachable" : void 0;
    return {
        state: 'ok',
        value: snapshot.data
    };
}
function mergeFragmentStates(states) {
    var value = [];
    var _iterator = (0, _createForOfIteratorHelper2["default"])(states), _step;
    try {
        for(_iterator.s(); !(_step = _iterator.n()).done;){
            var state = _step.value;
            if (state.state === 'ok') {
                value.push(state.value);
            } else {
                return state;
            }
        }
    } catch (err) {
        _iterator.e(err);
    } finally{
        _iterator.f();
    }
    return {
        state: 'ok',
        value: value
    };
}
module.exports = {
    observeFragment: observeFragment,
    waitForFragmentData: waitForFragmentData
};
}),
"[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function deepFreeze(object) {
    if (!shouldBeFrozen(object)) {
        return object;
    }
    Object.freeze(object);
    Object.getOwnPropertyNames(object).forEach(function(name) {
        var property = object[name];
        if (property && typeof property === 'object' && !Object.isFrozen(property)) {
            deepFreeze(property);
        }
    });
    return object;
}
function shouldBeFrozen(value) {
    return value != null && (Array.isArray(value) || typeof value === 'object' && value.constructor === Object);
}
module.exports = deepFreeze;
}),
"[project]/node_modules/relay-runtime/lib/util/getRequestIdentifier.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-rsc] (ecmascript)"), stableCopy = _require.stableCopy;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function getRequestIdentifier(parameters, variables) {
    var requestID = parameters.cacheID != null ? parameters.cacheID : parameters.id;
    !(requestID != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'getRequestIdentifier: Expected request `%s` to have either a ' + 'valid `id` or `cacheID` property', parameters.name) : "TURBOPACK unreachable" : void 0;
    return requestID + JSON.stringify(stableCopy(variables));
}
module.exports = getRequestIdentifier;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var deepFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-rsc] (ecmascript)");
var getRequestIdentifier = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRequestIdentifier.js [app-rsc] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-rsc] (ecmascript)"), hasCycle = _require.hasCycle;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-rsc] (ecmascript)"), getOperationVariables = _require2.getOperationVariables;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-rsc] (ecmascript)"), createNormalizationSelector = _require3.createNormalizationSelector, createReaderSelector = _require3.createReaderSelector;
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), ROOT_ID = _require4.ROOT_ID;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function createOperationDescriptor(request, variables, cacheConfig) {
    var dataID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ROOT_ID;
    var operation = request.operation;
    var operationVariables = getOperationVariables(operation, request.params.providedVariables, variables);
    if (RelayFeatureFlags.ENABLE_CYLE_DETECTION_IN_VARIABLES) {
        !!hasCycle(operationVariables) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Cycle detected in variables passed to operation `%s`.', request.operation.name) : "TURBOPACK unreachable" : void 0;
    }
    var requestDescriptor = createRequestDescriptor(request, operationVariables, cacheConfig);
    var operationDescriptor = {
        fragment: createReaderSelector(request.fragment, dataID, operationVariables, requestDescriptor),
        request: requestDescriptor,
        root: createNormalizationSelector(operation, dataID, operationVariables)
    };
    if ("TURBOPACK compile-time truthy", 1) {
        Object.freeze(operationDescriptor.fragment);
        Object.freeze(operationDescriptor.root);
        Object.freeze(operationDescriptor);
    }
    return operationDescriptor;
}
function createRequestDescriptor(request, variables, cacheConfig) {
    var requestDescriptor = {
        identifier: getRequestIdentifier(request.params, variables),
        node: request,
        variables: variables,
        cacheConfig: cacheConfig
    };
    if ("TURBOPACK compile-time truthy", 1) {
        deepFreeze(variables);
        Object.freeze(request);
        Object.freeze(requestDescriptor);
    }
    return requestDescriptor;
}
module.exports = {
    createOperationDescriptor: createOperationDescriptor,
    createRequestDescriptor: createRequestDescriptor
};
}),
"[project]/node_modules/relay-runtime/lib/store/observeQueryExperimental.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/observeFragmentExperimental.js [app-rsc] (ecmascript)"), observeFragment = _require.observeFragment;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-rsc] (ecmascript)"), createOperationDescriptor = _require2.createOperationDescriptor;
function observeQuery(environment, gqlQuery, variables) {
    var operation = createOperationDescriptor(gqlQuery, variables);
    var rootFragmentRef = {
        __id: operation.fragment.dataID,
        __fragments: (0, _defineProperty2["default"])({}, operation.fragment.node.name, operation.request.variables),
        __fragmentOwner: operation.request
    };
    var fragmentNode = operation.request.node.fragment;
    return observeFragment(environment, fragmentNode, rootFragmentRef);
}
module.exports = {
    observeQuery: observeQuery
};
}),
"[project]/node_modules/relay-runtime/lib/store/waitForFragmentExperimental.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _asyncToGenerator = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/asyncToGenerator.js [app-rsc] (ecmascript)").default;
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/observeFragmentExperimental.js [app-rsc] (ecmascript)"), observeFragment = _require.observeFragment;
function waitForFragmentData(_x, _x2, _x3) {
    return _waitForFragmentData.apply(this, arguments);
}
function _waitForFragmentData() {
    _waitForFragmentData = _asyncToGenerator(function*(environment, fragment, fragmentRef) {
        var subscription;
        try {
            var _subscription;
            var data = yield new Promise(function(resolve, reject) {
                subscription = observeFragment(environment, fragment, fragmentRef).subscribe({
                    next: function next(val) {
                        if (val.state === 'ok') {
                            resolve(val.value);
                        } else if (val.state === 'error') {
                            reject(val.error);
                        }
                    }
                });
            });
            (_subscription = subscription) === null || _subscription === void 0 ? void 0 : _subscription.unsubscribe();
            return data;
        } catch (e) {
            var _subscription2;
            (_subscription2 = subscription) === null || _subscription2 === void 0 ? void 0 : _subscription2.unsubscribe();
            throw e;
        }
    });
    return _waitForFragmentData.apply(this, arguments);
}
module.exports = {
    waitForFragmentData: waitForFragmentData
};
}),
"[project]/node_modules/relay-runtime/lib/experimental.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var resolverDataInjector = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/resolverDataInjector.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/observeFragmentExperimental.js [app-rsc] (ecmascript)"), observeFragment = _require.observeFragment;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/observeQueryExperimental.js [app-rsc] (ecmascript)"), observeQuery = _require2.observeQuery;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/waitForFragmentExperimental.js [app-rsc] (ecmascript)"), waitForFragmentData = _require3.waitForFragmentData;
function isValueResult(input) {
    return input.ok === true;
}
function isErrorResult(input) {
    return input.ok === false;
}
module.exports = {
    resolverDataInjector: resolverDataInjector,
    isValueResult: isValueResult,
    isErrorResult: isErrorResult,
    observeQuery: observeQuery,
    observeFragment: observeFragment,
    waitForFragmentData: waitForFragmentData
};
}),
"[project]/node_modules/relay-runtime/lib/util/StringInterner.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var internTable = new Map();
var nextIndex = 1;
var digits = initDigitTable();
var INTERN_PREFIX = '\t';
var ESCAPE_PREFIX = '\v';
function initDigitTable() {
    var digits = new Set();
    for(var i = 0; i < 10; ++i){
        digits.add(i.toString());
    }
    return digits;
}
function escape(str) {
    if (str[0] === INTERN_PREFIX && digits.has(str[1]) || str[0] === ESCAPE_PREFIX) {
        return ESCAPE_PREFIX + str;
    }
    return str;
}
function intern(str, limit) {
    if (limit == null || str.length < limit) {
        return escape(str);
    }
    var internedString = internTable.get(str);
    if (internedString != null) {
        return internedString;
    }
    internedString = INTERN_PREFIX + nextIndex++;
    internTable.set(str, internedString);
    return internedString;
}
module.exports = {
    intern: intern
};
}),
"[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/StringInterner.js [app-rsc] (ecmascript)"), intern = _require.intern;
var PREFIX = 'client:';
function generateClientID(id, storageKey, index) {
    var internedId = RelayFeatureFlags.STRING_INTERN_LEVEL <= 0 ? id : intern(id, RelayFeatureFlags.MAX_DATA_ID_LENGTH);
    var key = internedId + ':' + storageKey;
    if (index != null) {
        key += ':' + index;
    }
    if (key.indexOf(PREFIX) !== 0) {
        key = PREFIX + key;
    }
    return key;
}
function isClientID(id) {
    return id.indexOf(PREFIX) === 0;
}
var localID = 0;
function generateUniqueClientID() {
    return "".concat(PREFIX, "local:").concat(localID++);
}
function generateClientObjectClientID(typename, localId, index) {
    var key = "".concat(PREFIX).concat(typename, ":").concat(localId);
    if (index != null) {
        key += ':' + index;
    }
    return key;
}
module.exports = {
    generateClientID: generateClientID,
    generateClientObjectClientID: generateClientObjectClientID,
    generateUniqueClientID: generateUniqueClientID,
    isClientID: isClientID
};
}),
"[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionInterface.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var CONNECTION_CALLS = {
    after: true,
    before: true,
    find: true,
    first: true,
    last: true,
    surrounds: true
};
var config = {
    CURSOR: 'cursor',
    EDGES: 'edges',
    END_CURSOR: 'endCursor',
    HAS_NEXT_PAGE: 'hasNextPage',
    HAS_PREV_PAGE: 'hasPreviousPage',
    NODE: 'node',
    PAGE_INFO_TYPE: 'PageInfo',
    PAGE_INFO: 'pageInfo',
    START_CURSOR: 'startCursor'
};
var ConnectionInterface = {
    inject: function inject(newConfig) {
        config = newConfig;
    },
    get: function get() {
        return config;
    },
    isConnectionCall: function isConnectionCall(call) {
        return CONNECTION_CALLS.hasOwnProperty(call.name);
    }
};
module.exports = ConnectionInterface;
}),
"[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-rsc] (ecmascript)"), generateClientID = _require.generateClientID;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), getStableStorageKey = _require2.getStableStorageKey;
var getRelayHandleKey = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRelayHandleKey.js [app-rsc] (ecmascript)");
var ConnectionInterface = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionInterface.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
var CONNECTION = 'connection';
var NEXT_EDGE_INDEX = '__connection_next_edge_index';
function update(store, payload) {
    var record = store.get(payload.dataID);
    if (!record) {
        return;
    }
    var _ConnectionInterface$ = ConnectionInterface.get(), EDGES = _ConnectionInterface$.EDGES, END_CURSOR = _ConnectionInterface$.END_CURSOR, HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE, HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE, PAGE_INFO = _ConnectionInterface$.PAGE_INFO, PAGE_INFO_TYPE = _ConnectionInterface$.PAGE_INFO_TYPE, START_CURSOR = _ConnectionInterface$.START_CURSOR;
    var serverConnection = record.getLinkedRecord(payload.fieldKey);
    var serverPageInfo = serverConnection && serverConnection.getLinkedRecord(PAGE_INFO);
    if (!serverConnection) {
        record.setValue(null, payload.handleKey, undefined, record.getErrors(payload.fieldKey));
        return;
    }
    var clientConnectionID = generateClientID(record.getDataID(), payload.handleKey);
    var clientConnectionField = record.getLinkedRecord(payload.handleKey);
    var clientConnection = clientConnectionField !== null && clientConnectionField !== void 0 ? clientConnectionField : store.get(clientConnectionID);
    var clientPageInfo = clientConnection && clientConnection.getLinkedRecord(PAGE_INFO);
    if (!clientConnection) {
        var connection = store.create(clientConnectionID, serverConnection.getType());
        connection.setValue(0, NEXT_EDGE_INDEX);
        connection.copyFieldsFrom(serverConnection);
        var serverEdges = serverConnection.getLinkedRecords(EDGES);
        if (serverEdges) {
            serverEdges = serverEdges.map(function(edge) {
                return buildConnectionEdge(store, connection, edge);
            });
            connection.setLinkedRecords(serverEdges, EDGES);
        }
        record.setLinkedRecord(connection, payload.handleKey);
        clientPageInfo = store.create(generateClientID(connection.getDataID(), PAGE_INFO), PAGE_INFO_TYPE);
        clientPageInfo.setValue(false, HAS_NEXT_PAGE);
        clientPageInfo.setValue(false, HAS_PREV_PAGE);
        clientPageInfo.setValue(null, END_CURSOR);
        clientPageInfo.setValue(null, START_CURSOR);
        if (serverPageInfo) {
            clientPageInfo.copyFieldsFrom(serverPageInfo);
        }
        connection.setLinkedRecord(clientPageInfo, PAGE_INFO);
    } else {
        if (clientConnectionField == null) {
            record.setLinkedRecord(clientConnection, payload.handleKey);
        }
        var _connection = clientConnection;
        var _serverEdges = serverConnection.getLinkedRecords(EDGES);
        if (_serverEdges) {
            _serverEdges = _serverEdges.map(function(edge) {
                return buildConnectionEdge(store, _connection, edge);
            });
        }
        var prevEdges = _connection.getLinkedRecords(EDGES);
        var prevPageInfo = _connection.getLinkedRecord(PAGE_INFO);
        _connection.copyFieldsFrom(serverConnection);
        if (prevEdges) {
            _connection.setLinkedRecords(prevEdges, EDGES);
        }
        if (prevPageInfo) {
            _connection.setLinkedRecord(prevPageInfo, PAGE_INFO);
        }
        var nextEdges = [];
        var args = payload.args;
        if (prevEdges && _serverEdges) {
            if (args.after != null) {
                var _clientPageInfo;
                var clientEndCursor = (_clientPageInfo = clientPageInfo) === null || _clientPageInfo === void 0 ? void 0 : _clientPageInfo.getValue(END_CURSOR);
                var serverEndCursor = serverPageInfo === null || serverPageInfo === void 0 ? void 0 : serverPageInfo.getValue(END_CURSOR);
                var isAddingEdgesAfterCurrentPage = clientPageInfo && args.after === clientEndCursor;
                var isFillingOutCurrentPage = clientPageInfo && clientEndCursor === serverEndCursor;
                if (isAddingEdgesAfterCurrentPage || isFillingOutCurrentPage) {
                    var nodeIDs = new Set();
                    mergeEdges(prevEdges, nextEdges, nodeIDs);
                    mergeEdges(_serverEdges, nextEdges, nodeIDs);
                } else {
                    ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected after cursor `%s`, edges must ' + 'be fetched from the end of the list (`%s`).', args.after, clientPageInfo && clientPageInfo.getValue(END_CURSOR)) : "TURBOPACK unreachable";
                    return;
                }
            } else if (args.before != null) {
                if (clientPageInfo && args.before === clientPageInfo.getValue(START_CURSOR)) {
                    var _nodeIDs = new Set();
                    mergeEdges(_serverEdges, nextEdges, _nodeIDs);
                    mergeEdges(prevEdges, nextEdges, _nodeIDs);
                } else {
                    ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected before cursor `%s`, edges must ' + 'be fetched from the beginning of the list (`%s`).', args.before, clientPageInfo && clientPageInfo.getValue(START_CURSOR)) : "TURBOPACK unreachable";
                    return;
                }
            } else {
                nextEdges = _serverEdges;
            }
        } else if (_serverEdges) {
            nextEdges = _serverEdges;
        } else {
            nextEdges = prevEdges;
        }
        if (nextEdges != null && nextEdges !== prevEdges) {
            _connection.setLinkedRecords(nextEdges, EDGES);
        }
        if (clientPageInfo && serverPageInfo) {
            if (args.after == null && args.before == null) {
                clientPageInfo.copyFieldsFrom(serverPageInfo);
            } else if (args.before != null || args.after == null && args.last) {
                clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_PREV_PAGE), HAS_PREV_PAGE);
                var startCursor = serverPageInfo.getValue(START_CURSOR);
                if (typeof startCursor === 'string') {
                    clientPageInfo.setValue(startCursor, START_CURSOR);
                }
            } else if (args.after != null || args.before == null && args.first) {
                clientPageInfo.setValue(!!serverPageInfo.getValue(HAS_NEXT_PAGE), HAS_NEXT_PAGE);
                var endCursor = serverPageInfo.getValue(END_CURSOR);
                if (typeof endCursor === 'string') {
                    clientPageInfo.setValue(endCursor, END_CURSOR);
                }
            }
        }
    }
}
function getConnection(record, key, filters) {
    var handleKey = getRelayHandleKey(CONNECTION, key, null);
    return record.getLinkedRecord(handleKey, filters);
}
function getConnectionID(recordID, key, filters) {
    var handleKey = getRelayHandleKey(CONNECTION, key, null);
    var storageKey = getStableStorageKey(handleKey, filters);
    return generateClientID(recordID, storageKey);
}
function insertEdgeAfter(record, newEdge, cursor) {
    var _ConnectionInterface$2 = ConnectionInterface.get(), CURSOR = _ConnectionInterface$2.CURSOR, EDGES = _ConnectionInterface$2.EDGES;
    var edges = record.getLinkedRecords(EDGES);
    if (!edges) {
        record.setLinkedRecords([
            newEdge
        ], EDGES);
        return;
    }
    var nextEdges;
    if (cursor == null) {
        nextEdges = edges.concat(newEdge);
    } else {
        nextEdges = [];
        var foundCursor = false;
        for(var ii = 0; ii < edges.length; ii++){
            var edge = edges[ii];
            nextEdges.push(edge);
            if (edge == null) {
                continue;
            }
            var edgeCursor = edge.getValue(CURSOR);
            if (cursor === edgeCursor) {
                nextEdges.push(newEdge);
                foundCursor = true;
            }
        }
        if (!foundCursor) {
            nextEdges.push(newEdge);
        }
    }
    record.setLinkedRecords(nextEdges, EDGES);
}
function createEdge(store, record, node, edgeType) {
    var _ConnectionInterface$3 = ConnectionInterface.get(), NODE = _ConnectionInterface$3.NODE;
    var edgeID = generateClientID(record.getDataID(), node.getDataID());
    var edge = store.get(edgeID);
    if (!edge) {
        edge = store.create(edgeID, edgeType);
    }
    edge.setLinkedRecord(node, NODE);
    if (edge.getValue('cursor') == null) {
        edge.setValue(null, 'cursor');
    }
    return edge;
}
function insertEdgeBefore(record, newEdge, cursor) {
    var _ConnectionInterface$4 = ConnectionInterface.get(), CURSOR = _ConnectionInterface$4.CURSOR, EDGES = _ConnectionInterface$4.EDGES;
    var edges = record.getLinkedRecords(EDGES);
    if (!edges) {
        record.setLinkedRecords([
            newEdge
        ], EDGES);
        return;
    }
    var nextEdges;
    if (cursor == null) {
        nextEdges = [
            newEdge
        ].concat(edges);
    } else {
        nextEdges = [];
        var foundCursor = false;
        for(var ii = 0; ii < edges.length; ii++){
            var edge = edges[ii];
            if (edge != null) {
                var edgeCursor = edge.getValue(CURSOR);
                if (cursor === edgeCursor) {
                    nextEdges.push(newEdge);
                    foundCursor = true;
                }
            }
            nextEdges.push(edge);
        }
        if (!foundCursor) {
            nextEdges.unshift(newEdge);
        }
    }
    record.setLinkedRecords(nextEdges, EDGES);
}
function deleteNode(record, nodeID) {
    var _ConnectionInterface$5 = ConnectionInterface.get(), EDGES = _ConnectionInterface$5.EDGES, NODE = _ConnectionInterface$5.NODE;
    var edges = record.getLinkedRecords(EDGES);
    if (!edges) {
        return;
    }
    var nextEdges;
    for(var ii = 0; ii < edges.length; ii++){
        var edge = edges[ii];
        var node = edge && edge.getLinkedRecord(NODE);
        if (node != null && node.getDataID() === nodeID) {
            if (nextEdges === undefined) {
                nextEdges = edges.slice(0, ii);
            }
        } else if (nextEdges !== undefined) {
            nextEdges.push(edge);
        }
    }
    if (nextEdges !== undefined) {
        record.setLinkedRecords(nextEdges, EDGES);
    }
}
function buildConnectionEdge(store, connection, edge) {
    if (edge == null) {
        return edge;
    }
    var _ConnectionInterface$6 = ConnectionInterface.get(), EDGES = _ConnectionInterface$6.EDGES;
    var edgeIndex = connection.getValue(NEXT_EDGE_INDEX);
    !(typeof edgeIndex === 'number') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ConnectionHandler: Expected %s to be a number, got `%s`.', NEXT_EDGE_INDEX, edgeIndex) : "TURBOPACK unreachable" : void 0;
    var edgeID = generateClientID(connection.getDataID(), EDGES, edgeIndex);
    var connectionEdge = store.create(edgeID, edge.getType());
    connectionEdge.copyFieldsFrom(edge);
    if (connectionEdge.getValue('cursor') == null) {
        connectionEdge.setValue(null, 'cursor');
    }
    connection.setValue(edgeIndex + 1, NEXT_EDGE_INDEX);
    return connectionEdge;
}
function mergeEdges(sourceEdges, targetEdges, nodeIDs) {
    var _ConnectionInterface$7 = ConnectionInterface.get(), NODE = _ConnectionInterface$7.NODE;
    for(var ii = 0; ii < sourceEdges.length; ii++){
        var edge = sourceEdges[ii];
        if (!edge) {
            continue;
        }
        var node = edge.getLinkedRecord(NODE);
        var nodeID = node && node.getDataID();
        if (nodeID) {
            if (nodeIDs.has(nodeID)) {
                continue;
            }
            nodeIDs.add(nodeID);
        }
        targetEdges.push(edge);
    }
}
module.exports = {
    buildConnectionEdge: buildConnectionEdge,
    createEdge: createEdge,
    deleteNode: deleteNode,
    getConnection: getConnection,
    getConnectionID: getConnectionID,
    insertEdgeAfter: insertEdgeAfter,
    insertEdgeBefore: insertEdgeBefore,
    update: update
};
}),
"[project]/node_modules/relay-runtime/lib/handlers/connection/MutationHandlers.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var ConnectionHandler = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js [app-rsc] (ecmascript)");
var ConnectionInterface = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionInterface.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
var DeleteRecordHandler = {
    update: function update(store, payload) {
        var record = store.get(payload.dataID);
        if (record != null) {
            var idOrIds = record.getValue(payload.fieldKey);
            if (typeof idOrIds === 'string') {
                store["delete"](idOrIds);
            } else if (Array.isArray(idOrIds)) {
                idOrIds.forEach(function(id) {
                    if (typeof id === 'string') {
                        store["delete"](id);
                    }
                });
            }
        }
    }
};
var DeleteEdgeHandler = {
    update: function update(store, payload) {
        var record = store.get(payload.dataID);
        if (record == null) {
            return;
        }
        var connections = payload.handleArgs.connections;
        !(connections != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'MutationHandlers: Expected connection IDs to be specified.') : "TURBOPACK unreachable" : void 0;
        var idOrIds = record.getValue(payload.fieldKey);
        var idList = Array.isArray(idOrIds) ? idOrIds : [
            idOrIds
        ];
        idList.forEach(function(id) {
            if (typeof id === 'string') {
                var _iterator = (0, _createForOfIteratorHelper2["default"])(connections), _step;
                try {
                    for(_iterator.s(); !(_step = _iterator.n()).done;){
                        var connectionID = _step.value;
                        var connection = store.get(connectionID);
                        if (connection == null) {
                            ("TURBOPACK compile-time truthy", 1) ? warning(false, "[Relay] The connection with id `%s` doesn't exist.", connectionID) : "TURBOPACK unreachable";
                            continue;
                        }
                        ConnectionHandler.deleteNode(connection, id);
                    }
                } catch (err) {
                    _iterator.e(err);
                } finally{
                    _iterator.f();
                }
            }
        });
    }
};
var AppendEdgeHandler = {
    update: edgeUpdater(ConnectionHandler.insertEdgeAfter)
};
var PrependEdgeHandler = {
    update: edgeUpdater(ConnectionHandler.insertEdgeBefore)
};
var AppendNodeHandler = {
    update: nodeUpdater(ConnectionHandler.insertEdgeAfter)
};
var PrependNodeHandler = {
    update: nodeUpdater(ConnectionHandler.insertEdgeBefore)
};
function edgeUpdater(insertFn) {
    return function(store, payload) {
        var _serverEdges;
        var record = store.get(payload.dataID);
        if (record == null) {
            return;
        }
        var connections = payload.handleArgs.connections;
        !(connections != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'MutationHandlers: Expected connection IDs to be specified.') : "TURBOPACK unreachable" : void 0;
        var singleServerEdge, serverEdges;
        try {
            singleServerEdge = record.getLinkedRecord(payload.fieldKey);
        } catch (_unused) {}
        if (!singleServerEdge) {
            try {
                serverEdges = record.getLinkedRecords(payload.fieldKey);
            } catch (_unused2) {}
        }
        if (singleServerEdge == null && serverEdges == null) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'MutationHandlers: Expected the server edge to be non-null.') : "TURBOPACK unreachable";
            return;
        }
        var _ConnectionInterface$ = ConnectionInterface.get(), NODE = _ConnectionInterface$.NODE, EDGES = _ConnectionInterface$.EDGES;
        var serverEdgeList = (_serverEdges = serverEdges) !== null && _serverEdges !== void 0 ? _serverEdges : [
            singleServerEdge
        ];
        var _iterator2 = (0, _createForOfIteratorHelper2["default"])(serverEdgeList), _step2;
        try {
            var _loop = function _loop() {
                var serverEdge = _step2.value;
                if (serverEdge == null) {
                    return "continue";
                }
                var serverNode = serverEdge.getLinkedRecord('node');
                if (!serverNode) {
                    return "continue";
                }
                var serverNodeId = serverNode.getDataID();
                var _iterator3 = (0, _createForOfIteratorHelper2["default"])(connections), _step3;
                try {
                    for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                        var connectionID = _step3.value;
                        var connection = store.get(connectionID);
                        if (connection == null) {
                            ("TURBOPACK compile-time truthy", 1) ? warning(false, "[Relay] The connection with id `%s` doesn't exist.", connectionID) : "TURBOPACK unreachable";
                            continue;
                        }
                        var nodeAlreadyExistsInConnection = (_connection$getLinked = connection.getLinkedRecords(EDGES)) === null || _connection$getLinked === void 0 ? void 0 : _connection$getLinked.some(function(edge) {
                            var _edge$getLinkedRecord;
                            return (edge === null || edge === void 0 ? void 0 : (_edge$getLinkedRecord = edge.getLinkedRecord(NODE)) === null || _edge$getLinkedRecord === void 0 ? void 0 : _edge$getLinkedRecord.getDataID()) === serverNodeId;
                        });
                        if (nodeAlreadyExistsInConnection) {
                            continue;
                        }
                        var clientEdge = ConnectionHandler.buildConnectionEdge(store, connection, serverEdge);
                        !(clientEdge != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'MutationHandlers: Failed to build the edge.') : "TURBOPACK unreachable" : void 0;
                        insertFn(connection, clientEdge);
                    }
                } catch (err) {
                    _iterator3.e(err);
                } finally{
                    _iterator3.f();
                }
            };
            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                var _connection$getLinked;
                var _ret = _loop();
                if (_ret === "continue") continue;
            }
        } catch (err) {
            _iterator2.e(err);
        } finally{
            _iterator2.f();
        }
    };
}
function nodeUpdater(insertFn) {
    return function(store, payload) {
        var _serverNodes;
        var record = store.get(payload.dataID);
        if (record == null) {
            return;
        }
        var _payload$handleArgs = payload.handleArgs, connections = _payload$handleArgs.connections, edgeTypeName = _payload$handleArgs.edgeTypeName;
        !(connections != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'MutationHandlers: Expected connection IDs to be specified.') : "TURBOPACK unreachable" : void 0;
        !(edgeTypeName != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'MutationHandlers: Expected edge typename to be specified.') : "TURBOPACK unreachable" : void 0;
        var singleServerNode;
        var serverNodes;
        try {
            singleServerNode = record.getLinkedRecord(payload.fieldKey);
        } catch (_unused3) {}
        if (!singleServerNode) {
            try {
                serverNodes = record.getLinkedRecords(payload.fieldKey);
            } catch (_unused4) {}
        }
        if (singleServerNode == null && serverNodes == null) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'MutationHandlers: Expected target node to exist.') : "TURBOPACK unreachable";
            return;
        }
        var _ConnectionInterface$2 = ConnectionInterface.get(), NODE = _ConnectionInterface$2.NODE, EDGES = _ConnectionInterface$2.EDGES;
        var serverNodeList = (_serverNodes = serverNodes) !== null && _serverNodes !== void 0 ? _serverNodes : [
            singleServerNode
        ];
        var _iterator4 = (0, _createForOfIteratorHelper2["default"])(serverNodeList), _step4;
        try {
            var _loop2 = function _loop2() {
                var serverNode = _step4.value;
                if (serverNode == null) {
                    return "continue";
                }
                var serverNodeId = serverNode.getDataID();
                var _iterator5 = (0, _createForOfIteratorHelper2["default"])(connections), _step5;
                try {
                    for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                        var connectionID = _step5.value;
                        var connection = store.get(connectionID);
                        if (connection == null) {
                            ("TURBOPACK compile-time truthy", 1) ? warning(false, "[Relay] The connection with id `%s` doesn't exist.", connectionID) : "TURBOPACK unreachable";
                            continue;
                        }
                        var nodeAlreadyExistsInConnection = (_connection$getLinked2 = connection.getLinkedRecords(EDGES)) === null || _connection$getLinked2 === void 0 ? void 0 : _connection$getLinked2.some(function(edge) {
                            var _edge$getLinkedRecord2;
                            return (edge === null || edge === void 0 ? void 0 : (_edge$getLinkedRecord2 = edge.getLinkedRecord(NODE)) === null || _edge$getLinkedRecord2 === void 0 ? void 0 : _edge$getLinkedRecord2.getDataID()) === serverNodeId;
                        });
                        if (nodeAlreadyExistsInConnection) {
                            continue;
                        }
                        var clientEdge = ConnectionHandler.createEdge(store, connection, serverNode, edgeTypeName);
                        !(clientEdge != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'MutationHandlers: Failed to build the edge.') : "TURBOPACK unreachable" : void 0;
                        insertFn(connection, clientEdge);
                    }
                } catch (err) {
                    _iterator5.e(err);
                } finally{
                    _iterator5.f();
                }
            };
            for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                var _connection$getLinked2;
                var _ret2 = _loop2();
                if (_ret2 === "continue") continue;
            }
        } catch (err) {
            _iterator4.e(err);
        } finally{
            _iterator4.f();
        }
    };
}
module.exports = {
    AppendEdgeHandler: AppendEdgeHandler,
    DeleteRecordHandler: DeleteRecordHandler,
    PrependEdgeHandler: PrependEdgeHandler,
    AppendNodeHandler: AppendNodeHandler,
    PrependNodeHandler: PrependNodeHandler,
    DeleteEdgeHandler: DeleteEdgeHandler
};
}),
"[project]/node_modules/relay-runtime/lib/handlers/RelayDefaultHandlerProvider.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ConnectionHandler = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js [app-rsc] (ecmascript)");
var MutationHandlers = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/MutationHandlers.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function RelayDefaultHandlerProvider(handle) {
    switch(handle){
        case 'connection':
            return ConnectionHandler;
        case 'deleteRecord':
            return MutationHandlers.DeleteRecordHandler;
        case 'deleteEdge':
            return MutationHandlers.DeleteEdgeHandler;
        case 'appendEdge':
            return MutationHandlers.AppendEdgeHandler;
        case 'prependEdge':
            return MutationHandlers.PrependEdgeHandler;
        case 'appendNode':
            return MutationHandlers.AppendNodeHandler;
        case 'prependNode':
            return MutationHandlers.PrependNodeHandler;
    }
    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayDefaultHandlerProvider: No handler provided for `%s`.', handle) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
}
module.exports = RelayDefaultHandlerProvider;
}),
"[project]/node_modules/relay-runtime/lib/store/isRelayModernEnvironment.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function isRelayModernEnvironment(environment) {
    return Boolean(environment && environment['@@RelayModernEnvironment']);
}
module.exports = isRelayModernEnvironment;
}),
"[project]/node_modules/relay-runtime/lib/mutations/RelayDeclarativeMutationConfig.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var ConnectionHandler = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
var MutationTypes = Object.freeze({
    RANGE_ADD: 'RANGE_ADD',
    RANGE_DELETE: 'RANGE_DELETE',
    NODE_DELETE: 'NODE_DELETE'
});
var RangeOperations = Object.freeze({
    APPEND: 'append',
    PREPEND: 'prepend'
});
function convert(configs, request, optimisticUpdater, updater) {
    var configOptimisticUpdates = optimisticUpdater ? [
        optimisticUpdater
    ] : [];
    var configUpdates = updater ? [
        updater
    ] : [];
    configs.forEach(function(config) {
        switch(config.type){
            case 'NODE_DELETE':
                var nodeDeleteResult = nodeDelete(config, request);
                if (nodeDeleteResult) {
                    configOptimisticUpdates.push(nodeDeleteResult);
                    configUpdates.push(nodeDeleteResult);
                }
                break;
            case 'RANGE_ADD':
                var rangeAddResult = rangeAdd(config, request);
                if (rangeAddResult) {
                    configOptimisticUpdates.push(rangeAddResult);
                    configUpdates.push(rangeAddResult);
                }
                break;
            case 'RANGE_DELETE':
                var rangeDeleteResult = rangeDelete(config, request);
                if (rangeDeleteResult) {
                    configOptimisticUpdates.push(rangeDeleteResult);
                    configUpdates.push(rangeDeleteResult);
                }
                break;
        }
    });
    return {
        optimisticUpdater: function optimisticUpdater(store, data) {
            configOptimisticUpdates.forEach(function(eachOptimisticUpdater) {
                eachOptimisticUpdater(store, data);
            });
        },
        updater: function updater(store, data) {
            configUpdates.forEach(function(eachUpdater) {
                eachUpdater(store, data);
            });
        }
    };
}
function nodeDelete(config, request) {
    var deletedIDFieldName = config.deletedIDFieldName;
    var rootField = getRootField(request);
    if (!rootField) {
        return null;
    }
    return function(store, data) {
        var payload = store.getRootField(rootField);
        if (!payload) {
            return;
        }
        var deleteID = payload.getValue(deletedIDFieldName);
        var deleteIDs = Array.isArray(deleteID) ? deleteID : [
            deleteID
        ];
        deleteIDs.forEach(function(id) {
            if (id && typeof id === 'string') {
                store["delete"](id);
            }
        });
    };
}
function rangeAdd(config, request) {
    var parentID = config.parentID, connectionInfo = config.connectionInfo, edgeName = config.edgeName;
    if (!parentID) {
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayDeclarativeMutationConfig: For mutation config RANGE_ADD ' + 'to work you must include a parentID') : "TURBOPACK unreachable";
        return null;
    }
    var rootField = getRootField(request);
    if (!connectionInfo || !rootField) {
        return null;
    }
    return function(store, data) {
        var parent = store.get(parentID);
        if (!parent) {
            return;
        }
        var payload = store.getRootField(rootField);
        if (!payload) {
            return;
        }
        var serverEdge = payload.getLinkedRecord(edgeName);
        var _iterator = (0, _createForOfIteratorHelper2["default"])(connectionInfo), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var info = _step.value;
                if (!serverEdge) {
                    continue;
                }
                var connection = ConnectionHandler.getConnection(parent, info.key, info.filters);
                if (!connection) {
                    continue;
                }
                var clientEdge = ConnectionHandler.buildConnectionEdge(store, connection, serverEdge);
                if (!clientEdge) {
                    continue;
                }
                switch(info.rangeBehavior){
                    case 'append':
                        ConnectionHandler.insertEdgeAfter(connection, clientEdge);
                        break;
                    case 'prepend':
                        ConnectionHandler.insertEdgeBefore(connection, clientEdge);
                        break;
                    default:
                        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayDeclarativeMutationConfig: RANGE_ADD range behavior `%s` ' + 'will not work as expected in RelayModern, supported range ' + "behaviors are 'append', 'prepend'.", info.rangeBehavior) : "TURBOPACK unreachable";
                        break;
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
    };
}
function rangeDelete(config, request) {
    var parentID = config.parentID, connectionKeys = config.connectionKeys, pathToConnection = config.pathToConnection, deletedIDFieldName = config.deletedIDFieldName;
    if (!parentID) {
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayDeclarativeMutationConfig: For mutation config RANGE_DELETE ' + 'to work you must include a parentID') : "TURBOPACK unreachable";
        return null;
    }
    var rootField = getRootField(request);
    if (!rootField) {
        return null;
    }
    return function(store, data) {
        if (!data) {
            return;
        }
        var deleteIDs = [];
        var deletedIDField = data[rootField];
        if (deletedIDField && Array.isArray(deletedIDFieldName)) {
            var _iterator2 = (0, _createForOfIteratorHelper2["default"])(deletedIDFieldName), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var eachField = _step2.value;
                    if (deletedIDField && typeof deletedIDField === 'object') {
                        deletedIDField = deletedIDField[eachField];
                    }
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
            if (Array.isArray(deletedIDField)) {
                deletedIDField.forEach(function(idObject) {
                    if (idObject && idObject.id && typeof idObject === 'object' && typeof idObject.id === 'string') {
                        deleteIDs.push(idObject.id);
                    }
                });
            } else if (deletedIDField && deletedIDField.id && typeof deletedIDField.id === 'string') {
                deleteIDs.push(deletedIDField.id);
            }
        } else if (deletedIDField && typeof deletedIDFieldName === 'string' && typeof deletedIDField === 'object') {
            deletedIDField = deletedIDField[deletedIDFieldName];
            if (typeof deletedIDField === 'string') {
                deleteIDs.push(deletedIDField);
            } else if (Array.isArray(deletedIDField)) {
                deletedIDField.forEach(function(id) {
                    if (typeof id === 'string') {
                        deleteIDs.push(id);
                    }
                });
            }
        }
        deleteNode(parentID, connectionKeys, pathToConnection, store, deleteIDs);
    };
}
function deleteNode(parentID, connectionKeys, pathToConnection, store, deleteIDs) {
    ("TURBOPACK compile-time truthy", 1) ? warning(connectionKeys != null, 'RelayDeclarativeMutationConfig: RANGE_DELETE must provide a ' + 'connectionKeys') : "TURBOPACK unreachable";
    var parent = store.get(parentID);
    if (!parent) {
        return;
    }
    if (pathToConnection.length < 2) {
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayDeclarativeMutationConfig: RANGE_DELETE ' + 'pathToConnection must include at least parent and connection') : "TURBOPACK unreachable";
        return;
    }
    var recordProxy = parent;
    for(var i = 1; i < pathToConnection.length - 1; i++){
        if (recordProxy) {
            recordProxy = recordProxy.getLinkedRecord(pathToConnection[i]);
        }
    }
    if (!connectionKeys || !recordProxy) {
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayDeclarativeMutationConfig: RANGE_DELETE ' + 'pathToConnection is incorrect. Unable to find connection with ' + 'parentID: %s and path: %s', parentID, pathToConnection.toString()) : "TURBOPACK unreachable";
        return;
    }
    var _iterator3 = (0, _createForOfIteratorHelper2["default"])(connectionKeys), _step3;
    try {
        var _loop = function _loop() {
            var key = _step3.value;
            var connection = ConnectionHandler.getConnection(recordProxy, key.key, key.filters);
            if (connection) {
                deleteIDs.forEach(function(deleteID) {
                    ConnectionHandler.deleteNode(connection, deleteID);
                });
            }
        };
        for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
            _loop();
        }
    } catch (err) {
        _iterator3.e(err);
    } finally{
        _iterator3.f();
    }
}
function getRootField(request) {
    if (request.fragment.selections && request.fragment.selections.length > 0 && request.fragment.selections[0].kind === 'LinkedField') {
        return request.fragment.selections[0].name;
    }
    return null;
}
module.exports = {
    MutationTypes: MutationTypes,
    RangeOperations: RangeOperations,
    convert: convert
};
}),
"[project]/node_modules/relay-runtime/lib/mutations/applyOptimisticMutation.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-rsc] (ecmascript)"), getRequest = _require.getRequest;
var isRelayModernEnvironment = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/isRelayModernEnvironment.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-rsc] (ecmascript)"), createOperationDescriptor = _require2.createOperationDescriptor;
var RelayDeclarativeMutationConfig = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayDeclarativeMutationConfig.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function applyOptimisticMutation(environment, config) {
    !isRelayModernEnvironment(environment) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'commitMutation: expected `environment` to be an instance of ' + '`RelayModernEnvironment`.') : "TURBOPACK unreachable" : void 0;
    var mutation = getRequest(config.mutation);
    if (mutation.params.operationKind !== 'mutation') {
        throw new Error('commitMutation: Expected mutation operation');
    }
    var optimisticUpdater = config.optimisticUpdater;
    var configs = config.configs, optimisticResponse = config.optimisticResponse, variables = config.variables;
    var operation = createOperationDescriptor(mutation, variables);
    if (configs) {
        var _RelayDeclarativeMuta = RelayDeclarativeMutationConfig.convert(configs, mutation, optimisticUpdater);
        optimisticUpdater = _RelayDeclarativeMuta.optimisticUpdater;
    }
    return environment.applyMutation({
        operation: operation,
        response: optimisticResponse,
        updater: optimisticUpdater
    });
}
module.exports = applyOptimisticMutation;
}),
"[project]/node_modules/relay-runtime/lib/mutations/commitLocalUpdate.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function commitLocalUpdate(environment, updater) {
    environment.commitUpdate(updater);
}
module.exports = commitLocalUpdate;
}),
"[project]/node_modules/relay-runtime/lib/mutations/validateMutation.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
var hasOwnProperty = Object.prototype.hasOwnProperty;
var validateMutation = function validateMutation() {};
if ("TURBOPACK compile-time truthy", 1) {
    var addFieldToDiff = function addFieldToDiff(path, diff, isScalar) {
        var deepLoc = diff;
        path.split('.').forEach(function(key, index, arr) {
            if (deepLoc[key] == null) {
                deepLoc[key] = {};
            }
            if (isScalar && index === arr.length - 1) {
                deepLoc[key] = '<scalar>';
            }
            deepLoc = deepLoc[key];
        });
    };
    validateMutation = function validateMutation(optimisticResponse, mutation, variables) {
        var operationName = mutation.operation.name;
        var context = {
            path: 'ROOT',
            visitedPaths: new Set(),
            variables: variables || {},
            missingDiff: {},
            extraDiff: {},
            moduleImportPaths: new Set()
        };
        validateSelections(optimisticResponse, mutation.operation.selections, context);
        validateOptimisticResponse(optimisticResponse, context);
        ("TURBOPACK compile-time truthy", 1) ? warning(context.missingDiff.ROOT == null, 'Expected `optimisticResponse` to match structure of server response for mutation `%s`, please define fields for all of\n%s', operationName, JSON.stringify(context.missingDiff.ROOT, null, 2)) : "TURBOPACK unreachable";
        ("TURBOPACK compile-time truthy", 1) ? warning(context.extraDiff.ROOT == null, 'Expected `optimisticResponse` to match structure of server response for mutation `%s`, please remove all fields of\n%s', operationName, JSON.stringify(context.extraDiff.ROOT, null, 2)) : "TURBOPACK unreachable";
    };
    var validateSelections = function validateSelections(optimisticResponse, selections, context) {
        selections.forEach(function(selection) {
            return validateSelection(optimisticResponse, selection, context);
        });
    };
    var validateSelection = function validateSelection(optimisticResponse, selection, context) {
        switch(selection.kind){
            case 'Condition':
                validateSelections(optimisticResponse, selection.selections, context);
                return;
            case 'ClientComponent':
            case 'FragmentSpread':
                validateSelections(optimisticResponse, selection.fragment.selections, context);
                return;
            case 'ScalarField':
            case 'LinkedField':
                return validateField(optimisticResponse, selection, context);
            case 'ActorChange':
                return validateField(optimisticResponse, selection.linkedField, context);
            case 'InlineFragment':
                var type = selection.type;
                var isConcreteType = selection.abstractKey == null;
                validateAbstractKey(context, selection.abstractKey);
                selection.selections.forEach(function(subselection) {
                    if (isConcreteType && optimisticResponse.__typename !== type) {
                        return;
                    }
                    validateSelection(optimisticResponse, subselection, context);
                });
                return;
            case 'ClientExtension':
                selection.selections.forEach(function(subselection) {
                    validateSelection(optimisticResponse, subselection, context);
                });
                return;
            case 'ModuleImport':
                return validateModuleImport(context);
            case 'TypeDiscriminator':
                return validateAbstractKey(context, selection.abstractKey);
            case 'ClientEdgeToClientObject':
            case 'LinkedHandle':
            case 'ScalarHandle':
            case 'Defer':
            case 'Stream':
            case 'RelayResolver':
            case 'RelayLiveResolver':
                {
                    return;
                }
            default:
                selection;
                return;
        }
    };
    var validateModuleImport = function validateModuleImport(context) {
        context.moduleImportPaths.add(context.path);
    };
    var validateAbstractKey = function validateAbstractKey(context, abstractKey) {
        if (abstractKey != null) {
            var path = "".concat(context.path, ".").concat(abstractKey);
            context.visitedPaths.add(path);
        }
    };
    var validateField = function validateField(optimisticResponse, field, context) {
        var fieldName = field.alias || field.name;
        var path = "".concat(context.path, ".").concat(fieldName);
        context.visitedPaths.add(path);
        switch(field.kind){
            case 'ScalarField':
                if (hasOwnProperty.call(optimisticResponse, fieldName) === false) {
                    addFieldToDiff(path, context.missingDiff, true);
                }
                return;
            case 'LinkedField':
                var selections = field.selections;
                if (optimisticResponse[fieldName] === null || hasOwnProperty.call(optimisticResponse, fieldName) && optimisticResponse[fieldName] === undefined) {
                    return;
                }
                if (field.plural) {
                    if (Array.isArray(optimisticResponse[fieldName])) {
                        optimisticResponse[fieldName].forEach(function(r) {
                            if (r !== null) {
                                validateSelections(r, selections, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, context), {}, {
                                    path: path
                                }));
                            }
                        });
                        return;
                    } else {
                        addFieldToDiff(path, context.missingDiff);
                        return;
                    }
                } else {
                    if (optimisticResponse[fieldName] instanceof Object) {
                        validateSelections(optimisticResponse[fieldName], selections, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, context), {}, {
                            path: path
                        }));
                        return;
                    } else {
                        addFieldToDiff(path, context.missingDiff);
                        return;
                    }
                }
        }
    };
    var validateOptimisticResponse = function validateOptimisticResponse(optimisticResponse, context) {
        if (Array.isArray(optimisticResponse)) {
            optimisticResponse.forEach(function(r) {
                if (r instanceof Object) {
                    validateOptimisticResponse(r, context);
                }
            });
            return;
        }
        Object.keys(optimisticResponse).forEach(function(key) {
            var value = optimisticResponse[key];
            var path = "".concat(context.path, ".").concat(key);
            if (context.moduleImportPaths.has(path)) {
                return;
            }
            if (!context.visitedPaths.has(path)) {
                addFieldToDiff(path, context.extraDiff);
                return;
            }
            if (value instanceof Object) {
                validateOptimisticResponse(value, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, context), {}, {
                    path: path
                }));
            }
        });
    };
}
module.exports = validateMutation;
}),
"[project]/node_modules/relay-runtime/lib/mutations/commitMutation.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-rsc] (ecmascript)"), getRequest = _require.getRequest;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-rsc] (ecmascript)"), generateUniqueClientID = _require2.generateUniqueClientID;
var isRelayModernEnvironment = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/isRelayModernEnvironment.js [app-rsc] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-rsc] (ecmascript)"), createOperationDescriptor = _require3.createOperationDescriptor;
var RelayDeclarativeMutationConfig = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayDeclarativeMutationConfig.js [app-rsc] (ecmascript)");
var validateMutation = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/validateMutation.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function commitMutation(environment, config) {
    !isRelayModernEnvironment(environment) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'commitMutation: expected `environment` to be an instance of ' + '`RelayModernEnvironment`.') : "TURBOPACK unreachable" : void 0;
    var mutation = getRequest(config.mutation);
    if (mutation.params.operationKind !== 'mutation') {
        throw new Error('commitMutation: Expected mutation operation');
    }
    if (mutation.kind !== 'Request') {
        throw new Error('commitMutation: Expected mutation to be of type request');
    }
    var optimisticResponse = config.optimisticResponse, optimisticUpdater = config.optimisticUpdater, updater = config.updater;
    var configs = config.configs, cacheConfig = config.cacheConfig, onError = config.onError, onUnsubscribe = config.onUnsubscribe, variables = config.variables, uploadables = config.uploadables;
    var operation = createOperationDescriptor(mutation, variables, cacheConfig, generateUniqueClientID());
    if (typeof optimisticResponse === 'function') {
        optimisticResponse = optimisticResponse();
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'commitMutation: Expected `optimisticResponse` to be an object, ' + 'received a function.') : "TURBOPACK unreachable";
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (optimisticResponse instanceof Object) {
            validateMutation(optimisticResponse, mutation, variables);
        }
    }
    if (configs) {
        var _RelayDeclarativeMuta = RelayDeclarativeMutationConfig.convert(configs, mutation, optimisticUpdater, updater);
        optimisticUpdater = _RelayDeclarativeMuta.optimisticUpdater;
        updater = _RelayDeclarativeMuta.updater;
    }
    var errors = [];
    var subscription = environment.executeMutation({
        operation: operation,
        optimisticResponse: optimisticResponse,
        optimisticUpdater: optimisticUpdater,
        updater: updater,
        uploadables: uploadables
    }).subscribe({
        next: function next(payload) {
            var _config$onNext;
            if (Array.isArray(payload)) {
                payload.forEach(function(item) {
                    if (item.errors) {
                        errors.push.apply(errors, (0, _toConsumableArray2["default"])(item.errors));
                    }
                });
            } else {
                if (payload.errors) {
                    errors.push.apply(errors, (0, _toConsumableArray2["default"])(payload.errors));
                }
            }
            (_config$onNext = config.onNext) === null || _config$onNext === void 0 ? void 0 : _config$onNext.call(config);
        },
        complete: function complete() {
            var onCompleted = config.onCompleted;
            if (onCompleted) {
                var snapshot = environment.lookup(operation.fragment);
                onCompleted(snapshot.data, errors.length !== 0 ? errors : null);
            }
        },
        error: onError,
        unsubscribe: onUnsubscribe
    });
    return {
        dispose: subscription.unsubscribe
    };
}
module.exports = commitMutation;
}),
"[project]/node_modules/relay-runtime/lib/util/withProvidedVariables.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
var WEAKMAP_SUPPORTED = typeof WeakMap === 'function';
var debugCache = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();
function withProvidedVariables(userSuppliedVariables, providedVariables) {
    if (providedVariables != null) {
        var operationVariables = {};
        Object.assign(operationVariables, userSuppliedVariables);
        Object.keys(providedVariables).forEach(function(varName) {
            var providerFunction = providedVariables[varName].get;
            var providerResult = providerFunction();
            if (!debugCache.has(providerFunction)) {
                debugCache.set(providerFunction, providerResult);
                operationVariables[varName] = providerResult;
            } else {
                var cachedResult = debugCache.get(providerFunction);
                if ("TURBOPACK compile-time truthy", 1) {
                    ("TURBOPACK compile-time truthy", 1) ? warning(areEqual(providerResult, cachedResult), 'Relay: Expected function `%s` for provider `%s` to be a pure function, ' + 'but got conflicting return values `%s` and `%s`', providerFunction.name, varName, providerResult, cachedResult) : "TURBOPACK unreachable";
                }
                operationVariables[varName] = cachedResult;
            }
        });
        return operationVariables;
    } else {
        return userSuppliedVariables;
    }
}
withProvidedVariables.tests_only_resetDebugCache = ("TURBOPACK compile-time truthy", 1) ? function() {
    debugCache = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();
} : "TURBOPACK unreachable";
module.exports = withProvidedVariables;
}),
"[project]/node_modules/relay-runtime/lib/network/ConvertToExecuteFunction.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayObservable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-rsc] (ecmascript)");
function convertFetch(fn) {
    return function fetch(request, variables, cacheConfig, uploadables, logRequestInfo) {
        var result = fn(request, variables, cacheConfig, uploadables, logRequestInfo);
        if (result instanceof Error) {
            return RelayObservable.create(function(sink) {
                return sink.error(result);
            });
        }
        return RelayObservable.from(result);
    };
}
module.exports = {
    convertFetch: convertFetch
};
}),
"[project]/node_modules/relay-runtime/lib/network/RelayNetwork.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var withProvidedVariables = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/withProvidedVariables.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/ConvertToExecuteFunction.js [app-rsc] (ecmascript)"), convertFetch = _require.convertFetch;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function create(fetchFn, subscribe) {
    var observeFetch = convertFetch(fetchFn);
    function execute(request, variables, cacheConfig, uploadables, logRequestInfo) {
        var operationVariables = withProvidedVariables(variables, request.providedVariables);
        if (request.operationKind === 'subscription') {
            !subscribe ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayNetwork: This network layer does not support Subscriptions. ' + 'To use Subscriptions, provide a custom network layer.') : "TURBOPACK unreachable" : void 0;
            !!uploadables ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayNetwork: Cannot provide uploadables while subscribing.') : "TURBOPACK unreachable" : void 0;
            return subscribe(request, operationVariables, cacheConfig);
        }
        var pollInterval = cacheConfig.poll;
        if (pollInterval != null) {
            !!uploadables ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayNetwork: Cannot provide uploadables while polling.') : "TURBOPACK unreachable" : void 0;
            return observeFetch(request, operationVariables, {
                force: true
            }).poll(pollInterval);
        }
        return observeFetch(request, operationVariables, cacheConfig, uploadables, logRequestInfo);
    }
    return {
        execute: execute
    };
}
module.exports = {
    create: create
};
}),
"[project]/node_modules/relay-runtime/lib/network/RelayQueryResponseCache.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-rsc] (ecmascript)"), stableCopy = _require.stableCopy;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var RelayQueryResponseCache = /*#__PURE__*/ function() {
    function RelayQueryResponseCache(_ref) {
        var size = _ref.size, ttl = _ref.ttl;
        !(size > 0) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayQueryResponseCache: Expected the max cache size to be > 0, got ' + '`%s`.', size) : "TURBOPACK unreachable" : void 0;
        !(ttl > 0) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayQueryResponseCache: Expected the max ttl to be > 0, got `%s`.', ttl) : "TURBOPACK unreachable" : void 0;
        this._responses = new Map();
        this._size = size;
        this._ttl = ttl;
    }
    var _proto = RelayQueryResponseCache.prototype;
    _proto.clear = function clear() {
        this._responses.clear();
    };
    _proto.get = function get(queryID, variables) {
        var _this = this;
        var cacheKey = getCacheKey(queryID, variables);
        this._responses.forEach(function(response, key) {
            if (!isCurrent(response.fetchTime, _this._ttl)) {
                _this._responses["delete"](key);
            }
        });
        var response = this._responses.get(cacheKey);
        if (response == null) {
            return null;
        }
        if (Array.isArray(response.payload)) {
            return response.payload.map(function(payload) {
                return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, payload), {}, {
                    extensions: (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, payload.extensions), {}, {
                        cacheTimestamp: response.fetchTime
                    })
                });
            });
        }
        return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, response.payload), {}, {
            extensions: (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, response.payload.extensions), {}, {
                cacheTimestamp: response.fetchTime
            })
        });
    };
    _proto.set = function set(queryID, variables, payload) {
        var fetchTime = Date.now();
        var cacheKey = getCacheKey(queryID, variables);
        this._responses["delete"](cacheKey);
        this._responses.set(cacheKey, {
            fetchTime: fetchTime,
            payload: payload
        });
        if (this._responses.size > this._size) {
            var firstKey = this._responses.keys().next();
            if (!firstKey.done) {
                this._responses["delete"](firstKey.value);
            }
        }
    };
    return RelayQueryResponseCache;
}();
function getCacheKey(queryID, variables) {
    return JSON.stringify(stableCopy({
        queryID: queryID,
        variables: variables
    }));
}
function isCurrent(fetchTime, ttl) {
    return fetchTime + ttl >= Date.now();
}
module.exports = RelayQueryResponseCache;
}),
"[project]/node_modules/relay-runtime/lib/query/fetchQuery.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var RelayObservable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-rsc] (ecmascript)"), createOperationDescriptor = _require.createOperationDescriptor;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js [app-rsc] (ecmascript)"), handlePotentialSnapshotErrors = _require2.handlePotentialSnapshotErrors;
var fetchQueryInternal = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/fetchQueryInternal.js [app-rsc] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-rsc] (ecmascript)"), getRequest = _require3.getRequest;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function fetchQuery(environment, query, variables, options) {
    var _options$fetchPolicy;
    var queryNode = getRequest(query);
    !(queryNode.params.operationKind === 'query') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'fetchQuery: Expected query operation') : "TURBOPACK unreachable" : void 0;
    var networkCacheConfig = (0, _objectSpread2["default"])({
        force: true
    }, options === null || options === void 0 ? void 0 : options.networkCacheConfig);
    var operation = createOperationDescriptor(queryNode, variables, networkCacheConfig);
    var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'network-only';
    function readData(snapshot) {
        handlePotentialSnapshotErrors(environment, snapshot.fieldErrors);
        return snapshot.data;
    }
    switch(fetchPolicy){
        case 'network-only':
            {
                return getNetworkObservable(environment, operation).map(readData);
            }
        case 'store-or-network':
            {
                if (environment.check(operation).status === 'available') {
                    return RelayObservable.from(environment.lookup(operation.fragment)).map(readData);
                }
                return getNetworkObservable(environment, operation).map(readData);
            }
        default:
            fetchPolicy;
            throw new Error('fetchQuery: Invalid fetchPolicy ' + fetchPolicy);
    }
}
function getNetworkObservable(environment, operation) {
    return fetchQueryInternal.fetchQuery(environment, operation).map(function() {
        return environment.lookup(operation.fragment);
    });
}
module.exports = fetchQuery;
}),
"[project]/node_modules/relay-runtime/lib/query/fetchQuery_DEPRECATED.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-rsc] (ecmascript)"), createOperationDescriptor = _require.createOperationDescriptor;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-rsc] (ecmascript)"), getRequest = _require2.getRequest;
function fetchQuery_DEPRECATED(environment, taggedNode, variables, cacheConfig) {
    var query = getRequest(taggedNode);
    if (query.params.operationKind !== 'query') {
        throw new Error('fetchQuery: Expected query operation');
    }
    var operation = createOperationDescriptor(query, variables, cacheConfig);
    return environment.execute({
        operation: operation
    }).map(function() {
        return environment.lookup(operation.fragment).data;
    }).toPromise();
}
module.exports = fetchQuery_DEPRECATED;
}),
"[project]/node_modules/relay-runtime/lib/query/PreloadableQueryRegistry.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var PreloadableQueryRegistry = /*#__PURE__*/ function() {
    function PreloadableQueryRegistry() {
        this._preloadableQueries = new Map();
        this._callbacks = new Map();
    }
    var _proto = PreloadableQueryRegistry.prototype;
    _proto.set = function set(key, value) {
        this._preloadableQueries.set(key, value);
        var callbacks = this._callbacks.get(key);
        if (callbacks != null) {
            callbacks.forEach(function(cb) {
                try {
                    cb(value);
                } catch (e) {
                    setTimeout(function() {
                        throw e;
                    }, 0);
                }
            });
        }
    };
    _proto.get = function get(key) {
        return this._preloadableQueries.get(key);
    };
    _proto.onLoad = function onLoad(key, callback) {
        var _this$_callbacks$get;
        var callbacks = (_this$_callbacks$get = this._callbacks.get(key)) !== null && _this$_callbacks$get !== void 0 ? _this$_callbacks$get : new Set();
        callbacks.add(callback);
        var dispose = function dispose() {
            callbacks["delete"](callback);
        };
        this._callbacks.set(key, callbacks);
        return {
            dispose: dispose
        };
    };
    _proto.clear = function clear() {
        this._preloadableQueries.clear();
    };
    return PreloadableQueryRegistry;
}();
var preloadableQueryRegistry = new PreloadableQueryRegistry();
module.exports = preloadableQueryRegistry;
}),
"[project]/node_modules/relay-runtime/lib/util/getPendingOperationsForFragment.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/fetchQueryInternal.js [app-rsc] (ecmascript)"), getPromiseForActiveRequest = _require.getPromiseForActiveRequest;
function getPendingOperationsForFragment(environment, fragmentNode, fragmentOwner) {
    var _pendingOperations$ma, _pendingOperations;
    var pendingOperations = [];
    var promise = getPromiseForActiveRequest(environment, fragmentOwner);
    if (promise != null) {
        pendingOperations = [
            fragmentOwner
        ];
    } else {
        var _result$pendingOperat, _result$promise;
        var operationTracker = environment.getOperationTracker();
        var result = operationTracker.getPendingOperationsAffectingOwner(fragmentOwner);
        pendingOperations = (_result$pendingOperat = result === null || result === void 0 ? void 0 : result.pendingOperations) !== null && _result$pendingOperat !== void 0 ? _result$pendingOperat : [];
        promise = (_result$promise = result === null || result === void 0 ? void 0 : result.promise) !== null && _result$promise !== void 0 ? _result$promise : null;
    }
    if (!promise) {
        return null;
    }
    var pendingOperationName = (_pendingOperations$ma = (_pendingOperations = pendingOperations) === null || _pendingOperations === void 0 ? void 0 : _pendingOperations.map(function(op) {
        return op.node.params.name;
    }).join(',')) !== null && _pendingOperations$ma !== void 0 ? _pendingOperations$ma : null;
    if (pendingOperationName == null || pendingOperationName.length === 0) {
        pendingOperationName = 'Unknown pending operation';
    }
    var fragmentName = fragmentNode.name;
    var promiseDisplayName = pendingOperationName === fragmentName ? "Relay(".concat(pendingOperationName, ")") : "Relay(".concat(pendingOperationName, ":").concat(fragmentName, ")");
    promise.displayName = promiseDisplayName;
    environment.__log({
        name: 'pendingoperation.found',
        fragment: fragmentNode,
        fragmentOwner: fragmentOwner,
        pendingOperations: pendingOperations
    });
    return {
        promise: promise,
        pendingOperations: pendingOperations
    };
}
module.exports = getPendingOperationsForFragment;
}),
"[project]/node_modules/relay-runtime/lib/util/isScalarAndEqual.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function isScalarAndEqual(valueA, valueB) {
    return valueA === valueB && (valueA === null || typeof valueA !== 'object');
}
module.exports = isScalarAndEqual;
}),
"[project]/node_modules/relay-runtime/lib/util/recycleNodesInto.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function recycleNodesInto(prevData, nextData) {
    return recycleNodesIntoImpl(prevData, nextData, true);
}
function recycleNodesIntoImpl(prevData, nextData, canMutate) {
    if (prevData === nextData || typeof prevData !== 'object' || !prevData || prevData.constructor !== Object && !Array.isArray(prevData) || typeof nextData !== 'object' || !nextData || nextData.constructor !== Object && !Array.isArray(nextData)) {
        return nextData;
    }
    var canRecycle = false;
    var prevArray = Array.isArray(prevData) ? prevData : null;
    var nextArray = Array.isArray(nextData) ? nextData : null;
    if (prevArray && nextArray) {
        var canMutateNext = canMutate && !Object.isFrozen(nextArray);
        canRecycle = nextArray.reduce(function(wasEqual, nextItem, ii) {
            var prevValue = prevArray[ii];
            var nextValue = recycleNodesIntoImpl(prevValue, nextItem, canMutateNext);
            if (nextValue !== nextArray[ii] && canMutateNext) {
                nextArray[ii] = nextValue;
            }
            return wasEqual && nextValue === prevArray[ii];
        }, true) && prevArray.length === nextArray.length;
    } else if (!prevArray && !nextArray) {
        var prevObject = prevData;
        var nextObject = nextData;
        var prevKeys = Object.keys(prevObject);
        var nextKeys = Object.keys(nextObject);
        var _canMutateNext = canMutate && !Object.isFrozen(nextObject);
        canRecycle = nextKeys.reduce(function(wasEqual, key) {
            var prevValue = prevObject[key];
            var nextValue = recycleNodesIntoImpl(prevValue, nextObject[key], _canMutateNext);
            if (nextValue !== nextObject[key] && _canMutateNext) {
                nextObject[key] = nextValue;
            }
            return wasEqual && nextValue === prevObject[key];
        }, true) && prevKeys.length === nextKeys.length;
    }
    return canRecycle ? prevData : nextData;
}
module.exports = recycleNodesInto;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayModernFragmentSpecResolver.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var getPendingOperationsForFragment = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getPendingOperationsForFragment.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js [app-rsc] (ecmascript)"), handlePotentialSnapshotErrors = _require.handlePotentialSnapshotErrors;
var isScalarAndEqual = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/isScalarAndEqual.js [app-rsc] (ecmascript)");
var recycleNodesInto = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/recycleNodesInto.js [app-rsc] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-rsc] (ecmascript)"), createRequestDescriptor = _require2.createRequestDescriptor;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-rsc] (ecmascript)"), areEqualSelectors = _require3.areEqualSelectors, createReaderSelector = _require3.createReaderSelector, getSelectorsFromObject = _require3.getSelectorsFromObject;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
var RelayModernFragmentSpecResolver = /*#__PURE__*/ function() {
    function RelayModernFragmentSpecResolver(context, fragments, props, callback, rootIsQueryRenderer) {
        var _this = this;
        (0, _defineProperty2["default"])(this, "_onChange", function() {
            _this._stale = true;
            if (typeof _this._callback === 'function') {
                _this._callback();
            }
        });
        this._callback = callback;
        this._context = context;
        this._data = {};
        this._fragments = fragments;
        this._props = {};
        this._resolvers = {};
        this._stale = false;
        this._rootIsQueryRenderer = rootIsQueryRenderer;
        this.setProps(props);
    }
    var _proto = RelayModernFragmentSpecResolver.prototype;
    _proto.dispose = function dispose() {
        for(var key in this._resolvers){
            if (this._resolvers.hasOwnProperty(key)) {
                disposeCallback(this._resolvers[key]);
            }
        }
    };
    _proto.resolve = function resolve() {
        if (this._stale) {
            var prevData = this._data;
            var nextData;
            for(var key in this._resolvers){
                if (this._resolvers.hasOwnProperty(key)) {
                    var resolver = this._resolvers[key];
                    var prevItem = prevData[key];
                    if (resolver) {
                        var nextItem = resolver.resolve();
                        if (nextData || nextItem !== prevItem) {
                            nextData = nextData || (0, _objectSpread2["default"])({}, prevData);
                            nextData[key] = nextItem;
                        }
                    } else {
                        var prop = this._props[key];
                        var _nextItem = prop !== undefined ? prop : null;
                        if (nextData || !isScalarAndEqual(_nextItem, prevItem)) {
                            nextData = nextData || (0, _objectSpread2["default"])({}, prevData);
                            nextData[key] = _nextItem;
                        }
                    }
                }
            }
            this._data = nextData || prevData;
            this._stale = false;
        }
        return this._data;
    };
    _proto.setCallback = function setCallback(props, callback) {
        this._callback = callback;
        if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
            this.setProps(props);
        }
    };
    _proto.setProps = function setProps(props) {
        this._props = {};
        var ownedSelectors = getSelectorsFromObject(this._fragments, props);
        for(var key in ownedSelectors){
            if (ownedSelectors.hasOwnProperty(key)) {
                var ownedSelector = ownedSelectors[key];
                var resolver = this._resolvers[key];
                if (ownedSelector == null) {
                    if (resolver != null) {
                        resolver.dispose();
                    }
                    resolver = null;
                } else if (ownedSelector.kind === 'PluralReaderSelector') {
                    if (resolver == null) {
                        resolver = new SelectorListResolver(this._context.environment, this._rootIsQueryRenderer, ownedSelector, this._callback != null, this._onChange);
                    } else {
                        !(resolver instanceof SelectorListResolver) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an array.', key) : "TURBOPACK unreachable" : void 0;
                        resolver.setSelector(ownedSelector);
                    }
                } else {
                    if (resolver == null) {
                        resolver = new SelectorResolver(this._context.environment, this._rootIsQueryRenderer, ownedSelector, this._callback != null, this._onChange);
                    } else {
                        !(resolver instanceof SelectorResolver) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernFragmentSpecResolver: Expected prop `%s` to always be an object.', key) : "TURBOPACK unreachable" : void 0;
                        resolver.setSelector(ownedSelector);
                    }
                }
                this._props[key] = props[key];
                this._resolvers[key] = resolver;
            }
        }
        this._stale = true;
    };
    _proto.setVariables = function setVariables(variables, request) {
        for(var key in this._resolvers){
            if (this._resolvers.hasOwnProperty(key)) {
                var resolver = this._resolvers[key];
                if (resolver) {
                    resolver.setVariables(variables, request);
                }
            }
        }
        this._stale = true;
    };
    return RelayModernFragmentSpecResolver;
}();
var SelectorResolver = /*#__PURE__*/ function() {
    function SelectorResolver(environment, rootIsQueryRenderer, selector, subscribeOnConstruction, callback) {
        var _this2 = this;
        (0, _defineProperty2["default"])(this, "_onChange", function(snapshot) {
            _this2._data = snapshot.data;
            _this2._isMissingData = snapshot.isMissingData;
            _this2._fieldErrors = snapshot.fieldErrors;
            _this2._callback();
        });
        var _snapshot = environment.lookup(selector);
        this._callback = callback;
        this._data = _snapshot.data;
        this._isMissingData = _snapshot.isMissingData;
        this._fieldErrors = _snapshot.fieldErrors;
        this._environment = environment;
        this._rootIsQueryRenderer = rootIsQueryRenderer;
        this._selector = selector;
        if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
            if (subscribeOnConstruction) {
                this._subscription = environment.subscribe(_snapshot, this._onChange);
            }
        } else {
            this._subscription = environment.subscribe(_snapshot, this._onChange);
        }
    }
    var _proto2 = SelectorResolver.prototype;
    _proto2.dispose = function dispose() {
        if (this._subscription) {
            this._subscription.dispose();
            this._subscription = null;
        }
    };
    _proto2.resolve = function resolve() {
        if (this._isMissingData === true) {
            var pendingOperationsResult = getPendingOperationsForFragment(this._environment, this._selector.node, this._selector.owner);
            var promise = pendingOperationsResult === null || pendingOperationsResult === void 0 ? void 0 : pendingOperationsResult.promise;
            if (promise != null) {
                if (this._rootIsQueryRenderer) {
                    ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Relay Container for fragment `%s` has missing data and ' + 'would suspend. When using features such as @defer or @module, ' + 'use `useFragment` instead of a Relay Container.', this._selector.node.name) : "TURBOPACK unreachable";
                } else {
                    var _pendingOperationsRes;
                    var pendingOperations = (_pendingOperationsRes = pendingOperationsResult === null || pendingOperationsResult === void 0 ? void 0 : pendingOperationsResult.pendingOperations) !== null && _pendingOperationsRes !== void 0 ? _pendingOperationsRes : [];
                    ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Relay Container for fragment `%s` suspended. When using ' + 'features such as @defer or @module, use `useFragment` instead ' + 'of a Relay Container.', this._selector.node.name) : "TURBOPACK unreachable";
                    this._environment.__log({
                        name: 'suspense.fragment',
                        data: this._data,
                        fragment: this._selector.node,
                        isRelayHooks: false,
                        isMissingData: this._isMissingData,
                        isPromiseCached: false,
                        pendingOperations: pendingOperations
                    });
                    throw promise;
                }
            }
        }
        handlePotentialSnapshotErrors(this._environment, this._fieldErrors);
        return this._data;
    };
    _proto2.setSelector = function setSelector(selector) {
        if (this._subscription != null && areEqualSelectors(selector, this._selector)) {
            return;
        }
        this.dispose();
        var snapshot = this._environment.lookup(selector);
        this._data = recycleNodesInto(this._data, snapshot.data);
        this._isMissingData = snapshot.isMissingData;
        this._fieldErrors = snapshot.fieldErrors;
        this._selector = selector;
        this._subscription = this._environment.subscribe(snapshot, this._onChange);
    };
    _proto2.setVariables = function setVariables(variables, request) {
        if (areEqual(variables, this._selector.variables)) {
            return;
        }
        var requestDescriptor = createRequestDescriptor(request, variables);
        var selector = createReaderSelector(this._selector.node, this._selector.dataID, variables, requestDescriptor);
        this.setSelector(selector);
    };
    return SelectorResolver;
}();
var SelectorListResolver = /*#__PURE__*/ function() {
    function SelectorListResolver(environment, rootIsQueryRenderer, selector, subscribeOnConstruction, callback) {
        var _this3 = this;
        (0, _defineProperty2["default"])(this, "_onChange", function(data) {
            _this3._stale = true;
            _this3._callback();
        });
        this._callback = callback;
        this._data = [];
        this._environment = environment;
        this._resolvers = [];
        this._stale = true;
        this._rootIsQueryRenderer = rootIsQueryRenderer;
        this._subscribeOnConstruction = subscribeOnConstruction;
        this.setSelector(selector);
    }
    var _proto3 = SelectorListResolver.prototype;
    _proto3.dispose = function dispose() {
        this._resolvers.forEach(disposeCallback);
    };
    _proto3.resolve = function resolve() {
        if (this._stale) {
            var prevData = this._data;
            var nextData;
            for(var ii = 0; ii < this._resolvers.length; ii++){
                var prevItem = prevData[ii];
                var nextItem = this._resolvers[ii].resolve();
                if (nextData || nextItem !== prevItem) {
                    nextData = nextData || prevData.slice(0, ii);
                    nextData.push(nextItem);
                }
            }
            if (!nextData && this._resolvers.length !== prevData.length) {
                nextData = prevData.slice(0, this._resolvers.length);
            }
            this._data = nextData || prevData;
            this._stale = false;
        }
        return this._data;
    };
    _proto3.setSelector = function setSelector(selector) {
        var selectors = selector.selectors;
        while(this._resolvers.length > selectors.length){
            var resolver = this._resolvers.pop();
            resolver.dispose();
        }
        for(var ii = 0; ii < selectors.length; ii++){
            if (ii < this._resolvers.length) {
                this._resolvers[ii].setSelector(selectors[ii]);
            } else {
                this._resolvers[ii] = new SelectorResolver(this._environment, this._rootIsQueryRenderer, selectors[ii], this._subscribeOnConstruction, this._onChange);
            }
        }
        this._stale = true;
    };
    _proto3.setVariables = function setVariables(variables, request) {
        this._resolvers.forEach(function(resolver) {
            return resolver.setVariables(variables, request);
        });
        this._stale = true;
    };
    return SelectorListResolver;
}();
function disposeCallback(disposable) {
    disposable && disposable.dispose();
}
module.exports = RelayModernFragmentSpecResolver;
}),
"[project]/node_modules/relay-runtime/lib/store/createFragmentSpecResolver.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayModernFragmentSpecResolver = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernFragmentSpecResolver.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function createFragmentSpecResolver(context, containerName, fragments, props, rootIsQueryRenderer, callback) {
    if ("TURBOPACK compile-time truthy", 1) {
        var fragmentNames = Object.keys(fragments);
        fragmentNames.forEach(function(fragmentName) {
            var propValue = props[fragmentName];
            ("TURBOPACK compile-time truthy", 1) ? warning(propValue !== undefined, 'createFragmentSpecResolver: Expected prop `%s` to be supplied to `%s`, but ' + 'got `undefined`. Pass an explicit `null` if this is intentional.', fragmentName, containerName) : "TURBOPACK unreachable";
        });
    }
    return new RelayModernFragmentSpecResolver(context, fragments, props, callback, rootIsQueryRenderer);
}
module.exports = createFragmentSpecResolver;
}),
"[project]/node_modules/relay-runtime/lib/store/createRelayContext.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var relayContext;
var firstReact;
function createRelayContext(react) {
    if (!relayContext) {
        relayContext = react.createContext(null);
        if ("TURBOPACK compile-time truthy", 1) {
            relayContext.displayName = 'RelayContext';
        }
        firstReact = react;
    }
    !(react === firstReact) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '[createRelayContext]: You are passing a different instance of React', react.version) : "TURBOPACK unreachable" : void 0;
    return relayContext;
}
module.exports = createRelayContext;
}),
"[project]/node_modules/relay-runtime/lib/store/createRelayLoggingContext.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var relayLoggingContext;
var firstReact;
function createRelayLoggingContext(react) {
    if (!relayLoggingContext) {
        relayLoggingContext = react.createContext(null);
        if ("TURBOPACK compile-time truthy", 1) {
            relayLoggingContext.displayName = 'RelayLoggingContext';
        }
        firstReact = react;
    }
    !(react === firstReact) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '[createRelayLoggingContext]: You are passing a different instance of React', react.version) : "TURBOPACK unreachable" : void 0;
    return relayLoggingContext;
}
module.exports = createRelayLoggingContext;
}),
"[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverSuspenseSentinel.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var LIVE_RESOLVER_SUSPENSE_SENTINEL = Object.freeze({
    __LIVE_RESOLVER_SUSPENSE_SENTINEL: true
});
function suspenseSentinel() {
    return LIVE_RESOLVER_SUSPENSE_SENTINEL;
}
function isSuspenseSentinel(value) {
    return value === LIVE_RESOLVER_SUSPENSE_SENTINEL;
}
module.exports = {
    isSuspenseSentinel: isSuspenseSentinel,
    suspenseSentinel: suspenseSentinel
};
}),
"[project]/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for(var n in r)if (({}).hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
    }
    return t;
}
module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js [app-rsc] (ecmascript)"));
var _toPropertyKey2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toPropertyKey.js [app-rsc] (ecmascript)"));
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var deepFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-rsc] (ecmascript)"), generateClientObjectClientID = _require.generateClientObjectClientID, isClientID = _require.isClientID;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverSuspenseSentinel.js [app-rsc] (ecmascript)"), isSuspenseSentinel = _require2.isSuspenseSentinel;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), ACTOR_IDENTIFIER_KEY = _require3.ACTOR_IDENTIFIER_KEY, ERRORS_KEY = _require3.ERRORS_KEY, ID_KEY = _require3.ID_KEY, INVALIDATED_AT_KEY = _require3.INVALIDATED_AT_KEY, REF_KEY = _require3.REF_KEY, REFS_KEY = _require3.REFS_KEY, RELAY_RESOLVER_VALUE_KEY = _require3.RELAY_RESOLVER_VALUE_KEY, ROOT_ID = _require3.ROOT_ID, TYPENAME_KEY = _require3.TYPENAME_KEY;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function clone(record) {
    return (0, _objectSpread2["default"])({}, record);
}
function copyFields(source, sink) {
    for(var key in source){
        if (source.hasOwnProperty(key)) {
            if (key !== ID_KEY && key !== TYPENAME_KEY) {
                sink[key] = source[key];
            }
        }
    }
}
function create(dataID, typeName) {
    var record = {};
    record[ID_KEY] = dataID;
    record[TYPENAME_KEY] = typeName;
    return record;
}
function fromObject(json) {
    return json;
}
function getDataID(record) {
    return record[ID_KEY];
}
function getFields(record) {
    if (ERRORS_KEY in record) {
        return Object.keys(record).filter(function(field) {
            return field !== ERRORS_KEY;
        });
    }
    return Object.keys(record);
}
function getType(record) {
    return record[TYPENAME_KEY];
}
function getErrors(record, storageKey) {
    var _record$ERRORS_KEY;
    return (_record$ERRORS_KEY = record[ERRORS_KEY]) === null || _record$ERRORS_KEY === void 0 ? void 0 : _record$ERRORS_KEY[storageKey];
}
function getValue(record, storageKey) {
    var value = record[storageKey];
    if (value && typeof value === 'object') {
        !(!value.hasOwnProperty(REF_KEY) && !value.hasOwnProperty(REFS_KEY)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getValue(): Expected a scalar (non-link) value for `%s.%s` ' + 'but found %s.', record[ID_KEY], storageKey, value.hasOwnProperty(REF_KEY) ? 'a linked record' : 'plural linked records') : "TURBOPACK unreachable" : void 0;
    }
    return value;
}
function hasValue(record, storageKey) {
    return storageKey in record;
}
function getLinkedRecordID(record, storageKey) {
    var maybeLink = record[storageKey];
    if (maybeLink == null) {
        return maybeLink;
    }
    var link = maybeLink;
    !(typeof link === 'object' && link && typeof link[REF_KEY] === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getLinkedRecordID(): Expected `%s.%s` to be a linked ID, ' + 'was `%s`.%s', record[ID_KEY], storageKey, JSON.stringify(link), typeof link === 'object' && link[REFS_KEY] !== undefined ? ' It appears to be a plural linked record: did you mean to call ' + 'getLinkedRecords() instead of getLinkedRecord()?' : '') : "TURBOPACK unreachable" : void 0;
    return link[REF_KEY];
}
function hasLinkedRecordID(record, storageKey) {
    var maybeLink = record[storageKey];
    if (maybeLink == null) {
        return false;
    }
    var link = maybeLink;
    return typeof link === 'object' && link && typeof link[REF_KEY] === 'string';
}
function getLinkedRecordIDs(record, storageKey) {
    var links = record[storageKey];
    if (links == null) {
        return links;
    }
    !(typeof links === 'object' && Array.isArray(links[REFS_KEY])) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getLinkedRecordIDs(): Expected `%s.%s` to contain an array ' + 'of linked IDs, got `%s`.%s', record[ID_KEY], storageKey, JSON.stringify(links), typeof links === 'object' && links[REF_KEY] !== undefined ? ' It appears to be a singular linked record: did you mean to call ' + 'getLinkedRecord() instead of getLinkedRecords()?' : '') : "TURBOPACK unreachable" : void 0;
    return links[REFS_KEY];
}
function hasLinkedRecordIDs(record, storageKey) {
    var links = record[storageKey];
    if (links == null) {
        return false;
    }
    return typeof links === 'object' && Array.isArray(links[REFS_KEY]) && links[REFS_KEY].every(function(link) {
        return typeof link === 'string';
    });
}
function getInvalidationEpoch(record) {
    if (record == null) {
        return null;
    }
    var invalidatedAt = record[INVALIDATED_AT_KEY];
    if (typeof invalidatedAt !== 'number') {
        return null;
    }
    return invalidatedAt;
}
function update(prevRecord, nextRecord) {
    var _updated2;
    if ("TURBOPACK compile-time truthy", 1) {
        var _getType, _getType2;
        var prevID = getDataID(prevRecord);
        var nextID = getDataID(nextRecord);
        ("TURBOPACK compile-time truthy", 1) ? warning(prevID === nextID, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : "TURBOPACK unreachable";
        var prevType = (_getType = getType(prevRecord)) !== null && _getType !== void 0 ? _getType : null;
        var nextType = (_getType2 = getType(nextRecord)) !== null && _getType2 !== void 0 ? _getType2 : null;
        ("TURBOPACK compile-time truthy", 1) ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : "TURBOPACK unreachable";
    }
    var prevErrorsByKey = prevRecord[ERRORS_KEY];
    var nextErrorsByKey = nextRecord[ERRORS_KEY];
    var updated = null;
    if (prevErrorsByKey == null && nextErrorsByKey == null) {
        var _updated;
        for(var storageKey in nextRecord){
            if (updated || !areEqual(prevRecord[storageKey], nextRecord[storageKey])) {
                updated = updated !== null ? updated : (0, _objectSpread2["default"])({}, prevRecord);
                updated[storageKey] = nextRecord[storageKey];
            }
        }
        return (_updated = updated) !== null && _updated !== void 0 ? _updated : prevRecord;
    }
    for(var _storageKey2 in nextRecord){
        if (_storageKey2 === ERRORS_KEY) {
            continue;
        }
        var nextValue = nextRecord[_storageKey2];
        var nextErrors = nextErrorsByKey === null || nextErrorsByKey === void 0 ? void 0 : nextErrorsByKey[_storageKey2];
        if (updated == null) {
            var prevValue = prevRecord[_storageKey2];
            var prevErrors = prevErrorsByKey === null || prevErrorsByKey === void 0 ? void 0 : prevErrorsByKey[_storageKey2];
            if (areEqual(prevValue, nextValue) && areEqual(prevErrors, nextErrors)) {
                continue;
            }
            updated = (0, _objectSpread2["default"])({}, prevRecord);
            if (prevErrorsByKey != null) {
                updated[ERRORS_KEY] = (0, _objectSpread2["default"])({}, prevErrorsByKey);
            }
        }
        setValue(updated, _storageKey2, nextValue);
        setErrors(updated, _storageKey2, nextErrors);
    }
    return (_updated2 = updated) !== null && _updated2 !== void 0 ? _updated2 : prevRecord;
}
function merge(record1, record2) {
    if ("TURBOPACK compile-time truthy", 1) {
        var _getType3, _getType4;
        var prevID = getDataID(record1);
        var nextID = getDataID(record2);
        ("TURBOPACK compile-time truthy", 1) ? warning(prevID === nextID, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : "TURBOPACK unreachable";
        var prevType = (_getType3 = getType(record1)) !== null && _getType3 !== void 0 ? _getType3 : null;
        var nextType = (_getType4 = getType(record2)) !== null && _getType4 !== void 0 ? _getType4 : null;
        ("TURBOPACK compile-time truthy", 1) ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : "TURBOPACK unreachable";
    }
    if (ERRORS_KEY in record1 || ERRORS_KEY in record2) {
        var errors1 = record1[ERRORS_KEY], fields1 = (0, _objectWithoutPropertiesLoose2["default"])(record1, [
            ERRORS_KEY
        ].map(_toPropertyKey2["default"]));
        var errors2 = record2[ERRORS_KEY], fields2 = (0, _objectWithoutPropertiesLoose2["default"])(record2, [
            ERRORS_KEY
        ].map(_toPropertyKey2["default"]));
        var updated = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, fields1), fields2);
        if (errors1 == null && errors2 == null) {
            return updated;
        }
        var updatedErrors = {};
        for(var storageKey in errors1){
            if (fields2.hasOwnProperty(storageKey)) {
                continue;
            }
            updatedErrors[storageKey] = errors1[storageKey];
        }
        for(var _storageKey3 in errors2){
            updatedErrors[_storageKey3] = errors2[_storageKey3];
        }
        for(var _storageKey in updatedErrors){
            updated[ERRORS_KEY] = updatedErrors;
            break;
        }
        return updated;
    } else {
        return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, record1), record2);
    }
}
function freeze(record) {
    deepFreeze(record);
}
function setErrors(record, storageKey, errors) {
    if ("TURBOPACK compile-time truthy", 1) {
        ("TURBOPACK compile-time truthy", 1) ? warning(storageKey in record, 'RelayModernRecord: Invalid error update, `%s` should not be undefined.', storageKey) : "TURBOPACK unreachable";
    }
    var errorsByStorageKey = record[ERRORS_KEY];
    if (errors != null && errors.length > 0) {
        if (errorsByStorageKey == null) {
            record[ERRORS_KEY] = (0, _defineProperty2["default"])({}, storageKey, errors);
        } else {
            errorsByStorageKey[storageKey] = errors;
        }
    } else if (errorsByStorageKey != null) {
        if (delete errorsByStorageKey[storageKey]) {
            for(var otherStorageKey in errorsByStorageKey){
                if (errorsByStorageKey.hasOwnProperty(otherStorageKey)) {
                    return;
                }
            }
            delete record[ERRORS_KEY];
        }
    }
}
function setValue(record, storageKey, value) {
    if ("TURBOPACK compile-time truthy", 1) {
        var prevID = getDataID(record);
        if (storageKey === ID_KEY) {
            ("TURBOPACK compile-time truthy", 1) ? warning(prevID === value, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, value) : "TURBOPACK unreachable";
        } else if (storageKey === TYPENAME_KEY) {
            var _getType5;
            var prevType = (_getType5 = getType(record)) !== null && _getType5 !== void 0 ? _getType5 : null;
            var nextType = value !== null && value !== void 0 ? value : null;
            ("TURBOPACK compile-time truthy", 1) ? warning(isClientID(getDataID(record)) && getDataID(record) !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : "TURBOPACK unreachable";
        }
    }
    record[storageKey] = value;
}
function setLinkedRecordID(record, storageKey, linkedID) {
    var link = {};
    link[REF_KEY] = linkedID;
    record[storageKey] = link;
}
function setLinkedRecordIDs(record, storageKey, linkedIDs) {
    var links = {};
    links[REFS_KEY] = linkedIDs;
    record[storageKey] = links;
}
function setActorLinkedRecordID(record, storageKey, actorIdentifier, linkedID) {
    var link = {};
    link[REF_KEY] = linkedID;
    link[ACTOR_IDENTIFIER_KEY] = actorIdentifier;
    record[storageKey] = link;
}
function getActorLinkedRecordID(record, storageKey) {
    var link = record[storageKey];
    if (link == null) {
        return link;
    }
    !(typeof link === 'object' && typeof link[REF_KEY] === 'string' && link[ACTOR_IDENTIFIER_KEY] != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getActorLinkedRecordID(): Expected `%s.%s` to be an actor specific linked ID, ' + 'was `%s`.', record[ID_KEY], storageKey, JSON.stringify(link)) : "TURBOPACK unreachable" : void 0;
    return [
        link[ACTOR_IDENTIFIER_KEY],
        link[REF_KEY]
    ];
}
function getResolverLinkedRecordID(record, typeName) {
    var id = getValue(record, RELAY_RESOLVER_VALUE_KEY);
    if (id == null || isSuspenseSentinel(id)) {
        return null;
    }
    if (typeof id === 'object') {
        id = id.id;
    }
    !(typeof id === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getResolverLinkedRecordID(): Expected value to be a linked ID, ' + 'was `%s`.', JSON.stringify(id)) : "TURBOPACK unreachable" : void 0;
    return generateClientObjectClientID(typeName, id);
}
function getResolverLinkedRecordIDs(record, typeName) {
    var resolverValue = getValue(record, RELAY_RESOLVER_VALUE_KEY);
    if (resolverValue == null || isSuspenseSentinel(resolverValue)) {
        return null;
    }
    !Array.isArray(resolverValue) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getResolverLinkedRecordIDs(): Expected value to be an array of linked IDs, ' + 'was `%s`.', JSON.stringify(resolverValue)) : "TURBOPACK unreachable" : void 0;
    return resolverValue.map(function(id) {
        if (id == null) {
            return null;
        }
        if (typeof id === 'object') {
            id = id.id;
        }
        !(typeof id === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernRecord.getResolverLinkedRecordIDs(): Expected item within resolver linked field to be a DataID, ' + 'was `%s`.', JSON.stringify(id)) : "TURBOPACK unreachable" : void 0;
        return generateClientObjectClientID(typeName, id);
    });
}
function toJSON(record) {
    return record;
}
module.exports = {
    clone: clone,
    copyFields: copyFields,
    create: create,
    freeze: freeze,
    fromObject: fromObject,
    getDataID: getDataID,
    getErrors: getErrors,
    getFields: getFields,
    getInvalidationEpoch: getInvalidationEpoch,
    getLinkedRecordID: getLinkedRecordID,
    getLinkedRecordIDs: getLinkedRecordIDs,
    getType: getType,
    getValue: getValue,
    hasValue: hasValue,
    hasLinkedRecordID: hasLinkedRecordID,
    hasLinkedRecordIDs: hasLinkedRecordIDs,
    merge: merge,
    setErrors: setErrors,
    setValue: setValue,
    setLinkedRecordID: setLinkedRecordID,
    setLinkedRecordIDs: setLinkedRecordIDs,
    update: update,
    getActorLinkedRecordID: getActorLinkedRecordID,
    setActorLinkedRecordID: setActorLinkedRecordID,
    getResolverLinkedRecordID: getResolverLinkedRecordID,
    getResolverLinkedRecordIDs: getResolverLinkedRecordIDs,
    toJSON: toJSON
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayRecordState.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayRecordState = {
    EXISTENT: 'EXISTENT',
    NONEXISTENT: 'NONEXISTENT',
    UNKNOWN: 'UNKNOWN'
};
module.exports = RelayRecordState;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)");
var RelayRecordState = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordState.js [app-rsc] (ecmascript)");
var EXISTENT = RelayRecordState.EXISTENT, NONEXISTENT = RelayRecordState.NONEXISTENT, UNKNOWN = RelayRecordState.UNKNOWN;
var RelayRecordSource = /*#__PURE__*/ function() {
    function RelayRecordSource(records) {
        var _this = this;
        this._records = new Map();
        if (records != null) {
            Object.keys(records).forEach(function(key) {
                var object = records[key];
                var record = RelayModernRecord.fromObject(object);
                _this._records.set(key, record);
            });
        }
    }
    RelayRecordSource.create = function create(records) {
        return new RelayRecordSource(records);
    };
    var _proto = RelayRecordSource.prototype;
    _proto.clear = function clear() {
        this._records = new Map();
    };
    _proto["delete"] = function _delete(dataID) {
        this._records.set(dataID, null);
    };
    _proto.get = function get(dataID) {
        return this._records.get(dataID);
    };
    _proto.getRecordIDs = function getRecordIDs() {
        return Array.from(this._records.keys());
    };
    _proto.getStatus = function getStatus(dataID) {
        if (!this._records.has(dataID)) {
            return UNKNOWN;
        }
        return this._records.get(dataID) == null ? NONEXISTENT : EXISTENT;
    };
    _proto.has = function has(dataID) {
        return this._records.has(dataID);
    };
    _proto.remove = function remove(dataID) {
        this._records["delete"](dataID);
    };
    _proto.set = function set(dataID, record) {
        this._records.set(dataID, record);
    };
    _proto.size = function size() {
        return this._records.size;
    };
    _proto.toJSON = function toJSON() {
        var obj = {};
        var _iterator = (0, _createForOfIteratorHelper2["default"])(this._records), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var _step$value = _step.value, key = _step$value[0], record = _step$value[1];
                obj[key] = RelayModernRecord.toJSON(record);
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        return obj;
    };
    return RelayRecordSource;
}();
module.exports = RelayRecordSource;
}),
"[project]/node_modules/relay-runtime/lib/multi-actor-environment/ActorIdentifier.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE = 'INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE';
function assertInternalActorIdentifier(actorIdentifier) {
    !(actorIdentifier === INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected to use only internal version of the `actorIdentifier`. "%s" was provided.', actorIdentifier) : "TURBOPACK unreachable" : void 0;
}
module.exports = {
    assertInternalActorIdentifier: assertInternalActorIdentifier,
    getActorIdentifier: function getActorIdentifier(actorID) {
        return actorID;
    },
    getDefaultActorIdentifier: function getDefaultActorIdentifier() {
        throw new Error('Not Implemented');
    },
    INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE: INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE
};
}),
"[project]/node_modules/relay-runtime/lib/multi-actor-environment/ActorUtils.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ACTOR_IDENTIFIER_FIELD_NAME = 'actor_key';
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/multi-actor-environment/ActorIdentifier.js [app-rsc] (ecmascript)"), getActorIdentifier = _require.getActorIdentifier;
function getActorIdentifierFromPayload(payload) {
    if (payload != null && typeof payload === 'object' && typeof payload[ACTOR_IDENTIFIER_FIELD_NAME] === 'string') {
        return getActorIdentifier(payload[ACTOR_IDENTIFIER_FIELD_NAME]);
    }
}
module.exports = {
    ACTOR_IDENTIFIER_FIELD_NAME: ACTOR_IDENTIFIER_FIELD_NAME,
    getActorIdentifierFromPayload: getActorIdentifierFromPayload
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayErrorTrie.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js [app-rsc] (ecmascript)"));
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-rsc] (ecmascript)"));
var _excluded = [
    "path",
    "locations"
];
var SELF = Symbol('$SELF');
function buildErrorTrie(errors) {
    if (errors == null) {
        return null;
    }
    var trie = new Map();
    var _iterator = (0, _createForOfIteratorHelper2["default"])(errors), _step;
    try {
        ERRORS: for(_iterator.s(); !(_step = _iterator.n()).done;){
            var _step$value = _step.value, path = _step$value.path, _ = _step$value.locations, error = (0, _objectWithoutPropertiesLoose2["default"])(_step$value, _excluded);
            if (path == null) {
                continue;
            }
            var length = path.length;
            if (length === 0) {
                continue;
            }
            var lastIndex = length - 1;
            var currentTrie = trie;
            for(var index = 0; index < lastIndex; index++){
                var key = path[index];
                var existingValue = currentTrie.get(key);
                if (existingValue instanceof Map) {
                    currentTrie = existingValue;
                    continue;
                }
                var newValue = new Map();
                if (Array.isArray(existingValue)) {
                    newValue.set(SELF, existingValue);
                }
                currentTrie.set(key, newValue);
                currentTrie = newValue;
            }
            var lastKey = path[lastIndex];
            var container = currentTrie.get(lastKey);
            if (container instanceof Map) {
                currentTrie = container;
                container = currentTrie.get(lastKey);
                lastKey = SELF;
            }
            if (Array.isArray(container)) {
                container.push(error);
            } else {
                currentTrie.set(lastKey, [
                    error
                ]);
            }
        }
    } catch (err) {
        _iterator.e(err);
    } finally{
        _iterator.f();
    }
    return trie;
}
function getErrorsByKey(trie, key) {
    var value = trie.get(key);
    if (value == null) {
        return null;
    }
    if (Array.isArray(value)) {
        return value;
    }
    var errors = [];
    recursivelyCopyErrorsIntoArray(value, errors);
    return errors;
}
function recursivelyCopyErrorsIntoArray(trieOrSet, errors) {
    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(trieOrSet), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var _step2$value = _step2.value, childKey = _step2$value[0], value = _step2$value[1];
            var oldLength = errors.length;
            if (Array.isArray(value)) {
                errors.push.apply(errors, (0, _toConsumableArray2["default"])(value));
            } else {
                recursivelyCopyErrorsIntoArray(value, errors);
            }
            if (childKey === SELF) {
                continue;
            }
            var newLength = errors.length;
            for(var index = oldLength; index < newLength; index++){
                var error = errors[index];
                if (error.path == null) {
                    errors[index] = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, error), {}, {
                        path: [
                            childKey
                        ]
                    });
                } else {
                    error.path.unshift(childKey);
                }
            }
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
}
function getNestedErrorTrieByKey(trie, key) {
    var value = trie.get(key);
    if (value instanceof Map) {
        return value;
    }
    return null;
}
module.exports = {
    SELF: SELF,
    buildErrorTrie: buildErrorTrie,
    getNestedErrorTrieByKey: getNestedErrorTrieByKey,
    getErrorsByKey: getErrorsByKey
};
}),
"[project]/node_modules/relay-runtime/lib/store/TypeID.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var PREFIX = 'client:__type:';
var TYPE_SCHEMA_TYPE = '__TypeSchema';
function generateTypeID(typeName) {
    return PREFIX + typeName;
}
function isTypeID(id) {
    return id.indexOf(PREFIX) === 0;
}
module.exports = {
    generateTypeID: generateTypeID,
    isTypeID: isTypeID,
    TYPE_SCHEMA_TYPE: TYPE_SCHEMA_TYPE
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayResponseNormalizer.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/multi-actor-environment/ActorUtils.js [app-rsc] (ecmascript)"), ACTOR_IDENTIFIER_FIELD_NAME = _require.ACTOR_IDENTIFIER_FIELD_NAME, getActorIdentifierFromPayload = _require.getActorIdentifierFromPayload;
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-rsc] (ecmascript)"), generateClientID = _require2.generateClientID, isClientID = _require2.isClientID;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-rsc] (ecmascript)"), getLocalVariables = _require3.getLocalVariables;
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayErrorTrie.js [app-rsc] (ecmascript)"), buildErrorTrie = _require4.buildErrorTrie, getErrorsByKey = _require4.getErrorsByKey, getNestedErrorTrieByKey = _require4.getNestedErrorTrieByKey;
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)");
var _require5 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-rsc] (ecmascript)"), createNormalizationSelector = _require5.createNormalizationSelector;
var _require6 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), ROOT_ID = _require6.ROOT_ID, TYPENAME_KEY = _require6.TYPENAME_KEY, getArgumentValues = _require6.getArgumentValues, getHandleStorageKey = _require6.getHandleStorageKey, getModuleComponentKey = _require6.getModuleComponentKey, getModuleOperationKey = _require6.getModuleOperationKey, getStorageKey = _require6.getStorageKey;
var _require7 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/TypeID.js [app-rsc] (ecmascript)"), TYPE_SCHEMA_TYPE = _require7.TYPE_SCHEMA_TYPE, generateTypeID = _require7.generateTypeID;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function normalize(recordSource, selector, response, options, errors, useExecTimeResolvers) {
    var dataID = selector.dataID, node = selector.node, variables = selector.variables;
    var normalizer = new RelayResponseNormalizer(recordSource, variables, options, useExecTimeResolvers !== null && useExecTimeResolvers !== void 0 ? useExecTimeResolvers : false);
    return normalizer.normalizeResponse(node, dataID, response, errors);
}
var RelayResponseNormalizer = /*#__PURE__*/ function() {
    function RelayResponseNormalizer(recordSource, variables, options, useExecTimeResolvers) {
        this._actorIdentifier = options.actorIdentifier;
        this._getDataId = options.getDataID;
        this._handleFieldPayloads = [];
        this._treatMissingFieldsAsNull = options.treatMissingFieldsAsNull;
        this._incrementalPlaceholders = [];
        this._isClientExtension = false;
        this._isUnmatchedAbstractType = false;
        this._useExecTimeResolvers = useExecTimeResolvers;
        this._followupPayloads = [];
        this._path = options.path ? (0, _toConsumableArray2["default"])(options.path) : [];
        this._recordSource = recordSource;
        this._variables = variables;
        this._shouldProcessClientComponents = options.shouldProcessClientComponents;
        this._log = options.log;
    }
    var _proto = RelayResponseNormalizer.prototype;
    _proto.normalizeResponse = function normalizeResponse(node, dataID, data, errors) {
        var record = this._recordSource.get(dataID);
        !record ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer(): Expected root record `%s` to exist.', dataID) : "TURBOPACK unreachable" : void 0;
        this._assignClientAbstractTypes(node);
        this._errorTrie = buildErrorTrie(errors);
        this._traverseSelections(node, record, data);
        return {
            errors: errors,
            fieldPayloads: this._handleFieldPayloads,
            incrementalPlaceholders: this._incrementalPlaceholders,
            followupPayloads: this._followupPayloads,
            source: this._recordSource,
            isFinal: false
        };
    };
    _proto._assignClientAbstractTypes = function _assignClientAbstractTypes(node) {
        var clientAbstractTypes = node.clientAbstractTypes;
        if (clientAbstractTypes != null) {
            for(var _i = 0, _Object$keys = Object.keys(clientAbstractTypes); _i < _Object$keys.length; _i++){
                var abstractType = _Object$keys[_i];
                var _iterator = (0, _createForOfIteratorHelper2["default"])(clientAbstractTypes[abstractType]), _step;
                try {
                    for(_iterator.s(); !(_step = _iterator.n()).done;){
                        var concreteType = _step.value;
                        var typeID = generateTypeID(concreteType);
                        var typeRecord = this._recordSource.get(typeID);
                        if (typeRecord == null) {
                            typeRecord = RelayModernRecord.create(typeID, TYPE_SCHEMA_TYPE);
                            this._recordSource.set(typeID, typeRecord);
                        }
                        RelayModernRecord.setValue(typeRecord, abstractType, true);
                    }
                } catch (err) {
                    _iterator.e(err);
                } finally{
                    _iterator.f();
                }
            }
        }
    };
    _proto._getVariableValue = function _getVariableValue(name) {
        !this._variables.hasOwnProperty(name) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer(): Undefined variable `%s`.', name) : "TURBOPACK unreachable" : void 0;
        return this._variables[name];
    };
    _proto._getRecordType = function _getRecordType(data) {
        var typeName = data[TYPENAME_KEY];
        !(typeName != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer(): Expected a typename for record `%s`.', JSON.stringify(data, null, 2)) : "TURBOPACK unreachable" : void 0;
        return typeName;
    };
    _proto._traverseSelections = function _traverseSelections(node, record, data) {
        for(var i = 0; i < node.selections.length; i++){
            var selection = node.selections[i];
            switch(selection.kind){
                case 'ScalarField':
                case 'LinkedField':
                    this._normalizeField(selection, record, data);
                    break;
                case 'Condition':
                    var conditionValue = Boolean(this._getVariableValue(selection.condition));
                    if (conditionValue === selection.passingValue) {
                        this._traverseSelections(selection, record, data);
                    }
                    break;
                case 'FragmentSpread':
                    {
                        var prevVariables = this._variables;
                        this._variables = getLocalVariables(this._variables, selection.fragment.argumentDefinitions, selection.args);
                        this._traverseSelections(selection.fragment, record, data);
                        this._variables = prevVariables;
                        break;
                    }
                case 'InlineFragment':
                    {
                        var abstractKey = selection.abstractKey;
                        if (abstractKey == null) {
                            var typeName = RelayModernRecord.getType(record);
                            if (typeName === selection.type) {
                                this._traverseSelections(selection, record, data);
                            }
                        } else {
                            var implementsInterface = Object.prototype.hasOwnProperty.call(data, abstractKey);
                            var _typeName = RelayModernRecord.getType(record);
                            var typeID = generateTypeID(_typeName);
                            var typeRecord = this._recordSource.get(typeID);
                            if (typeRecord == null) {
                                typeRecord = RelayModernRecord.create(typeID, TYPE_SCHEMA_TYPE);
                                this._recordSource.set(typeID, typeRecord);
                            }
                            RelayModernRecord.setValue(typeRecord, abstractKey, implementsInterface);
                            if (implementsInterface) {
                                this._traverseSelections(selection, record, data);
                            }
                        }
                        break;
                    }
                case 'TypeDiscriminator':
                    {
                        var _abstractKey = selection.abstractKey;
                        var _implementsInterface = Object.prototype.hasOwnProperty.call(data, _abstractKey);
                        var _typeName2 = RelayModernRecord.getType(record);
                        var _typeID = generateTypeID(_typeName2);
                        var _typeRecord = this._recordSource.get(_typeID);
                        if (_typeRecord == null) {
                            _typeRecord = RelayModernRecord.create(_typeID, TYPE_SCHEMA_TYPE);
                            this._recordSource.set(_typeID, _typeRecord);
                        }
                        RelayModernRecord.setValue(_typeRecord, _abstractKey, _implementsInterface);
                        break;
                    }
                case 'LinkedHandle':
                case 'ScalarHandle':
                    var args = selection.args ? getArgumentValues(selection.args, this._variables) : {};
                    var fieldKey = getStorageKey(selection, this._variables);
                    var handleKey = getHandleStorageKey(selection, this._variables);
                    this._handleFieldPayloads.push({
                        args: args,
                        dataID: RelayModernRecord.getDataID(record),
                        fieldKey: fieldKey,
                        handle: selection.handle,
                        handleKey: handleKey,
                        handleArgs: selection.handleArgs ? getArgumentValues(selection.handleArgs, this._variables) : {}
                    });
                    break;
                case 'ModuleImport':
                    this._normalizeModuleImport(selection, record, data);
                    break;
                case 'Defer':
                    this._normalizeDefer(selection, record, data);
                    break;
                case 'Stream':
                    this._normalizeStream(selection, record, data);
                    break;
                case 'ClientExtension':
                    var isClientExtension = this._isClientExtension;
                    this._isClientExtension = true;
                    this._traverseSelections(selection, record, data);
                    this._isClientExtension = isClientExtension;
                    break;
                case 'ClientComponent':
                    if (this._shouldProcessClientComponents === false) {
                        break;
                    }
                    this._traverseSelections(selection.fragment, record, data);
                    break;
                case 'ActorChange':
                    this._normalizeActorChange(selection, record, data);
                    break;
                case 'RelayResolver':
                case 'RelayLiveResolver':
                    if (!this._useExecTimeResolvers) {
                        this._normalizeResolver(selection, record, data);
                    }
                    break;
                case 'ClientEdgeToClientObject':
                    if (!this._useExecTimeResolvers) {
                        this._normalizeResolver(selection.backingField, record, data);
                    }
                    break;
                default:
                    selection;
                    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer(): Unexpected ast kind `%s`.', selection.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
        }
    };
    _proto._normalizeResolver = function _normalizeResolver(resolver, record, data) {
        if (resolver.fragment != null) {
            this._traverseSelections(resolver.fragment, record, data);
        }
    };
    _proto._normalizeDefer = function _normalizeDefer(defer, record, data) {
        var isDeferred = defer["if"] === null || this._getVariableValue(defer["if"]);
        if ("TURBOPACK compile-time truthy", 1) {
            ("TURBOPACK compile-time truthy", 1) ? warning(typeof isDeferred === 'boolean', 'RelayResponseNormalizer: Expected value for @defer `if` argument to ' + 'be a boolean, got `%s`.', isDeferred) : "TURBOPACK unreachable";
        }
        if (isDeferred === false) {
            this._traverseSelections(defer, record, data);
        } else {
            this._incrementalPlaceholders.push({
                kind: 'defer',
                data: data,
                label: defer.label,
                path: (0, _toConsumableArray2["default"])(this._path),
                selector: createNormalizationSelector(defer, RelayModernRecord.getDataID(record), this._variables),
                typeName: RelayModernRecord.getType(record),
                actorIdentifier: this._actorIdentifier
            });
        }
    };
    _proto._normalizeStream = function _normalizeStream(stream, record, data) {
        this._traverseSelections(stream, record, data);
        var isStreamed = stream["if"] === null || this._getVariableValue(stream["if"]);
        if ("TURBOPACK compile-time truthy", 1) {
            ("TURBOPACK compile-time truthy", 1) ? warning(typeof isStreamed === 'boolean', 'RelayResponseNormalizer: Expected value for @stream `if` argument ' + 'to be a boolean, got `%s`.', isStreamed) : "TURBOPACK unreachable";
        }
        if (isStreamed === true) {
            this._incrementalPlaceholders.push({
                kind: 'stream',
                label: stream.label,
                path: (0, _toConsumableArray2["default"])(this._path),
                parentID: RelayModernRecord.getDataID(record),
                node: stream,
                variables: this._variables,
                actorIdentifier: this._actorIdentifier
            });
        }
    };
    _proto._normalizeModuleImport = function _normalizeModuleImport(moduleImport, record, data) {
        !(typeof data === 'object' && data) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected data for @module to be an object.') : "TURBOPACK unreachable" : void 0;
        var typeName = RelayModernRecord.getType(record);
        var componentKey = getModuleComponentKey(moduleImport.documentName);
        var componentReference = moduleImport.componentModuleProvider || data[componentKey];
        RelayModernRecord.setValue(record, componentKey, componentReference !== null && componentReference !== void 0 ? componentReference : null);
        var operationKey = getModuleOperationKey(moduleImport.documentName);
        var operationReference = moduleImport.operationModuleProvider || data[operationKey];
        RelayModernRecord.setValue(record, operationKey, operationReference !== null && operationReference !== void 0 ? operationReference : null);
        if (operationReference != null) {
            this._followupPayloads.push({
                kind: 'ModuleImportPayload',
                args: moduleImport.args,
                data: data,
                dataID: RelayModernRecord.getDataID(record),
                operationReference: operationReference,
                path: (0, _toConsumableArray2["default"])(this._path),
                typeName: typeName,
                variables: this._variables,
                actorIdentifier: this._actorIdentifier
            });
        }
    };
    _proto._normalizeField = function _normalizeField(selection, record, data) {
        !(typeof data === 'object' && data) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'writeField(): Expected data for field `%s` to be an object.', selection.name) : "TURBOPACK unreachable" : void 0;
        var responseKey = selection.alias || selection.name;
        var storageKey = getStorageKey(selection, this._variables);
        var fieldValue = data[responseKey];
        var isNoncompliantlyNullish = RelayFeatureFlags.ENABLE_NONCOMPLIANT_ERROR_HANDLING_ON_LISTS && Array.isArray(fieldValue) && fieldValue.length === 0;
        if (fieldValue == null || isNoncompliantlyNullish) {
            if (fieldValue === undefined) {
                var isOptionalField = this._isClientExtension || this._isUnmatchedAbstractType;
                if (isOptionalField) {
                    return;
                } else if (!this._treatMissingFieldsAsNull) {
                    if ("TURBOPACK compile-time truthy", 1) {
                        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayResponseNormalizer: Payload did not contain a value ' + 'for field `%s: %s`. Check that you are parsing with the same ' + 'query that was used to fetch the payload.', responseKey, storageKey) : "TURBOPACK unreachable";
                    }
                    return;
                }
            }
            if (selection.kind === 'ScalarField') {
                this._validateConflictingFieldsWithIdenticalId(record, storageKey, null);
            }
            if (isNoncompliantlyNullish) {
                if (selection.kind === 'LinkedField') {
                    RelayModernRecord.setLinkedRecordIDs(record, storageKey, []);
                } else {
                    RelayModernRecord.setValue(record, storageKey, []);
                }
            } else {
                RelayModernRecord.setValue(record, storageKey, null);
            }
            var errorTrie = this._errorTrie;
            if (errorTrie != null) {
                var errors = getErrorsByKey(errorTrie, responseKey);
                if (errors != null) {
                    RelayModernRecord.setErrors(record, storageKey, errors);
                }
            }
            return;
        }
        if (selection.kind === 'ScalarField') {
            this._validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue);
            RelayModernRecord.setValue(record, storageKey, fieldValue);
        } else if (selection.kind === 'LinkedField') {
            this._path.push(responseKey);
            var oldErrorTrie = this._errorTrie;
            this._errorTrie = oldErrorTrie == null ? null : getNestedErrorTrieByKey(oldErrorTrie, responseKey);
            if (selection.plural) {
                this._normalizePluralLink(selection, record, storageKey, fieldValue);
            } else {
                this._normalizeLink(selection, record, storageKey, fieldValue);
            }
            this._errorTrie = oldErrorTrie;
            this._path.pop();
        } else {
            selection;
            ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer(): Unexpected ast kind `%s` during normalization.', selection.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
    };
    _proto._normalizeActorChange = function _normalizeActorChange(selection, record, data) {
        var _field$concreteType;
        var field = selection.linkedField;
        !(typeof data === 'object' && data) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '_normalizeActorChange(): Expected data for field `%s` to be an object.', field.name) : "TURBOPACK unreachable" : void 0;
        var responseKey = field.alias || field.name;
        var storageKey = getStorageKey(field, this._variables);
        var fieldValue = data[responseKey];
        if (fieldValue == null) {
            if (fieldValue === undefined) {
                var isOptionalField = this._isClientExtension || this._isUnmatchedAbstractType;
                if (isOptionalField) {
                    return;
                } else if (!this._treatMissingFieldsAsNull) {
                    if ("TURBOPACK compile-time truthy", 1) {
                        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayResponseNormalizer: Payload did not contain a value ' + 'for field `%s: %s`. Check that you are parsing with the same ' + 'query that was used to fetch the payload.', responseKey, storageKey) : "TURBOPACK unreachable";
                    }
                    return;
                }
            }
            RelayModernRecord.setValue(record, storageKey, null);
            return;
        }
        var actorIdentifier = getActorIdentifierFromPayload(fieldValue);
        if (actorIdentifier == null) {
            if ("TURBOPACK compile-time truthy", 1) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'RelayResponseNormalizer: Payload did not contain a value ' + 'for field `%s`. Check that you are parsing with the same ' + 'query that was used to fetch the payload. Payload is `%s`.', ACTOR_IDENTIFIER_FIELD_NAME, JSON.stringify(fieldValue, null, 2)) : "TURBOPACK unreachable";
            }
            RelayModernRecord.setValue(record, storageKey, null);
            return;
        }
        var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : this._getRecordType(fieldValue);
        var nextID = this._getDataId(fieldValue, typeName) || RelayModernRecord.getLinkedRecordID(record, storageKey) || generateClientID(RelayModernRecord.getDataID(record), storageKey);
        !(typeof nextID === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected id on field `%s` to be a string.', storageKey) : "TURBOPACK unreachable" : void 0;
        RelayModernRecord.setActorLinkedRecordID(record, storageKey, actorIdentifier, nextID);
        this._followupPayloads.push({
            kind: 'ActorPayload',
            data: fieldValue,
            dataID: nextID,
            path: [].concat((0, _toConsumableArray2["default"])(this._path), [
                responseKey
            ]),
            typeName: typeName,
            variables: this._variables,
            node: field,
            actorIdentifier: actorIdentifier
        });
    };
    _proto._normalizeLink = function _normalizeLink(field, record, storageKey, fieldValue) {
        var _field$concreteType2;
        !(typeof fieldValue === 'object' && fieldValue) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected data for field `%s` to be an object.', storageKey) : "TURBOPACK unreachable" : void 0;
        var nextID = this._getDataId(fieldValue, (_field$concreteType2 = field.concreteType) !== null && _field$concreteType2 !== void 0 ? _field$concreteType2 : this._getRecordType(fieldValue)) || RelayModernRecord.getLinkedRecordID(record, storageKey) || generateClientID(RelayModernRecord.getDataID(record), storageKey);
        !(typeof nextID === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected id on field `%s` to be a string.', storageKey) : "TURBOPACK unreachable" : void 0;
        this._validateConflictingLinkedFieldsWithIdenticalId(RelayModernRecord.getLinkedRecordID(record, storageKey), nextID, storageKey);
        RelayModernRecord.setLinkedRecordID(record, storageKey, nextID);
        var nextRecord = this._recordSource.get(nextID);
        if (!nextRecord) {
            var typeName = field.concreteType || this._getRecordType(fieldValue);
            nextRecord = RelayModernRecord.create(nextID, typeName);
            this._recordSource.set(nextID, nextRecord);
        } else {
            this._validateRecordType(nextRecord, field, fieldValue);
        }
        this._traverseSelections(field, nextRecord, fieldValue);
    };
    _proto._normalizePluralLink = function _normalizePluralLink(field, record, storageKey, fieldValue) {
        var _this = this;
        !Array.isArray(fieldValue) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected data for field `%s` to be an array ' + 'of objects.', storageKey) : "TURBOPACK unreachable" : void 0;
        var prevIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);
        var nextIDs = [];
        fieldValue.forEach(function(item, nextIndex) {
            var _field$concreteType3;
            if (item == null) {
                nextIDs.push(item);
                return;
            }
            _this._path.push(String(nextIndex));
            var oldErrorTrie = _this._errorTrie;
            _this._errorTrie = oldErrorTrie == null ? null : getNestedErrorTrieByKey(oldErrorTrie, nextIndex);
            !(typeof item === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected elements for field `%s` to be ' + 'objects.', storageKey) : "TURBOPACK unreachable" : void 0;
            var nextID = _this._getDataId(item, (_field$concreteType3 = field.concreteType) !== null && _field$concreteType3 !== void 0 ? _field$concreteType3 : _this._getRecordType(item)) || prevIDs && prevIDs[nextIndex] || generateClientID(RelayModernRecord.getDataID(record), storageKey, nextIndex);
            !(typeof nextID === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayResponseNormalizer: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : "TURBOPACK unreachable" : void 0;
            nextIDs.push(nextID);
            var nextRecord = _this._recordSource.get(nextID);
            if (!nextRecord) {
                var typeName = field.concreteType || _this._getRecordType(item);
                nextRecord = RelayModernRecord.create(nextID, typeName);
                _this._recordSource.set(nextID, nextRecord);
            } else {
                _this._validateRecordType(nextRecord, field, item);
            }
            if (prevIDs) {
                _this._validateConflictingLinkedFieldsWithIdenticalId(prevIDs[nextIndex], nextID, storageKey);
            }
            _this._traverseSelections(field, nextRecord, item);
            _this._errorTrie = oldErrorTrie;
            _this._path.pop();
        });
        RelayModernRecord.setLinkedRecordIDs(record, storageKey, nextIDs);
    };
    _proto._validateRecordType = function _validateRecordType(record, field, payload) {
        if (RelayFeatureFlags.ENABLE_STORE_ID_COLLISION_LOGGING) {
            var _field$concreteType4;
            var typeName = (_field$concreteType4 = field.concreteType) !== null && _field$concreteType4 !== void 0 ? _field$concreteType4 : this._getRecordType(payload);
            var dataID = RelayModernRecord.getDataID(record);
            var expected = isClientID(dataID) && dataID !== ROOT_ID || RelayModernRecord.getType(record) === typeName;
            if (!expected) {
                var logEvent = {
                    name: 'idCollision.typename',
                    previous_typename: RelayModernRecord.getType(record),
                    new_typename: typeName
                };
                if (this._log != null) {
                    this._log(logEvent);
                }
            }
        }
        if ("TURBOPACK compile-time truthy", 1) {
            var _field$concreteType5;
            var _typeName3 = (_field$concreteType5 = field.concreteType) !== null && _field$concreteType5 !== void 0 ? _field$concreteType5 : this._getRecordType(payload);
            var _dataID = RelayModernRecord.getDataID(record);
            var _expected = isClientID(_dataID) && _dataID !== ROOT_ID || RelayModernRecord.getType(record) === _typeName3;
            ("TURBOPACK compile-time truthy", 1) ? warning(_expected, 'RelayResponseNormalizer: Invalid record `%s`. Expected %s to be ' + 'consistent, but the record was assigned conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', _dataID, TYPENAME_KEY, RelayModernRecord.getType(record), _typeName3) : "TURBOPACK unreachable";
        }
    };
    _proto._validateConflictingFieldsWithIdenticalId = function _validateConflictingFieldsWithIdenticalId(record, storageKey, fieldValue) {
        if ("TURBOPACK compile-time truthy", 1) {
            var previousValue = RelayModernRecord.getValue(record, storageKey);
            var dataID = RelayModernRecord.getDataID(record);
            var expected = storageKey === TYPENAME_KEY || previousValue === undefined || areEqual(previousValue, fieldValue);
            ("TURBOPACK compile-time truthy", 1) ? warning(expected, 'RelayResponseNormalizer: Invalid record. The record contains two ' + 'instances of the same id: `%s` with conflicting field, %s and its values: %s and %s. ' + 'If two fields are different but share ' + 'the same id, one field will overwrite the other.', dataID, storageKey, previousValue, fieldValue) : "TURBOPACK unreachable";
        }
    };
    _proto._validateConflictingLinkedFieldsWithIdenticalId = function _validateConflictingLinkedFieldsWithIdenticalId(prevID, nextID, storageKey) {
        if ("TURBOPACK compile-time truthy", 1) {
            var expected = prevID === undefined || prevID === nextID;
            ("TURBOPACK compile-time truthy", 1) ? warning(expected, 'RelayResponseNormalizer: Invalid record. The record contains ' + 'references to the conflicting field, %s and its id values: %s and %s. ' + 'We need to make sure that the record the field points ' + 'to remains consistent or one field will overwrite the other.', storageKey, prevID, nextID) : "TURBOPACK unreachable";
        }
    };
    return RelayResponseNormalizer;
}();
module.exports = {
    normalize: normalize
};
}),
"[project]/node_modules/relay-runtime/lib/store/normalizeResponse.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _RelayModernRecord = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)"));
var _RelayRecordSource = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-rsc] (ecmascript)"));
var _RelayResponseNormalizer = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayResponseNormalizer.js [app-rsc] (ecmascript)"));
function normalizeResponse(response, selector, typeName, options, useExecTimeResolvers) {
    var _response$extensions;
    var data = response.data, errors = response.errors;
    var source = _RelayRecordSource["default"].create();
    var record = _RelayModernRecord["default"].create(selector.dataID, typeName);
    source.set(selector.dataID, record);
    var relayPayload = _RelayResponseNormalizer["default"].normalize(source, selector, data, options, errors, useExecTimeResolvers);
    return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, relayPayload), {}, {
        isFinal: ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.is_final) === true
    });
}
module.exports = normalizeResponse;
}),
"[project]/node_modules/relay-runtime/lib/store/readInlineData.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-rsc] (ecmascript)"), getInlineDataFragment = _require.getInlineDataFragment;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), FRAGMENTS_KEY = _require2.FRAGMENTS_KEY;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function readInlineData(fragment, fragmentRef) {
    var _fragmentRef$FRAGMENT;
    var inlineDataFragment = getInlineDataFragment(fragment);
    if (fragmentRef == null) {
        return fragmentRef;
    }
    !(typeof fragmentRef === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'readInlineData(): Expected an object, got `%s`.', typeof fragmentRef) : "TURBOPACK unreachable" : void 0;
    var inlineData = (_fragmentRef$FRAGMENT = fragmentRef[FRAGMENTS_KEY]) === null || _fragmentRef$FRAGMENT === void 0 ? void 0 : _fragmentRef$FRAGMENT[inlineDataFragment.name];
    !(inlineData != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'readInlineData(): Expected fragment `%s` to be spread in the parent ' + 'fragment.', inlineDataFragment.name) : "TURBOPACK unreachable" : void 0;
    return inlineData;
}
module.exports = readInlineData;
}),
"[project]/node_modules/relay-runtime/lib/util/generateID.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var id = 100000;
function generateID() {
    return id++;
}
module.exports = generateID;
}),
"[project]/node_modules/relay-runtime/lib/network/wrapNetworkWithLogObserver.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var generateID = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/generateID.js [app-rsc] (ecmascript)");
function wrapNetworkWithLogObserver(env, network) {
    return {
        execute: function execute(params, variables, cacheConfig, uploadables, _, encryptedVariables, preprocessResponse, checkOperation) {
            var networkRequestId = generateID();
            var logObserver = {
                start: function start(subscription) {
                    env.__log({
                        name: 'network.start',
                        networkRequestId: networkRequestId,
                        params: params,
                        variables: variables,
                        cacheConfig: cacheConfig
                    });
                },
                next: function next(response) {
                    env.__log({
                        name: 'network.next',
                        networkRequestId: networkRequestId,
                        response: response
                    });
                },
                error: function error(_error) {
                    env.__log({
                        name: 'network.error',
                        networkRequestId: networkRequestId,
                        error: _error
                    });
                },
                complete: function complete() {
                    env.__log({
                        name: 'network.complete',
                        networkRequestId: networkRequestId
                    });
                },
                unsubscribe: function unsubscribe() {
                    env.__log({
                        name: 'network.unsubscribe',
                        networkRequestId: networkRequestId
                    });
                }
            };
            var logRequestInfo = function logRequestInfo(info) {
                env.__log({
                    name: 'network.info',
                    networkRequestId: networkRequestId,
                    info: info
                });
            };
            return network.execute(params, variables, cacheConfig, uploadables, logRequestInfo, encryptedVariables, preprocessResponse, checkOperation)["do"](logObserver);
        }
    };
}
module.exports = wrapNetworkWithLogObserver;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayOperationTracker.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var RelayOperationTracker = /*#__PURE__*/ function() {
    function RelayOperationTracker() {
        this._ownersToPendingOperations = new Map();
        this._pendingOperationsToOwners = new Map();
        this._ownersToPendingPromise = new Map();
    }
    var _proto = RelayOperationTracker.prototype;
    _proto.update = function update(pendingOperation, affectedOwners) {
        if (affectedOwners.size === 0) {
            return;
        }
        var pendingOperationIdentifier = pendingOperation.identifier;
        var newlyAffectedOwnersIdentifier = new Set();
        var _iterator = (0, _createForOfIteratorHelper2["default"])(affectedOwners), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var owner = _step.value;
                var ownerIdentifier = owner.identifier;
                var pendingOperationsAffectingOwner = this._ownersToPendingOperations.get(ownerIdentifier);
                if (pendingOperationsAffectingOwner != null) {
                    if (!pendingOperationsAffectingOwner.has(pendingOperationIdentifier)) {
                        pendingOperationsAffectingOwner.set(pendingOperationIdentifier, pendingOperation);
                        newlyAffectedOwnersIdentifier.add(ownerIdentifier);
                    }
                } else {
                    this._ownersToPendingOperations.set(ownerIdentifier, new Map([
                        [
                            pendingOperationIdentifier,
                            pendingOperation
                        ]
                    ]));
                    newlyAffectedOwnersIdentifier.add(ownerIdentifier);
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        if (newlyAffectedOwnersIdentifier.size === 0) {
            return;
        }
        var ownersAffectedByPendingOperation = this._pendingOperationsToOwners.get(pendingOperationIdentifier) || new Set();
        var _iterator2 = (0, _createForOfIteratorHelper2["default"])(newlyAffectedOwnersIdentifier), _step2;
        try {
            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                var _ownerIdentifier = _step2.value;
                this._resolveOwnerResolvers(_ownerIdentifier);
                ownersAffectedByPendingOperation.add(_ownerIdentifier);
            }
        } catch (err) {
            _iterator2.e(err);
        } finally{
            _iterator2.f();
        }
        this._pendingOperationsToOwners.set(pendingOperationIdentifier, ownersAffectedByPendingOperation);
    };
    _proto.complete = function complete(pendingOperation) {
        var pendingOperationIdentifier = pendingOperation.identifier;
        var affectedOwnersIdentifier = this._pendingOperationsToOwners.get(pendingOperationIdentifier);
        if (affectedOwnersIdentifier == null) {
            return;
        }
        var completedOwnersIdentifier = new Set();
        var updatedOwnersIdentifier = new Set();
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(affectedOwnersIdentifier), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var ownerIdentifier = _step3.value;
                var pendingOperationsAffectingOwner = this._ownersToPendingOperations.get(ownerIdentifier);
                if (!pendingOperationsAffectingOwner) {
                    continue;
                }
                pendingOperationsAffectingOwner["delete"](pendingOperationIdentifier);
                if (pendingOperationsAffectingOwner.size > 0) {
                    updatedOwnersIdentifier.add(ownerIdentifier);
                } else {
                    completedOwnersIdentifier.add(ownerIdentifier);
                }
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
        var _iterator4 = (0, _createForOfIteratorHelper2["default"])(completedOwnersIdentifier), _step4;
        try {
            for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                var _ownerIdentifier2 = _step4.value;
                this._resolveOwnerResolvers(_ownerIdentifier2);
                this._ownersToPendingOperations["delete"](_ownerIdentifier2);
            }
        } catch (err) {
            _iterator4.e(err);
        } finally{
            _iterator4.f();
        }
        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(updatedOwnersIdentifier), _step5;
        try {
            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                var _ownerIdentifier3 = _step5.value;
                this._resolveOwnerResolvers(_ownerIdentifier3);
            }
        } catch (err) {
            _iterator5.e(err);
        } finally{
            _iterator5.f();
        }
        this._pendingOperationsToOwners["delete"](pendingOperationIdentifier);
    };
    _proto._resolveOwnerResolvers = function _resolveOwnerResolvers(ownerIdentifier) {
        var promiseEntry = this._ownersToPendingPromise.get(ownerIdentifier);
        if (promiseEntry != null) {
            promiseEntry.resolve();
        }
        this._ownersToPendingPromise["delete"](ownerIdentifier);
    };
    _proto.getPendingOperationsAffectingOwner = function getPendingOperationsAffectingOwner(owner) {
        var ownerIdentifier = owner.identifier;
        var pendingOperationsForOwner = this._ownersToPendingOperations.get(ownerIdentifier);
        if (pendingOperationsForOwner == null || pendingOperationsForOwner.size === 0) {
            return null;
        }
        var cachedPromiseEntry = this._ownersToPendingPromise.get(ownerIdentifier);
        if (cachedPromiseEntry != null) {
            return {
                promise: cachedPromiseEntry.promise,
                pendingOperations: cachedPromiseEntry.pendingOperations
            };
        }
        var resolve;
        var promise = new Promise(function(r) {
            resolve = r;
        });
        !(resolve != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayOperationTracker: Expected resolver to be defined. If you' + 'are seeing this, it is likely a bug in Relay.') : "TURBOPACK unreachable" : void 0;
        var pendingOperations = Array.from(pendingOperationsForOwner.values());
        this._ownersToPendingPromise.set(ownerIdentifier, {
            promise: promise,
            resolve: resolve,
            pendingOperations: pendingOperations
        });
        return {
            promise: promise,
            pendingOperations: pendingOperations
        };
    };
    return RelayOperationTracker;
}();
module.exports = RelayOperationTracker;
}),
"[project]/node_modules/relay-runtime/lib/util/registerEnvironmentWithDevTools.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function registerEnvironmentWithDevTools(environment) {
    var _global = ("TURBOPACK compile-time truthy", 1) ? /*TURBOPACK member replacement*/ __turbopack_context__.g : "TURBOPACK unreachable";
    var devToolsHook = _global && _global.__RELAY_DEVTOOLS_HOOK__;
    if (devToolsHook) {
        devToolsHook.registerEnvironment(environment);
    }
}
module.exports = registerEnvironmentWithDevTools;
}),
"[project]/node_modules/relay-runtime/lib/store/ViewerPattern.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-rsc] (ecmascript)"), generateClientID = _require.generateClientID;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), ROOT_ID = _require2.ROOT_ID;
var VIEWER_ID = generateClientID(ROOT_ID, 'viewer');
var VIEWER_TYPE = 'Viewer';
module.exports = {
    VIEWER_ID: VIEWER_ID,
    VIEWER_TYPE: VIEWER_TYPE
};
}),
"[project]/node_modules/relay-runtime/lib/store/defaultGetDataID.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ViewerPattern.js [app-rsc] (ecmascript)"), VIEWER_ID = _require.VIEWER_ID, VIEWER_TYPE = _require.VIEWER_TYPE;
function defaultGetDataID(fieldValue, typeName) {
    if (typeName === VIEWER_TYPE) {
        return fieldValue.id == null ? VIEWER_ID : fieldValue.id;
    }
    return fieldValue.id;
}
module.exports = defaultGetDataID;
}),
"[project]/node_modules/relay-runtime/lib/store/defaultRelayFieldLogger.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var defaultRelayFieldLogger = function defaultRelayFieldLogger(event) {
    if (("TURBOPACK compile-time value", "development") !== "production" && event.kind === 'missing_required_field.log') {
        throw new Error('Relay Environment Configuration Error (dev only): `@required(action: LOG)` requires that the Relay Environment be configured with a `relayFieldLogger`.');
    }
};
module.exports = defaultRelayFieldLogger;
}),
"[project]/node_modules/relay-runtime/lib/util/getOperation.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-rsc] (ecmascript)"), REQUEST = _require.REQUEST, SPLIT_OPERATION = _require.SPLIT_OPERATION;
function getOperation(node) {
    switch(node.kind){
        case REQUEST:
            return node.operation;
        case SPLIT_OPERATION:
        default:
            return node;
    }
}
module.exports = getOperation;
}),
"[project]/node_modules/relay-runtime/lib/util/RelayError.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function createError(type, name, messageFormat) {
    for(var _len = arguments.length, messageParams = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
        messageParams[_key - 3] = arguments[_key];
    }
    var index = 0;
    var message = messageFormat.replace(/%s/g, function() {
        return String(messageParams[index++]);
    });
    var err = new Error(message);
    var error = Object.assign(err, {
        name: name,
        messageFormat: messageFormat,
        messageParams: messageParams,
        type: type,
        taalOpcodes: [
            2,
            2
        ]
    });
    if (error.stack === undefined) {
        try {
            throw error;
        } catch (_unused) {}
    }
    return error;
}
module.exports = {
    create: function create(name, messageFormat) {
        for(var _len2 = arguments.length, messageParams = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++){
            messageParams[_key2 - 2] = arguments[_key2];
        }
        return createError.apply(void 0, [
            'error',
            name,
            messageFormat
        ].concat(messageParams));
    },
    createWarning: function createWarning(name, messageFormat) {
        for(var _len3 = arguments.length, messageParams = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++){
            messageParams[_key3 - 2] = arguments[_key3];
        }
        return createError.apply(void 0, [
            'warn',
            name,
            messageFormat
        ].concat(messageParams));
    }
};
}),
"[project]/node_modules/relay-runtime/lib/util/withStartAndDuration.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _window, _window$performance;
var isPerformanceNowAvailable = ("TURBOPACK compile-time value", "undefined") !== 'undefined' && typeof ((_window = window) === null || _window === void 0 ? void 0 : (_window$performance = _window.performance) === null || _window$performance === void 0 ? void 0 : _window$performance.now) === 'function';
function currentTimestamp() {
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    return Date.now();
}
function withStartAndDuration(cb) {
    var startTime = currentTimestamp();
    var result = cb();
    return [
        startTime,
        currentTimestamp() - startTime,
        result
    ];
}
module.exports = withStartAndDuration;
}),
"[project]/node_modules/relay-runtime/lib/store/OperationExecutor.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-rsc] (ecmascript)"));
var RelayObservable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-rsc] (ecmascript)");
var generateID = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/generateID.js [app-rsc] (ecmascript)");
var getOperation = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getOperation.js [app-rsc] (ecmascript)");
var RelayError = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayError.js [app-rsc] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-rsc] (ecmascript)"), stableCopy = _require.stableCopy;
var withStartAndDuration = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/withStartAndDuration.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-rsc] (ecmascript)"), generateClientID = _require2.generateClientID, generateUniqueClientID = _require2.generateUniqueClientID;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-rsc] (ecmascript)"), getLocalVariables = _require3.getLocalVariables;
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)");
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-rsc] (ecmascript)"), createNormalizationSelector = _require4.createNormalizationSelector, createReaderSelector = _require4.createReaderSelector;
var RelayRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-rsc] (ecmascript)");
var _require5 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), ROOT_TYPE = _require5.ROOT_TYPE, TYPENAME_KEY = _require5.TYPENAME_KEY, getStorageKey = _require5.getStorageKey;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function execute(config) {
    return new Executor(config);
}
var Executor = /*#__PURE__*/ function() {
    function Executor(_ref3) {
        var _this = this;
        var _ref, _this$_operation$requ, _this$_operation$requ2;
        var actorIdentifier = _ref3.actorIdentifier, getDataID = _ref3.getDataID, getPublishQueue = _ref3.getPublishQueue, getStore = _ref3.getStore, isClientPayload = _ref3.isClientPayload, operation = _ref3.operation, operationExecutions = _ref3.operationExecutions, operationLoader = _ref3.operationLoader, operationTracker = _ref3.operationTracker, optimisticConfig = _ref3.optimisticConfig, scheduler = _ref3.scheduler, shouldProcessClientComponents = _ref3.shouldProcessClientComponents, sink = _ref3.sink, source = _ref3.source, treatMissingFieldsAsNull = _ref3.treatMissingFieldsAsNull, updater = _ref3.updater, log = _ref3.log, normalizeResponse = _ref3.normalizeResponse;
        this._actorIdentifier = actorIdentifier;
        this._getDataID = getDataID;
        this._treatMissingFieldsAsNull = treatMissingFieldsAsNull;
        this._incrementalPayloadsPending = false;
        this._incrementalResults = new Map();
        this._log = log;
        this._executeId = generateID();
        this._nextSubscriptionId = 0;
        this._operation = operation;
        this._operationExecutions = operationExecutions;
        this._operationLoader = operationLoader;
        this._operationTracker = operationTracker;
        this._operationUpdateEpochs = new Map();
        this._optimisticUpdates = null;
        this._useExecTimeResolvers = (_ref = (_this$_operation$requ = this._operation.request.node.operation.use_exec_time_resolvers) !== null && _this$_operation$requ !== void 0 ? _this$_operation$requ : ((_this$_operation$requ2 = this._operation.request.node.operation.exec_time_resolvers_enabled_provider) === null || _this$_operation$requ2 === void 0 ? void 0 : _this$_operation$requ2.get()) === true) !== null && _ref !== void 0 ? _ref : false;
        this._execTimeResolverResponseComplete = false;
        this._pendingModulePayloadsCount = 0;
        this._getPublishQueue = getPublishQueue;
        this._scheduler = scheduler;
        this._sink = sink;
        this._source = new Map();
        this._state = 'started';
        this._getStore = getStore;
        this._subscriptions = new Map();
        this._updater = updater;
        this._isClientPayload = isClientPayload === true;
        this._isSubscriptionOperation = this._operation.request.node.params.operationKind === 'subscription';
        this._shouldProcessClientComponents = shouldProcessClientComponents;
        this._retainDisposables = new Map();
        this._seenActors = new Set();
        this._completeFns = [];
        this._normalizeResponse = normalizeResponse;
        var id = this._nextSubscriptionId++;
        if (RelayFeatureFlags.PROCESS_OPTIMISTIC_UPDATE_BEFORE_SUBSCRIPTION && optimisticConfig != null) {
            this._processOptimisticResponse(optimisticConfig.response != null ? {
                data: optimisticConfig.response
            } : null, optimisticConfig.updater, false);
        }
        source.subscribe({
            complete: function complete() {
                return _this._complete(id);
            },
            error: function error(_error2) {
                return _this._error(_error2);
            },
            next: function next(response) {
                try {
                    _this._next(id, response);
                } catch (error) {
                    sink.error(error);
                }
            },
            start: function start(subscription) {
                var _this$_operation$requ3;
                _this._start(id, subscription);
                _this._log({
                    name: 'execute.start',
                    executeId: _this._executeId,
                    params: _this._operation.request.node.params,
                    variables: _this._operation.request.variables,
                    cacheConfig: (_this$_operation$requ3 = _this._operation.request.cacheConfig) !== null && _this$_operation$requ3 !== void 0 ? _this$_operation$requ3 : {}
                });
            },
            unsubscribe: function unsubscribe() {
                _this._log({
                    name: 'execute.unsubscribe',
                    executeId: _this._executeId
                });
            }
        });
        if (!RelayFeatureFlags.PROCESS_OPTIMISTIC_UPDATE_BEFORE_SUBSCRIPTION && optimisticConfig != null) {
            this._processOptimisticResponse(optimisticConfig.response != null ? {
                data: optimisticConfig.response
            } : null, optimisticConfig.updater, false);
        }
    }
    var _proto = Executor.prototype;
    _proto.cancel = function cancel() {
        var _this2 = this;
        if (this._state === 'completed') {
            return;
        }
        this._state = 'completed';
        this._operationExecutions["delete"](this._operation.request.identifier);
        if (this._subscriptions.size !== 0) {
            this._subscriptions.forEach(function(sub) {
                return sub.unsubscribe();
            });
            this._subscriptions.clear();
        }
        var optimisticUpdates = this._optimisticUpdates;
        if (optimisticUpdates !== null) {
            this._optimisticUpdates = null;
            optimisticUpdates.forEach(function(update) {
                return _this2._getPublishQueueAndSaveActor().revertUpdate(update);
            });
            this._runPublishQueue();
        }
        this._incrementalResults.clear();
        if (this._asyncStoreUpdateDisposable != null) {
            this._asyncStoreUpdateDisposable.dispose();
            this._asyncStoreUpdateDisposable = null;
        }
        this._completeFns = [];
        this._completeOperationTracker();
        this._disposeRetainedData();
    };
    _proto._updateActiveState = function _updateActiveState() {
        var activeState;
        switch(this._state){
            case 'started':
                {
                    activeState = 'active';
                    break;
                }
            case 'loading_incremental':
                {
                    activeState = 'active';
                    break;
                }
            case 'completed':
                {
                    activeState = 'inactive';
                    break;
                }
            case 'loading_final':
                {
                    activeState = this._pendingModulePayloadsCount > 0 || this._useExecTimeResolvers && !this._execTimeResolverResponseComplete ? 'active' : 'inactive';
                    break;
                }
            default:
                this._state;
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: invalid executor state.') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
        this._operationExecutions.set(this._operation.request.identifier, activeState);
    };
    _proto._schedule = function _schedule(task, priority) {
        var _this3 = this;
        var scheduler = this._scheduler;
        if (scheduler != null) {
            var id = this._nextSubscriptionId++;
            RelayObservable.create(function(sink) {
                var cancellationToken = scheduler.schedule(function() {
                    try {
                        task();
                        sink.complete();
                    } catch (error) {
                        sink.error(error);
                    }
                }, priority);
                return function() {
                    return scheduler.cancel(cancellationToken);
                };
            }).subscribe({
                complete: function complete() {
                    return _this3._complete(id);
                },
                error: function error(_error3) {
                    return _this3._error(_error3);
                },
                start: function start(subscription) {
                    return _this3._start(id, subscription);
                }
            });
        } else {
            task();
        }
    };
    _proto._complete = function _complete(id) {
        this._subscriptions["delete"](id);
        if (this._subscriptions.size === 0) {
            this.cancel();
            this._sink.complete();
            this._log({
                name: 'execute.complete',
                executeId: this._executeId
            });
        }
    };
    _proto._error = function _error(error) {
        this.cancel();
        this._sink.error(error);
        this._log({
            name: 'execute.error',
            executeId: this._executeId,
            error: error
        });
    };
    _proto._start = function _start(id, subscription) {
        this._subscriptions.set(id, subscription);
        this._updateActiveState();
    };
    _proto._next = function _next(_id, response) {
        var _this4 = this;
        var priority = this._state === 'loading_incremental' ? 'low' : 'default';
        this._schedule(function() {
            _this4._log({
                name: 'execute.next.start',
                executeId: _this4._executeId,
                response: response,
                operation: _this4._operation
            });
            _this4._handleNext(response);
            _this4._maybeCompleteSubscriptionOperationTracking();
            _this4._log({
                name: 'execute.next.end',
                executeId: _this4._executeId,
                response: response,
                operation: _this4._operation
            });
        }, priority);
    };
    _proto._handleErrorResponse = function _handleErrorResponse(responses) {
        var _this5 = this;
        var results = [];
        responses.forEach(function(response) {
            if (response.data === null && response.extensions != null && !response.hasOwnProperty('errors')) {
                return;
            } else if (response.data == null) {
                var errors = response.hasOwnProperty('errors') && response.errors != null ? response.errors : null;
                var messages = errors ? errors.map(function(_ref4) {
                    var message = _ref4.message;
                    return message;
                }).join('\n') : '(No errors)';
                var error = RelayError.create('RelayNetwork', 'No data returned for operation `' + _this5._operation.request.node.params.name + '`, got error(s):\n' + messages + '\n\nSee the error `source` property for more information.');
                error.source = {
                    errors: errors,
                    operation: _this5._operation.request.node,
                    variables: _this5._operation.request.variables
                };
                error.stack;
                throw error;
            } else {
                var responseWithData = response;
                results.push(responseWithData);
            }
        });
        return results;
    };
    _proto._handleOptimisticResponses = function _handleOptimisticResponses(responses) {
        var _response$extensions;
        if (responses.length > 1) {
            if (responses.some(function(responsePart) {
                var _responsePart$extensi;
                return ((_responsePart$extensi = responsePart.extensions) === null || _responsePart$extensi === void 0 ? void 0 : _responsePart$extensi.isOptimistic) === true;
            })) {
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Optimistic responses cannot be batched.') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
            return false;
        }
        var response = responses[0];
        var isOptimistic = ((_response$extensions = response.extensions) === null || _response$extensions === void 0 ? void 0 : _response$extensions.isOptimistic) === true;
        if (isOptimistic && this._state !== 'started') {
            ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: optimistic payload received after server payload.') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
        if (isOptimistic) {
            this._processOptimisticResponse(response, null, this._treatMissingFieldsAsNull);
            this._sink.next(response);
            return true;
        }
        return false;
    };
    _proto._handleNext = function _handleNext(response) {
        if (this._state === 'completed') {
            return;
        }
        this._seenActors.clear();
        var responses = Array.isArray(response) ? response : [
            response
        ];
        var responsesWithData = this._handleErrorResponse(responses);
        if (responsesWithData.length === 0) {
            var isFinal = responses.some(function(x) {
                var _x$extensions;
                return ((_x$extensions = x.extensions) === null || _x$extensions === void 0 ? void 0 : _x$extensions.is_final) === true;
            });
            if (isFinal) {
                this._state = 'loading_final';
                this._updateActiveState();
                this._incrementalPayloadsPending = false;
            }
            this._sink.next(response);
            return;
        }
        var isOptimistic = this._handleOptimisticResponses(responsesWithData);
        if (isOptimistic) {
            return;
        }
        var _partitionGraphQLResp = partitionGraphQLResponses(responsesWithData), nonIncrementalResponses = _partitionGraphQLResp[0], incrementalResponses = _partitionGraphQLResp[1], normalizedResponses = _partitionGraphQLResp[2];
        var hasNonIncrementalResponses = nonIncrementalResponses.length > 0;
        var hasNormalizedResponses = normalizedResponses.length > 0;
        if (hasNonIncrementalResponses) {
            if (this._isSubscriptionOperation) {
                var nextID = generateUniqueClientID();
                this._operation = {
                    request: this._operation.request,
                    fragment: createReaderSelector(this._operation.fragment.node, nextID, this._operation.fragment.variables, this._operation.fragment.owner),
                    root: createNormalizationSelector(this._operation.root.node, nextID, this._operation.root.variables)
                };
            }
            var payloadFollowups = this._processResponses(nonIncrementalResponses);
            this._processPayloadFollowups(payloadFollowups);
        }
        if (hasNormalizedResponses) {
            var _payloadFollowups = [];
            for(var i = 0; i < normalizedResponses.length; i++){
                var _response$extensions2;
                var _response = normalizedResponses[i];
                var source = new RelayRecordSource(_response.data);
                var isFinal = ((_response$extensions2 = _response.extensions) === null || _response$extensions2 === void 0 ? void 0 : _response$extensions2.is_final) === true;
                var payload = {
                    errors: [],
                    fieldPayloads: [],
                    followupPayloads: [],
                    incrementalPlaceholders: [],
                    isFinal: isFinal,
                    source: source
                };
                this._getPublishQueueAndSaveActor().commitPayload(this._operation, payload, this._updater);
                _payloadFollowups.push(payload);
                this._execTimeResolverResponseComplete = isFinal;
                if (isFinal) {
                    this._updateActiveState();
                }
            }
        }
        if (incrementalResponses.length > 0) {
            var _payloadFollowups2 = this._processIncrementalResponses(incrementalResponses);
            this._processPayloadFollowups(_payloadFollowups2);
        }
        if (this._isSubscriptionOperation) {
            if (responsesWithData[0].extensions == null) {
                responsesWithData[0].extensions = {
                    __relay_subscription_root_id: this._operation.fragment.dataID
                };
            } else {
                responsesWithData[0].extensions.__relay_subscription_root_id = this._operation.fragment.dataID;
            }
        }
        var updatedOwners = this._runPublishQueue(hasNonIncrementalResponses || hasNormalizedResponses ? this._operation : undefined);
        if (hasNonIncrementalResponses) {
            if (this._incrementalPayloadsPending) {
                this._retainData();
            }
        }
        this._updateOperationTracker(updatedOwners);
        this._sink.next(response);
    };
    _proto._processOptimisticResponse = function _processOptimisticResponse(response, updater, treatMissingFieldsAsNull) {
        var _this6 = this;
        !(this._optimisticUpdates === null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: environment.execute: only support one optimistic response per ' + 'execute.') : "TURBOPACK unreachable" : void 0;
        if (response == null && updater == null) {
            return;
        }
        var optimisticUpdates = [];
        if (response) {
            var payload = this._normalizeResponse(response, this._operation.root, ROOT_TYPE, {
                actorIdentifier: this._actorIdentifier,
                getDataID: this._getDataID,
                log: this._log,
                path: [],
                shouldProcessClientComponents: this._shouldProcessClientComponents,
                treatMissingFieldsAsNull: treatMissingFieldsAsNull
            }, this._useExecTimeResolvers);
            validateOptimisticResponsePayload(payload);
            optimisticUpdates.push({
                operation: this._operation,
                payload: payload,
                updater: updater
            });
            this._processOptimisticFollowups(payload, optimisticUpdates);
        } else if (updater) {
            optimisticUpdates.push({
                operation: this._operation,
                payload: {
                    errors: null,
                    fieldPayloads: null,
                    incrementalPlaceholders: null,
                    followupPayloads: null,
                    source: RelayRecordSource.create(),
                    isFinal: false
                },
                updater: updater
            });
        }
        this._optimisticUpdates = optimisticUpdates;
        optimisticUpdates.forEach(function(update) {
            return _this6._getPublishQueueAndSaveActor().applyUpdate(update);
        });
        var updatedOwners = this._runPublishQueue();
        if (RelayFeatureFlags.ENABLE_OPERATION_TRACKER_OPTIMISTIC_UPDATES) {
            this._updateOperationTracker(updatedOwners);
        }
    };
    _proto._processOptimisticFollowups = function _processOptimisticFollowups(payload, optimisticUpdates) {
        if (payload.followupPayloads && payload.followupPayloads.length) {
            var followupPayloads = payload.followupPayloads;
            var _iterator = (0, _createForOfIteratorHelper2["default"])(followupPayloads), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var followupPayload = _step.value;
                    switch(followupPayload.kind){
                        case 'ModuleImportPayload':
                            var operationLoader = this._expectOperationLoader();
                            var operation = operationLoader.get(followupPayload.operationReference);
                            if (operation == null) {
                                this._processAsyncOptimisticModuleImport(followupPayload);
                            } else {
                                var moduleImportOptimisticUpdates = this._processOptimisticModuleImport(operation, followupPayload);
                                optimisticUpdates.push.apply(optimisticUpdates, (0, _toConsumableArray2["default"])(moduleImportOptimisticUpdates));
                            }
                            break;
                        case 'ActorPayload':
                            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'OperationExecutor: Unexpected optimistic ActorPayload. These updates are not supported.') : "TURBOPACK unreachable";
                            break;
                        default:
                            followupPayload;
                            ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Unexpected followup kind `%s`. when processing optimistic updates.', followupPayload.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
                    }
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
        }
    };
    _proto._normalizeFollowupPayload = function _normalizeFollowupPayload(followupPayload, normalizationNode) {
        var variables;
        if (normalizationNode.kind === 'SplitOperation' && followupPayload.kind === 'ModuleImportPayload') {
            variables = getLocalVariables(followupPayload.variables, normalizationNode.argumentDefinitions, followupPayload.args);
        } else {
            variables = followupPayload.variables;
        }
        var selector = createNormalizationSelector(normalizationNode, followupPayload.dataID, variables);
        var nextResponse = {
            data: followupPayload.data,
            extensions: this._state === 'loading_final' ? {
                is_final: true
            } : undefined
        };
        return this._normalizeResponse(nextResponse, selector, followupPayload.typeName, {
            actorIdentifier: this._actorIdentifier,
            getDataID: this._getDataID,
            log: this._log,
            path: followupPayload.path,
            treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
            shouldProcessClientComponents: this._shouldProcessClientComponents
        }, this._useExecTimeResolvers);
    };
    _proto._processOptimisticModuleImport = function _processOptimisticModuleImport(normalizationRootNode, moduleImportPayload) {
        var operation = getOperation(normalizationRootNode);
        var optimisticUpdates = [];
        var modulePayload = this._normalizeFollowupPayload(moduleImportPayload, operation);
        validateOptimisticResponsePayload(modulePayload);
        optimisticUpdates.push({
            operation: this._operation,
            payload: modulePayload,
            updater: null
        });
        this._processOptimisticFollowups(modulePayload, optimisticUpdates);
        return optimisticUpdates;
    };
    _proto._processAsyncOptimisticModuleImport = function _processAsyncOptimisticModuleImport(moduleImportPayload) {
        var _this7 = this;
        this._expectOperationLoader().load(moduleImportPayload.operationReference).then(function(operation) {
            if (operation == null || _this7._state !== 'started') {
                return;
            }
            var moduleImportOptimisticUpdates = _this7._processOptimisticModuleImport(operation, moduleImportPayload);
            moduleImportOptimisticUpdates.forEach(function(update) {
                return _this7._getPublishQueueAndSaveActor().applyUpdate(update);
            });
            if (_this7._optimisticUpdates == null) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'OperationExecutor: Unexpected ModuleImport optimistic ' + 'update in operation %s.' + _this7._operation.request.node.params.name) : "TURBOPACK unreachable";
            } else {
                var _this$_optimisticUpda;
                (_this$_optimisticUpda = _this7._optimisticUpdates).push.apply(_this$_optimisticUpda, (0, _toConsumableArray2["default"])(moduleImportOptimisticUpdates));
                _this7._runPublishQueue();
            }
        });
    };
    _proto._processResponses = function _processResponses(responses) {
        var _this8 = this;
        this._log({
            name: 'execute.normalize.start',
            operation: this._operation
        });
        if (this._optimisticUpdates !== null) {
            this._optimisticUpdates.forEach(function(update) {
                _this8._getPublishQueueAndSaveActor().revertUpdate(update);
            });
            this._optimisticUpdates = null;
        }
        this._incrementalPayloadsPending = false;
        this._incrementalResults.clear();
        this._source.clear();
        return responses.map(function(payloadPart) {
            var relayPayload = _this8._normalizeResponse(payloadPart, _this8._operation.root, ROOT_TYPE, {
                actorIdentifier: _this8._actorIdentifier,
                getDataID: _this8._getDataID,
                log: _this8._log,
                path: [],
                treatMissingFieldsAsNull: _this8._treatMissingFieldsAsNull,
                shouldProcessClientComponents: _this8._shouldProcessClientComponents
            }, _this8._useExecTimeResolvers);
            _this8._getPublishQueueAndSaveActor().commitPayload(_this8._operation, relayPayload, _this8._updater);
            _this8._log({
                name: 'execute.normalize.end',
                operation: _this8._operation
            });
            return relayPayload;
        });
    };
    _proto._processPayloadFollowups = function _processPayloadFollowups(payloads) {
        var _this9 = this;
        if (this._state === 'completed') {
            return;
        }
        payloads.forEach(function(payload) {
            var incrementalPlaceholders = payload.incrementalPlaceholders, followupPayloads = payload.followupPayloads, isFinal = payload.isFinal;
            _this9._state = isFinal ? 'loading_final' : 'loading_incremental';
            _this9._updateActiveState();
            if (isFinal) {
                _this9._incrementalPayloadsPending = false;
            }
            if (followupPayloads && followupPayloads.length !== 0) {
                followupPayloads.forEach(function(followupPayload) {
                    var _followupPayload$acto;
                    var prevActorIdentifier = _this9._actorIdentifier;
                    _this9._actorIdentifier = (_followupPayload$acto = followupPayload.actorIdentifier) !== null && _followupPayload$acto !== void 0 ? _followupPayload$acto : _this9._actorIdentifier;
                    _this9._processFollowupPayload(followupPayload);
                    _this9._actorIdentifier = prevActorIdentifier;
                });
            }
            if (incrementalPlaceholders && incrementalPlaceholders.length !== 0) {
                _this9._incrementalPayloadsPending = _this9._state !== 'loading_final';
                incrementalPlaceholders.forEach(function(incrementalPlaceholder) {
                    var _incrementalPlacehold;
                    var prevActorIdentifier = _this9._actorIdentifier;
                    _this9._actorIdentifier = (_incrementalPlacehold = incrementalPlaceholder.actorIdentifier) !== null && _incrementalPlacehold !== void 0 ? _incrementalPlacehold : _this9._actorIdentifier;
                    _this9._processIncrementalPlaceholder(payload, incrementalPlaceholder);
                    _this9._actorIdentifier = prevActorIdentifier;
                });
                if (_this9._isClientPayload || _this9._state === 'loading_final') {
                    ("TURBOPACK compile-time truthy", 1) ? warning(_this9._isClientPayload, 'RelayModernEnvironment: Operation `%s` contains @defer/@stream ' + 'directives but was executed in non-streaming mode. See ' + 'https://fburl.com/relay-incremental-delivery-non-streaming-warning.', _this9._operation.request.node.params.name) : "TURBOPACK unreachable";
                    var relayPayloads = [];
                    incrementalPlaceholders.forEach(function(placeholder) {
                        if (placeholder.kind === 'defer') {
                            relayPayloads.push(_this9._processDeferResponse(placeholder.label, placeholder.path, placeholder, {
                                data: placeholder.data,
                                extensions: {
                                    is_final: true
                                }
                            }));
                        }
                    });
                    if (relayPayloads.length > 0) {
                        _this9._processPayloadFollowups(relayPayloads);
                    }
                }
            }
        });
    };
    _proto._maybeCompleteSubscriptionOperationTracking = function _maybeCompleteSubscriptionOperationTracking() {
        if (!this._isSubscriptionOperation && !(this._useExecTimeResolvers && this._execTimeResolverResponseComplete && this._state === 'loading_final')) {
            return;
        }
        if (this._pendingModulePayloadsCount === 0 && this._incrementalPayloadsPending === false) {
            this._completeOperationTracker();
        }
    };
    _proto._processFollowupPayload = function _processFollowupPayload(followupPayload) {
        var _this10 = this;
        switch(followupPayload.kind){
            case 'ModuleImportPayload':
                var operationLoader = this._expectOperationLoader();
                var node = operationLoader.get(followupPayload.operationReference);
                if (node != null) {
                    this._processFollowupPayloadWithNormalizationNode(followupPayload, getOperation(node));
                } else {
                    var id = this._nextSubscriptionId++;
                    this._pendingModulePayloadsCount++;
                    var decrementPendingCount = function decrementPendingCount() {
                        _this10._pendingModulePayloadsCount--;
                        _this10._maybeCompleteSubscriptionOperationTracking();
                    };
                    var networkObservable = RelayObservable.from(new Promise(function(resolve, reject) {
                        operationLoader.load(followupPayload.operationReference).then(resolve, reject);
                    }));
                    RelayObservable.create(function(sink) {
                        var cancellationToken;
                        var subscription = networkObservable.subscribe({
                            next: function next(loadedNode) {
                                if (loadedNode != null) {
                                    var publishModuleImportPayload = function publishModuleImportPayload() {
                                        try {
                                            var operation = getOperation(loadedNode);
                                            var batchAsyncModuleUpdatesFN = RelayFeatureFlags.BATCH_ASYNC_MODULE_UPDATES_FN;
                                            var shouldScheduleAsyncStoreUpdate = batchAsyncModuleUpdatesFN != null && _this10._pendingModulePayloadsCount > 1;
                                            var _withStartAndDuration = withStartAndDuration(function() {
                                                _this10._handleFollowupPayload(followupPayload, operation);
                                                if (shouldScheduleAsyncStoreUpdate) {
                                                    _this10._scheduleAsyncStoreUpdate(batchAsyncModuleUpdatesFN, sink.complete);
                                                } else {
                                                    var updatedOwners = _this10._runPublishQueue();
                                                    _this10._updateOperationTracker(updatedOwners);
                                                }
                                            }), _ = _withStartAndDuration[0], duration = _withStartAndDuration[1];
                                            _this10._log({
                                                name: 'execute.async.module',
                                                executeId: _this10._executeId,
                                                operationName: operation.name,
                                                duration: duration
                                            });
                                            if (!shouldScheduleAsyncStoreUpdate) {
                                                sink.complete();
                                            }
                                        } catch (error) {
                                            sink.error(error);
                                        }
                                    };
                                    var scheduler = _this10._scheduler;
                                    if (scheduler == null) {
                                        publishModuleImportPayload();
                                    } else {
                                        cancellationToken = scheduler.schedule(publishModuleImportPayload);
                                    }
                                } else {
                                    sink.complete();
                                }
                            },
                            error: sink.error
                        });
                        return function() {
                            subscription.unsubscribe();
                            if (_this10._scheduler != null && cancellationToken != null) {
                                _this10._scheduler.cancel(cancellationToken);
                            }
                        };
                    }).subscribe({
                        complete: function complete() {
                            _this10._complete(id);
                            decrementPendingCount();
                        },
                        error: function error(_error4) {
                            _this10._error(_error4);
                            decrementPendingCount();
                        },
                        start: function start(subscription) {
                            return _this10._start(id, subscription);
                        }
                    });
                }
                break;
            case 'ActorPayload':
                this._processFollowupPayloadWithNormalizationNode(followupPayload, followupPayload.node);
                break;
            default:
                followupPayload;
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Unexpected followup kind `%s`.', followupPayload.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
    };
    _proto._processFollowupPayloadWithNormalizationNode = function _processFollowupPayloadWithNormalizationNode(followupPayload, normalizationNode) {
        this._handleFollowupPayload(followupPayload, normalizationNode);
        this._maybeCompleteSubscriptionOperationTracking();
    };
    _proto._handleFollowupPayload = function _handleFollowupPayload(followupPayload, normalizationNode) {
        var relayPayload = this._normalizeFollowupPayload(followupPayload, normalizationNode);
        this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload);
        this._processPayloadFollowups([
            relayPayload
        ]);
    };
    _proto._processIncrementalPlaceholder = function _processIncrementalPlaceholder(relayPayload, placeholder) {
        var _relayPayload$fieldPa;
        var label = placeholder.label, path = placeholder.path;
        var pathKey = path.map(String).join('.');
        var resultForLabel = this._incrementalResults.get(label);
        if (resultForLabel == null) {
            resultForLabel = new Map();
            this._incrementalResults.set(label, resultForLabel);
        }
        var resultForPath = resultForLabel.get(pathKey);
        var pendingResponses = resultForPath != null && resultForPath.kind === 'response' ? resultForPath.responses : null;
        resultForLabel.set(pathKey, {
            kind: 'placeholder',
            placeholder: placeholder
        });
        var parentID;
        if (placeholder.kind === 'stream') {
            parentID = placeholder.parentID;
        } else if (placeholder.kind === 'defer') {
            parentID = placeholder.selector.dataID;
        } else {
            placeholder;
            ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Unsupported incremental placeholder kind `%s`.', placeholder.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
        var parentRecord = relayPayload.source.get(parentID);
        var parentPayloads = ((_relayPayload$fieldPa = relayPayload.fieldPayloads) !== null && _relayPayload$fieldPa !== void 0 ? _relayPayload$fieldPa : []).filter(function(fieldPayload) {
            var fieldID = generateClientID(fieldPayload.dataID, fieldPayload.fieldKey);
            return fieldPayload.dataID === parentID || fieldID === parentID;
        });
        !(parentRecord != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected record `%s` to exist.', parentID) : "TURBOPACK unreachable" : void 0;
        var nextParentRecord;
        var nextParentPayloads;
        var previousParentEntry = this._source.get(parentID);
        if (previousParentEntry != null) {
            nextParentRecord = RelayModernRecord.update(previousParentEntry.record, parentRecord);
            var handlePayloads = new Map();
            var dedupePayload = function dedupePayload(payload) {
                var key = stableStringify(payload);
                handlePayloads.set(key, payload);
            };
            previousParentEntry.fieldPayloads.forEach(dedupePayload);
            parentPayloads.forEach(dedupePayload);
            nextParentPayloads = Array.from(handlePayloads.values());
        } else {
            nextParentRecord = parentRecord;
            nextParentPayloads = parentPayloads;
        }
        this._source.set(parentID, {
            record: nextParentRecord,
            fieldPayloads: nextParentPayloads
        });
        if (pendingResponses != null) {
            var payloadFollowups = this._processIncrementalResponses(pendingResponses);
            this._processPayloadFollowups(payloadFollowups);
        }
    };
    _proto._processIncrementalResponses = function _processIncrementalResponses(incrementalResponses) {
        var _this11 = this;
        var relayPayloads = [];
        incrementalResponses.forEach(function(incrementalResponse) {
            var label = incrementalResponse.label, path = incrementalResponse.path, response = incrementalResponse.response;
            var resultForLabel = _this11._incrementalResults.get(label);
            if (resultForLabel == null) {
                resultForLabel = new Map();
                _this11._incrementalResults.set(label, resultForLabel);
            }
            if (label.indexOf('$defer$') !== -1) {
                var pathKey = path.map(String).join('.');
                var resultForPath = resultForLabel.get(pathKey);
                if (resultForPath == null) {
                    resultForPath = {
                        kind: 'response',
                        responses: [
                            incrementalResponse
                        ]
                    };
                    resultForLabel.set(pathKey, resultForPath);
                    return;
                } else if (resultForPath.kind === 'response') {
                    resultForPath.responses.push(incrementalResponse);
                    return;
                }
                var placeholder = resultForPath.placeholder;
                !(placeholder.kind === 'defer') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected data for path `%s` for label `%s` ' + 'to be data for @defer, was `@%s`.', pathKey, label, placeholder.kind) : "TURBOPACK unreachable" : void 0;
                relayPayloads.push(_this11._processDeferResponse(label, path, placeholder, response));
            } else {
                var _pathKey = path.slice(0, -2).map(String).join('.');
                var _resultForPath = resultForLabel.get(_pathKey);
                if (_resultForPath == null) {
                    _resultForPath = {
                        kind: 'response',
                        responses: [
                            incrementalResponse
                        ]
                    };
                    resultForLabel.set(_pathKey, _resultForPath);
                    return;
                } else if (_resultForPath.kind === 'response') {
                    _resultForPath.responses.push(incrementalResponse);
                    return;
                }
                var _placeholder = _resultForPath.placeholder;
                !(_placeholder.kind === 'stream') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected data for path `%s` for label `%s` ' + 'to be data for @stream, was `@%s`.', _pathKey, label, _placeholder.kind) : "TURBOPACK unreachable" : void 0;
                relayPayloads.push(_this11._processStreamResponse(label, path, _placeholder, response));
            }
        });
        return relayPayloads;
    };
    _proto._processDeferResponse = function _processDeferResponse(label, path, placeholder, response) {
        var _placeholder$actorIde;
        var parentID = placeholder.selector.dataID;
        var prevActorIdentifier = this._actorIdentifier;
        this._actorIdentifier = (_placeholder$actorIde = placeholder.actorIdentifier) !== null && _placeholder$actorIde !== void 0 ? _placeholder$actorIde : this._actorIdentifier;
        var relayPayload = this._normalizeResponse(response, placeholder.selector, placeholder.typeName, {
            actorIdentifier: this._actorIdentifier,
            getDataID: this._getDataID,
            log: this._log,
            path: placeholder.path,
            treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
            shouldProcessClientComponents: this._shouldProcessClientComponents
        }, this._useExecTimeResolvers);
        this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload);
        var parentEntry = this._source.get(parentID);
        !(parentEntry != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected the parent record `%s` for @defer ' + 'data to exist.', parentID) : "TURBOPACK unreachable" : void 0;
        var fieldPayloads = parentEntry.fieldPayloads;
        if (fieldPayloads.length !== 0) {
            var _response$extensions3;
            var handleFieldsRelayPayload = {
                errors: null,
                fieldPayloads: fieldPayloads,
                incrementalPlaceholders: null,
                followupPayloads: null,
                source: RelayRecordSource.create(),
                isFinal: ((_response$extensions3 = response.extensions) === null || _response$extensions3 === void 0 ? void 0 : _response$extensions3.is_final) === true
            };
            this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);
        }
        this._actorIdentifier = prevActorIdentifier;
        return relayPayload;
    };
    _proto._processStreamResponse = function _processStreamResponse(label, path, placeholder, response) {
        var parentID = placeholder.parentID, node = placeholder.node, variables = placeholder.variables, actorIdentifier = placeholder.actorIdentifier;
        var prevActorIdentifier = this._actorIdentifier;
        this._actorIdentifier = actorIdentifier !== null && actorIdentifier !== void 0 ? actorIdentifier : this._actorIdentifier;
        var field = node.selections[0];
        !(field != null && field.kind === 'LinkedField' && field.plural === true) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected @stream to be used on a plural field.') : "TURBOPACK unreachable" : void 0;
        var _this$_normalizeStrea = this._normalizeStreamItem(response, parentID, field, variables, path, placeholder.path), fieldPayloads = _this$_normalizeStrea.fieldPayloads, itemID = _this$_normalizeStrea.itemID, itemIndex = _this$_normalizeStrea.itemIndex, prevIDs = _this$_normalizeStrea.prevIDs, relayPayload = _this$_normalizeStrea.relayPayload, storageKey = _this$_normalizeStrea.storageKey;
        this._getPublishQueueAndSaveActor().commitPayload(this._operation, relayPayload, function(store) {
            var currentParentRecord = store.get(parentID);
            if (currentParentRecord == null) {
                return;
            }
            var currentItems = currentParentRecord.getLinkedRecords(storageKey);
            if (currentItems == null) {
                return;
            }
            if (currentItems.length !== prevIDs.length || currentItems.some(function(currentItem, index) {
                return prevIDs[index] !== (currentItem && currentItem.getDataID());
            })) {
                return;
            }
            var nextItems = (0, _toConsumableArray2["default"])(currentItems);
            nextItems[itemIndex] = store.get(itemID);
            currentParentRecord.setLinkedRecords(nextItems, storageKey);
        });
        if (fieldPayloads.length !== 0) {
            var handleFieldsRelayPayload = {
                errors: null,
                fieldPayloads: fieldPayloads,
                incrementalPlaceholders: null,
                followupPayloads: null,
                source: RelayRecordSource.create(),
                isFinal: false
            };
            this._getPublishQueueAndSaveActor().commitPayload(this._operation, handleFieldsRelayPayload);
        }
        this._actorIdentifier = prevActorIdentifier;
        return relayPayload;
    };
    _proto._normalizeStreamItem = function _normalizeStreamItem(response, parentID, field, variables, path, normalizationPath) {
        var _field$alias, _field$concreteType, _ref2, _this$_getDataID;
        var data = response.data;
        !(typeof data === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected the GraphQL @stream payload `data` ' + 'value to be an object.') : "TURBOPACK unreachable" : void 0;
        var responseKey = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;
        var storageKey = getStorageKey(field, variables);
        var parentEntry = this._source.get(parentID);
        !(parentEntry != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected the parent record `%s` for @stream ' + 'data to exist.', parentID) : "TURBOPACK unreachable" : void 0;
        var parentRecord = parentEntry.record, fieldPayloads = parentEntry.fieldPayloads;
        var prevIDs = RelayModernRecord.getLinkedRecordIDs(parentRecord, storageKey);
        !(prevIDs != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected record `%s` to have fetched field ' + '`%s` with @stream.', parentID, field.name) : "TURBOPACK unreachable" : void 0;
        var finalPathEntry = path[path.length - 1];
        var itemIndex = parseInt(finalPathEntry, 10);
        !(itemIndex === finalPathEntry && itemIndex >= 0) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected path for @stream to end in a ' + 'positive integer index, got `%s`', finalPathEntry) : "TURBOPACK unreachable" : void 0;
        var typeName = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : data[TYPENAME_KEY];
        !(typeof typeName === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected @stream field `%s` to have a ' + '__typename.', field.name) : "TURBOPACK unreachable" : void 0;
        var itemID = (_ref2 = (_this$_getDataID = this._getDataID(data, typeName)) !== null && _this$_getDataID !== void 0 ? _this$_getDataID : prevIDs === null || prevIDs === void 0 ? void 0 : prevIDs[itemIndex]) !== null && _ref2 !== void 0 ? _ref2 : generateClientID(parentID, storageKey, itemIndex);
        !(typeof itemID === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected id of elements of field `%s` to ' + 'be strings.', storageKey) : "TURBOPACK unreachable" : void 0;
        var selector = createNormalizationSelector(field, itemID, variables);
        var nextParentRecord = RelayModernRecord.clone(parentRecord);
        var nextIDs = (0, _toConsumableArray2["default"])(prevIDs);
        nextIDs[itemIndex] = itemID;
        RelayModernRecord.setLinkedRecordIDs(nextParentRecord, storageKey, nextIDs);
        this._source.set(parentID, {
            record: nextParentRecord,
            fieldPayloads: fieldPayloads
        });
        var relayPayload = this._normalizeResponse(response, selector, typeName, {
            actorIdentifier: this._actorIdentifier,
            getDataID: this._getDataID,
            log: this._log,
            path: [].concat((0, _toConsumableArray2["default"])(normalizationPath), [
                responseKey,
                String(itemIndex)
            ]),
            treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
            shouldProcessClientComponents: this._shouldProcessClientComponents
        }, this._useExecTimeResolvers);
        return {
            fieldPayloads: fieldPayloads,
            itemID: itemID,
            itemIndex: itemIndex,
            prevIDs: prevIDs,
            relayPayload: relayPayload,
            storageKey: storageKey
        };
    };
    _proto._scheduleAsyncStoreUpdate = function _scheduleAsyncStoreUpdate(scheduleFn, completeFn) {
        var _this12 = this;
        this._completeFns.push(completeFn);
        if (this._asyncStoreUpdateDisposable != null) {
            return;
        }
        this._asyncStoreUpdateDisposable = scheduleFn(function() {
            _this12._asyncStoreUpdateDisposable = null;
            var updatedOwners = _this12._runPublishQueue();
            _this12._updateOperationTracker(updatedOwners);
            var _iterator2 = (0, _createForOfIteratorHelper2["default"])(_this12._completeFns), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var complete = _step2.value;
                    complete();
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
            _this12._completeFns = [];
        });
    };
    _proto._updateOperationTracker = function _updateOperationTracker(updatedOwners) {
        if (updatedOwners != null && updatedOwners.length > 0) {
            this._operationTracker.update(this._operation.request, new Set(updatedOwners));
        }
    };
    _proto._completeOperationTracker = function _completeOperationTracker() {
        this._operationTracker.complete(this._operation.request);
    };
    _proto._getPublishQueueAndSaveActor = function _getPublishQueueAndSaveActor() {
        this._seenActors.add(this._actorIdentifier);
        return this._getPublishQueue(this._actorIdentifier);
    };
    _proto._getActorsToVisit = function _getActorsToVisit() {
        if (this._seenActors.size === 0) {
            return new Set([
                this._actorIdentifier
            ]);
        } else {
            return this._seenActors;
        }
    };
    _proto._runPublishQueue = function _runPublishQueue(operation) {
        var updatedOwners = new Set();
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(this._getActorsToVisit()), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var actorIdentifier = _step3.value;
                var owners = this._getPublishQueue(actorIdentifier).run(operation);
                owners.forEach(function(owner) {
                    return updatedOwners.add(owner);
                });
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
        return Array.from(updatedOwners);
    };
    _proto._retainData = function _retainData() {
        var _iterator4 = (0, _createForOfIteratorHelper2["default"])(this._getActorsToVisit()), _step4;
        try {
            for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                var actorIdentifier = _step4.value;
                if (!this._retainDisposables.has(actorIdentifier)) {
                    this._retainDisposables.set(actorIdentifier, this._getStore(actorIdentifier).retain(this._operation));
                }
            }
        } catch (err) {
            _iterator4.e(err);
        } finally{
            _iterator4.f();
        }
    };
    _proto._disposeRetainedData = function _disposeRetainedData() {
        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(this._retainDisposables.values()), _step5;
        try {
            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                var disposable = _step5.value;
                disposable.dispose();
            }
        } catch (err) {
            _iterator5.e(err);
        } finally{
            _iterator5.f();
        }
        this._retainDisposables.clear();
    };
    _proto._expectOperationLoader = function _expectOperationLoader() {
        var operationLoader = this._operationLoader;
        !operationLoader ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: Expected an operationLoader to be ' + 'configured when using `@match`.') : "TURBOPACK unreachable" : void 0;
        return operationLoader;
    };
    return Executor;
}();
function partitionGraphQLResponses(responses) {
    var nonIncrementalResponses = [];
    var incrementalResponses = [];
    var normalizedResponses = [];
    responses.forEach(function(response) {
        var _response$extensions4;
        if (response.path != null || response.label != null) {
            var label = response.label, path = response.path;
            if (label == null || path == null) {
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: invalid incremental payload, expected ' + '`path` and `label` to either both be null/undefined, or ' + '`path` to be an `Array<string | number>` and `label` to be a ' + '`string`.') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
            incrementalResponses.push({
                label: label,
                path: path,
                response: response
            });
        } else if (((_response$extensions4 = response.extensions) === null || _response$extensions4 === void 0 ? void 0 : _response$extensions4.is_normalized) === true) {
            normalizedResponses.push(response);
        } else {
            nonIncrementalResponses.push(response);
        }
    });
    return [
        nonIncrementalResponses,
        incrementalResponses,
        normalizedResponses
    ];
}
function stableStringify(value) {
    var _JSON$stringify;
    return (_JSON$stringify = JSON.stringify(stableCopy(value))) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : '';
}
function validateOptimisticResponsePayload(payload) {
    var incrementalPlaceholders = payload.incrementalPlaceholders;
    if (incrementalPlaceholders != null && incrementalPlaceholders.length !== 0) {
        ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'OperationExecutor: optimistic responses cannot be returned ' + 'for operations that use incremental data delivery (@defer, ' + '@stream, and @stream_connection).') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
    }
}
module.exports = {
    execute: execute
};
}),
"[project]/node_modules/relay-runtime/lib/util/resolveImmediate.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var resolvedPromise = Promise.resolve();
function resolveImmediate(callback) {
    resolvedPromise.then(callback)["catch"](throwNext);
}
function throwNext(error) {
    setTimeout(function() {
        throw error;
    }, 0);
}
module.exports = resolveImmediate;
}),
"[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceMutator.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordState.js [app-rsc] (ecmascript)"), EXISTENT = _require.EXISTENT;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var RelayRecordSourceMutator = /*#__PURE__*/ function() {
    function RelayRecordSourceMutator(base, sink) {
        this.__sources = [
            sink,
            base
        ];
        this._base = base;
        this._sink = sink;
    }
    var _proto = RelayRecordSourceMutator.prototype;
    _proto.unstable_getRawRecordWithChanges = function unstable_getRawRecordWithChanges(dataID) {
        var baseRecord = this._base.get(dataID);
        var sinkRecord = this._sink.get(dataID);
        if (sinkRecord === undefined) {
            if (baseRecord == null) {
                return baseRecord;
            }
            var nextRecord = RelayModernRecord.clone(baseRecord);
            if ("TURBOPACK compile-time truthy", 1) {
                RelayModernRecord.freeze(nextRecord);
            }
            return nextRecord;
        } else if (sinkRecord === null) {
            return null;
        } else if (baseRecord != null) {
            var _nextRecord = RelayModernRecord.update(baseRecord, sinkRecord);
            if ("TURBOPACK compile-time truthy", 1) {
                if (_nextRecord !== baseRecord) {
                    RelayModernRecord.freeze(_nextRecord);
                }
            }
            return _nextRecord;
        } else {
            var _nextRecord2 = RelayModernRecord.clone(sinkRecord);
            if ("TURBOPACK compile-time truthy", 1) {
                RelayModernRecord.freeze(_nextRecord2);
            }
            return _nextRecord2;
        }
    };
    _proto._getSinkRecord = function _getSinkRecord(dataID) {
        var sinkRecord = this._sink.get(dataID);
        if (!sinkRecord) {
            var baseRecord = this._base.get(dataID);
            !baseRecord ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceMutator: Cannot modify non-existent record `%s`.', dataID) : "TURBOPACK unreachable" : void 0;
            sinkRecord = RelayModernRecord.create(dataID, RelayModernRecord.getType(baseRecord));
            this._sink.set(dataID, sinkRecord);
        }
        return sinkRecord;
    };
    _proto.copyFields = function copyFields(sourceID, sinkID) {
        var sinkSource = this._sink.get(sourceID);
        var baseSource = this._base.get(sourceID);
        !(sinkSource || baseSource) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceMutator#copyFields(): Cannot copy fields from ' + 'non-existent record `%s`.', sourceID) : "TURBOPACK unreachable" : void 0;
        var sink = this._getSinkRecord(sinkID);
        if (baseSource) {
            RelayModernRecord.copyFields(baseSource, sink);
        }
        if (sinkSource) {
            RelayModernRecord.copyFields(sinkSource, sink);
        }
    };
    _proto.copyFieldsFromRecord = function copyFieldsFromRecord(record, sinkID) {
        var sink = this._getSinkRecord(sinkID);
        RelayModernRecord.copyFields(record, sink);
    };
    _proto.create = function create(dataID, typeName) {
        !(this._base.getStatus(dataID) !== EXISTENT && this._sink.getStatus(dataID) !== EXISTENT) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceMutator#create(): Cannot create a record with id ' + '`%s`, this record already exists.', dataID) : "TURBOPACK unreachable" : void 0;
        var record = RelayModernRecord.create(dataID, typeName);
        this._sink.set(dataID, record);
    };
    _proto["delete"] = function _delete(dataID) {
        this._sink["delete"](dataID);
    };
    _proto.getStatus = function getStatus(dataID) {
        return this._sink.has(dataID) ? this._sink.getStatus(dataID) : this._base.getStatus(dataID);
    };
    _proto.getType = function getType(dataID) {
        for(var ii = 0; ii < this.__sources.length; ii++){
            var record = this.__sources[ii].get(dataID);
            if (record) {
                return RelayModernRecord.getType(record);
            } else if (record === null) {
                return null;
            }
        }
    };
    _proto.getValue = function getValue(dataID, storageKey) {
        for(var ii = 0; ii < this.__sources.length; ii++){
            var record = this.__sources[ii].get(dataID);
            if (record) {
                var value = RelayModernRecord.getValue(record, storageKey);
                if (value !== undefined) {
                    return value;
                }
            } else if (record === null) {
                return null;
            }
        }
    };
    _proto.setValue = function setValue(dataID, storageKey, value) {
        var sinkRecord = this._getSinkRecord(dataID);
        RelayModernRecord.setValue(sinkRecord, storageKey, value);
    };
    _proto.getErrors = function getErrors(dataID, storageKey) {
        for(var ii = 0; ii < this.__sources.length; ii++){
            var record = this.__sources[ii].get(dataID);
            if (record) {
                var value = RelayModernRecord.getErrors(record, storageKey);
                if (value !== undefined) {
                    return value;
                }
            } else if (record === null) {
                return null;
            }
        }
    };
    _proto.setErrors = function setErrors(dataID, storageKey, errors) {
        var sinkRecord = this._getSinkRecord(dataID);
        RelayModernRecord.setErrors(sinkRecord, storageKey, errors);
    };
    _proto.getLinkedRecordID = function getLinkedRecordID(dataID, storageKey) {
        for(var ii = 0; ii < this.__sources.length; ii++){
            var record = this.__sources[ii].get(dataID);
            if (record) {
                var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
                if (linkedID !== undefined) {
                    return linkedID;
                }
            } else if (record === null) {
                return null;
            }
        }
    };
    _proto.setLinkedRecordID = function setLinkedRecordID(dataID, storageKey, linkedID) {
        var sinkRecord = this._getSinkRecord(dataID);
        RelayModernRecord.setLinkedRecordID(sinkRecord, storageKey, linkedID);
    };
    _proto.getLinkedRecordIDs = function getLinkedRecordIDs(dataID, storageKey) {
        for(var ii = 0; ii < this.__sources.length; ii++){
            var record = this.__sources[ii].get(dataID);
            if (record) {
                var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);
                if (linkedIDs !== undefined) {
                    return linkedIDs;
                }
            } else if (record === null) {
                return null;
            }
        }
    };
    _proto.setLinkedRecordIDs = function setLinkedRecordIDs(dataID, storageKey, linkedIDs) {
        var sinkRecord = this._getSinkRecord(dataID);
        RelayModernRecord.setLinkedRecordIDs(sinkRecord, storageKey, linkedIDs);
    };
    return RelayRecordSourceMutator;
}();
module.exports = RelayRecordSourceMutator;
}),
"[project]/node_modules/relay-runtime/lib/mutations/createUpdatableProxy.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), getArgumentValues = _require.getArgumentValues;
var nonUpdatableKeys = [
    'id',
    '__id',
    '__typename',
    'js'
];
function createUpdatableProxy(updatableProxyRootRecord, variables, selections, recordSourceProxy, missingFieldHandlers) {
    var mutableUpdatableProxy = {};
    updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selections, recordSourceProxy, missingFieldHandlers);
    if ("TURBOPACK compile-time truthy", 1) {
        Object.freeze(mutableUpdatableProxy);
    }
    return mutableUpdatableProxy;
}
function updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selections, recordSourceProxy, missingFieldHandlers) {
    var _selection$alias3;
    var _iterator = (0, _createForOfIteratorHelper2["default"])(selections), _step;
    try {
        var _loop = function _loop() {
            var selection = _step.value;
            switch(selection.kind){
                case 'LinkedField':
                    if (selection.plural) {
                        Object.defineProperty(mutableUpdatableProxy, (_selection$alias = selection.alias) !== null && _selection$alias !== void 0 ? _selection$alias : selection.name, {
                            get: createGetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers),
                            set: createSetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy)
                        });
                    } else {
                        Object.defineProperty(mutableUpdatableProxy, (_selection$alias2 = selection.alias) !== null && _selection$alias2 !== void 0 ? _selection$alias2 : selection.name, {
                            get: createGetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers),
                            set: createSetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy)
                        });
                    }
                    break;
                case 'ScalarField':
                    var scalarFieldName = (_selection$alias3 = selection.alias) !== null && _selection$alias3 !== void 0 ? _selection$alias3 : selection.name;
                    Object.defineProperty(mutableUpdatableProxy, scalarFieldName, {
                        get: function get() {
                            var _selection$args;
                            var newVariables = getArgumentValues((_selection$args = selection.args) !== null && _selection$args !== void 0 ? _selection$args : [], variables);
                            var value = updatableProxyRootRecord.getValue(selection.name, newVariables);
                            if (value == null) {
                                value = getScalarUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers);
                            }
                            return value;
                        },
                        set: nonUpdatableKeys.includes(selection.name) ? undefined : function(newValue) {
                            var _selection$args2;
                            var newVariables = getArgumentValues((_selection$args2 = selection.args) !== null && _selection$args2 !== void 0 ? _selection$args2 : [], variables);
                            updatableProxyRootRecord.setValue__UNSAFE(newValue, selection.name, newVariables);
                        }
                    });
                    break;
                case 'InlineFragment':
                    if (updatableProxyRootRecord.getType() === selection.type) {
                        updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selection.selections, recordSourceProxy, missingFieldHandlers);
                    }
                    break;
                case 'ClientExtension':
                    updateProxyFromSelections(mutableUpdatableProxy, updatableProxyRootRecord, variables, selection.selections, recordSourceProxy, missingFieldHandlers);
                    break;
                case 'FragmentSpread':
                    break;
                case 'Condition':
                case 'ActorChange':
                case 'InlineDataFragmentSpread':
                case 'AliasedInlineFragmentSpread':
                case 'ClientEdgeToClientObject':
                case 'ClientEdgeToServerObject':
                case 'Defer':
                case 'ModuleImport':
                case 'RequiredField':
                case 'CatchField':
                case 'Stream':
                case 'RelayResolver':
                case 'RelayLiveResolver':
                    throw new Error('Encountered an unexpected ReaderSelection variant in RelayRecordSourceProxy. This indicates a bug in Relay.');
                default:
                    selection.kind;
                    throw new Error('Encountered an unexpected ReaderSelection variant in RelayRecordSourceProxy. This indicates a bug in Relay.');
            }
        };
        for(_iterator.s(); !(_step = _iterator.n()).done;){
            var _selection$alias;
            var _selection$alias2;
            _loop();
        }
    } catch (err) {
        _iterator.e(err);
    } finally{
        _iterator.f();
    }
}
function createSetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy) {
    return function set(newValue) {
        var _selection$args3;
        var newVariables = getArgumentValues((_selection$args3 = selection.args) !== null && _selection$args3 !== void 0 ? _selection$args3 : [], variables);
        if (newValue == null) {
            throw new Error('Do not assign null to plural linked fields; assign an empty array instead.');
        } else {
            var recordProxies = newValue.map(function(item) {
                if (item == null) {
                    throw new Error('When assigning an array of items, none of the items should be null or undefined.');
                }
                var __id = item.__id;
                if (__id == null) {
                    throw new Error('The __id field must be present on each item passed to the setter. This indicates a bug in Relay.');
                }
                var newValueRecord = recordSourceProxy.get(__id);
                if (newValueRecord == null) {
                    throw new Error("Did not find item with data id ".concat(__id, " in the store."));
                }
                return newValueRecord;
            });
            updatableProxyRootRecord.setLinkedRecords(recordProxies, selection.name, newVariables);
        }
    };
}
function createSetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy) {
    return function set(newValue) {
        var _selection$args4;
        var newVariables = getArgumentValues((_selection$args4 = selection.args) !== null && _selection$args4 !== void 0 ? _selection$args4 : [], variables);
        if (newValue == null) {
            updatableProxyRootRecord.setValue(newValue, selection.name, newVariables);
        } else {
            var __id = newValue.__id;
            if (__id == null) {
                throw new Error('The __id field must be present on the argument. This indicates a bug in Relay.');
            }
            var newValueRecord = recordSourceProxy.get(__id);
            if (newValueRecord == null) {
                throw new Error("Did not find item with data id ".concat(__id, " in the store."));
            }
            updatableProxyRootRecord.setLinkedRecord(newValueRecord, selection.name, newVariables);
        }
    };
}
function createGetterForPluralLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
    return function() {
        var _selection$args5;
        var newVariables = getArgumentValues((_selection$args5 = selection.args) !== null && _selection$args5 !== void 0 ? _selection$args5 : [], variables);
        var linkedRecords = updatableProxyRootRecord.getLinkedRecords(selection.name, newVariables);
        if (linkedRecords === undefined) {
            linkedRecords = getPluralLinkedRecordUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers);
        }
        if (linkedRecords != null) {
            return linkedRecords.map(function(linkedRecord) {
                if (linkedRecord != null) {
                    var updatableProxy = {};
                    updateProxyFromSelections(updatableProxy, linkedRecord, variables, selection.selections, recordSourceProxy, missingFieldHandlers);
                    if ("TURBOPACK compile-time truthy", 1) {
                        Object.freeze(updatableProxy);
                    }
                    return updatableProxy;
                } else {
                    return linkedRecord;
                }
            });
        } else {
            return linkedRecords;
        }
    };
}
function createGetterForSingularLinkedField(selection, variables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
    return function() {
        var _selection$args6;
        var newVariables = getArgumentValues((_selection$args6 = selection.args) !== null && _selection$args6 !== void 0 ? _selection$args6 : [], variables);
        var linkedRecord = updatableProxyRootRecord.getLinkedRecord(selection.name, newVariables);
        if (linkedRecord === undefined) {
            linkedRecord = getLinkedRecordUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers);
        }
        if (linkedRecord != null) {
            var updatableProxy = {};
            updateProxyFromSelections(updatableProxy, linkedRecord, variables, selection.selections, recordSourceProxy, missingFieldHandlers);
            if ("TURBOPACK compile-time truthy", 1) {
                Object.freeze(updatableProxy);
            }
            return updatableProxy;
        } else {
            return linkedRecord;
        }
    };
}
function getLinkedRecordUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(missingFieldHandlers), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var handler = _step2.value;
            if (handler.kind === 'linked') {
                var newId = handler.handle(selection, updatableProxyRootRecord, newVariables, recordSourceProxy);
                if (newId != null) {
                    return recordSourceProxy.get(newId);
                }
            }
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
}
function getPluralLinkedRecordUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
    var _iterator3 = (0, _createForOfIteratorHelper2["default"])(missingFieldHandlers), _step3;
    try {
        for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
            var handler = _step3.value;
            if (handler.kind === 'pluralLinked') {
                var newIds = handler.handle(selection, updatableProxyRootRecord, newVariables, recordSourceProxy);
                if (newIds != null) {
                    return newIds.map(function(newId) {
                        if (newId != null) {
                            return recordSourceProxy.get(newId);
                        }
                    });
                }
            }
        }
    } catch (err) {
        _iterator3.e(err);
    } finally{
        _iterator3.f();
    }
}
function getScalarUsingMissingFieldHandlers(selection, newVariables, updatableProxyRootRecord, recordSourceProxy, missingFieldHandlers) {
    var _iterator4 = (0, _createForOfIteratorHelper2["default"])(missingFieldHandlers), _step4;
    try {
        for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
            var handler = _step4.value;
            if (handler.kind === 'scalar') {
                var value = handler.handle(selection, updatableProxyRootRecord, newVariables, recordSourceProxy);
                if (value !== undefined) {
                    return value;
                }
            }
        }
    } catch (err) {
        _iterator4.e(err);
    } finally{
        _iterator4.f();
    }
}
module.exports = {
    createUpdatableProxy: createUpdatableProxy
};
}),
"[project]/node_modules/relay-runtime/lib/mutations/readUpdatableFragment.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-rsc] (ecmascript)"), getFragment = _require.getFragment;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-rsc] (ecmascript)"), getVariablesFromFragment = _require2.getVariablesFromFragment;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), ID_KEY = _require3.ID_KEY;
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/createUpdatableProxy.js [app-rsc] (ecmascript)"), createUpdatableProxy = _require4.createUpdatableProxy;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function readUpdatableFragment(fragment, fragmentReference, proxy, missingFieldHandlers) {
    var updatableFragment = getFragment(fragment);
    var fragmentVariables = getVariablesFromFragment(updatableFragment, fragmentReference);
    var id = fragmentReference[ID_KEY];
    var fragmentRoot = proxy.get(id);
    !(fragmentRoot != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, "No record with ".concat(id, " was found. This likely indicates a problem with Relay.")) : "TURBOPACK unreachable" : void 0;
    return {
        updatableData: createUpdatableProxy(fragmentRoot, fragmentVariables, updatableFragment.selections, proxy, missingFieldHandlers)
    };
}
module.exports = {
    readUpdatableFragment: readUpdatableFragment
};
}),
"[project]/node_modules/relay-runtime/lib/mutations/readUpdatableQuery.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-rsc] (ecmascript)"), getUpdatableQuery = _require.getUpdatableQuery;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/createUpdatableProxy.js [app-rsc] (ecmascript)"), createUpdatableProxy = _require2.createUpdatableProxy;
function readUpdatableQuery(query, variables, proxy, missingFieldHandlers) {
    var updatableQuery = getUpdatableQuery(query);
    return {
        updatableData: createUpdatableProxy(proxy.getRoot(), variables, updatableQuery.fragment.selections, proxy, missingFieldHandlers)
    };
}
module.exports = {
    readUpdatableQuery: readUpdatableQuery
};
}),
"[project]/node_modules/relay-runtime/lib/mutations/RelayRecordProxy.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-rsc] (ecmascript)"), generateClientID = _require.generateClientID;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), getStableStorageKey = _require2.getStableStorageKey;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var RelayRecordProxy = /*#__PURE__*/ function() {
    function RelayRecordProxy(source, mutator, dataID) {
        this._dataID = dataID;
        this._mutator = mutator;
        this._source = source;
    }
    var _proto = RelayRecordProxy.prototype;
    _proto.copyFieldsFrom = function copyFieldsFrom(source) {
        this._mutator.copyFields(source.getDataID(), this._dataID);
    };
    _proto.getDataID = function getDataID() {
        return this._dataID;
    };
    _proto.getType = function getType() {
        var type = this._mutator.getType(this._dataID);
        !(type != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordProxy: Cannot get the type of deleted record `%s`.', this._dataID) : "TURBOPACK unreachable" : void 0;
        return type;
    };
    _proto.getValue = function getValue(name, args) {
        var storageKey = getStableStorageKey(name, args);
        return this._mutator.getValue(this._dataID, storageKey);
    };
    _proto.setValue = function setValue(value, name, args, errors) {
        !isValidLeafValue(value) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordProxy#setValue(): Expected a scalar or array of scalars, ' + 'got `%s`.', JSON.stringify(value)) : "TURBOPACK unreachable" : void 0;
        return this.setValue__UNSAFE(value, name, args, errors);
    };
    _proto.getErrors = function getErrors(name, args) {
        var storageKey = getStableStorageKey(name, args);
        return this._mutator.getErrors(this._dataID, storageKey);
    };
    _proto.setValue__UNSAFE = function setValue__UNSAFE(value, name, args, errors) {
        var storageKey = getStableStorageKey(name, args);
        this._mutator.setValue(this._dataID, storageKey, value);
        if (errors != null) {
            if (errors.length === 0) {
                this._mutator.setErrors(this._dataID, storageKey);
            } else {
                this._mutator.setErrors(this._dataID, storageKey, errors);
            }
        }
        return this;
    };
    _proto.getLinkedRecord = function getLinkedRecord(name, args) {
        var storageKey = getStableStorageKey(name, args);
        var linkedID = this._mutator.getLinkedRecordID(this._dataID, storageKey);
        return linkedID != null ? this._source.get(linkedID) : linkedID;
    };
    _proto.setLinkedRecord = function setLinkedRecord(record, name, args) {
        !(record instanceof RelayRecordProxy) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordProxy#setLinkedRecord(): Expected a record, got `%s`.', record) : "TURBOPACK unreachable" : void 0;
        var storageKey = getStableStorageKey(name, args);
        var linkedID = record.getDataID();
        this._mutator.setLinkedRecordID(this._dataID, storageKey, linkedID);
        return this;
    };
    _proto.getOrCreateLinkedRecord = function getOrCreateLinkedRecord(name, typeName, args) {
        var linkedRecord = this.getLinkedRecord(name, args);
        if (!linkedRecord) {
            var _this$_source$get;
            var storageKey = getStableStorageKey(name, args);
            var clientID = generateClientID(this.getDataID(), storageKey);
            linkedRecord = (_this$_source$get = this._source.get(clientID)) !== null && _this$_source$get !== void 0 ? _this$_source$get : this._source.create(clientID, typeName);
            this.setLinkedRecord(linkedRecord, name, args);
        }
        return linkedRecord;
    };
    _proto.getLinkedRecords = function getLinkedRecords(name, args) {
        var _this = this;
        var storageKey = getStableStorageKey(name, args);
        var linkedIDs = this._mutator.getLinkedRecordIDs(this._dataID, storageKey);
        if (linkedIDs == null) {
            return linkedIDs;
        }
        return linkedIDs.map(function(linkedID) {
            return linkedID != null ? _this._source.get(linkedID) : linkedID;
        });
    };
    _proto.setLinkedRecords = function setLinkedRecords(records, name, args) {
        !Array.isArray(records) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordProxy#setLinkedRecords(): Expected records to be an array, got `%s`.', records) : "TURBOPACK unreachable" : void 0;
        var storageKey = getStableStorageKey(name, args);
        var linkedIDs = records.map(function(record) {
            return record && record.getDataID();
        });
        this._mutator.setLinkedRecordIDs(this._dataID, storageKey, linkedIDs);
        return this;
    };
    _proto.invalidateRecord = function invalidateRecord() {
        this._source.markIDForInvalidation(this._dataID);
    };
    return RelayRecordProxy;
}();
function isValidLeafValue(value) {
    return value == null || typeof value !== 'object' || Array.isArray(value) && value.every(isValidLeafValue);
}
module.exports = RelayRecordProxy;
}),
"[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceProxy.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordState.js [app-rsc] (ecmascript)"), EXISTENT = _require.EXISTENT, NONEXISTENT = _require.NONEXISTENT;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), ROOT_ID = _require2.ROOT_ID, ROOT_TYPE = _require2.ROOT_TYPE;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/readUpdatableFragment.js [app-rsc] (ecmascript)"), _readUpdatableFragment = _require3.readUpdatableFragment;
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/readUpdatableQuery.js [app-rsc] (ecmascript)"), _readUpdatableQuery = _require4.readUpdatableQuery;
var RelayRecordProxy = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayRecordProxy.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var RelayRecordSourceProxy = /*#__PURE__*/ function() {
    function RelayRecordSourceProxy(mutator, getDataID, handlerProvider, missingFieldHandlers, log) {
        this.__mutator = mutator;
        this._handlerProvider = handlerProvider || null;
        this._proxies = {};
        this._getDataID = getDataID;
        this._invalidatedStore = false;
        this._idsMarkedForInvalidation = new Set();
        this._missingFieldHandlers = missingFieldHandlers;
        this._log = log !== null && log !== void 0 ? log : function(LogEvent) {};
    }
    var _proto = RelayRecordSourceProxy.prototype;
    _proto.publishSource = function publishSource(source, fieldPayloads) {
        var _this = this;
        var dataIDs = source.getRecordIDs();
        dataIDs.forEach(function(dataID) {
            var status = source.getStatus(dataID);
            if (status === EXISTENT) {
                var sourceRecord = source.get(dataID);
                if (sourceRecord) {
                    if (_this.__mutator.getStatus(dataID) !== EXISTENT) {
                        _this.create(dataID, RelayModernRecord.getType(sourceRecord));
                    }
                    _this.__mutator.copyFieldsFromRecord(sourceRecord, dataID);
                }
            } else if (status === NONEXISTENT) {
                _this["delete"](dataID);
            }
        });
        if (fieldPayloads && fieldPayloads.length) {
            fieldPayloads.forEach(function(fieldPayload) {
                var handler = _this._handlerProvider && _this._handlerProvider(fieldPayload.handle);
                !handler ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernEnvironment: Expected a handler to be provided for handle `%s`.', fieldPayload.handle) : "TURBOPACK unreachable" : void 0;
                handler.update(_this, fieldPayload);
            });
        }
    };
    _proto.create = function create(dataID, typeName) {
        this.__mutator.create(dataID, typeName);
        delete this._proxies[dataID];
        var record = this.get(dataID);
        !record ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceProxy#create(): Expected the created record to exist.') : "TURBOPACK unreachable" : void 0;
        return record;
    };
    _proto["delete"] = function _delete(dataID) {
        !(dataID !== ROOT_ID) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceProxy#delete(): Cannot delete the root record.') : "TURBOPACK unreachable" : void 0;
        delete this._proxies[dataID];
        this.__mutator["delete"](dataID);
    };
    _proto.get = function get(dataID) {
        if (!this._proxies.hasOwnProperty(dataID)) {
            var status = this.__mutator.getStatus(dataID);
            if (status === EXISTENT) {
                this._proxies[dataID] = new RelayRecordProxy(this, this.__mutator, dataID);
            } else {
                this._proxies[dataID] = status === NONEXISTENT ? null : undefined;
            }
        }
        return this._proxies[dataID];
    };
    _proto.getRoot = function getRoot() {
        var root = this.get(ROOT_ID);
        if (!root) {
            root = this.create(ROOT_ID, ROOT_TYPE);
        }
        !(root && root.getType() === ROOT_TYPE) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceProxy#getRoot(): Expected the source to contain a ' + 'root record, %s.', root == null ? 'no root record found' : "found a root record of type `".concat(root.getType(), "`")) : "TURBOPACK unreachable" : void 0;
        return root;
    };
    _proto.invalidateStore = function invalidateStore() {
        this._invalidatedStore = true;
    };
    _proto.isStoreMarkedForInvalidation = function isStoreMarkedForInvalidation() {
        return this._invalidatedStore;
    };
    _proto.markIDForInvalidation = function markIDForInvalidation(dataID) {
        this._idsMarkedForInvalidation.add(dataID);
    };
    _proto.getIDsMarkedForInvalidation = function getIDsMarkedForInvalidation() {
        return this._idsMarkedForInvalidation;
    };
    _proto.readUpdatableQuery = function readUpdatableQuery(query, variables) {
        return _readUpdatableQuery(query, variables, this, this._missingFieldHandlers);
    };
    _proto.readUpdatableFragment = function readUpdatableFragment(fragment, fragmentReference) {
        return _readUpdatableFragment(fragment, fragmentReference, this, this._missingFieldHandlers);
    };
    return RelayRecordSourceProxy;
}();
module.exports = RelayRecordSourceProxy;
}),
"[project]/node_modules/relay-runtime/lib/store/cloneRelayHandleSourceField.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-rsc] (ecmascript)"), LINKED_FIELD = _require.LINKED_FIELD;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), getHandleStorageKey = _require2.getHandleStorageKey;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function cloneRelayHandleSourceField(handleField, selections, variables) {
    var sourceField = selections.find(function(source) {
        return source.kind === LINKED_FIELD && source.name === handleField.name && source.alias === handleField.alias && areEqual(source.args, handleField.args);
    });
    !(sourceField && sourceField.kind === LINKED_FIELD) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'cloneRelayHandleSourceField: Expected a corresponding source field for ' + 'handle `%s`.', handleField.handle) : "TURBOPACK unreachable" : void 0;
    var handleKey = getHandleStorageKey(handleField, variables);
    return {
        kind: 'LinkedField',
        alias: sourceField.alias,
        name: handleKey,
        storageKey: handleKey,
        args: null,
        concreteType: sourceField.concreteType,
        plural: sourceField.plural,
        selections: sourceField.selections
    };
}
module.exports = cloneRelayHandleSourceField;
}),
"[project]/node_modules/relay-runtime/lib/store/cloneRelayScalarHandleSourceField.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-rsc] (ecmascript)"), SCALAR_FIELD = _require.SCALAR_FIELD;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), getHandleStorageKey = _require2.getHandleStorageKey;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function cloneRelayScalarHandleSourceField(handleField, selections, variables) {
    var sourceField = selections.find(function(source) {
        return source.kind === SCALAR_FIELD && source.name === handleField.name && source.alias === handleField.alias && areEqual(source.args, handleField.args);
    });
    !(sourceField && sourceField.kind === SCALAR_FIELD) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'cloneRelayScalarHandleSourceField: Expected a corresponding source field for ' + 'handle `%s`.', handleField.handle) : "TURBOPACK unreachable" : void 0;
    var handleKey = getHandleStorageKey(handleField, variables);
    return {
        kind: 'ScalarField',
        alias: sourceField.alias,
        name: handleKey,
        storageKey: handleKey,
        args: null
    };
}
module.exports = cloneRelayScalarHandleSourceField;
}),
"[project]/node_modules/relay-runtime/lib/store/DataChecker.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var RelayRecordSourceMutator = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceMutator.js [app-rsc] (ecmascript)");
var RelayRecordSourceProxy = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceProxy.js [app-rsc] (ecmascript)");
var getOperation = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getOperation.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-rsc] (ecmascript)"), isClientID = _require.isClientID;
var cloneRelayHandleSourceField = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/cloneRelayHandleSourceField.js [app-rsc] (ecmascript)");
var cloneRelayScalarHandleSourceField = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/cloneRelayScalarHandleSourceField.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-rsc] (ecmascript)"), getLocalVariables = _require2.getLocalVariables;
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordState.js [app-rsc] (ecmascript)"), EXISTENT = _require3.EXISTENT, UNKNOWN = _require3.UNKNOWN;
var RelayStoreUtils = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)");
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/TypeID.js [app-rsc] (ecmascript)"), TYPE_SCHEMA_TYPE = _require4.TYPE_SCHEMA_TYPE, generateTypeID = _require4.generateTypeID;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var getModuleOperationKey = RelayStoreUtils.getModuleOperationKey, getStorageKey = RelayStoreUtils.getStorageKey, getArgumentValues = RelayStoreUtils.getArgumentValues;
function check(getSourceForActor, getTargetForActor, defaultActorIdentifier, selector, handlers, operationLoader, getDataID, shouldProcessClientComponents, log, useExecTimeResolvers) {
    if (log != null) {
        log({
            name: 'store.datachecker.start',
            selector: selector
        });
    }
    var dataID = selector.dataID, node = selector.node, variables = selector.variables;
    var checker = new DataChecker(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents, log, useExecTimeResolvers);
    var result = checker.check(node, dataID);
    if (log != null) {
        log({
            name: 'store.datachecker.end',
            selector: selector
        });
    }
    return result;
}
var DataChecker = /*#__PURE__*/ function() {
    function DataChecker(getSourceForActor, getTargetForActor, defaultActorIdentifier, variables, handlers, operationLoader, getDataID, shouldProcessClientComponents, log, useExecTimeResolvers) {
        this._getSourceForActor = getSourceForActor;
        this._getTargetForActor = getTargetForActor;
        this._getDataID = getDataID;
        this._source = getSourceForActor(defaultActorIdentifier);
        this._mutatorRecordSourceProxyCache = new Map();
        var _this$_getMutatorAndR = this._getMutatorAndRecordProxyForActor(defaultActorIdentifier), mutator = _this$_getMutatorAndR[0], recordSourceProxy = _this$_getMutatorAndR[1];
        this._useExecTimeResolvers = useExecTimeResolvers !== null && useExecTimeResolvers !== void 0 ? useExecTimeResolvers : false;
        this._mostRecentlyInvalidatedAt = null;
        this._handlers = handlers;
        this._mutator = mutator;
        this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;
        this._recordSourceProxy = recordSourceProxy;
        this._recordWasMissing = false;
        this._variables = variables;
        this._shouldProcessClientComponents = shouldProcessClientComponents;
        this._log = log;
    }
    var _proto = DataChecker.prototype;
    _proto._getMutatorAndRecordProxyForActor = function _getMutatorAndRecordProxyForActor(actorIdentifier) {
        var tuple = this._mutatorRecordSourceProxyCache.get(actorIdentifier);
        if (tuple == null) {
            var target = this._getTargetForActor(actorIdentifier);
            var mutator = new RelayRecordSourceMutator(this._getSourceForActor(actorIdentifier), target);
            var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID, undefined, this._handlers, this._log);
            tuple = [
                mutator,
                recordSourceProxy
            ];
            this._mutatorRecordSourceProxyCache.set(actorIdentifier, tuple);
        }
        return tuple;
    };
    _proto.check = function check(node, dataID) {
        this._assignClientAbstractTypes(node);
        this._traverse(node, dataID);
        return this._recordWasMissing === true ? {
            status: 'missing',
            mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt
        } : {
            status: 'available',
            mostRecentlyInvalidatedAt: this._mostRecentlyInvalidatedAt
        };
    };
    _proto._getVariableValue = function _getVariableValue(name) {
        !this._variables.hasOwnProperty(name) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayAsyncLoader(): Undefined variable `%s`.', name) : "TURBOPACK unreachable" : void 0;
        return this._variables[name];
    };
    _proto._handleMissing = function _handleMissing() {
        this._recordWasMissing = true;
    };
    _proto._handleMissingScalarField = function _handleMissingScalarField(field, dataID) {
        if (field.name === 'id' && field.alias == null && isClientID(dataID)) {
            return undefined;
        }
        var args = field.args != undefined ? getArgumentValues(field.args, this._variables) : {};
        var _iterator = (0, _createForOfIteratorHelper2["default"])(this._handlers), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var handler = _step.value;
                if (handler.kind === 'scalar') {
                    var newValue = handler.handle(field, this._recordSourceProxy.get(dataID), args, this._recordSourceProxy);
                    if (newValue !== undefined) {
                        return newValue;
                    }
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        this._handleMissing();
    };
    _proto._handleMissingLinkField = function _handleMissingLinkField(field, dataID) {
        var args = field.args != undefined ? getArgumentValues(field.args, this._variables) : {};
        var _iterator2 = (0, _createForOfIteratorHelper2["default"])(this._handlers), _step2;
        try {
            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                var handler = _step2.value;
                if (handler.kind === 'linked') {
                    var newValue = handler.handle(field, this._recordSourceProxy.get(dataID), args, this._recordSourceProxy);
                    if (newValue !== undefined && (newValue === null || this._mutator.getStatus(newValue) === EXISTENT)) {
                        return newValue;
                    }
                }
            }
        } catch (err) {
            _iterator2.e(err);
        } finally{
            _iterator2.f();
        }
        this._handleMissing();
    };
    _proto._handleMissingPluralLinkField = function _handleMissingPluralLinkField(field, dataID) {
        var _this = this;
        var args = field.args != undefined ? getArgumentValues(field.args, this._variables) : {};
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(this._handlers), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var handler = _step3.value;
                if (handler.kind === 'pluralLinked') {
                    var newValue = handler.handle(field, this._recordSourceProxy.get(dataID), args, this._recordSourceProxy);
                    if (newValue != null) {
                        var allItemsKnown = newValue.every(function(linkedID) {
                            return linkedID != null && _this._mutator.getStatus(linkedID) === EXISTENT;
                        });
                        if (allItemsKnown) {
                            return newValue;
                        }
                    } else if (newValue === null) {
                        return null;
                    }
                }
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
        this._handleMissing();
    };
    _proto._traverse = function _traverse(node, dataID) {
        var status = this._mutator.getStatus(dataID);
        if (status === UNKNOWN) {
            this._handleMissing();
        }
        if (status === EXISTENT) {
            var record = this._source.get(dataID);
            var invalidatedAt = RelayModernRecord.getInvalidationEpoch(record);
            if (invalidatedAt != null) {
                this._mostRecentlyInvalidatedAt = this._mostRecentlyInvalidatedAt != null ? Math.max(this._mostRecentlyInvalidatedAt, invalidatedAt) : invalidatedAt;
            }
            this._traverseSelections(node.selections, dataID);
        }
    };
    _proto._traverseSelections = function _traverseSelections(selections, dataID) {
        var _this2 = this;
        selections.forEach(function(selection) {
            switch(selection.kind){
                case 'ScalarField':
                    _this2._checkScalar(selection, dataID);
                    break;
                case 'LinkedField':
                    if (selection.plural) {
                        _this2._checkPluralLink(selection, dataID);
                    } else {
                        _this2._checkLink(selection, dataID);
                    }
                    break;
                case 'ActorChange':
                    _this2._checkActorChange(selection.linkedField, dataID);
                    break;
                case 'Condition':
                    var conditionValue = Boolean(_this2._getVariableValue(selection.condition));
                    if (conditionValue === selection.passingValue) {
                        _this2._traverseSelections(selection.selections, dataID);
                    }
                    break;
                case 'InlineFragment':
                    {
                        var _abstractKey = selection.abstractKey;
                        if (_abstractKey == null) {
                            var typeName = _this2._mutator.getType(dataID);
                            if (typeName === selection.type) {
                                _this2._traverseSelections(selection.selections, dataID);
                            }
                        } else {
                            var _recordType = _this2._mutator.getType(dataID);
                            !(_recordType != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : "TURBOPACK unreachable" : void 0;
                            var _typeID = generateTypeID(_recordType);
                            var _implementsInterface = _this2._mutator.getValue(_typeID, _abstractKey);
                            if (_implementsInterface === true) {
                                _this2._traverseSelections(selection.selections, dataID);
                            } else if (_implementsInterface == null) {
                                _this2._handleMissing();
                            }
                        }
                        break;
                    }
                case 'LinkedHandle':
                    {
                        var handleField = cloneRelayHandleSourceField(selection, selections, _this2._variables);
                        if (handleField.plural) {
                            _this2._checkPluralLink(handleField, dataID);
                        } else {
                            _this2._checkLink(handleField, dataID);
                        }
                        break;
                    }
                case 'ScalarHandle':
                    {
                        var _handleField = cloneRelayScalarHandleSourceField(selection, selections, _this2._variables);
                        _this2._checkScalar(_handleField, dataID);
                        break;
                    }
                case 'ModuleImport':
                    _this2._checkModuleImport(selection, dataID);
                    break;
                case 'Defer':
                case 'Stream':
                    _this2._traverseSelections(selection.selections, dataID);
                    break;
                case 'FragmentSpread':
                    var prevVariables = _this2._variables;
                    _this2._variables = getLocalVariables(_this2._variables, selection.fragment.argumentDefinitions, selection.args);
                    _this2._traverseSelections(selection.fragment.selections, dataID);
                    _this2._variables = prevVariables;
                    break;
                case 'ClientExtension':
                    var recordWasMissing = _this2._recordWasMissing;
                    _this2._traverseSelections(selection.selections, dataID);
                    _this2._recordWasMissing = recordWasMissing;
                    break;
                case 'TypeDiscriminator':
                    var abstractKey = selection.abstractKey;
                    var recordType = _this2._mutator.getType(dataID);
                    !(recordType != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'DataChecker: Expected record `%s` to have a known type', dataID) : "TURBOPACK unreachable" : void 0;
                    var typeID = generateTypeID(recordType);
                    var implementsInterface = _this2._mutator.getValue(typeID, abstractKey);
                    if (implementsInterface == null) {
                        _this2._handleMissing();
                    }
                    break;
                case 'ClientComponent':
                    if (_this2._shouldProcessClientComponents === false) {
                        break;
                    }
                    _this2._traverseSelections(selection.fragment.selections, dataID);
                    break;
                case 'RelayResolver':
                case 'RelayLiveResolver':
                    if (!_this2._useExecTimeResolvers) {
                        _this2._checkResolver(selection, dataID);
                    }
                    break;
                case 'ClientEdgeToClientObject':
                    if (!_this2._useExecTimeResolvers) {
                        _this2._checkResolver(selection.backingField, dataID);
                    }
                    break;
                default:
                    selection;
                    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayAsyncLoader(): Unexpected ast kind `%s`.', selection.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
        });
    };
    _proto._checkResolver = function _checkResolver(resolver, dataID) {
        if (resolver.fragment) {
            this._traverseSelections([
                resolver.fragment
            ], dataID);
        }
    };
    _proto._checkModuleImport = function _checkModuleImport(moduleImport, dataID) {
        var operationLoader = this._operationLoader;
        !(operationLoader !== null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'DataChecker: Expected an operationLoader to be configured when using `@module`.') : "TURBOPACK unreachable" : void 0;
        var operationKey = getModuleOperationKey(moduleImport.documentName);
        var operationReference = this._mutator.getValue(dataID, operationKey);
        if (operationReference == null) {
            if (operationReference === undefined) {
                this._handleMissing();
            }
            return;
        }
        var normalizationRootNode = operationLoader.get(operationReference);
        if (normalizationRootNode != null) {
            var operation = getOperation(normalizationRootNode);
            var prevVariables = this._variables;
            this._variables = getLocalVariables(this._variables, operation.argumentDefinitions, moduleImport.args);
            this._traverse(operation, dataID);
            this._variables = prevVariables;
        } else {
            this._handleMissing();
        }
    };
    _proto._checkScalar = function _checkScalar(field, dataID) {
        var storageKey = getStorageKey(field, this._variables);
        var fieldValue = this._mutator.getValue(dataID, storageKey);
        if (fieldValue === undefined) {
            fieldValue = this._handleMissingScalarField(field, dataID);
            if (fieldValue !== undefined) {
                this._mutator.setValue(dataID, storageKey, fieldValue);
            }
        }
    };
    _proto._checkLink = function _checkLink(field, dataID) {
        var storageKey = getStorageKey(field, this._variables);
        var linkedID = this._mutator.getLinkedRecordID(dataID, storageKey);
        if (linkedID === undefined) {
            linkedID = this._handleMissingLinkField(field, dataID);
            if (linkedID != null) {
                this._mutator.setLinkedRecordID(dataID, storageKey, linkedID);
            } else if (linkedID === null) {
                this._mutator.setValue(dataID, storageKey, null);
            }
        }
        if (linkedID != null) {
            this._traverse(field, linkedID);
        }
    };
    _proto._checkPluralLink = function _checkPluralLink(field, dataID) {
        var _this3 = this;
        var storageKey = getStorageKey(field, this._variables);
        var linkedIDs = this._mutator.getLinkedRecordIDs(dataID, storageKey);
        if (linkedIDs === undefined) {
            linkedIDs = this._handleMissingPluralLinkField(field, dataID);
            if (linkedIDs != null) {
                this._mutator.setLinkedRecordIDs(dataID, storageKey, linkedIDs);
            } else if (linkedIDs === null) {
                this._mutator.setValue(dataID, storageKey, null);
            }
        }
        if (linkedIDs) {
            linkedIDs.forEach(function(linkedID) {
                if (linkedID != null) {
                    _this3._traverse(field, linkedID);
                }
            });
        }
    };
    _proto._checkActorChange = function _checkActorChange(field, dataID) {
        var storageKey = getStorageKey(field, this._variables);
        var record = this._source.get(dataID);
        var tuple = record != null ? RelayModernRecord.getActorLinkedRecordID(record, storageKey) : record;
        if (tuple == null) {
            if (tuple === undefined) {
                this._handleMissing();
            }
        } else {
            var actorIdentifier = tuple[0], linkedID = tuple[1];
            var prevSource = this._source;
            var prevMutator = this._mutator;
            var prevRecordSourceProxy = this._recordSourceProxy;
            var _this$_getMutatorAndR2 = this._getMutatorAndRecordProxyForActor(actorIdentifier), mutator = _this$_getMutatorAndR2[0], recordSourceProxy = _this$_getMutatorAndR2[1];
            this._source = this._getSourceForActor(actorIdentifier);
            this._mutator = mutator;
            this._recordSourceProxy = recordSourceProxy;
            this._assignClientAbstractTypes(field);
            this._traverse(field, linkedID);
            this._source = prevSource;
            this._mutator = prevMutator;
            this._recordSourceProxy = prevRecordSourceProxy;
        }
    };
    _proto._assignClientAbstractTypes = function _assignClientAbstractTypes(node) {
        var clientAbstractTypes = node.clientAbstractTypes;
        if (clientAbstractTypes != null) {
            for(var _i = 0, _Object$keys = Object.keys(clientAbstractTypes); _i < _Object$keys.length; _i++){
                var abstractType = _Object$keys[_i];
                var _iterator4 = (0, _createForOfIteratorHelper2["default"])(clientAbstractTypes[abstractType]), _step4;
                try {
                    for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                        var concreteType = _step4.value;
                        var typeID = generateTypeID(concreteType);
                        if (this._source.get(typeID) == null) {
                            this._mutator.create(typeID, TYPE_SCHEMA_TYPE);
                        }
                        if (this._mutator.getValue(typeID, abstractType) == null) {
                            this._mutator.setValue(typeID, abstractType, true);
                        }
                    }
                } catch (err) {
                    _iterator4.e(err);
                } finally{
                    _iterator4.f();
                }
            }
        }
    };
    return DataChecker;
}();
module.exports = {
    check: check
};
}),
"[project]/node_modules/relay-runtime/lib/util/shallowFreeze.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function shallowFreeze(value) {
    if (typeof value === 'object' && value != null && (Array.isArray(value) || value.constructor === Object)) {
        Object.freeze(value);
    }
};
}),
"[project]/node_modules/relay-runtime/lib/store/live-resolvers/getOutputTypeRecordIDs.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS = _require.RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function getOutputTypeRecordIDs(record) {
    var maybeOutputTypeRecordIDs = RelayModernRecord.getValue(record, RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS);
    if (maybeOutputTypeRecordIDs == null) {
        return null;
    }
    !(maybeOutputTypeRecordIDs instanceof Set) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'getOutputTypeRecordIDs: Expected the `%s` field on record `%s` to be of type Set. Instead, it is a %s.', RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS, typeof maybeOutputTypeRecordIDs) : "TURBOPACK unreachable" : void 0;
    return maybeOutputTypeRecordIDs;
}
module.exports = getOutputTypeRecordIDs;
}),
"[project]/node_modules/relay-runtime/lib/store/live-resolvers/isLiveStateValue.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function isLiveStateValue(v) {
    return v != null && typeof v === 'object' && typeof v.read === 'function' && typeof v.subscribe === 'function';
}
module.exports = isLiveStateValue;
}),
"[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverCache.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var recycleNodesInto = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/recycleNodesInto.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-rsc] (ecmascript)"), RELAY_LIVE_RESOLVER = _require.RELAY_LIVE_RESOLVER;
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-rsc] (ecmascript)");
var shallowFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/shallowFreeze.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-rsc] (ecmascript)"), generateClientID = _require2.generateClientID, generateClientObjectClientID = _require2.generateClientObjectClientID;
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-rsc] (ecmascript)"), createNormalizationSelector = _require3.createNormalizationSelector;
var RelayRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-rsc] (ecmascript)");
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayResponseNormalizer.js [app-rsc] (ecmascript)"), normalize = _require4.normalize;
var _require5 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), RELAY_RESOLVER_ERROR_KEY = _require5.RELAY_RESOLVER_ERROR_KEY, RELAY_RESOLVER_INVALIDATION_KEY = _require5.RELAY_RESOLVER_INVALIDATION_KEY, RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS = _require5.RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS, RELAY_RESOLVER_SNAPSHOT_KEY = _require5.RELAY_RESOLVER_SNAPSHOT_KEY, RELAY_RESOLVER_VALUE_KEY = _require5.RELAY_RESOLVER_VALUE_KEY, getReadTimeResolverStorageKey = _require5.getReadTimeResolverStorageKey, getStorageKey = _require5.getStorageKey;
var getOutputTypeRecordIDs = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/getOutputTypeRecordIDs.js [app-rsc] (ecmascript)");
var isLiveStateValue = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/isLiveStateValue.js [app-rsc] (ecmascript)");
var _require6 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverSuspenseSentinel.js [app-rsc] (ecmascript)"), isSuspenseSentinel = _require6.isSuspenseSentinel;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
var RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY = '__resolverLiveStateSubscription';
var RELAY_RESOLVER_LIVE_STATE_VALUE = '__resolverLiveStateValue';
var RELAY_RESOLVER_LIVE_STATE_DIRTY = '__resolverLiveStateDirty';
var RELAY_RESOLVER_RECORD_TYPENAME = '__RELAY_RESOLVER__';
var MODEL_PROPERTY_NAME = '__relay_model_instance';
function addDependencyEdge(edges, from, to) {
    var set = edges.get(from);
    if (!set) {
        set = new Set();
        edges.set(from, set);
    }
    set.add(to);
}
var LiveResolverCache = /*#__PURE__*/ function() {
    function LiveResolverCache(getRecordSource, store) {
        this._resolverIDToRecordIDs = new Map();
        this._recordIDToResolverIDs = new Map();
        this._getRecordSource = getRecordSource;
        this._store = store;
        this._handlingBatch = false;
        this._liveResolverBatchRecordSource = null;
    }
    var _proto = LiveResolverCache.prototype;
    _proto.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(recordID, field, variables, evaluate, getDataForResolverFragment) {
        var recordSource = this._getRecordSource();
        var record = expectRecord(recordSource, recordID);
        var storageKey = getReadTimeResolverStorageKey(field, variables);
        var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
        var linkedRecord = linkedID == null ? null : recordSource.get(linkedID);
        var updatedDataIDs;
        if (linkedRecord == null || this._isInvalid(linkedRecord, getDataForResolverFragment)) {
            var _linkedID;
            if (linkedRecord != null) {
                maybeUnsubscribeFromLiveState(linkedRecord);
            }
            linkedID = (_linkedID = linkedID) !== null && _linkedID !== void 0 ? _linkedID : generateClientID(recordID, storageKey);
            linkedRecord = RelayModernRecord.create(linkedID, RELAY_RESOLVER_RECORD_TYPENAME);
            var evaluationResult = evaluate();
            RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_SNAPSHOT_KEY, evaluationResult.snapshot);
            RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_ERROR_KEY, evaluationResult.error);
            if (field.kind === RELAY_LIVE_RESOLVER) {
                if (evaluationResult.resolverResult != null) {
                    if ("TURBOPACK compile-time truthy", 1) {
                        !isLiveStateValue(evaluationResult.resolverResult) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected the @live Relay Resolver backing the field "%s" to return a value ' + 'that implements LiveState. Did you mean to remove the @live annotation on this resolver?', field.path) : "TURBOPACK unreachable" : void 0;
                    }
                    !(evaluationResult.error == null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Did not expect resolver to have both a value and an error.') : "TURBOPACK unreachable" : void 0;
                    var liveState = evaluationResult.resolverResult;
                    updatedDataIDs = this._setLiveStateValue(linkedRecord, linkedID, liveState, field, variables);
                } else {
                    if ("TURBOPACK compile-time truthy", 1) {
                        var _evaluationResult$sna;
                        !(evaluationResult.error != null || ((_evaluationResult$sna = evaluationResult.snapshot) === null || _evaluationResult$sna === void 0 ? void 0 : _evaluationResult$sna.isMissingData)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected the @live Relay Resolver backing the field "%s" to return a value ' + 'that implements LiveState interface. The result for this field is `%s`, we also did not detect any errors, ' + 'or missing data during resolver execution. Did you mean to remove the @live annotation on this ' + 'resolver, or was there unexpected early return in the function?', field.path, String(evaluationResult.resolverResult)) : "TURBOPACK unreachable" : void 0;
                    }
                }
            } else {
                if ("TURBOPACK compile-time truthy", 1) {
                    !!isLiveStateValue(evaluationResult.resolverResult) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unexpected LiveState value returned from the non-@live Relay Resolver backing the field "%s". Did you intend to add @live to this resolver?', field.path) : "TURBOPACK unreachable" : void 0;
                }
                updatedDataIDs = this._setResolverValue(linkedRecord, evaluationResult.resolverResult, field, variables);
            }
            recordSource.set(linkedID, linkedRecord);
            var currentRecord = expectRecord(recordSource, recordID);
            var nextRecord = RelayModernRecord.clone(currentRecord);
            RelayModernRecord.setLinkedRecordID(nextRecord, storageKey, linkedID);
            recordSource.set(recordID, nextRecord);
            if (field.fragment != null) {
                var _evaluationResult$sna2;
                var fragmentStorageKey = getStorageKey(field.fragment, variables);
                var resolverID = generateClientID(recordID, fragmentStorageKey);
                addDependencyEdge(this._resolverIDToRecordIDs, resolverID, linkedID);
                addDependencyEdge(this._recordIDToResolverIDs, recordID, resolverID);
                var seenRecordIds = (_evaluationResult$sna2 = evaluationResult.snapshot) === null || _evaluationResult$sna2 === void 0 ? void 0 : _evaluationResult$sna2.seenRecords;
                if (seenRecordIds != null) {
                    var _iterator = (0, _createForOfIteratorHelper2["default"])(seenRecordIds), _step;
                    try {
                        for(_iterator.s(); !(_step = _iterator.n()).done;){
                            var seenRecordID = _step.value;
                            addDependencyEdge(this._recordIDToResolverIDs, seenRecordID, resolverID);
                        }
                    } catch (err) {
                        _iterator.e(err);
                    } finally{
                        _iterator.f();
                    }
                }
            }
        } else if (field.kind === RELAY_LIVE_RESOLVER && RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY)) {
            var _linkedID2;
            linkedID = (_linkedID2 = linkedID) !== null && _linkedID2 !== void 0 ? _linkedID2 : generateClientID(recordID, storageKey);
            linkedRecord = RelayModernRecord.clone(linkedRecord);
            var _liveState = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_VALUE);
            if (!isLiveStateValue(_liveState)) {
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unexpected LiveState value returned from Relay Resolver internal field `RELAY_RESOLVER_LIVE_STATE_VALUE`. ' + 'It is likely a bug in Relay, or a corrupt state of the relay store state ' + 'Field Path `%s`. Record `%s`.', field.path, JSON.stringify(linkedRecord)) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
            updatedDataIDs = this._setLiveResolverValue(linkedRecord, _liveState, field, variables);
            RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY, false);
            recordSource.set(linkedID, linkedRecord);
        }
        var answer = this._getResolverValue(linkedRecord);
        var snapshot = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_SNAPSHOT_KEY);
        var error = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_ERROR_KEY);
        var suspenseID = null;
        if (isSuspenseSentinel(answer)) {
            var _linkedID3;
            suspenseID = (_linkedID3 = linkedID) !== null && _linkedID3 !== void 0 ? _linkedID3 : generateClientID(recordID, storageKey);
        }
        return [
            answer,
            linkedID,
            error,
            snapshot,
            suspenseID,
            updatedDataIDs
        ];
    };
    _proto.getLiveResolverPromise = function getLiveResolverPromise(liveStateID) {
        var recordSource = this._getRecordSource();
        var liveStateRecord = recordSource.get(liveStateID);
        !(liveStateRecord != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected to find record for live resolver.') : "TURBOPACK unreachable" : void 0;
        var liveState = RelayModernRecord.getValue(liveStateRecord, RELAY_RESOLVER_LIVE_STATE_VALUE);
        return new Promise(function(resolve) {
            var unsubscribe = liveState.subscribe(function() {
                unsubscribe();
                resolve();
            });
        });
    };
    _proto._setLiveStateValue = function _setLiveStateValue(linkedRecord, linkedID, liveState, field, variables) {
        var handler = this._makeLiveStateHandler(linkedID);
        var unsubscribe = liveState.subscribe(handler);
        RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_VALUE, liveState);
        var updatedDataIDs = this._setLiveResolverValue(linkedRecord, liveState, field, variables);
        RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY, false);
        RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY, unsubscribe);
        return updatedDataIDs;
    };
    _proto._makeLiveStateHandler = function _makeLiveStateHandler(linkedID) {
        var _this = this;
        return function() {
            var currentSource = _this._getRecordSource();
            var currentRecord = currentSource.get(linkedID);
            if (!currentRecord) {
                return;
            }
            if (!RelayModernRecord.hasValue(currentRecord, RELAY_RESOLVER_LIVE_STATE_VALUE)) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Unexpected callback for a incomplete live resolver record (__id: `%s`). The record has missing live state value. ' + 'This is a no-op and indicates a memory leak, and possible bug in Relay Live Resolvers. ' + 'Possible cause: The original record was GC-ed, or was created with the optimistic record source.' + ' Record details: `%s`.', linkedID, JSON.stringify(currentRecord)) : "TURBOPACK unreachable";
                return;
            }
            var nextRecord = RelayModernRecord.clone(currentRecord);
            RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_LIVE_STATE_DIRTY, true);
            _this._setLiveResolverUpdate(linkedID, nextRecord);
        };
    };
    _proto._setLiveResolverUpdate = function _setLiveResolverUpdate(linkedId, record) {
        if (this._handlingBatch) {
            if (this._liveResolverBatchRecordSource == null) {
                this._liveResolverBatchRecordSource = RelayRecordSource.create();
            }
            this._liveResolverBatchRecordSource.set(linkedId, record);
        } else {
            var nextSource = RelayRecordSource.create();
            nextSource.set(linkedId, record);
            this._store.publish(nextSource);
            this._store.notify();
        }
    };
    _proto.batchLiveStateUpdates = function batchLiveStateUpdates(callback) {
        !!this._handlingBatch ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unexpected nested call to batchLiveStateUpdates.') : "TURBOPACK unreachable" : void 0;
        this._handlingBatch = true;
        try {
            callback();
        } finally{
            if (this._liveResolverBatchRecordSource != null) {
                this._store.publish(this._liveResolverBatchRecordSource);
                this._store.notify();
            }
            this._liveResolverBatchRecordSource = null;
            this._handlingBatch = false;
        }
    };
    _proto._setLiveResolverValue = function _setLiveResolverValue(resolverRecord, liveValue, field, variables) {
        var value = null;
        var resolverError = null;
        try {
            value = liveValue.read();
        } catch (e) {
            resolverError = e;
        }
        RelayModernRecord.setValue(resolverRecord, RELAY_RESOLVER_ERROR_KEY, resolverError);
        return this._setResolverValue(resolverRecord, value, field, variables);
    };
    _proto._setResolverValue = function _setResolverValue(resolverRecord, value, field, variables) {
        var normalizationInfo = field.normalizationInfo;
        var updatedDataIDs = null;
        if (value != null && normalizationInfo != null && !isSuspenseSentinel(value)) {
            var resolverValue;
            var prevOutputTypeRecordIDs = getOutputTypeRecordIDs(resolverRecord);
            var nextOutputTypeRecordIDs = new Set();
            var currentSource = this._getRecordSource();
            if (normalizationInfo.plural) {
                !Array.isArray(value) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '_setResolverValue: Expected array value for plural @outputType resolver.') : "TURBOPACK unreachable" : void 0;
                resolverValue = [];
                var nextSource = RelayRecordSource.create();
                for(var ii = 0; ii < value.length; ii++){
                    var currentValue = value[ii];
                    if (currentValue == null) {
                        continue;
                    }
                    !(typeof currentValue === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '_setResolverValue: Expected object value as the payload for the @outputType resolver.') : "TURBOPACK unreachable" : void 0;
                    var typename = getConcreteTypename(normalizationInfo, currentValue);
                    var outputTypeDataID = generateClientObjectClientID(typename, RelayModernRecord.getDataID(resolverRecord), ii);
                    var source = this._normalizeOutputTypeValue(outputTypeDataID, currentValue, variables, normalizationInfo, [
                        field.path,
                        String(ii)
                    ], typename);
                    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(source.getRecordIDs()), _step2;
                    try {
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                            var recordID = _step2.value;
                            nextSource.set(recordID, expectRecord(source, recordID));
                            nextOutputTypeRecordIDs.add(recordID);
                        }
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                    resolverValue.push(outputTypeDataID);
                }
                updatedDataIDs = updateCurrentSource(currentSource, nextSource, prevOutputTypeRecordIDs);
            } else {
                !(typeof value === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '_setResolverValue: Expected object value as the payload for the @outputType resolver.') : "TURBOPACK unreachable" : void 0;
                var _typename = getConcreteTypename(normalizationInfo, value);
                var _outputTypeDataID = generateClientObjectClientID(_typename, RelayModernRecord.getDataID(resolverRecord));
                var _nextSource = this._normalizeOutputTypeValue(_outputTypeDataID, value, variables, normalizationInfo, [
                    field.path
                ], _typename);
                var _iterator3 = (0, _createForOfIteratorHelper2["default"])(_nextSource.getRecordIDs()), _step3;
                try {
                    for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                        var _recordID = _step3.value;
                        nextOutputTypeRecordIDs.add(_recordID);
                    }
                } catch (err) {
                    _iterator3.e(err);
                } finally{
                    _iterator3.f();
                }
                resolverValue = _outputTypeDataID;
                updatedDataIDs = updateCurrentSource(currentSource, _nextSource, prevOutputTypeRecordIDs);
            }
            RelayModernRecord.setValue(resolverRecord, RELAY_RESOLVER_OUTPUT_TYPE_RECORD_IDS, nextOutputTypeRecordIDs);
            shallowFreeze(resolverValue);
            RelayModernRecord.setValue(resolverRecord, RELAY_RESOLVER_VALUE_KEY, resolverValue);
        } else {
            shallowFreeze(value);
            RelayModernRecord.setValue(resolverRecord, RELAY_RESOLVER_VALUE_KEY, value);
        }
        return updatedDataIDs;
    };
    _proto.notifyUpdatedSubscribers = function notifyUpdatedSubscribers(updatedDataIDs) {
        this._store.__notifyUpdatedSubscribers(updatedDataIDs);
    };
    _proto._getResolverValue = function _getResolverValue(resolverRecord) {
        return RelayModernRecord.getValue(resolverRecord, RELAY_RESOLVER_VALUE_KEY);
    };
    _proto.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {
        var recordSource = this._getRecordSource();
        var visited = new Set();
        var recordsToVisit = Array.from(updatedDataIDs);
        while(recordsToVisit.length){
            var recordID = recordsToVisit.pop();
            visited.add(recordID);
            updatedDataIDs.add(recordID);
            var fragmentSet = this._recordIDToResolverIDs.get(recordID);
            if (fragmentSet == null) {
                continue;
            }
            var _iterator4 = (0, _createForOfIteratorHelper2["default"])(fragmentSet), _step4;
            try {
                for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                    var fragment = _step4.value;
                    if (!visited.has(fragment)) {
                        visited.add(fragment);
                        var recordSet = this._resolverIDToRecordIDs.get(fragment);
                        if (recordSet == null) {
                            continue;
                        }
                        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(recordSet), _step5;
                        try {
                            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                                var anotherRecordID = _step5.value;
                                markInvalidatedResolverRecord(anotherRecordID, recordSource);
                                if (!visited.has(anotherRecordID)) {
                                    visited.add(anotherRecordID);
                                    recordsToVisit.push(anotherRecordID);
                                }
                            }
                        } catch (err) {
                            _iterator5.e(err);
                        } finally{
                            _iterator5.f();
                        }
                    }
                }
            } catch (err) {
                _iterator4.e(err);
            } finally{
                _iterator4.f();
            }
        }
    };
    _proto._isInvalid = function _isInvalid(record, getDataForResolverFragment) {
        if (!RelayModernRecord.getValue(record, RELAY_RESOLVER_INVALIDATION_KEY)) {
            return false;
        }
        var snapshot = RelayModernRecord.getValue(record, RELAY_RESOLVER_SNAPSHOT_KEY);
        var originalInputs = snapshot === null || snapshot === void 0 ? void 0 : snapshot.data;
        var readerSelector = snapshot === null || snapshot === void 0 ? void 0 : snapshot.selector;
        if (originalInputs == null || readerSelector == null) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Expected previous inputs and reader selector on resolver record with ID %s, but they were missing.', RelayModernRecord.getDataID(record)) : "TURBOPACK unreachable";
            return true;
        }
        var _getDataForResolverFr = getDataForResolverFragment(readerSelector), latestValues = _getDataForResolverFr.data;
        var recycled = recycleNodesInto(originalInputs, latestValues);
        if (recycled !== originalInputs) {
            return true;
        }
        if (RelayFeatureFlags.MARK_RESOLVER_VALUES_AS_CLEAN_AFTER_FRAGMENT_REREAD) {
            var nextRecord = RelayModernRecord.clone(record);
            RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, false);
            var recordSource = this._getRecordSource();
            recordSource.set(RelayModernRecord.getDataID(record), nextRecord);
        }
        return false;
    };
    _proto._normalizeOutputTypeValue = function _normalizeOutputTypeValue(outputTypeDataID, value, variables, normalizationInfo, fieldPath, typename) {
        var source = RelayRecordSource.create();
        switch(normalizationInfo.kind){
            case 'OutputType':
                {
                    var record = RelayModernRecord.create(outputTypeDataID, typename);
                    source.set(outputTypeDataID, record);
                    var selector = createNormalizationSelector(normalizationInfo.normalizationNode, outputTypeDataID, variables);
                    var useExecTimeResolvers = false;
                    var normalizationOptions = this._store.__getNormalizationOptions(fieldPath);
                    return normalize(source, selector, value, normalizationOptions, undefined, useExecTimeResolvers).source;
                }
            case 'WeakModel':
                {
                    var _record = RelayModernRecord.create(outputTypeDataID, typename);
                    RelayModernRecord.setValue(_record, MODEL_PROPERTY_NAME, value);
                    source.set(outputTypeDataID, _record);
                    return source;
                }
            default:
                normalizationInfo.kind;
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'LiveResolverCache: Unexpected normalization info kind `%s`.', normalizationInfo.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
    };
    _proto.ensureClientRecord = function ensureClientRecord(id, typeName) {
        var key = generateClientObjectClientID(typeName, id);
        var recordSource = this._getRecordSource();
        if (!recordSource.has(key)) {
            var newRecord = RelayModernRecord.create(key, typeName);
            RelayModernRecord.setValue(newRecord, 'id', id);
            recordSource.set(key, newRecord);
        }
        return key;
    };
    _proto.unsubscribeFromLiveResolverRecords = function unsubscribeFromLiveResolverRecords(invalidatedDataIDs) {
        return unsubscribeFromLiveResolverRecordsImpl(this._getRecordSource(), invalidatedDataIDs);
    };
    _proto.invalidateResolverRecords = function invalidateResolverRecords(invalidatedDataIDs) {
        if (invalidatedDataIDs.size === 0) {
            return;
        }
        var _iterator6 = (0, _createForOfIteratorHelper2["default"])(invalidatedDataIDs), _step6;
        try {
            for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){
                var dataID = _step6.value;
                var record = this._getRecordSource().get(dataID);
                if (record != null && isResolverRecord(record)) {
                    this._getRecordSource()["delete"](dataID);
                }
            }
        } catch (err) {
            _iterator6.e(err);
        } finally{
            _iterator6.f();
        }
    };
    return LiveResolverCache;
}();
function updateCurrentSource(currentSource, nextSource, prevOutputTypeRecordIDs) {
    var updatedDataIDs = new Set();
    if (prevOutputTypeRecordIDs != null) {
        var _iterator7 = (0, _createForOfIteratorHelper2["default"])(prevOutputTypeRecordIDs), _step7;
        try {
            for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){
                var recordID = _step7.value;
                if (!nextSource.has(recordID)) {
                    updatedDataIDs.add(recordID);
                    currentSource.remove(recordID);
                }
            }
        } catch (err) {
            _iterator7.e(err);
        } finally{
            _iterator7.f();
        }
    }
    var _iterator8 = (0, _createForOfIteratorHelper2["default"])(nextSource.getRecordIDs()), _step8;
    try {
        for(_iterator8.s(); !(_step8 = _iterator8.n()).done;){
            var _recordID2 = _step8.value;
            var nextRecord = expectRecord(nextSource, _recordID2);
            if (currentSource.has(_recordID2)) {
                var currentRecord = expectRecord(currentSource, _recordID2);
                var updatedRecord = RelayModernRecord.update(currentRecord, nextRecord);
                if (updatedRecord !== currentRecord) {
                    updatedDataIDs.add(_recordID2);
                    currentSource.set(_recordID2, updatedRecord);
                    markInvalidatedLinkedResolverRecords(currentRecord, currentSource);
                }
            } else {
                currentSource.set(_recordID2, nextRecord);
            }
        }
    } catch (err) {
        _iterator8.e(err);
    } finally{
        _iterator8.f();
    }
    return updatedDataIDs;
}
function getAllLinkedRecordIds(record) {
    var linkedRecordIDs = new Set();
    RelayModernRecord.getFields(record).forEach(function(field) {
        if (RelayModernRecord.hasLinkedRecordID(record, field)) {
            var linkedRecordID = RelayModernRecord.getLinkedRecordID(record, field);
            if (linkedRecordID != null) {
                linkedRecordIDs.add(linkedRecordID);
            }
        } else if (RelayModernRecord.hasLinkedRecordIDs(record, field)) {
            var _RelayModernRecord$ge;
            (_RelayModernRecord$ge = RelayModernRecord.getLinkedRecordIDs(record, field)) === null || _RelayModernRecord$ge === void 0 ? void 0 : _RelayModernRecord$ge.forEach(function(linkedRecordID) {
                if (linkedRecordID != null) {
                    linkedRecordIDs.add(linkedRecordID);
                }
            });
        }
    });
    return linkedRecordIDs;
}
function markInvalidatedResolverRecord(dataID, recordSource) {
    var record = recordSource.get(dataID);
    if (!record) {
        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Expected a resolver record with ID %s, but it was missing.', dataID) : "TURBOPACK unreachable";
        return;
    }
    var nextRecord = RelayModernRecord.clone(record);
    RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, true);
    recordSource.set(dataID, nextRecord);
}
function markInvalidatedLinkedResolverRecords(record, recordSource) {
    var currentLinkedDataIDs = getAllLinkedRecordIds(record);
    var _iterator9 = (0, _createForOfIteratorHelper2["default"])(currentLinkedDataIDs), _step9;
    try {
        for(_iterator9.s(); !(_step9 = _iterator9.n()).done;){
            var recordID = _step9.value;
            var _record2 = recordSource.get(recordID);
            if (_record2 != null && isResolverRecord(_record2)) {
                markInvalidatedResolverRecord(recordID, recordSource);
            }
        }
    } catch (err) {
        _iterator9.e(err);
    } finally{
        _iterator9.f();
    }
}
function unsubscribeFromLiveResolverRecordsImpl(recordSource, invalidatedDataIDs) {
    if (invalidatedDataIDs.size === 0) {
        return;
    }
    var _iterator10 = (0, _createForOfIteratorHelper2["default"])(invalidatedDataIDs), _step10;
    try {
        for(_iterator10.s(); !(_step10 = _iterator10.n()).done;){
            var dataID = _step10.value;
            var record = recordSource.get(dataID);
            if (record != null && isResolverRecord(record)) {
                maybeUnsubscribeFromLiveState(record);
            }
        }
    } catch (err) {
        _iterator10.e(err);
    } finally{
        _iterator10.f();
    }
}
function isResolverRecord(record) {
    return RelayModernRecord.getType(record) === RELAY_RESOLVER_RECORD_TYPENAME;
}
function maybeUnsubscribeFromLiveState(linkedRecord) {
    var previousUnsubscribe = RelayModernRecord.getValue(linkedRecord, RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY);
    if (previousUnsubscribe != null) {
        previousUnsubscribe();
    }
}
function expectRecord(source, recordID) {
    var record = source.get(recordID);
    !(record != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected a record with ID `%s` to exist in the record source.', recordID) : "TURBOPACK unreachable" : void 0;
    return record;
}
function getUpdatedDataIDs(updatedRecords) {
    return updatedRecords;
}
function getConcreteTypename(normalizationInfo, currentValue) {
    var _normalizationInfo$co;
    var typename = (_normalizationInfo$co = normalizationInfo.concreteType) !== null && _normalizationInfo$co !== void 0 ? _normalizationInfo$co : currentValue.__typename;
    !(typename != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'normalizationInfo.concreteType should not be null, or the value returned from the resolver should include a __typename field, ' + 'or the resolver should have a flow error. If not, this indicates a bug in Relay.') : "TURBOPACK unreachable" : void 0;
    return typename;
}
module.exports = {
    LiveResolverCache: LiveResolverCache,
    getUpdatedDataIDs: getUpdatedDataIDs,
    RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY: RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayOptimisticRecordSource.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)");
var RelayRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var UNPUBLISH_RECORD_SENTINEL = RelayModernRecord.fromObject(Object.freeze({
    __UNPUBLISH_RECORD_SENTINEL: true
}));
var RelayOptimisticRecordSource = /*#__PURE__*/ function() {
    function RelayOptimisticRecordSource(base) {
        this._base = base;
        this._sink = RelayRecordSource.create();
    }
    var _proto = RelayOptimisticRecordSource.prototype;
    _proto.has = function has(dataID) {
        if (this._sink.has(dataID)) {
            var sinkRecord = this._sink.get(dataID);
            return sinkRecord !== UNPUBLISH_RECORD_SENTINEL;
        } else {
            return this._base.has(dataID);
        }
    };
    _proto.get = function get(dataID) {
        if (this._sink.has(dataID)) {
            var sinkRecord = this._sink.get(dataID);
            if (sinkRecord === UNPUBLISH_RECORD_SENTINEL) {
                return undefined;
            } else {
                return sinkRecord;
            }
        } else {
            return this._base.get(dataID);
        }
    };
    _proto.getStatus = function getStatus(dataID) {
        var record = this.get(dataID);
        if (record === undefined) {
            return 'UNKNOWN';
        } else if (record === null) {
            return 'NONEXISTENT';
        } else {
            return 'EXISTENT';
        }
    };
    _proto.clear = function clear() {
        this._base = RelayRecordSource.create();
        this._sink.clear();
    };
    _proto["delete"] = function _delete(dataID) {
        this._sink["delete"](dataID);
    };
    _proto.remove = function remove(dataID) {
        this._sink.set(dataID, UNPUBLISH_RECORD_SENTINEL);
    };
    _proto.set = function set(dataID, record) {
        this._sink.set(dataID, record);
    };
    _proto.getRecordIDs = function getRecordIDs() {
        return Object.keys(this.toJSON());
    };
    _proto.size = function size() {
        return Object.keys(this.toJSON()).length;
    };
    _proto.toJSON = function toJSON() {
        var _this = this;
        var merged = (0, _objectSpread2["default"])({}, this._base.toJSON());
        this._sink.getRecordIDs().forEach(function(dataID) {
            var record = _this.get(dataID);
            if (record === undefined) {
                delete merged[dataID];
            } else {
                merged[dataID] = RelayModernRecord.toJSON(record);
            }
        });
        return merged;
    };
    _proto.getOptimisticRecordIDs = function getOptimisticRecordIDs() {
        return new Set(this._sink.getRecordIDs());
    };
    return RelayOptimisticRecordSource;
}();
function create(base) {
    return new RelayOptimisticRecordSource(base);
}
function getOptimisticRecordIDs(source) {
    !(source instanceof RelayOptimisticRecordSource) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'getOptimisticRecordIDs: Instance of RelayOptimisticRecordSource is expected') : "TURBOPACK unreachable" : void 0;
    return source.getOptimisticRecordIDs();
}
module.exports = {
    create: create,
    getOptimisticRecordIDs: getOptimisticRecordIDs
};
}),
"[project]/node_modules/relay-runtime/lib/store/ResolverCache.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-rsc] (ecmascript)"), RELAY_LIVE_RESOLVER = _require.RELAY_LIVE_RESOLVER;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var NoopResolverCache = /*#__PURE__*/ function() {
    function NoopResolverCache() {}
    var _proto = NoopResolverCache.prototype;
    _proto.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(recordID, field, variables, evaluate, getDataForResolverFragment) {
        !(field.kind !== RELAY_LIVE_RESOLVER) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'This store does not support Live Resolvers') : "TURBOPACK unreachable" : void 0;
        var _evaluate = evaluate(), resolverResult = _evaluate.resolverResult, snapshot = _evaluate.snapshot, error = _evaluate.error;
        return [
            resolverResult,
            undefined,
            error,
            snapshot,
            undefined,
            undefined
        ];
    };
    _proto.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {};
    _proto.ensureClientRecord = function ensureClientRecord(id, typeName) {
        ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Client Edges to Client Objects are not supported in this version of Relay Store') : "TURBOPACK unreachable" : "TURBOPACK unreachable";
    };
    _proto.notifyUpdatedSubscribers = function notifyUpdatedSubscribers(updatedDataIDs) {};
    return NoopResolverCache;
}();
module.exports = {
    NoopResolverCache: NoopResolverCache
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayReader.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js [app-rsc] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-rsc] (ecmascript)"));
var _excluded = [
    "message"
];
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverSuspenseSentinel.js [app-rsc] (ecmascript)"), isSuspenseSentinel = _require.isSuspenseSentinel;
var RelayConcreteVariables = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-rsc] (ecmascript)");
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), CLIENT_EDGE_TRAVERSAL_PATH = _require2.CLIENT_EDGE_TRAVERSAL_PATH, FRAGMENT_OWNER_KEY = _require2.FRAGMENT_OWNER_KEY, FRAGMENT_PROP_NAME_KEY = _require2.FRAGMENT_PROP_NAME_KEY, FRAGMENTS_KEY = _require2.FRAGMENTS_KEY, ID_KEY = _require2.ID_KEY, MODULE_COMPONENT_KEY = _require2.MODULE_COMPONENT_KEY, ROOT_ID = _require2.ROOT_ID, getArgumentValues = _require2.getArgumentValues, getModuleComponentKey = _require2.getModuleComponentKey, getStorageKey = _require2.getStorageKey;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ResolverCache.js [app-rsc] (ecmascript)"), NoopResolverCache = _require3.NoopResolverCache;
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ResolverFragments.js [app-rsc] (ecmascript)"), RESOLVER_FRAGMENT_ERRORED_SENTINEL = _require4.RESOLVER_FRAGMENT_ERRORED_SENTINEL, withResolverContext = _require4.withResolverContext;
var _require5 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/TypeID.js [app-rsc] (ecmascript)"), generateTypeID = _require5.generateTypeID;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function read(recordSource, selector, resolverCache, resolverContext) {
    var reader = new RelayReader(recordSource, selector, resolverCache !== null && resolverCache !== void 0 ? resolverCache : new NoopResolverCache(), resolverContext);
    return reader.read();
}
var RelayReader = /*#__PURE__*/ function() {
    function RelayReader(recordSource, selector, resolverCache, resolverContext) {
        var _selector$clientEdgeT, _ref, _this$_owner$node$ope, _this$_owner$node$ope2;
        this._clientEdgeTraversalPath = (_selector$clientEdgeT = selector.clientEdgeTraversalPath) !== null && _selector$clientEdgeT !== void 0 && _selector$clientEdgeT.length ? (0, _toConsumableArray2["default"])(selector.clientEdgeTraversalPath) : [];
        this._missingClientEdges = [];
        this._missingLiveResolverFields = [];
        this._isMissingData = false;
        this._isWithinUnmatchedTypeRefinement = false;
        this._fieldErrors = null;
        this._owner = selector.owner;
        this._useExecTimeResolvers = (_ref = (_this$_owner$node$ope = this._owner.node.operation.use_exec_time_resolvers) !== null && _this$_owner$node$ope !== void 0 ? _this$_owner$node$ope : ((_this$_owner$node$ope2 = this._owner.node.operation.exec_time_resolvers_enabled_provider) === null || _this$_owner$node$ope2 === void 0 ? void 0 : _this$_owner$node$ope2.get()) === true) !== null && _ref !== void 0 ? _ref : false;
        this._recordSource = recordSource;
        this._seenRecords = new Set();
        this._selector = selector;
        this._variables = selector.variables;
        this._resolverCache = resolverCache;
        this._fragmentName = selector.node.name;
        this._updatedDataIDs = new Set();
        this._resolverContext = resolverContext;
    }
    var _proto = RelayReader.prototype;
    _proto.read = function read() {
        var _this$_selector$node$;
        var _this$_selector = this._selector, node = _this$_selector.node, dataID = _this$_selector.dataID, isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;
        var abstractKey = node.abstractKey;
        var record = this._recordSource.get(dataID);
        var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement;
        if (isDataExpectedToBePresent && abstractKey == null && record != null) {
            if (!this._recordMatchesTypeCondition(record, node.type)) {
                isDataExpectedToBePresent = false;
            }
        }
        if (isDataExpectedToBePresent && abstractKey != null && record != null) {
            var implementsInterface = this._implementsInterface(record, abstractKey);
            if (implementsInterface === false) {
                isDataExpectedToBePresent = false;
            }
        }
        this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;
        var data = this._traverse(node, dataID, null);
        var catchTo = (_this$_selector$node$ = this._selector.node.metadata) === null || _this$_selector$node$ === void 0 ? void 0 : _this$_selector$node$.catchTo;
        if (catchTo != null) {
            data = this._catchErrors(data, catchTo, null);
        }
        if (this._updatedDataIDs.size > 0) {
            this._resolverCache.notifyUpdatedSubscribers(this._updatedDataIDs);
            this._updatedDataIDs.clear();
        }
        return {
            data: data,
            isMissingData: this._isMissingData && isDataExpectedToBePresent,
            missingClientEdges: this._missingClientEdges.length ? this._missingClientEdges : null,
            missingLiveResolverFields: this._missingLiveResolverFields,
            seenRecords: this._seenRecords,
            selector: this._selector,
            fieldErrors: this._fieldErrors
        };
    };
    _proto._maybeAddFieldErrors = function _maybeAddFieldErrors(record, storageKey) {
        var errors = RelayModernRecord.getErrors(record, storageKey);
        if (errors == null) {
            return;
        }
        var owner = this._fragmentName;
        if (this._fieldErrors == null) {
            this._fieldErrors = [];
        }
        for(var i = 0; i < errors.length; i++){
            var _error$path, _this$_selector$node$2, _this$_selector$node$3;
            var error = errors[i];
            this._fieldErrors.push({
                kind: 'relay_field_payload.error',
                owner: owner,
                fieldPath: ((_error$path = error.path) !== null && _error$path !== void 0 ? _error$path : []).join('.'),
                error: error,
                shouldThrow: (_this$_selector$node$2 = (_this$_selector$node$3 = this._selector.node.metadata) === null || _this$_selector$node$3 === void 0 ? void 0 : _this$_selector$node$3.throwOnFieldError) !== null && _this$_selector$node$2 !== void 0 ? _this$_selector$node$2 : false,
                handled: false,
                uiContext: undefined
            });
        }
    };
    _proto._markDataAsMissing = function _markDataAsMissing(fieldName) {
        var _this$_selector$node$4, _this$_selector$node$5;
        if (this._isWithinUnmatchedTypeRefinement) {
            return;
        }
        if (this._fieldErrors == null) {
            this._fieldErrors = [];
        }
        var owner = this._fragmentName;
        this._fieldErrors.push(((_this$_selector$node$4 = (_this$_selector$node$5 = this._selector.node.metadata) === null || _this$_selector$node$5 === void 0 ? void 0 : _this$_selector$node$5.throwOnFieldError) !== null && _this$_selector$node$4 !== void 0 ? _this$_selector$node$4 : false) ? {
            kind: 'missing_expected_data.throw',
            owner: owner,
            fieldPath: fieldName,
            handled: false,
            uiContext: undefined
        } : {
            kind: 'missing_expected_data.log',
            owner: owner,
            fieldPath: fieldName,
            uiContext: undefined
        });
        this._isMissingData = true;
        if (this._clientEdgeTraversalPath.length) {
            var top = this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1];
            if (top !== null) {
                this._missingClientEdges.push({
                    request: top.readerClientEdge.operation,
                    clientEdgeDestinationID: top.clientEdgeDestinationID
                });
            }
        }
    };
    _proto._traverse = function _traverse(node, dataID, prevData) {
        var record = this._recordSource.get(dataID);
        this._seenRecords.add(dataID);
        if (record == null) {
            if (record === undefined) {
                this._markDataAsMissing('<record>');
            }
            return record;
        }
        var data = prevData || {};
        var hadRequiredData = this._traverseSelections(node.selections, record, data);
        return hadRequiredData ? data : null;
    };
    _proto._getVariableValue = function _getVariableValue(name) {
        !this._variables.hasOwnProperty(name) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Undefined variable `%s`.', name) : "TURBOPACK unreachable" : void 0;
        return this._variables[name];
    };
    _proto._maybeReportUnexpectedNull = function _maybeReportUnexpectedNull(selection) {
        if (selection.action === 'NONE') {
            return;
        }
        var owner = this._fragmentName;
        if (this._fieldErrors == null) {
            this._fieldErrors = [];
        }
        var fieldName;
        if (selection.field.linkedField != null) {
            var _selection$field$link;
            fieldName = (_selection$field$link = selection.field.linkedField.alias) !== null && _selection$field$link !== void 0 ? _selection$field$link : selection.field.linkedField.name;
        } else {
            var _selection$field$alia;
            fieldName = (_selection$field$alia = selection.field.alias) !== null && _selection$field$alia !== void 0 ? _selection$field$alia : selection.field.name;
        }
        switch(selection.action){
            case 'THROW':
                this._fieldErrors.push({
                    kind: 'missing_required_field.throw',
                    fieldPath: fieldName,
                    owner: owner,
                    handled: false,
                    uiContext: undefined
                });
                return;
            case 'LOG':
                this._fieldErrors.push({
                    kind: 'missing_required_field.log',
                    fieldPath: fieldName,
                    owner: owner,
                    uiContext: undefined
                });
                return;
            default:
                selection.action;
        }
    };
    _proto._handleRequiredFieldValue = function _handleRequiredFieldValue(selection, value) {
        if (value == null) {
            this._maybeReportUnexpectedNull(selection);
            return false;
        }
        return true;
    };
    _proto._catchErrors = function _catchErrors(_value, to, previousResponseFields) {
        var value = _value;
        switch(to){
            case 'RESULT':
                value = this._asResult(_value);
                break;
            case 'NULL':
                if (this._fieldErrors != null && this._fieldErrors.length > 0) {
                    value = null;
                }
                break;
            default:
                to;
        }
        var childrenFieldErrors = this._fieldErrors;
        this._fieldErrors = previousResponseFields;
        if (childrenFieldErrors != null) {
            if (this._fieldErrors == null) {
                this._fieldErrors = [];
            }
            for(var i = 0; i < childrenFieldErrors.length; i++){
                this._fieldErrors.push(markFieldErrorHasHandled(childrenFieldErrors[i]));
            }
        }
        return value;
    };
    _proto._asResult = function _asResult(value) {
        if (this._fieldErrors == null || this._fieldErrors.length === 0) {
            return {
                ok: true,
                value: value
            };
        }
        var errors = this._fieldErrors.map(function(error) {
            switch(error.kind){
                case 'relay_field_payload.error':
                    var _error$error = error.error, message = _error$error.message, displayError = (0, _objectWithoutPropertiesLoose2["default"])(_error$error, _excluded);
                    return displayError;
                case 'missing_expected_data.throw':
                case 'missing_expected_data.log':
                    return {
                        path: error.fieldPath.split('.')
                    };
                case 'relay_resolver.error':
                    return {
                        message: "Relay: Error in resolver for field at ".concat(error.fieldPath, " in ").concat(error.owner)
                    };
                case 'missing_required_field.throw':
                    return {
                        message: "Relay: Missing @required value at path '".concat(error.fieldPath, "' in '").concat(error.owner, "'.")
                    };
                case 'missing_required_field.log':
                    return null;
                default:
                    error.kind;
                    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unexpected error fieldError kind: %s', error.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
        }).filter(Boolean);
        return {
            ok: false,
            errors: errors
        };
    };
    _proto._traverseSelections = function _traverseSelections(selections, record, data) {
        for(var i = 0; i < selections.length; i++){
            var selection = selections[i];
            switch(selection.kind){
                case 'RequiredField':
                    var requiredFieldValue = this._readClientSideDirectiveField(selection, record, data);
                    if (!this._handleRequiredFieldValue(selection, requiredFieldValue)) {
                        return false;
                    }
                    break;
                case 'CatchField':
                    {
                        var _selection$field$back, _selection$field, _field$alias;
                        var previousResponseFields = this._fieldErrors;
                        this._fieldErrors = null;
                        var catchFieldValue = this._readClientSideDirectiveField(selection, record, data);
                        var field = (_selection$field$back = (_selection$field = selection.field) === null || _selection$field === void 0 ? void 0 : _selection$field.backingField) !== null && _selection$field$back !== void 0 ? _selection$field$back : selection.field;
                        var fieldName = (_field$alias = field === null || field === void 0 ? void 0 : field.alias) !== null && _field$alias !== void 0 ? _field$alias : field === null || field === void 0 ? void 0 : field.name;
                        !(fieldName != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, "Couldn't determine field name for this field. It might be a ReaderClientExtension - which is not yet supported.") : "TURBOPACK unreachable" : void 0;
                        data[fieldName] = this._catchErrors(catchFieldValue, selection.to, previousResponseFields);
                        break;
                    }
                case 'ScalarField':
                    this._readScalar(selection, record, data);
                    break;
                case 'LinkedField':
                    if (selection.plural) {
                        this._readPluralLink(selection, record, data);
                    } else {
                        this._readLink(selection, record, data);
                    }
                    break;
                case 'Condition':
                    var conditionValue = Boolean(this._getVariableValue(selection.condition));
                    if (conditionValue === selection.passingValue) {
                        var hasExpectedData = this._traverseSelections(selection.selections, record, data);
                        if (!hasExpectedData) {
                            return false;
                        }
                    }
                    break;
                case 'InlineFragment':
                    {
                        var _hasExpectedData = this._readInlineFragment(selection, record, data, false);
                        if (_hasExpectedData === false) {
                            return false;
                        }
                        break;
                    }
                case 'RelayLiveResolver':
                case 'RelayResolver':
                    {
                        if (this._useExecTimeResolvers) {
                            this._readScalar(selection, record, data);
                        } else {
                            this._readResolverField(selection, record, data);
                        }
                        break;
                    }
                case 'FragmentSpread':
                    this._createFragmentPointer(selection, record, data);
                    break;
                case 'AliasedInlineFragmentSpread':
                    {
                        this._readAliasedInlineFragment(selection, record, data);
                        break;
                    }
                case 'ModuleImport':
                    this._readModuleImport(selection, record, data);
                    break;
                case 'InlineDataFragmentSpread':
                    this._createInlineDataOrResolverFragmentPointer(selection, record, data);
                    break;
                case 'Defer':
                case 'ClientExtension':
                    {
                        var isMissingData = this._isMissingData;
                        var alreadyMissingClientEdges = this._missingClientEdges.length;
                        this._clientEdgeTraversalPath.push(null);
                        var _hasExpectedData2 = this._traverseSelections(selection.selections, record, data);
                        this._isMissingData = isMissingData || this._missingClientEdges.length > alreadyMissingClientEdges || this._missingLiveResolverFields.length > 0;
                        this._clientEdgeTraversalPath.pop();
                        if (!_hasExpectedData2) {
                            return false;
                        }
                        break;
                    }
                case 'Stream':
                    {
                        var _hasExpectedData3 = this._traverseSelections(selection.selections, record, data);
                        if (!_hasExpectedData3) {
                            return false;
                        }
                        break;
                    }
                case 'ActorChange':
                    this._readActorChange(selection, record, data);
                    break;
                case 'ClientEdgeToClientObject':
                case 'ClientEdgeToServerObject':
                    if (this._useExecTimeResolvers && (selection.backingField.kind === 'RelayResolver' || selection.backingField.kind === 'RelayLiveResolver')) {
                        var linkedField = selection.linkedField;
                        if (linkedField.plural) {
                            this._readPluralLink(linkedField, record, data);
                        } else {
                            this._readLink(linkedField, record, data);
                        }
                    } else {
                        this._readClientEdge(selection, record, data);
                    }
                    break;
                default:
                    selection;
                    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
        }
        return true;
    };
    _proto._readClientSideDirectiveField = function _readClientSideDirectiveField(selection, record, data) {
        switch(selection.field.kind){
            case 'ScalarField':
                return this._readScalar(selection.field, record, data);
            case 'LinkedField':
                if (selection.field.plural) {
                    return this._readPluralLink(selection.field, record, data);
                } else {
                    return this._readLink(selection.field, record, data);
                }
            case 'RelayResolver':
            case 'RelayLiveResolver':
                {
                    if (this._useExecTimeResolvers) {
                        return this._readScalar(selection.field, record, data);
                    } else {
                        return this._readResolverField(selection.field, record, data);
                    }
                }
            case 'ClientEdgeToClientObject':
            case 'ClientEdgeToServerObject':
                if (this._useExecTimeResolvers && (selection.field.backingField.kind === 'RelayResolver' || selection.field.backingField.kind === 'RelayLiveResolver')) {
                    var field = selection.field;
                    if (field.linkedField.plural) {
                        return this._readPluralLink(field.linkedField, record, data);
                    } else {
                        return this._readLink(field.linkedField, record, data);
                    }
                } else {
                    return this._readClientEdge(selection.field, record, data);
                }
            case 'AliasedInlineFragmentSpread':
                return this._readAliasedInlineFragment(selection.field, record, data);
            default:
                selection.field.kind;
                ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.field.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
        }
    };
    _proto._readResolverField = function _readResolverField(field, record, data) {
        var _field$alias2;
        var parentRecordID = RelayModernRecord.getDataID(record);
        var prevErrors = this._fieldErrors;
        this._fieldErrors = null;
        var result = this._readResolverFieldImpl(field, parentRecordID);
        var fieldName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;
        this._prependPreviousErrors(prevErrors, fieldName);
        data[fieldName] = result;
        return result;
    };
    _proto._readResolverFieldImpl = function _readResolverFieldImpl(field, parentRecordID) {
        var _this = this;
        var fragment = field.fragment;
        var snapshot;
        var getDataForResolverFragment = function getDataForResolverFragment(singularReaderSelector) {
            if (snapshot != null) {
                return {
                    data: snapshot.data,
                    isMissingData: snapshot.isMissingData,
                    fieldErrors: snapshot.fieldErrors
                };
            }
            snapshot = read(_this._recordSource, singularReaderSelector, _this._resolverCache);
            return {
                data: snapshot.data,
                isMissingData: snapshot.isMissingData,
                fieldErrors: snapshot.fieldErrors
            };
        };
        var evaluate = function evaluate() {
            if (fragment != null) {
                var key = {
                    __id: parentRecordID,
                    __fragmentOwner: _this._owner,
                    __fragments: (0, _defineProperty2["default"])({}, fragment.name, fragment.args ? getArgumentValues(fragment.args, _this._variables) : {})
                };
                if (_this._clientEdgeTraversalPath.length > 0 && _this._clientEdgeTraversalPath[_this._clientEdgeTraversalPath.length - 1] !== null) {
                    key[CLIENT_EDGE_TRAVERSAL_PATH] = (0, _toConsumableArray2["default"])(_this._clientEdgeTraversalPath);
                }
                var resolverContext = {
                    getDataForResolverFragment: getDataForResolverFragment
                };
                return withResolverContext(resolverContext, function() {
                    var _getResolverValue = getResolverValue(field, _this._variables, key, _this._resolverContext), resolverResult = _getResolverValue[0], resolverError = _getResolverValue[1];
                    return {
                        resolverResult: resolverResult,
                        snapshot: snapshot,
                        error: resolverError
                    };
                });
            } else {
                var _getResolverValue2 = getResolverValue(field, _this._variables, null, _this._resolverContext), resolverResult = _getResolverValue2[0], _resolverError = _getResolverValue2[1];
                return {
                    resolverResult: resolverResult,
                    snapshot: undefined,
                    error: _resolverError
                };
            }
        };
        var _this$_resolverCache$ = this._resolverCache.readFromCacheOrEvaluate(parentRecordID, field, this._variables, evaluate, getDataForResolverFragment), result = _this$_resolverCache$[0], seenRecord = _this$_resolverCache$[1], resolverError = _this$_resolverCache$[2], cachedSnapshot = _this$_resolverCache$[3], suspenseID = _this$_resolverCache$[4], updatedDataIDs = _this$_resolverCache$[5];
        this._propagateResolverMetadata(field.path, cachedSnapshot, resolverError, seenRecord, suspenseID, updatedDataIDs);
        return result;
    };
    _proto._propagateResolverMetadata = function _propagateResolverMetadata(fieldPath, cachedSnapshot, resolverError, seenRecord, suspenseID, updatedDataIDs) {
        var _this2 = this;
        if (cachedSnapshot != null) {
            if (cachedSnapshot.missingClientEdges != null) {
                for(var i = 0; i < cachedSnapshot.missingClientEdges.length; i++){
                    var missing = cachedSnapshot.missingClientEdges[i];
                    this._missingClientEdges.push(missing);
                }
            }
            if (cachedSnapshot.missingLiveResolverFields != null) {
                this._isMissingData = this._isMissingData || cachedSnapshot.missingLiveResolverFields.length > 0;
                for(var _i = 0; _i < cachedSnapshot.missingLiveResolverFields.length; _i++){
                    var missingResolverField = cachedSnapshot.missingLiveResolverFields[_i];
                    this._missingLiveResolverFields.push(missingResolverField);
                }
            }
            if (cachedSnapshot.fieldErrors != null) {
                if (this._fieldErrors == null) {
                    this._fieldErrors = [];
                }
                for(var _i2 = 0; _i2 < cachedSnapshot.fieldErrors.length; _i2++){
                    var _this$_selector$node$6;
                    var error = cachedSnapshot.fieldErrors[_i2];
                    if (((_this$_selector$node$6 = this._selector.node.metadata) === null || _this$_selector$node$6 === void 0 ? void 0 : _this$_selector$node$6.throwOnFieldError) === true) {
                        this._fieldErrors.push(error);
                    } else {
                        this._fieldErrors.push(markFieldErrorHasHandled(error));
                    }
                }
            }
            this._isMissingData = this._isMissingData || cachedSnapshot.isMissingData;
        }
        if (resolverError) {
            var _this$_selector$node$7, _this$_selector$node$8;
            var errorEvent = {
                kind: 'relay_resolver.error',
                fieldPath: fieldPath,
                owner: this._fragmentName,
                error: resolverError,
                shouldThrow: (_this$_selector$node$7 = (_this$_selector$node$8 = this._selector.node.metadata) === null || _this$_selector$node$8 === void 0 ? void 0 : _this$_selector$node$8.throwOnFieldError) !== null && _this$_selector$node$7 !== void 0 ? _this$_selector$node$7 : false,
                handled: false,
                uiContext: undefined
            };
            if (this._fieldErrors == null) {
                this._fieldErrors = [
                    errorEvent
                ];
            } else {
                this._fieldErrors.push(errorEvent);
            }
        }
        if (seenRecord != null) {
            this._seenRecords.add(seenRecord);
        }
        if (suspenseID != null) {
            this._isMissingData = true;
            this._missingLiveResolverFields.push(suspenseID);
        }
        if (updatedDataIDs != null) {
            updatedDataIDs.forEach(function(recordID) {
                _this2._updatedDataIDs.add(recordID);
            });
        }
    };
    _proto._readClientEdge = function _readClientEdge(field, record, data) {
        var _this3 = this;
        var _backingField$alias;
        var backingField = field.backingField;
        !(backingField.kind !== 'ClientExtension') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Client extension client edges are not yet implemented.') : "TURBOPACK unreachable" : void 0;
        var fieldName = (_backingField$alias = backingField.alias) !== null && _backingField$alias !== void 0 ? _backingField$alias : backingField.name;
        var backingFieldData = {};
        this._traverseSelections([
            backingField
        ], record, backingFieldData);
        var clientEdgeResolverResponse = backingFieldData[fieldName];
        if (clientEdgeResolverResponse == null || isSuspenseSentinel(clientEdgeResolverResponse)) {
            data[fieldName] = clientEdgeResolverResponse;
            return clientEdgeResolverResponse;
        }
        if (field.linkedField.plural) {
            !Array.isArray(clientEdgeResolverResponse) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected plural Client Edge Relay Resolver at `%s` in `%s` to return an array containing IDs or objects with shape {id}.', backingField.path, this._owner.identifier) : "TURBOPACK unreachable" : void 0;
            var storeIDs;
            !(field.kind === 'ClientEdgeToClientObject') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unexpected Client Edge to plural server type `%s`. This should be prevented by the compiler.', field.kind) : "TURBOPACK unreachable" : void 0;
            if (field.backingField.normalizationInfo == null) {
                storeIDs = clientEdgeResolverResponse.map(function(itemResponse) {
                    var _field$concreteType;
                    var concreteType = (_field$concreteType = field.concreteType) !== null && _field$concreteType !== void 0 ? _field$concreteType : itemResponse.__typename;
                    !(typeof concreteType === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected resolver for field at `%s` in `%s` modeling an edge to an abstract type to return an object with a `__typename` property.', backingField.path, _this3._owner.identifier) : "TURBOPACK unreachable" : void 0;
                    var localId = extractIdFromResponse(itemResponse, backingField.path, _this3._owner.identifier);
                    var id = _this3._resolverCache.ensureClientRecord(localId, concreteType);
                    var modelResolvers = field.modelResolvers;
                    if (modelResolvers != null) {
                        var modelResolver = modelResolvers[concreteType];
                        !(modelResolver !== undefined) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Invalid `__typename` returned by resolver at `%s` in `%s`. Expected one of %s but got `%s`.', backingField.path, _this3._owner.identifier, Object.keys(modelResolvers).join(', '), concreteType) : "TURBOPACK unreachable" : void 0;
                        var model = _this3._readResolverFieldImpl(modelResolver, id);
                        return model != null ? id : null;
                    }
                    return id;
                });
            } else {
                storeIDs = clientEdgeResolverResponse.map(function(obj) {
                    return extractIdFromResponse(obj, backingField.path, _this3._owner.identifier);
                });
            }
            this._clientEdgeTraversalPath.push(null);
            var edgeValues = this._readLinkedIds(field.linkedField, storeIDs, record, data);
            this._clientEdgeTraversalPath.pop();
            data[fieldName] = edgeValues;
            return edgeValues;
        } else {
            var _field$concreteType2;
            var id = extractIdFromResponse(clientEdgeResolverResponse, backingField.path, this._owner.identifier);
            var storeID;
            var concreteType = (_field$concreteType2 = field.concreteType) !== null && _field$concreteType2 !== void 0 ? _field$concreteType2 : clientEdgeResolverResponse.__typename;
            var traversalPathSegment;
            if (field.kind === 'ClientEdgeToClientObject') {
                if (field.backingField.normalizationInfo == null) {
                    !(typeof concreteType === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected resolver for field at `%s` in `%s` modeling an edge to an abstract type to return an object with a `__typename` property.', backingField.path, this._owner.identifier) : "TURBOPACK unreachable" : void 0;
                    storeID = this._resolverCache.ensureClientRecord(id, concreteType);
                    traversalPathSegment = null;
                } else {
                    storeID = id;
                    traversalPathSegment = null;
                }
            } else {
                storeID = id;
                traversalPathSegment = {
                    readerClientEdge: field,
                    clientEdgeDestinationID: id
                };
            }
            var modelResolvers = field.modelResolvers;
            if (modelResolvers != null) {
                !(typeof concreteType === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected resolver for field at `%s` in `%s` modeling an edge to an abstract type to return an object with a `__typename` property.', backingField.path, this._owner.identifier) : "TURBOPACK unreachable" : void 0;
                var modelResolver = modelResolvers[concreteType];
                !(modelResolver !== undefined) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Invalid `__typename` returned by resolver at `%s` in `%s`. Expected one of %s but got `%s`.', backingField.path, this._owner.identifier, Object.keys(modelResolvers).join(', '), concreteType) : "TURBOPACK unreachable" : void 0;
                var model = this._readResolverFieldImpl(modelResolver, storeID);
                if (model == null) {
                    data[fieldName] = null;
                    return null;
                }
            }
            this._clientEdgeTraversalPath.push(traversalPathSegment);
            var prevData = data[fieldName];
            !(prevData == null || typeof prevData === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Expected data for field at `%s` in `%s` on record `%s` ' + 'to be an object, got `%s`.', backingField.path, this._owner.identifier, RelayModernRecord.getDataID(record), prevData) : "TURBOPACK unreachable" : void 0;
            var prevErrors = this._fieldErrors;
            this._fieldErrors = null;
            var edgeValue = this._traverse(field.linkedField, storeID, prevData);
            this._prependPreviousErrors(prevErrors, fieldName);
            this._clientEdgeTraversalPath.pop();
            data[fieldName] = edgeValue;
            return edgeValue;
        }
    };
    _proto._readScalar = function _readScalar(field, record, data) {
        var _field$alias3;
        var fieldName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;
        var storageKey = getStorageKey(field, this._variables);
        var value = RelayModernRecord.getValue(record, storageKey);
        if (value === null || RelayFeatureFlags.ENABLE_NONCOMPLIANT_ERROR_HANDLING_ON_LISTS && Array.isArray(value) && value.length === 0) {
            this._maybeAddFieldErrors(record, storageKey);
        } else if (value === undefined) {
            this._markDataAsMissing(fieldName);
        }
        data[fieldName] = value;
        return value;
    };
    _proto._readLink = function _readLink(field, record, data) {
        var _field$alias4;
        var fieldName = (_field$alias4 = field.alias) !== null && _field$alias4 !== void 0 ? _field$alias4 : field.name;
        var storageKey = getStorageKey(field, this._variables);
        var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
        if (linkedID == null) {
            data[fieldName] = linkedID;
            if (linkedID === null) {
                this._maybeAddFieldErrors(record, storageKey);
            } else if (linkedID === undefined) {
                this._markDataAsMissing(fieldName);
            }
            return linkedID;
        }
        var prevData = data[fieldName];
        !(prevData == null || typeof prevData === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Expected data for field `%s` at `%s` on record `%s` ' + 'to be an object, got `%s`.', fieldName, this._owner.identifier, RelayModernRecord.getDataID(record), prevData) : "TURBOPACK unreachable" : void 0;
        var prevErrors = this._fieldErrors;
        this._fieldErrors = null;
        var value = this._traverse(field, linkedID, prevData);
        this._prependPreviousErrors(prevErrors, fieldName);
        data[fieldName] = value;
        return value;
    };
    _proto._prependPreviousErrors = function _prependPreviousErrors(prevErrors, fieldNameOrIndex) {
        if (this._fieldErrors != null) {
            for(var i = 0; i < this._fieldErrors.length; i++){
                var event = this._fieldErrors[i];
                if (event.owner === this._fragmentName && (event.kind === 'missing_expected_data.throw' || event.kind === 'missing_expected_data.log' || event.kind === 'missing_required_field.throw' || event.kind === 'missing_required_field.log')) {
                    event.fieldPath = "".concat(fieldNameOrIndex, ".").concat(event.fieldPath);
                }
            }
            if (prevErrors != null) {
                for(var _i3 = this._fieldErrors.length - 1; _i3 >= 0; _i3--){
                    prevErrors.push(this._fieldErrors[_i3]);
                }
                this._fieldErrors = prevErrors;
            }
        } else {
            this._fieldErrors = prevErrors;
        }
    };
    _proto._readActorChange = function _readActorChange(field, record, data) {
        var _field$alias5;
        var fieldName = (_field$alias5 = field.alias) !== null && _field$alias5 !== void 0 ? _field$alias5 : field.name;
        var storageKey = getStorageKey(field, this._variables);
        var externalRef = RelayModernRecord.getActorLinkedRecordID(record, storageKey);
        if (externalRef == null) {
            data[fieldName] = externalRef;
            if (externalRef === undefined) {
                this._markDataAsMissing(fieldName);
            } else if (externalRef === null) {
                this._maybeAddFieldErrors(record, storageKey);
            }
            return data[fieldName];
        }
        var actorIdentifier = externalRef[0], dataID = externalRef[1];
        var fragmentRef = {};
        this._createFragmentPointer(field.fragmentSpread, RelayModernRecord.fromObject({
            __id: dataID
        }), fragmentRef);
        data[fieldName] = {
            __fragmentRef: fragmentRef,
            __viewer: actorIdentifier
        };
        return data[fieldName];
    };
    _proto._readPluralLink = function _readPluralLink(field, record, data) {
        var storageKey = getStorageKey(field, this._variables);
        var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);
        if (linkedIDs === null || RelayFeatureFlags.ENABLE_NONCOMPLIANT_ERROR_HANDLING_ON_LISTS && Array.isArray(linkedIDs) && linkedIDs.length === 0) {
            this._maybeAddFieldErrors(record, storageKey);
        }
        return this._readLinkedIds(field, linkedIDs, record, data);
    };
    _proto._readLinkedIds = function _readLinkedIds(field, linkedIDs, record, data) {
        var _this4 = this;
        var _field$alias6;
        var fieldName = (_field$alias6 = field.alias) !== null && _field$alias6 !== void 0 ? _field$alias6 : field.name;
        if (linkedIDs == null) {
            data[fieldName] = linkedIDs;
            if (linkedIDs === undefined) {
                this._markDataAsMissing(fieldName);
            }
            return linkedIDs;
        }
        var prevData = data[fieldName];
        !(prevData == null || Array.isArray(prevData)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an array, got `%s`.', fieldName, RelayModernRecord.getDataID(record), prevData) : "TURBOPACK unreachable" : void 0;
        var prevErrors = this._fieldErrors;
        this._fieldErrors = null;
        var linkedArray = prevData || [];
        linkedIDs.forEach(function(linkedID, nextIndex) {
            if (linkedID == null) {
                if (linkedID === undefined) {
                    _this4._markDataAsMissing(String(nextIndex));
                }
                linkedArray[nextIndex] = linkedID;
                return;
            }
            var prevItem = linkedArray[nextIndex];
            !(prevItem == null || typeof prevItem === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', fieldName, RelayModernRecord.getDataID(record), prevItem) : "TURBOPACK unreachable" : void 0;
            var prevErrors = _this4._fieldErrors;
            _this4._fieldErrors = null;
            linkedArray[nextIndex] = _this4._traverse(field, linkedID, prevItem);
            _this4._prependPreviousErrors(prevErrors, nextIndex);
        });
        this._prependPreviousErrors(prevErrors, fieldName);
        data[fieldName] = linkedArray;
        return linkedArray;
    };
    _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {
        var componentKey = getModuleComponentKey(moduleImport.documentName);
        var relayStoreComponent = RelayModernRecord.getValue(record, componentKey);
        var component = relayStoreComponent !== undefined ? relayStoreComponent : moduleImport.componentModuleProvider;
        if (component == null) {
            if (component === undefined) {
                this._markDataAsMissing('<module-import>');
            }
            return;
        }
        this._createFragmentPointer({
            kind: 'FragmentSpread',
            name: moduleImport.fragmentName,
            args: moduleImport.args
        }, record, data);
        data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;
        data[MODULE_COMPONENT_KEY] = component;
    };
    _proto._readAliasedInlineFragment = function _readAliasedInlineFragment(aliasedInlineFragment, record, data) {
        var prevErrors = this._fieldErrors;
        this._fieldErrors = null;
        var fieldValue = this._readInlineFragment(aliasedInlineFragment.fragment, record, {}, true);
        this._prependPreviousErrors(prevErrors, aliasedInlineFragment.name);
        if (fieldValue === false) {
            fieldValue = null;
        }
        data[aliasedInlineFragment.name] = fieldValue;
    };
    _proto._readInlineFragment = function _readInlineFragment(inlineFragment, record, data, skipUnmatchedAbstractTypes) {
        if (inlineFragment.type == null) {
            var hasExpectedData = this._traverseSelections(inlineFragment.selections, record, data);
            if (hasExpectedData === false) {
                return false;
            }
            return data;
        }
        var abstractKey = inlineFragment.abstractKey;
        if (abstractKey == null) {
            if (!this._recordMatchesTypeCondition(record, inlineFragment.type)) {
                return null;
            } else {
                var hasExpectedData = this._traverseSelections(inlineFragment.selections, record, data);
                if (!hasExpectedData) {
                    return false;
                }
            }
        } else {
            var implementsInterface = this._implementsInterface(record, abstractKey);
            if (implementsInterface === false && skipUnmatchedAbstractTypes) {
                return null;
            }
            var parentIsMissingData = this._isMissingData;
            var parentIsWithinUnmatchedTypeRefinement = this._isWithinUnmatchedTypeRefinement;
            this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement || implementsInterface === false;
            var hasMissingData = this._traverseSelections(inlineFragment.selections, record, data);
            this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement;
            if (implementsInterface === false) {
                this._isMissingData = parentIsMissingData;
                return null;
            } else if (implementsInterface == null) {
                return undefined;
            } else if (hasMissingData === false) {
                return false;
            }
        }
        return data;
    };
    _proto._recordMatchesTypeCondition = function _recordMatchesTypeCondition(record, type) {
        var typeName = RelayModernRecord.getType(record);
        return typeName != null && typeName === type || RelayModernRecord.getDataID(record) === ROOT_ID;
    };
    _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {
        var fragmentPointers = data[FRAGMENTS_KEY];
        if (fragmentPointers == null) {
            fragmentPointers = data[FRAGMENTS_KEY] = {};
        }
        !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : "TURBOPACK unreachable" : void 0;
        if (data[ID_KEY] == null) {
            data[ID_KEY] = RelayModernRecord.getDataID(record);
        }
        fragmentPointers[fragmentSpread.name] = getArgumentValues(fragmentSpread.args, this._variables, this._isWithinUnmatchedTypeRefinement);
        data[FRAGMENT_OWNER_KEY] = this._owner;
        if (this._clientEdgeTraversalPath.length > 0 && this._clientEdgeTraversalPath[this._clientEdgeTraversalPath.length - 1] !== null) {
            data[CLIENT_EDGE_TRAVERSAL_PATH] = (0, _toConsumableArray2["default"])(this._clientEdgeTraversalPath);
        }
    };
    _proto._createInlineDataOrResolverFragmentPointer = function _createInlineDataOrResolverFragmentPointer(fragmentSpreadOrFragment, record, data) {
        var fragmentPointers = data[FRAGMENTS_KEY];
        if (fragmentPointers == null) {
            fragmentPointers = data[FRAGMENTS_KEY] = {};
        }
        !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : "TURBOPACK unreachable" : void 0;
        if (data[ID_KEY] == null) {
            data[ID_KEY] = RelayModernRecord.getDataID(record);
        }
        var inlineData = {};
        var parentFragmentName = this._fragmentName;
        this._fragmentName = fragmentSpreadOrFragment.name;
        var parentVariables = this._variables;
        var argumentVariables = fragmentSpreadOrFragment.args ? getArgumentValues(fragmentSpreadOrFragment.args, this._variables) : {};
        this._variables = RelayConcreteVariables.getFragmentVariables(fragmentSpreadOrFragment, this._owner.variables, argumentVariables);
        this._traverseSelections(fragmentSpreadOrFragment.selections, record, inlineData);
        this._variables = parentVariables;
        this._fragmentName = parentFragmentName;
        fragmentPointers[fragmentSpreadOrFragment.name] = inlineData;
    };
    _proto._implementsInterface = function _implementsInterface(record, abstractKey) {
        var typeName = RelayModernRecord.getType(record);
        var typeRecord = this._recordSource.get(generateTypeID(typeName));
        var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;
        if (implementsInterface == null) {
            this._markDataAsMissing('<abstract-type-hint>');
        }
        return implementsInterface;
    };
    return RelayReader;
}();
function markFieldErrorHasHandled(event) {
    switch(event.kind){
        case 'missing_expected_data.throw':
        case 'missing_required_field.throw':
        case 'relay_field_payload.error':
        case 'relay_resolver.error':
            return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, event), {}, {
                handled: true
            });
        case 'missing_expected_data.log':
        case 'missing_required_field.log':
            return event;
        default:
            event.kind;
            ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Unexpected error response field kind: %s', event.kind) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
    }
}
function getResolverValue(field, variables, fragmentKey, resolverContext) {
    var resolverFunction = typeof field.resolverModule === 'function' ? field.resolverModule : field.resolverModule["default"];
    var resolverResult = null;
    var resolverError = null;
    try {
        var resolverFunctionArgs = [];
        if (field.fragment != null) {
            resolverFunctionArgs.push(fragmentKey);
        }
        var args = field.args ? getArgumentValues(field.args, variables) : undefined;
        resolverFunctionArgs.push(args);
        resolverFunctionArgs.push(resolverContext);
        resolverResult = resolverFunction.apply(null, resolverFunctionArgs);
    } catch (e) {
        resolverResult = null;
        if (e !== RESOLVER_FRAGMENT_ERRORED_SENTINEL) {
            resolverError = e;
        }
    }
    return [
        resolverResult,
        resolverError
    ];
}
function extractIdFromResponse(individualResponse, path, owner) {
    if (typeof individualResponse === 'string') {
        return individualResponse;
    } else if (typeof individualResponse === 'object' && individualResponse != null && typeof individualResponse.id === 'string') {
        return individualResponse.id;
    }
    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected object returned from edge resolver to be a string or an object with an `id` property at path %s in %s,', path, owner) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
}
module.exports = {
    read: read
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayReferenceMarker.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var getOperation = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getOperation.js [app-rsc] (ecmascript)");
var cloneRelayHandleSourceField = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/cloneRelayHandleSourceField.js [app-rsc] (ecmascript)");
var getOutputTypeRecordIDs = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/getOutputTypeRecordIDs.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-rsc] (ecmascript)"), getLocalVariables = _require.getLocalVariables;
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)");
var RelayStoreUtils = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/TypeID.js [app-rsc] (ecmascript)"), generateTypeID = _require2.generateTypeID;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var getReadTimeResolverStorageKey = RelayStoreUtils.getReadTimeResolverStorageKey, getStorageKey = RelayStoreUtils.getStorageKey, getModuleOperationKey = RelayStoreUtils.getModuleOperationKey;
function mark(recordSource, selector, references, operationLoader, shouldProcessClientComponents, useExecTimeResolvers) {
    var dataID = selector.dataID, node = selector.node, variables = selector.variables;
    var marker = new RelayReferenceMarker(recordSource, variables, references, operationLoader, shouldProcessClientComponents, useExecTimeResolvers);
    marker.mark(node, dataID);
}
var RelayReferenceMarker = /*#__PURE__*/ function() {
    function RelayReferenceMarker(recordSource, variables, references, operationLoader, shouldProcessClientComponents, useExecTimeResolvers) {
        this._operationLoader = operationLoader !== null && operationLoader !== void 0 ? operationLoader : null;
        this._operationName = null;
        this._useExecTimeResolvers = useExecTimeResolvers !== null && useExecTimeResolvers !== void 0 ? useExecTimeResolvers : false;
        this._recordSource = recordSource;
        this._references = references;
        this._variables = variables;
        this._shouldProcessClientComponents = shouldProcessClientComponents;
    }
    var _proto = RelayReferenceMarker.prototype;
    _proto.mark = function mark(node, dataID) {
        if (node.kind === 'Operation' || node.kind === 'SplitOperation') {
            this._operationName = node.name;
        }
        this._traverse(node, dataID);
    };
    _proto._traverse = function _traverse(node, dataID) {
        this._references.add(dataID);
        var record = this._recordSource.get(dataID);
        if (record == null) {
            return;
        }
        this._traverseSelections(node.selections, record);
    };
    _proto._getVariableValue = function _getVariableValue(name) {
        !this._variables.hasOwnProperty(name) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReferenceMarker(): Undefined variable `%s`.', name) : "TURBOPACK unreachable" : void 0;
        return this._variables[name];
    };
    _proto._traverseSelections = function _traverseSelections(selections, record) {
        var _this = this;
        selections.forEach(function(selection) {
            switch(selection.kind){
                case 'ActorChange':
                    _this._traverseLink(selection.linkedField, record);
                    break;
                case 'LinkedField':
                    if (selection.plural) {
                        _this._traversePluralLink(selection, record);
                    } else {
                        _this._traverseLink(selection, record);
                    }
                    break;
                case 'Condition':
                    var conditionValue = Boolean(_this._getVariableValue(selection.condition));
                    if (conditionValue === selection.passingValue) {
                        _this._traverseSelections(selection.selections, record);
                    }
                    break;
                case 'InlineFragment':
                    if (selection.abstractKey == null) {
                        var typeName = RelayModernRecord.getType(record);
                        if (typeName != null && typeName === selection.type || typeName === RelayStoreUtils.ROOT_TYPE) {
                            _this._traverseSelections(selection.selections, record);
                        }
                    } else {
                        var _typeName = RelayModernRecord.getType(record);
                        var typeID = generateTypeID(_typeName);
                        _this._references.add(typeID);
                        _this._traverseSelections(selection.selections, record);
                    }
                    break;
                case 'FragmentSpread':
                    var prevVariables = _this._variables;
                    _this._variables = getLocalVariables(_this._variables, selection.fragment.argumentDefinitions, selection.args);
                    _this._traverseSelections(selection.fragment.selections, record);
                    _this._variables = prevVariables;
                    break;
                case 'LinkedHandle':
                    var handleField = cloneRelayHandleSourceField(selection, selections, _this._variables);
                    if (handleField.plural) {
                        _this._traversePluralLink(handleField, record);
                    } else {
                        _this._traverseLink(handleField, record);
                    }
                    break;
                case 'Defer':
                case 'Stream':
                    _this._traverseSelections(selection.selections, record);
                    break;
                case 'ScalarField':
                case 'ScalarHandle':
                    break;
                case 'TypeDiscriminator':
                    {
                        var _typeName2 = RelayModernRecord.getType(record);
                        var _typeID = generateTypeID(_typeName2);
                        _this._references.add(_typeID);
                        break;
                    }
                case 'ModuleImport':
                    _this._traverseModuleImport(selection, record);
                    break;
                case 'ClientExtension':
                    _this._traverseSelections(selection.selections, record);
                    break;
                case 'ClientComponent':
                    if (_this._shouldProcessClientComponents === false) {
                        break;
                    }
                    _this._traverseSelections(selection.fragment.selections, record);
                    break;
                case 'RelayResolver':
                case 'RelayLiveResolver':
                    _this._traverseResolverField(selection, record);
                    break;
                case 'ClientEdgeToClientObject':
                    _this._traverseClientEdgeToClientObject(selection, record);
                    break;
                default:
                    selection;
                    ("TURBOPACK compile-time truthy", 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReferenceMarker: Unknown AST node `%s`.', selection) : "TURBOPACK unreachable" : "TURBOPACK unreachable";
            }
        });
    };
    _proto._traverseClientEdgeToClientObject = function _traverseClientEdgeToClientObject(field, record) {
        if (this._useExecTimeResolvers) {
            this._traverseLink(field.linkedField, record);
            return;
        }
        var dataID = this._traverseResolverField(field.backingField, record);
        if (dataID == null) {
            return;
        }
        var resolverRecord = this._recordSource.get(dataID);
        if (resolverRecord == null) {
            return;
        }
        if (field.backingField.isOutputType) {
            var outputTypeRecordIDs = getOutputTypeRecordIDs(resolverRecord);
            if (outputTypeRecordIDs != null) {
                var _iterator = (0, _createForOfIteratorHelper2["default"])(outputTypeRecordIDs), _step;
                try {
                    for(_iterator.s(); !(_step = _iterator.n()).done;){
                        var _dataID = _step.value;
                        this._references.add(_dataID);
                    }
                } catch (err) {
                    _iterator.e(err);
                } finally{
                    _iterator.f();
                }
            }
        } else {
            var linkedField = field.linkedField;
            var concreteType = linkedField.concreteType;
            if (concreteType == null) {
                return;
            }
            if (linkedField.plural) {
                var dataIDs = RelayModernRecord.getResolverLinkedRecordIDs(resolverRecord, concreteType);
                if (dataIDs != null) {
                    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(dataIDs), _step2;
                    try {
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                            var _dataID2 = _step2.value;
                            if (_dataID2 != null) {
                                this._traverse(linkedField, _dataID2);
                            }
                        }
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                }
            } else {
                var _dataID3 = RelayModernRecord.getResolverLinkedRecordID(resolverRecord, concreteType);
                if (_dataID3 != null) {
                    this._traverse(linkedField, _dataID3);
                }
            }
        }
    };
    _proto._traverseResolverField = function _traverseResolverField(field, record) {
        if (this._useExecTimeResolvers) {
            return;
        }
        var storageKey = getReadTimeResolverStorageKey(field, this._variables);
        var dataID = RelayModernRecord.getLinkedRecordID(record, storageKey);
        if (dataID != null) {
            this._references.add(dataID);
        }
        var fragment = field.fragment;
        if (fragment != null) {
            this._traverseSelections([
                fragment
            ], record);
        }
        return dataID;
    };
    _proto._traverseModuleImport = function _traverseModuleImport(moduleImport, record) {
        var _this$_operationName;
        var operationLoader = this._operationLoader;
        !(operationLoader !== null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayReferenceMarker: Expected an operationLoader to be configured when using `@module`. ' + 'Could not load fragment `%s` in operation `%s`.', moduleImport.fragmentName, (_this$_operationName = this._operationName) !== null && _this$_operationName !== void 0 ? _this$_operationName : '(unknown)') : "TURBOPACK unreachable" : void 0;
        var operationKey = getModuleOperationKey(moduleImport.documentName);
        var operationReference = RelayModernRecord.getValue(record, operationKey);
        if (operationReference == null) {
            return;
        }
        var normalizationRootNode = operationLoader.get(operationReference);
        if (normalizationRootNode != null) {
            var operation = getOperation(normalizationRootNode);
            var prevVariables = this._variables;
            this._variables = getLocalVariables(this._variables, operation.argumentDefinitions, moduleImport.args);
            this._traverseSelections(operation.selections, record);
            this._variables = prevVariables;
        }
    };
    _proto._traverseLink = function _traverseLink(field, record) {
        var storageKey = getStorageKey(field, this._variables);
        var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);
        if (linkedID == null) {
            return;
        }
        this._traverse(field, linkedID);
    };
    _proto._traversePluralLink = function _traversePluralLink(field, record) {
        var _this2 = this;
        var storageKey = getStorageKey(field, this._variables);
        var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);
        if (linkedIDs == null) {
            return;
        }
        linkedIDs.forEach(function(linkedID) {
            if (linkedID != null) {
                _this2._traverse(field, linkedID);
            }
        });
    };
    return RelayReferenceMarker;
}();
module.exports = {
    mark: mark
};
}),
"[project]/node_modules/relay-runtime/lib/store/hasOverlappingIDs.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ITERATOR_KEY = Symbol.iterator;
function hasOverlappingIDs(seenRecords, updatedRecordIDs) {
    var iterator = seenRecords[ITERATOR_KEY]();
    var next = iterator.next();
    while(!next.done){
        var key = next.value;
        if (updatedRecordIDs.has(key)) {
            return true;
        }
        next = iterator.next();
    }
    return false;
}
module.exports = hasOverlappingIDs;
}),
"[project]/node_modules/relay-runtime/lib/store/hasSignificantOverlappingIDs.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), ROOT_ID = _require.ROOT_ID;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ViewerPattern.js [app-rsc] (ecmascript)"), VIEWER_ID = _require2.VIEWER_ID;
var ITERATOR_KEY = Symbol.iterator;
function hasSignificantOverlappingIDs(seenRecords, updatedRecordIDs) {
    var iterator = seenRecords[ITERATOR_KEY]();
    var next = iterator.next();
    while(!next.done){
        var key = next.value;
        if (updatedRecordIDs.has(key) && key !== ROOT_ID && key !== VIEWER_ID) {
            return true;
        }
        next = iterator.next();
    }
    return false;
}
module.exports = hasSignificantOverlappingIDs;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayStoreSubscriptions.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var deepFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-rsc] (ecmascript)");
var recycleNodesInto = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/recycleNodesInto.js [app-rsc] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-rsc] (ecmascript)");
var hasOverlappingIDs = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/hasOverlappingIDs.js [app-rsc] (ecmascript)");
var hasSignificantOverlappingIDs = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/hasSignificantOverlappingIDs.js [app-rsc] (ecmascript)");
var RelayReader = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayReader.js [app-rsc] (ecmascript)");
var RelayStoreSubscriptions = /*#__PURE__*/ function() {
    function RelayStoreSubscriptions(log, resolverCache, resolverContext) {
        this._subscriptions = new Set();
        this.__log = log;
        this._resolverCache = resolverCache;
        this._resolverContext = resolverContext;
    }
    var _proto = RelayStoreSubscriptions.prototype;
    _proto.subscribe = function subscribe(snapshot, callback) {
        var _this = this;
        var subscription = {
            backup: null,
            callback: callback,
            snapshot: snapshot,
            stale: false
        };
        var dispose = function dispose() {
            _this._subscriptions["delete"](subscription);
        };
        this._subscriptions.add(subscription);
        return {
            dispose: dispose
        };
    };
    _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {
        var _this2 = this;
        this._subscriptions.forEach(function(subscription) {
            if (!subscription.stale) {
                subscription.backup = subscription.snapshot;
                return;
            }
            var snapshot = subscription.snapshot;
            var backup = RelayReader.read(source, snapshot.selector, _this2._resolverCache, _this2._resolverContext);
            var nextData = recycleNodesInto(snapshot.data, backup.data);
            backup.data = nextData;
            subscription.backup = backup;
        });
    };
    _proto.restoreSubscriptions = function restoreSubscriptions() {
        this._subscriptions.forEach(function(subscription) {
            var backup = subscription.backup;
            subscription.backup = null;
            if (backup) {
                if (backup.data !== subscription.snapshot.data) {
                    subscription.stale = true;
                }
                subscription.snapshot = {
                    data: subscription.snapshot.data,
                    isMissingData: backup.isMissingData,
                    missingClientEdges: backup.missingClientEdges,
                    missingLiveResolverFields: backup.missingLiveResolverFields,
                    seenRecords: backup.seenRecords,
                    selector: backup.selector,
                    fieldErrors: backup.fieldErrors
                };
            } else {
                subscription.stale = true;
            }
        });
    };
    _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {
        var _this3 = this;
        var hasUpdatedRecords = updatedRecordIDs.size !== 0;
        this._subscriptions.forEach(function(subscription) {
            var owner = _this3._updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation);
            if (owner != null) {
                updatedOwners.push(owner);
            }
        });
    };
    _proto._updateSubscription = function _updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation) {
        var backup = subscription.backup, callback = subscription.callback, snapshot = subscription.snapshot, stale = subscription.stale;
        var hasOverlappingUpdates = hasUpdatedRecords && hasOverlappingIDs(snapshot.seenRecords, updatedRecordIDs);
        if (!stale && !hasOverlappingUpdates) {
            return;
        }
        var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector, this._resolverCache, this._resolverContext) : backup;
        var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);
        nextSnapshot = {
            data: nextData,
            isMissingData: nextSnapshot.isMissingData,
            missingClientEdges: nextSnapshot.missingClientEdges,
            missingLiveResolverFields: nextSnapshot.missingLiveResolverFields,
            seenRecords: nextSnapshot.seenRecords,
            selector: nextSnapshot.selector,
            fieldErrors: nextSnapshot.fieldErrors
        };
        if ("TURBOPACK compile-time truthy", 1) {
            deepFreeze(nextSnapshot);
        }
        subscription.snapshot = nextSnapshot;
        subscription.stale = false;
        if (nextSnapshot.data !== snapshot.data) {
            if (this.__log && RelayFeatureFlags.ENABLE_NOTIFY_SUBSCRIPTION) {
                this.__log({
                    name: 'store.notify.subscription',
                    sourceOperation: sourceOperation,
                    snapshot: snapshot,
                    nextSnapshot: nextSnapshot
                });
            }
            callback(nextSnapshot);
            return snapshot.selector.owner;
        }
        if (RelayFeatureFlags.ENABLE_LOOSE_SUBSCRIPTION_ATTRIBUTION && (stale || hasSignificantOverlappingIDs(snapshot.seenRecords, updatedRecordIDs))) {
            return snapshot.selector.owner;
        }
    };
    _proto.size = function size() {
        return this._subscriptions.size;
    };
    return RelayStoreSubscriptions;
}();
module.exports = RelayStoreSubscriptions;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayModernStore.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/multi-actor-environment/ActorIdentifier.js [app-rsc] (ecmascript)"), INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE = _require.INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE, assertInternalActorIdentifier = _require.assertInternalActorIdentifier;
var deepFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-rsc] (ecmascript)");
var resolveImmediate = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/resolveImmediate.js [app-rsc] (ecmascript)");
var DataChecker = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/DataChecker.js [app-rsc] (ecmascript)");
var defaultGetDataID = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/defaultGetDataID.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverCache.js [app-rsc] (ecmascript)"), LiveResolverCache = _require2.LiveResolverCache, RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY = _require2.RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY, getUpdatedDataIDs = _require2.getUpdatedDataIDs;
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)");
var RelayOptimisticRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayOptimisticRecordSource.js [app-rsc] (ecmascript)");
var RelayReader = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayReader.js [app-rsc] (ecmascript)");
var RelayReferenceMarker = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayReferenceMarker.js [app-rsc] (ecmascript)");
var RelayStoreSubscriptions = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreSubscriptions.js [app-rsc] (ecmascript)");
var RelayStoreUtils = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), ROOT_ID = _require3.ROOT_ID, ROOT_TYPE = _require3.ROOT_TYPE;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var DEFAULT_RELEASE_BUFFER_SIZE = 10;
var RelayModernStore = /*#__PURE__*/ function() {
    function RelayModernStore(source, options) {
        var _this = this;
        var _options$gcReleaseBuf, _options$shouldRetain, _options$gcScheduler, _options$getDataID, _options$log, _options$operationLoa, _options$shouldProces, _options$treatMissing;
        (0, _defineProperty2["default"])(this, "_gcStep", function() {
            if (_this._gcRun) {
                if (_this._gcRun.next().done) {
                    _this._gcRun = null;
                } else {
                    _this._gcScheduler(_this._gcStep);
                }
            }
        });
        if ("TURBOPACK compile-time truthy", 1) {
            var storeIDs = source.getRecordIDs();
            for(var ii = 0; ii < storeIDs.length; ii++){
                var record = source.get(storeIDs[ii]);
                if (record) {
                    RelayModernRecord.freeze(record);
                }
            }
        }
        this._currentWriteEpoch = 0;
        this._gcHoldCounter = 0;
        this._gcReleaseBufferSize = (_options$gcReleaseBuf = options === null || options === void 0 ? void 0 : options.gcReleaseBufferSize) !== null && _options$gcReleaseBuf !== void 0 ? _options$gcReleaseBuf : DEFAULT_RELEASE_BUFFER_SIZE;
        this._shouldRetainWithinTTL_EXPERIMENTAL = (_options$shouldRetain = options === null || options === void 0 ? void 0 : options.shouldRetainWithinTTL_EXPERIMENTAL) !== null && _options$shouldRetain !== void 0 ? _options$shouldRetain : false;
        this._gcRun = null;
        this._gcScheduler = (_options$gcScheduler = options === null || options === void 0 ? void 0 : options.gcScheduler) !== null && _options$gcScheduler !== void 0 ? _options$gcScheduler : resolveImmediate;
        this._getDataID = (_options$getDataID = options === null || options === void 0 ? void 0 : options.getDataID) !== null && _options$getDataID !== void 0 ? _options$getDataID : defaultGetDataID;
        this._globalInvalidationEpoch = null;
        this._invalidationSubscriptions = new Set();
        this._invalidatedRecordIDs = new Set();
        this.__log = (_options$log = options === null || options === void 0 ? void 0 : options.log) !== null && _options$log !== void 0 ? _options$log : null;
        this._queryCacheExpirationTime = options === null || options === void 0 ? void 0 : options.queryCacheExpirationTime;
        this._operationLoader = (_options$operationLoa = options === null || options === void 0 ? void 0 : options.operationLoader) !== null && _options$operationLoa !== void 0 ? _options$operationLoa : null;
        this._optimisticSource = null;
        this._recordSource = source;
        this._releaseBuffer = [];
        this._roots = new Map();
        this._shouldScheduleGC = false;
        this._resolverCache = new LiveResolverCache(function() {
            return _this._getMutableRecordSource();
        }, this);
        this._resolverContext = options === null || options === void 0 ? void 0 : options.resolverContext;
        this._storeSubscriptions = new RelayStoreSubscriptions(options === null || options === void 0 ? void 0 : options.log, this._resolverCache, this._resolverContext);
        this._updatedRecordIDs = new Set();
        this._shouldProcessClientComponents = (_options$shouldProces = options === null || options === void 0 ? void 0 : options.shouldProcessClientComponents) !== null && _options$shouldProces !== void 0 ? _options$shouldProces : false;
        this._treatMissingFieldsAsNull = (_options$treatMissing = options === null || options === void 0 ? void 0 : options.treatMissingFieldsAsNull) !== null && _options$treatMissing !== void 0 ? _options$treatMissing : false;
        this._actorIdentifier = options === null || options === void 0 ? void 0 : options.actorIdentifier;
        initializeRecordSource(this._recordSource);
    }
    var _proto = RelayModernStore.prototype;
    _proto.getSource = function getSource() {
        var _this$_optimisticSour;
        return (_this$_optimisticSour = this._optimisticSource) !== null && _this$_optimisticSour !== void 0 ? _this$_optimisticSour : this._recordSource;
    };
    _proto.getOperationLoader = function getOperationLoader() {
        return this._operationLoader;
    };
    _proto._getMutableRecordSource = function _getMutableRecordSource() {
        var _this$_optimisticSour2;
        return (_this$_optimisticSour2 = this._optimisticSource) !== null && _this$_optimisticSour2 !== void 0 ? _this$_optimisticSour2 : this._recordSource;
    };
    _proto.getLiveResolverPromise = function getLiveResolverPromise(recordID) {
        return this._resolverCache.getLiveResolverPromise(recordID);
    };
    _proto.batchLiveStateUpdates = function batchLiveStateUpdates(callback) {
        if (this.__log != null) {
            this.__log({
                name: 'liveresolver.batch.start'
            });
        }
        try {
            this._resolverCache.batchLiveStateUpdates(callback);
        } finally{
            if (this.__log != null) {
                this.__log({
                    name: 'liveresolver.batch.end'
                });
            }
        }
    };
    _proto.check = function check(operation, options) {
        var _ref, _operation$request$no, _operation$request$no2, _options$handlers, _options$getSourceFor, _options$getTargetFor, _options$defaultActor;
        var selector = operation.root;
        var source = this._getMutableRecordSource();
        var globalInvalidationEpoch = this._globalInvalidationEpoch;
        var useExecTimeResolvers = (_ref = (_operation$request$no = operation.request.node.operation.use_exec_time_resolvers) !== null && _operation$request$no !== void 0 ? _operation$request$no : ((_operation$request$no2 = operation.request.node.operation.exec_time_resolvers_enabled_provider) === null || _operation$request$no2 === void 0 ? void 0 : _operation$request$no2.get()) === true) !== null && _ref !== void 0 ? _ref : false;
        var rootEntry = this._roots.get(operation.request.identifier);
        var operationLastWrittenAt = rootEntry != null ? rootEntry.epoch : null;
        if (globalInvalidationEpoch != null) {
            if (operationLastWrittenAt == null || operationLastWrittenAt <= globalInvalidationEpoch) {
                return {
                    status: 'stale'
                };
            }
        }
        var handlers = (_options$handlers = options === null || options === void 0 ? void 0 : options.handlers) !== null && _options$handlers !== void 0 ? _options$handlers : [];
        var getSourceForActor = (_options$getSourceFor = options === null || options === void 0 ? void 0 : options.getSourceForActor) !== null && _options$getSourceFor !== void 0 ? _options$getSourceFor : function(actorIdentifier) {
            assertInternalActorIdentifier(actorIdentifier);
            return source;
        };
        var getTargetForActor = (_options$getTargetFor = options === null || options === void 0 ? void 0 : options.getTargetForActor) !== null && _options$getTargetFor !== void 0 ? _options$getTargetFor : function(actorIdentifier) {
            assertInternalActorIdentifier(actorIdentifier);
            return source;
        };
        var operationAvailability = DataChecker.check(getSourceForActor, getTargetForActor, (_options$defaultActor = options === null || options === void 0 ? void 0 : options.defaultActorIdentifier) !== null && _options$defaultActor !== void 0 ? _options$defaultActor : INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE, selector, handlers, this._operationLoader, this._getDataID, this._shouldProcessClientComponents, this.__log, useExecTimeResolvers);
        return getAvailabilityStatus(operationAvailability, operationLastWrittenAt, rootEntry === null || rootEntry === void 0 ? void 0 : rootEntry.fetchTime, this._queryCacheExpirationTime);
    };
    _proto.retain = function retain(operation) {
        var _this2 = this;
        var id = operation.request.identifier;
        var disposed = false;
        var dispose = function dispose() {
            if (disposed) {
                return;
            }
            disposed = true;
            var rootEntry = _this2._roots.get(id);
            if (rootEntry == null) {
                return;
            }
            rootEntry.refCount--;
            if (rootEntry.refCount === 0) {
                var _queryCacheExpirationTime = _this2._queryCacheExpirationTime;
                var rootEntryIsStale = rootEntry.fetchTime != null && _queryCacheExpirationTime != null && rootEntry.fetchTime <= Date.now() - _queryCacheExpirationTime;
                if (rootEntryIsStale) {
                    if (!_this2._shouldRetainWithinTTL_EXPERIMENTAL) {
                        _this2._roots["delete"](id);
                    }
                    _this2.scheduleGC();
                } else {
                    _this2._releaseBuffer.push(id);
                    if (_this2._releaseBuffer.length > _this2._gcReleaseBufferSize) {
                        var _id = _this2._releaseBuffer.shift();
                        if (!_this2._shouldRetainWithinTTL_EXPERIMENTAL) {
                            _this2._roots["delete"](_id);
                        }
                        _this2.scheduleGC();
                    }
                }
            }
        };
        var rootEntry = this._roots.get(id);
        if (rootEntry != null) {
            if (rootEntry.refCount === 0) {
                this._releaseBuffer = this._releaseBuffer.filter(function(_id) {
                    return _id !== id;
                });
            }
            rootEntry.refCount += 1;
        } else {
            this._roots.set(id, {
                operation: operation,
                refCount: 1,
                epoch: null,
                fetchTime: null
            });
        }
        return {
            dispose: dispose
        };
    };
    _proto.lookup = function lookup(selector) {
        var log = this.__log;
        if (log != null) {
            log({
                name: 'store.lookup.start',
                selector: selector
            });
        }
        var source = this.getSource();
        var snapshot = RelayReader.read(source, selector, this._resolverCache, this._resolverContext);
        if ("TURBOPACK compile-time truthy", 1) {
            deepFreeze(snapshot);
        }
        if (log != null) {
            log({
                name: 'store.lookup.end',
                selector: selector
            });
        }
        return snapshot;
    };
    _proto.notify = function notify(sourceOperation, invalidateStore) {
        var _this3 = this;
        var log = this.__log;
        if (log != null) {
            log({
                name: 'store.notify.start',
                sourceOperation: sourceOperation
            });
        }
        this._currentWriteEpoch++;
        if (invalidateStore === true) {
            this._globalInvalidationEpoch = this._currentWriteEpoch;
        }
        this._resolverCache.invalidateDataIDs(this._updatedRecordIDs);
        var source = this.getSource();
        var updatedOwners = [];
        this._storeSubscriptions.updateSubscriptions(source, this._updatedRecordIDs, updatedOwners, sourceOperation);
        this._invalidationSubscriptions.forEach(function(subscription) {
            _this3._updateInvalidationSubscription(subscription, invalidateStore === true);
        });
        if (sourceOperation != null) {
            var id = sourceOperation.request.identifier;
            var rootEntry = this._roots.get(id);
            if (rootEntry != null) {
                rootEntry.epoch = this._currentWriteEpoch;
                rootEntry.fetchTime = Date.now();
            } else if (sourceOperation.request.node.params.operationKind === 'query' && this._gcReleaseBufferSize > 0 && this._releaseBuffer.length < this._gcReleaseBufferSize) {
                var temporaryRootEntry = {
                    operation: sourceOperation,
                    refCount: 0,
                    epoch: this._currentWriteEpoch,
                    fetchTime: Date.now()
                };
                this._releaseBuffer.push(id);
                this._roots.set(id, temporaryRootEntry);
            }
        }
        if (log != null) {
            log({
                name: 'store.notify.complete',
                sourceOperation: sourceOperation,
                updatedRecordIDs: this._updatedRecordIDs,
                invalidatedRecordIDs: this._invalidatedRecordIDs,
                subscriptionsSize: this._storeSubscriptions.size(),
                updatedOwners: updatedOwners
            });
        }
        this._updatedRecordIDs.clear();
        this._invalidatedRecordIDs.clear();
        return updatedOwners;
    };
    _proto.publish = function publish(source, idsMarkedForInvalidation) {
        var target = this._getMutableRecordSource();
        updateTargetFromSource(target, source, this._currentWriteEpoch + 1, idsMarkedForInvalidation, this._updatedRecordIDs, this._invalidatedRecordIDs);
        var log = this.__log;
        if (log != null) {
            log({
                name: 'store.publish',
                source: source,
                optimistic: target === this._optimisticSource
            });
        }
    };
    _proto.subscribe = function subscribe(snapshot, callback) {
        return this._storeSubscriptions.subscribe(snapshot, callback);
    };
    _proto.holdGC = function holdGC() {
        var _this4 = this;
        if (this._gcRun) {
            this._gcRun = null;
            this._shouldScheduleGC = true;
        }
        this._gcHoldCounter++;
        var dispose = function dispose() {
            if (_this4._gcHoldCounter > 0) {
                _this4._gcHoldCounter--;
                if (_this4._gcHoldCounter === 0 && _this4._shouldScheduleGC) {
                    _this4.scheduleGC();
                    _this4._shouldScheduleGC = false;
                }
            }
        };
        return {
            dispose: dispose
        };
    };
    _proto.toJSON = function toJSON() {
        return 'RelayModernStore()';
    };
    _proto.getEpoch = function getEpoch() {
        return this._currentWriteEpoch;
    };
    _proto.__getUpdatedRecordIDs = function __getUpdatedRecordIDs() {
        return this._updatedRecordIDs;
    };
    _proto.lookupInvalidationState = function lookupInvalidationState(dataIDs) {
        var _this5 = this;
        var invalidations = new Map();
        dataIDs.forEach(function(dataID) {
            var _RelayModernRecord$ge;
            var record = _this5.getSource().get(dataID);
            invalidations.set(dataID, (_RelayModernRecord$ge = RelayModernRecord.getInvalidationEpoch(record)) !== null && _RelayModernRecord$ge !== void 0 ? _RelayModernRecord$ge : null);
        });
        invalidations.set('global', this._globalInvalidationEpoch);
        return {
            dataIDs: dataIDs,
            invalidations: invalidations
        };
    };
    _proto.checkInvalidationState = function checkInvalidationState(prevInvalidationState) {
        var latestInvalidationState = this.lookupInvalidationState(prevInvalidationState.dataIDs);
        var currentInvalidations = latestInvalidationState.invalidations;
        var prevInvalidations = prevInvalidationState.invalidations;
        if (currentInvalidations.get('global') !== prevInvalidations.get('global')) {
            return true;
        }
        var _iterator = (0, _createForOfIteratorHelper2["default"])(prevInvalidationState.dataIDs), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var dataID = _step.value;
                if (currentInvalidations.get(dataID) !== prevInvalidations.get(dataID)) {
                    return true;
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        return false;
    };
    _proto.subscribeToInvalidationState = function subscribeToInvalidationState(invalidationState, callback) {
        var _this6 = this;
        var subscription = {
            callback: callback,
            invalidationState: invalidationState
        };
        var dispose = function dispose() {
            _this6._invalidationSubscriptions["delete"](subscription);
        };
        this._invalidationSubscriptions.add(subscription);
        return {
            dispose: dispose
        };
    };
    _proto._updateInvalidationSubscription = function _updateInvalidationSubscription(subscription, invalidatedStore) {
        var _this7 = this;
        var callback = subscription.callback, invalidationState = subscription.invalidationState;
        var dataIDs = invalidationState.dataIDs;
        var isSubscribedToInvalidatedIDs = invalidatedStore || dataIDs.some(function(dataID) {
            return _this7._invalidatedRecordIDs.has(dataID);
        });
        if (!isSubscribedToInvalidatedIDs) {
            return;
        }
        callback();
    };
    _proto.snapshot = function snapshot() {
        !(this._optimisticSource == null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernStore: Unexpected call to snapshot() while a previous ' + 'snapshot exists.') : "TURBOPACK unreachable" : void 0;
        var log = this.__log;
        if (log != null) {
            log({
                name: 'store.snapshot'
            });
        }
        this._storeSubscriptions.snapshotSubscriptions(this.getSource());
        if (this._gcRun) {
            this._gcRun = null;
            this._shouldScheduleGC = true;
        }
        this._optimisticSource = RelayOptimisticRecordSource.create(this.getSource());
    };
    _proto.restore = function restore() {
        var optimisticSource = this._optimisticSource;
        !optimisticSource ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernStore: Unexpected call to restore(), expected a snapshot ' + 'to exist (make sure to call snapshot()).') : "TURBOPACK unreachable" : void 0;
        var log = this.__log;
        if (log != null) {
            log({
                name: 'store.restore'
            });
        }
        var optimisticIDs = RelayOptimisticRecordSource.getOptimisticRecordIDs(optimisticSource);
        this._resolverCache.unsubscribeFromLiveResolverRecords(optimisticIDs);
        this._optimisticSource = null;
        if (this._shouldScheduleGC) {
            this.scheduleGC();
        }
        this._storeSubscriptions.restoreSubscriptions();
        this._resolverCache.invalidateResolverRecords(optimisticIDs);
    };
    _proto.scheduleGC = function scheduleGC() {
        if (this._gcHoldCounter > 0) {
            this._shouldScheduleGC = true;
            return;
        }
        if (this._gcRun) {
            return;
        }
        this._gcRun = this._collect();
        this._gcScheduler(this._gcStep);
    };
    _proto.__gc = function __gc() {
        if (this._optimisticSource != null) {
            return;
        }
        var gcRun = this._collect();
        while(!gcRun.next().done){}
    };
    _proto._collect = function* _collect() {
        if (this._shouldRetainWithinTTL_EXPERIMENTAL && this._queryCacheExpirationTime == null) {
            return;
        }
        var log = this.__log;
        top: while(true){
            if (log != null) {
                log({
                    name: 'store.gc.start'
                });
            }
            var startEpoch = this._currentWriteEpoch;
            var references = new Set();
            var _iterator2 = (0, _createForOfIteratorHelper2["default"])(this._roots.entries()), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var _ref2, _operation$request$no3, _operation$request$no4;
                    var _step2$value = _step2.value, _dataID = _step2$value[0], _step2$value$ = _step2$value[1], operation = _step2$value$.operation, refCount = _step2$value$.refCount, fetchTime = _step2$value$.fetchTime;
                    if (this._shouldRetainWithinTTL_EXPERIMENTAL) {
                        var _queryCacheExpirationTime = this._queryCacheExpirationTime;
                        !(_queryCacheExpirationTime != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Query cache expiration time should be non-null if executing GC') : "TURBOPACK unreachable" : void 0;
                        var recordHasExpired = fetchTime == null || fetchTime <= Date.now() - _queryCacheExpirationTime;
                        var recordShouldBeCollected = recordHasExpired && refCount === 0 && !this._releaseBuffer.includes(_dataID);
                        if (recordShouldBeCollected) {
                            continue;
                        }
                    }
                    var selector = operation.root;
                    var useExecTimeResolvers = (_ref2 = (_operation$request$no3 = operation.request.node.operation.use_exec_time_resolvers) !== null && _operation$request$no3 !== void 0 ? _operation$request$no3 : ((_operation$request$no4 = operation.request.node.operation.exec_time_resolvers_enabled_provider) === null || _operation$request$no4 === void 0 ? void 0 : _operation$request$no4.get()) === true) !== null && _ref2 !== void 0 ? _ref2 : false;
                    RelayReferenceMarker.mark(this._recordSource, selector, references, this._operationLoader, this._shouldProcessClientComponents, useExecTimeResolvers);
                    yield;
                    if (startEpoch !== this._currentWriteEpoch) {
                        if (log != null) {
                            log({
                                name: 'store.gc.interrupted'
                            });
                        }
                        continue top;
                    }
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
            var storeIDs = this._recordSource.getRecordIDs();
            for(var ii = 0; ii < storeIDs.length; ii++){
                var dataID = storeIDs[ii];
                if (!references.has(dataID)) {
                    var record = this._recordSource.get(dataID);
                    if (record != null) {
                        var maybeResolverSubscription = RelayModernRecord.getValue(record, RELAY_RESOLVER_LIVE_STATE_SUBSCRIPTION_KEY);
                        if (maybeResolverSubscription != null) {
                            maybeResolverSubscription();
                        }
                    }
                    this._recordSource.remove(dataID);
                    if (this._shouldRetainWithinTTL_EXPERIMENTAL) {
                        this._roots["delete"](dataID);
                    }
                }
            }
            if (log != null) {
                log({
                    name: 'store.gc.end',
                    references: references
                });
            }
            return;
        }
    };
    _proto.__getNormalizationOptions = function __getNormalizationOptions(path) {
        return {
            path: path,
            getDataID: this._getDataID,
            log: this.__log,
            treatMissingFieldsAsNull: this._treatMissingFieldsAsNull,
            shouldProcessClientComponents: this._shouldProcessClientComponents,
            actorIdentifier: this._actorIdentifier
        };
    };
    _proto.__notifyUpdatedSubscribers = function __notifyUpdatedSubscribers(updatedRecords) {
        var nextUpdatedRecordIDs = getUpdatedDataIDs(updatedRecords);
        var prevUpdatedRecordIDs = this._updatedRecordIDs;
        this._updatedRecordIDs = nextUpdatedRecordIDs;
        this.notify();
        this._updatedRecordIDs = prevUpdatedRecordIDs;
    };
    return RelayModernStore;
}();
function initializeRecordSource(target) {
    if (!target.has(ROOT_ID)) {
        var rootRecord = RelayModernRecord.create(ROOT_ID, ROOT_TYPE);
        target.set(ROOT_ID, rootRecord);
    }
}
function updateTargetFromSource(target, source, currentWriteEpoch, idsMarkedForInvalidation, updatedRecordIDs, invalidatedRecordIDs) {
    if (idsMarkedForInvalidation) {
        idsMarkedForInvalidation.forEach(function(dataID) {
            var targetRecord = target.get(dataID);
            var sourceRecord = source.get(dataID);
            if (sourceRecord === null) {
                return;
            }
            var nextRecord;
            if (targetRecord != null) {
                nextRecord = RelayModernRecord.clone(targetRecord);
            } else {
                nextRecord = sourceRecord != null ? RelayModernRecord.clone(sourceRecord) : null;
            }
            if (!nextRecord) {
                return;
            }
            RelayModernRecord.setValue(nextRecord, RelayStoreUtils.INVALIDATED_AT_KEY, currentWriteEpoch);
            invalidatedRecordIDs.add(dataID);
            target.set(dataID, nextRecord);
        });
    }
    var dataIDs = source.getRecordIDs();
    for(var ii = 0; ii < dataIDs.length; ii++){
        var dataID = dataIDs[ii];
        var sourceRecord = source.get(dataID);
        var targetRecord = target.get(dataID);
        if ("TURBOPACK compile-time truthy", 1) {
            if (sourceRecord) {
                RelayModernRecord.freeze(sourceRecord);
            }
        }
        if (sourceRecord && targetRecord) {
            var nextRecord = RelayModernRecord.update(targetRecord, sourceRecord);
            if (nextRecord !== targetRecord) {
                if ("TURBOPACK compile-time truthy", 1) {
                    RelayModernRecord.freeze(nextRecord);
                }
                updatedRecordIDs.add(dataID);
                target.set(dataID, nextRecord);
            }
        } else if (sourceRecord === null) {
            target["delete"](dataID);
            if (targetRecord !== null) {
                updatedRecordIDs.add(dataID);
            }
        } else if (sourceRecord) {
            target.set(dataID, sourceRecord);
            updatedRecordIDs.add(dataID);
        }
    }
}
function getAvailabilityStatus(operationAvailability, operationLastWrittenAt, operationFetchTime, queryCacheExpirationTime) {
    var mostRecentlyInvalidatedAt = operationAvailability.mostRecentlyInvalidatedAt, status = operationAvailability.status;
    if (typeof mostRecentlyInvalidatedAt === 'number') {
        if (operationLastWrittenAt == null || mostRecentlyInvalidatedAt > operationLastWrittenAt) {
            return {
                status: 'stale'
            };
        }
    }
    if (status === 'missing') {
        return {
            status: 'missing'
        };
    }
    if (operationFetchTime != null && queryCacheExpirationTime != null) {
        var isStale = operationFetchTime <= Date.now() - queryCacheExpirationTime;
        if (isStale) {
            return {
                status: 'stale'
            };
        }
    }
    return {
        status: 'available',
        fetchTime: operationFetchTime !== null && operationFetchTime !== void 0 ? operationFetchTime : null
    };
}
module.exports = RelayModernStore;
}),
"[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceSelectorProxy.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), ROOT_TYPE = _require.ROOT_TYPE, getStorageKey = _require.getStorageKey;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/readUpdatableFragment.js [app-rsc] (ecmascript)"), _readUpdatableFragment = _require2.readUpdatableFragment;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/readUpdatableQuery.js [app-rsc] (ecmascript)"), _readUpdatableQuery = _require3.readUpdatableQuery;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var RelayRecordSourceSelectorProxy = /*#__PURE__*/ function() {
    function RelayRecordSourceSelectorProxy(mutator, recordSource, readSelector, missingFieldHandlers) {
        this.__mutator = mutator;
        this.__recordSource = recordSource;
        this._readSelector = readSelector;
        this._missingFieldHandlers = missingFieldHandlers;
    }
    var _proto = RelayRecordSourceSelectorProxy.prototype;
    _proto.create = function create(dataID, typeName) {
        return this.__recordSource.create(dataID, typeName);
    };
    _proto["delete"] = function _delete(dataID) {
        this.__recordSource["delete"](dataID);
    };
    _proto.get = function get(dataID) {
        return this.__recordSource.get(dataID);
    };
    _proto.getRoot = function getRoot() {
        return this.__recordSource.getRoot();
    };
    _proto.getOperationRoot = function getOperationRoot() {
        var root = this.__recordSource.get(this._readSelector.dataID);
        if (!root) {
            root = this.__recordSource.create(this._readSelector.dataID, ROOT_TYPE);
        }
        return root;
    };
    _proto._getRootField = function _getRootField(selector, fieldName, plural) {
        var field = selector.node.selections.find(function(selection) {
            return selection.kind === 'LinkedField' && selection.name === fieldName || selection.kind === 'RequiredField' && selection.field.name === fieldName;
        });
        if (field && field.kind === 'RequiredField') {
            field = field.field;
        }
        !(field && field.kind === 'LinkedField') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceSelectorProxy#getRootField(): Cannot find root ' + 'field `%s`, no such field is defined on GraphQL document `%s`.', fieldName, selector.node.name) : "TURBOPACK unreachable" : void 0;
        !(field.plural === plural) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayRecordSourceSelectorProxy#getRootField(): Expected root field ' + '`%s` to be %s.', fieldName, plural ? 'plural' : 'singular') : "TURBOPACK unreachable" : void 0;
        return field;
    };
    _proto.getRootField = function getRootField(fieldName) {
        var field = this._getRootField(this._readSelector, fieldName, false);
        var storageKey = getStorageKey(field, this._readSelector.variables);
        return this.getOperationRoot().getLinkedRecord(storageKey);
    };
    _proto.getPluralRootField = function getPluralRootField(fieldName) {
        var field = this._getRootField(this._readSelector, fieldName, true);
        var storageKey = getStorageKey(field, this._readSelector.variables);
        return this.getOperationRoot().getLinkedRecords(storageKey);
    };
    _proto.invalidateStore = function invalidateStore() {
        this.__recordSource.invalidateStore();
    };
    _proto.readUpdatableQuery = function readUpdatableQuery(query, variables) {
        return _readUpdatableQuery(query, variables, this, this._missingFieldHandlers);
    };
    _proto.readUpdatableFragment = function readUpdatableFragment(fragment, fragmentReference) {
        return _readUpdatableFragment(fragment, fragmentReference, this, this._missingFieldHandlers);
    };
    return RelayRecordSourceSelectorProxy;
}();
module.exports = RelayRecordSourceSelectorProxy;
}),
"[project]/node_modules/relay-runtime/lib/store/RelayPublishQueue.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _global$ErrorUtils$ap, _global$ErrorUtils;
var RelayRecordSourceMutator = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceMutator.js [app-rsc] (ecmascript)");
var RelayRecordSourceProxy = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceProxy.js [app-rsc] (ecmascript)");
var RelayRecordSourceSelectorProxy = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayRecordSourceSelectorProxy.js [app-rsc] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-rsc] (ecmascript)");
var RelayReader = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayReader.js [app-rsc] (ecmascript)");
var RelayRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
var _global = ("TURBOPACK compile-time truthy", 1) ? /*TURBOPACK member replacement*/ __turbopack_context__.g : "TURBOPACK unreachable";
var applyWithGuard = (_global$ErrorUtils$ap = _global === null || _global === void 0 ? void 0 : (_global$ErrorUtils = _global.ErrorUtils) === null || _global$ErrorUtils === void 0 ? void 0 : _global$ErrorUtils.applyWithGuard) !== null && _global$ErrorUtils$ap !== void 0 ? _global$ErrorUtils$ap : function(callback, context, args, onError, name) {
    return callback.apply(context, args);
};
var RelayPublishQueue = /*#__PURE__*/ function() {
    function RelayPublishQueue(store, handlerProvider, getDataID, missingFieldHandlers, log) {
        this._hasStoreSnapshot = false;
        this._handlerProvider = handlerProvider || null;
        this._pendingBackupRebase = false;
        this._pendingData = new Set();
        this._pendingOptimisticUpdates = new Set();
        this._store = store;
        this._appliedOptimisticUpdates = new Set();
        this._gcHold = null;
        this._getDataID = getDataID;
        this._missingFieldHandlers = missingFieldHandlers;
        this._log = log;
    }
    var _proto = RelayPublishQueue.prototype;
    _proto.applyUpdate = function applyUpdate(updater) {
        !(!this._appliedOptimisticUpdates.has(updater) && !this._pendingOptimisticUpdates.has(updater)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayPublishQueue: Cannot apply the same update function more than ' + 'once concurrently.') : "TURBOPACK unreachable" : void 0;
        this._pendingOptimisticUpdates.add(updater);
    };
    _proto.revertUpdate = function revertUpdate(updater) {
        if (this._pendingOptimisticUpdates.has(updater)) {
            this._pendingOptimisticUpdates["delete"](updater);
        } else if (this._appliedOptimisticUpdates.has(updater)) {
            this._pendingBackupRebase = true;
            this._appliedOptimisticUpdates["delete"](updater);
        }
    };
    _proto.revertAll = function revertAll() {
        this._pendingBackupRebase = true;
        this._pendingOptimisticUpdates.clear();
        this._appliedOptimisticUpdates.clear();
    };
    _proto.commitPayload = function commitPayload(operation, payload, updater) {
        this._pendingBackupRebase = true;
        this._pendingData.add({
            kind: 'payload',
            operation: operation,
            payload: payload,
            updater: updater
        });
    };
    _proto.commitUpdate = function commitUpdate(updater) {
        this._pendingBackupRebase = true;
        this._pendingData.add({
            kind: 'updater',
            updater: updater
        });
    };
    _proto.commitSource = function commitSource(source) {
        this._pendingBackupRebase = true;
        this._pendingData.add({
            kind: 'source',
            source: source
        });
    };
    _proto.run = function run(sourceOperation) {
        var runWillClearGcHold = this._appliedOptimisticUpdates === 0 && !!this._gcHold;
        var runIsANoop = !this._pendingBackupRebase && this._pendingOptimisticUpdates.size === 0 && !runWillClearGcHold;
        ("TURBOPACK compile-time truthy", 1) ? warning(!runIsANoop, 'RelayPublishQueue.run was called, but the call would have been a noop.') : "TURBOPACK unreachable";
        RelayFeatureFlags.DISALLOW_NESTED_UPDATES ? !(this._isRunning !== true) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'A store update was detected within another store update. Please ' + "make sure new store updates aren't being executed within an " + 'updater function for a different update.') : "TURBOPACK unreachable" : void 0 : ("TURBOPACK compile-time truthy", 1) ? warning(this._isRunning !== true, 'A store update was detected within another store update. Please ' + "make sure new store updates aren't being executed within an " + 'updater function for a different update.') : "TURBOPACK unreachable";
        this._isRunning = true;
        if (runIsANoop) {
            this._isRunning = false;
            return [];
        }
        if (this._pendingBackupRebase) {
            if (this._hasStoreSnapshot) {
                this._store.restore();
                this._hasStoreSnapshot = false;
            }
        }
        var invalidatedStore = this._commitData();
        if (this._pendingOptimisticUpdates.size || this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {
            if (!this._hasStoreSnapshot) {
                this._store.snapshot();
                this._hasStoreSnapshot = true;
            }
            this._applyUpdates();
        }
        this._pendingBackupRebase = false;
        if (this._appliedOptimisticUpdates.size > 0) {
            if (!this._gcHold) {
                this._gcHold = this._store.holdGC();
            }
        } else {
            if (this._gcHold) {
                this._gcHold.dispose();
                this._gcHold = null;
            }
        }
        this._isRunning = false;
        return this._store.notify(sourceOperation, invalidatedStore);
    };
    _proto._publishSourceFromPayload = function _publishSourceFromPayload(pendingPayload) {
        var _this = this;
        var payload = pendingPayload.payload, operation = pendingPayload.operation, updater = pendingPayload.updater;
        var source = payload.source, fieldPayloads = payload.fieldPayloads;
        var mutator = new RelayRecordSourceMutator(this._store.getSource(), source);
        var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID, this._handlerProvider, this._missingFieldHandlers, this._log);
        if (fieldPayloads && fieldPayloads.length) {
            fieldPayloads.forEach(function(fieldPayload) {
                var handler = _this._handlerProvider && _this._handlerProvider(fieldPayload.handle);
                !handler ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernEnvironment: Expected a handler to be provided for ' + 'handle `%s`.', fieldPayload.handle) : "TURBOPACK unreachable" : void 0;
                handler.update(recordSourceProxy, fieldPayload);
            });
        }
        if (updater) {
            var selector = operation.fragment;
            !(selector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernEnvironment: Expected a selector to be provided with updater function.') : "TURBOPACK unreachable" : void 0;
            var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, selector, this._missingFieldHandlers);
            var selectorData = lookupSelector(source, selector);
            updater(recordSourceSelectorProxy, selectorData);
        }
        var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();
        this._store.publish(source, idsMarkedForInvalidation);
        return recordSourceProxy.isStoreMarkedForInvalidation();
    };
    _proto._commitData = function _commitData() {
        var _this2 = this;
        if (!this._pendingData.size) {
            return false;
        }
        var invalidatedStore = false;
        this._pendingData.forEach(function(data) {
            if (data.kind === 'payload') {
                var payloadInvalidatedStore = _this2._publishSourceFromPayload(data);
                invalidatedStore = invalidatedStore || payloadInvalidatedStore;
            } else if (data.kind === 'source') {
                var source = data.source;
                _this2._store.publish(source);
            } else {
                var updater = data.updater;
                var sink = RelayRecordSource.create();
                var mutator = new RelayRecordSourceMutator(_this2._store.getSource(), sink);
                var recordSourceProxy = new RelayRecordSourceProxy(mutator, _this2._getDataID, _this2._handlerProvider, _this2._missingFieldHandlers, _this2._log);
                applyWithGuard(updater, null, [
                    recordSourceProxy
                ], null, 'RelayPublishQueue:commitData');
                invalidatedStore = invalidatedStore || recordSourceProxy.isStoreMarkedForInvalidation();
                var idsMarkedForInvalidation = recordSourceProxy.getIDsMarkedForInvalidation();
                _this2._store.publish(sink, idsMarkedForInvalidation);
            }
        });
        this._pendingData.clear();
        return invalidatedStore;
    };
    _proto._applyUpdates = function _applyUpdates() {
        var _this3 = this;
        var sink = RelayRecordSource.create();
        var mutator = new RelayRecordSourceMutator(this._store.getSource(), sink);
        var recordSourceProxy = new RelayRecordSourceProxy(mutator, this._getDataID, this._handlerProvider, this._missingFieldHandlers, this._log);
        var processUpdate = function processUpdate(optimisticUpdate) {
            if (optimisticUpdate.storeUpdater) {
                var storeUpdater = optimisticUpdate.storeUpdater;
                applyWithGuard(storeUpdater, null, [
                    recordSourceProxy
                ], null, 'RelayPublishQueue:applyUpdates');
            } else {
                var operation = optimisticUpdate.operation, payload = optimisticUpdate.payload, updater = optimisticUpdate.updater;
                var source = payload.source, fieldPayloads = payload.fieldPayloads;
                if (source) {
                    recordSourceProxy.publishSource(source, fieldPayloads);
                }
                if (updater) {
                    var selectorData;
                    if (source) {
                        selectorData = lookupSelector(source, operation.fragment);
                    }
                    var recordSourceSelectorProxy = new RelayRecordSourceSelectorProxy(mutator, recordSourceProxy, operation.fragment, _this3._missingFieldHandlers);
                    applyWithGuard(updater, null, [
                        recordSourceSelectorProxy,
                        selectorData
                    ], null, 'RelayPublishQueue:applyUpdates');
                }
            }
        };
        if (this._pendingBackupRebase && this._appliedOptimisticUpdates.size) {
            this._appliedOptimisticUpdates.forEach(processUpdate);
        }
        if (this._pendingOptimisticUpdates.size) {
            this._pendingOptimisticUpdates.forEach(function(optimisticUpdate) {
                processUpdate(optimisticUpdate);
                _this3._appliedOptimisticUpdates.add(optimisticUpdate);
            });
            this._pendingOptimisticUpdates.clear();
        }
        this._store.publish(sink);
    };
    return RelayPublishQueue;
}();
function lookupSelector(source, selector) {
    var selectorData = RelayReader.read(source, selector).data;
    if ("TURBOPACK compile-time truthy", 1) {
        var deepFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-rsc] (ecmascript)");
        if (selectorData) {
            deepFreeze(selectorData);
        }
    }
    return selectorData;
}
module.exports = RelayPublishQueue;
}),
"[project]/node_modules/relay-runtime/lib/store/StoreInspector.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-rsc] (ecmascript)"));
var inspect = function inspect() {};
if ("TURBOPACK compile-time truthy", 1) {
    var formattersInstalled = false;
    var installDevtoolFormatters = function installDevtoolFormatters() {
        var _window$devtoolsForma;
        if (formattersInstalled) {
            return;
        }
        formattersInstalled = true;
        if (window.devtoolsFormatters == null) {
            window.devtoolsFormatters = [];
        }
        if (!Array.isArray(window.devtoolsFormatters)) {
            return;
        }
        console.info('Make sure to select "Enable custom formatters" in the Chrome ' + 'Developer Tools settings, tab "Preferences" under the "Console" ' + 'section.');
        (_window$devtoolsForma = window.devtoolsFormatters).push.apply(_window$devtoolsForma, (0, _toConsumableArray2["default"])(createFormatters()));
    };
    var createFormatters = function createFormatters() {
        var listStyle = {
            style: 'list-style-type: none; padding: 0; margin: 0 0 0 12px; font-style: normal'
        };
        var keyStyle = {
            style: 'rgb(136, 19, 145)'
        };
        var nullStyle = {
            style: 'color: #777'
        };
        var reference = function reference(object, config) {
            return object == null ? [
                'span',
                nullStyle,
                'undefined'
            ] : [
                'object',
                {
                    object: object,
                    config: config
                }
            ];
        };
        var renderRecordHeader = function renderRecordHeader(record) {
            return [
                'span',
                {
                    style: 'font-style: italic'
                },
                record.__typename,
                [
                    'span',
                    nullStyle,
                    ' {id: "',
                    record.__id,
                    '", }'
                ]
            ];
        };
        var isRecord = function isRecord(o) {
            return o != null && typeof o.__id === 'string';
        };
        var RecordEntry = function RecordEntry(key, value) {
            this.key = key;
            this.value = value;
        };
        var renderRecordEntries = function renderRecordEntries(record) {
            var children = Object.keys(record).map(function(key) {
                return [
                    'li',
                    {},
                    [
                        'object',
                        {
                            object: new RecordEntry(key, record[key])
                        }
                    ]
                ];
            });
            return [
                'ol',
                listStyle
            ].concat((0, _toConsumableArray2["default"])(children));
        };
        var recordFormatter = {
            header: function header(obj) {
                if (!isRecord(obj)) {
                    return null;
                }
                return renderRecordHeader(obj);
            },
            hasBody: function hasBody(obj) {
                return true;
            },
            body: function body(obj) {
                return renderRecordEntries(obj);
            }
        };
        var recordEntryFormatter = {
            header: function header(obj) {
                if (obj instanceof RecordEntry) {
                    var value = isRecord(obj.value) ? renderRecordHeader(obj.value) : reference(obj.value);
                    return [
                        'span',
                        keyStyle,
                        obj.key,
                        ': ',
                        value
                    ];
                }
                return null;
            },
            hasBody: function hasBody(obj) {
                return isRecord(obj.value);
            },
            body: function body(obj) {
                return renderRecordEntries(obj.value);
            }
        };
        return [
            recordFormatter,
            recordEntryFormatter
        ];
    };
    var getWrappedRecord = function getWrappedRecord(source, dataID) {
        var record = source.get(dataID);
        if (record == null) {
            return record;
        }
        return new Proxy((0, _objectSpread2["default"])({}, record), {
            get: function get(target, prop) {
                var value = target[prop];
                if (value == null) {
                    return value;
                }
                if (typeof value === 'object') {
                    if (typeof value.__ref === 'string') {
                        return getWrappedRecord(source, value.__ref);
                    }
                    if (Array.isArray(value.__refs)) {
                        return value.__refs.map(function(ref) {
                            return getWrappedRecord(source, ref);
                        });
                    }
                }
                return value;
            }
        });
    };
    inspect = function inspect(environment, dataID) {
        installDevtoolFormatters();
        return getWrappedRecord(environment.getStore().getSource(), dataID !== null && dataID !== void 0 ? dataID : 'client:root');
    };
}
module.exports = {
    inspect: inspect
};
}),
"[project]/node_modules/relay-runtime/lib/store/RelayModernEnvironment.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var RelayDefaultHandlerProvider = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/RelayDefaultHandlerProvider.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/multi-actor-environment/ActorIdentifier.js [app-rsc] (ecmascript)"), INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE = _require.INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE, assertInternalActorIdentifier = _require.assertInternalActorIdentifier;
var RelayObservable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-rsc] (ecmascript)");
var wrapNetworkWithLogObserver = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/wrapNetworkWithLogObserver.js [app-rsc] (ecmascript)");
var RelayOperationTracker = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayOperationTracker.js [app-rsc] (ecmascript)");
var registerEnvironmentWithDevTools = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/registerEnvironmentWithDevTools.js [app-rsc] (ecmascript)");
var defaultGetDataID = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/defaultGetDataID.js [app-rsc] (ecmascript)");
var defaultRelayFieldLogger = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/defaultRelayFieldLogger.js [app-rsc] (ecmascript)");
var normalizeResponse = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/normalizeResponse.js [app-rsc] (ecmascript)");
var OperationExecutor = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/OperationExecutor.js [app-rsc] (ecmascript)");
var RelayModernStore = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernStore.js [app-rsc] (ecmascript)");
var RelayPublishQueue = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayPublishQueue.js [app-rsc] (ecmascript)");
var RelayRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var RelayModernEnvironment = /*#__PURE__*/ function() {
    function RelayModernEnvironment(config) {
        var _this = this;
        var _config$store, _config$log, _config$relayFieldLog, _config$UNSTABLE_defa, _config$getDataID, _config$missingFieldH, _config$handlerProvid, _config$scheduler, _config$isServer, _config$normalizeResp, _config$operationTrac;
        this.configName = config.configName;
        this._treatMissingFieldsAsNull = config.treatMissingFieldsAsNull === true;
        var operationLoader = config.operationLoader;
        if ("TURBOPACK compile-time truthy", 1) {
            if (operationLoader != null) {
                !(typeof operationLoader === 'object' && typeof operationLoader.get === 'function' && typeof operationLoader.load === 'function') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayModernEnvironment: Expected `operationLoader` to be an object ' + 'with get() and load() functions, got `%s`.', operationLoader) : "TURBOPACK unreachable" : void 0;
            }
        }
        var store = (_config$store = config.store) !== null && _config$store !== void 0 ? _config$store : new RelayModernStore(new RelayRecordSource(), {
            log: config.log,
            operationLoader: config.operationLoader,
            getDataID: config.getDataID,
            shouldProcessClientComponents: config.shouldProcessClientComponents
        });
        this.__log = (_config$log = config.log) !== null && _config$log !== void 0 ? _config$log : emptyFunction;
        this.relayFieldLogger = (_config$relayFieldLog = config.relayFieldLogger) !== null && _config$relayFieldLog !== void 0 ? _config$relayFieldLog : defaultRelayFieldLogger;
        this._defaultRenderPolicy = (_config$UNSTABLE_defa = config.UNSTABLE_defaultRenderPolicy) !== null && _config$UNSTABLE_defa !== void 0 ? _config$UNSTABLE_defa : 'partial';
        this._operationLoader = operationLoader;
        this._operationExecutions = new Map();
        this._network = wrapNetworkWithLogObserver(this, config.network);
        this._getDataID = (_config$getDataID = config.getDataID) !== null && _config$getDataID !== void 0 ? _config$getDataID : defaultGetDataID;
        this._missingFieldHandlers = (_config$missingFieldH = config.missingFieldHandlers) !== null && _config$missingFieldH !== void 0 ? _config$missingFieldH : [];
        this._publishQueue = new RelayPublishQueue(store, (_config$handlerProvid = config.handlerProvider) !== null && _config$handlerProvid !== void 0 ? _config$handlerProvid : RelayDefaultHandlerProvider, this._getDataID, this._missingFieldHandlers, this.__log);
        this._scheduler = (_config$scheduler = config.scheduler) !== null && _config$scheduler !== void 0 ? _config$scheduler : null;
        this._store = store;
        this.options = config.options;
        this._isServer = (_config$isServer = config.isServer) !== null && _config$isServer !== void 0 ? _config$isServer : false;
        this._normalizeResponse = (_config$normalizeResp = config.normalizeResponse) !== null && _config$normalizeResp !== void 0 ? _config$normalizeResp : normalizeResponse;
        this.__setNet = function(newNet) {
            return _this._network = wrapNetworkWithLogObserver(_this, newNet);
        };
        if ("TURBOPACK compile-time truthy", 1) {
            var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/StoreInspector.js [app-rsc] (ecmascript)"), inspect = _require2.inspect;
            this.DEBUG_inspect = function(dataID) {
                return inspect(_this, dataID);
            };
        }
        this._operationTracker = (_config$operationTrac = config.operationTracker) !== null && _config$operationTrac !== void 0 ? _config$operationTrac : new RelayOperationTracker();
        this._shouldProcessClientComponents = config.shouldProcessClientComponents;
        registerEnvironmentWithDevTools(this);
    }
    var _proto = RelayModernEnvironment.prototype;
    _proto.getStore = function getStore() {
        return this._store;
    };
    _proto.getNetwork = function getNetwork() {
        return this._network;
    };
    _proto.getOperationTracker = function getOperationTracker() {
        return this._operationTracker;
    };
    _proto.getScheduler = function getScheduler() {
        return this._scheduler;
    };
    _proto.isRequestActive = function isRequestActive(requestIdentifier) {
        var activeState = this._operationExecutions.get(requestIdentifier);
        return activeState === 'active';
    };
    _proto.UNSTABLE_getDefaultRenderPolicy = function UNSTABLE_getDefaultRenderPolicy() {
        return this._defaultRenderPolicy;
    };
    _proto.applyUpdate = function applyUpdate(optimisticUpdate) {
        var _this2 = this;
        var dispose = function dispose() {
            _this2._scheduleUpdates(function() {
                _this2._publishQueue.revertUpdate(optimisticUpdate);
                _this2._publishQueue.run();
            });
        };
        this._scheduleUpdates(function() {
            _this2._publishQueue.applyUpdate(optimisticUpdate);
            _this2._publishQueue.run();
        });
        return {
            dispose: dispose
        };
    };
    _proto.revertUpdate = function revertUpdate(update) {
        var _this3 = this;
        this._scheduleUpdates(function() {
            _this3._publishQueue.revertUpdate(update);
            _this3._publishQueue.run();
        });
    };
    _proto.replaceUpdate = function replaceUpdate(update, newUpdate) {
        var _this4 = this;
        this._scheduleUpdates(function() {
            _this4._publishQueue.revertUpdate(update);
            _this4._publishQueue.applyUpdate(newUpdate);
            _this4._publishQueue.run();
        });
    };
    _proto.applyMutation = function applyMutation(optimisticConfig) {
        var subscription = this._execute({
            createSource: function createSource() {
                return RelayObservable.create(function(_sink) {});
            },
            isClientPayload: false,
            operation: optimisticConfig.operation,
            optimisticConfig: optimisticConfig,
            updater: null
        }).subscribe({});
        return {
            dispose: function dispose() {
                return subscription.unsubscribe();
            }
        };
    };
    _proto.check = function check(operation) {
        if (this._missingFieldHandlers.length === 0 && !operationHasClientAbstractTypes(operation)) {
            return this._store.check(operation);
        }
        return this._checkSelectorAndHandleMissingFields(operation, this._missingFieldHandlers);
    };
    _proto.commitPayload = function commitPayload(operation, payload) {
        this._execute({
            createSource: function createSource() {
                return RelayObservable.from({
                    data: payload
                });
            },
            isClientPayload: true,
            operation: operation,
            optimisticConfig: null,
            updater: null
        }).subscribe({});
    };
    _proto.commitUpdate = function commitUpdate(updater) {
        var _this5 = this;
        this._scheduleUpdates(function() {
            _this5._publishQueue.commitUpdate(updater);
            _this5._publishQueue.run();
        });
    };
    _proto.lookup = function lookup(readSelector) {
        return this._store.lookup(readSelector);
    };
    _proto.subscribe = function subscribe(snapshot, callback) {
        return this._store.subscribe(snapshot, callback);
    };
    _proto.retain = function retain(operation) {
        return this._store.retain(operation);
    };
    _proto.isServer = function isServer() {
        return this._isServer;
    };
    _proto._checkSelectorAndHandleMissingFields = function _checkSelectorAndHandleMissingFields(operation, handlers) {
        var _this6 = this;
        var target = RelayRecordSource.create();
        var source = this._store.getSource();
        var result = this._store.check(operation, {
            handlers: handlers,
            defaultActorIdentifier: INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE,
            getSourceForActor: function getSourceForActor(actorIdentifier) {
                assertInternalActorIdentifier(actorIdentifier);
                return source;
            },
            getTargetForActor: function getTargetForActor(actorIdentifier) {
                assertInternalActorIdentifier(actorIdentifier);
                return target;
            }
        });
        if (target.size() > 0) {
            this._scheduleUpdates(function() {
                _this6._publishQueue.commitSource(target);
                _this6._publishQueue.run();
            });
        }
        return result;
    };
    _proto._scheduleUpdates = function _scheduleUpdates(task) {
        var scheduler = this._scheduler;
        if (scheduler != null) {
            scheduler.schedule(task);
        } else {
            task();
        }
    };
    _proto.execute = function execute(_ref) {
        var _this7 = this;
        var operation = _ref.operation;
        return this._execute({
            createSource: function createSource() {
                return _this7.getNetwork().execute(operation.request.node.params, operation.request.variables, operation.request.cacheConfig || {}, null, undefined, undefined, undefined, function() {
                    return _this7.check(operation);
                });
            },
            isClientPayload: false,
            operation: operation,
            optimisticConfig: null,
            updater: null
        });
    };
    _proto.executeSubscription = function executeSubscription(_ref2) {
        var _this8 = this;
        var operation = _ref2.operation, updater = _ref2.updater;
        return this._execute({
            createSource: function createSource() {
                return _this8.getNetwork().execute(operation.request.node.params, operation.request.variables, operation.request.cacheConfig || {}, null);
            },
            isClientPayload: false,
            operation: operation,
            optimisticConfig: null,
            updater: updater
        });
    };
    _proto.executeMutation = function executeMutation(_ref3) {
        var _this9 = this;
        var operation = _ref3.operation, optimisticResponse = _ref3.optimisticResponse, optimisticUpdater = _ref3.optimisticUpdater, updater = _ref3.updater, uploadables = _ref3.uploadables;
        var optimisticConfig;
        if (optimisticResponse || optimisticUpdater) {
            optimisticConfig = {
                operation: operation,
                response: optimisticResponse,
                updater: optimisticUpdater
            };
        }
        return this._execute({
            createSource: function createSource() {
                return _this9.getNetwork().execute(operation.request.node.params, operation.request.variables, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, operation.request.cacheConfig), {}, {
                    force: true
                }), uploadables);
            },
            isClientPayload: false,
            operation: operation,
            optimisticConfig: optimisticConfig,
            updater: updater
        });
    };
    _proto.executeWithSource = function executeWithSource(_ref4) {
        var operation = _ref4.operation, source = _ref4.source;
        return this._execute({
            createSource: function createSource() {
                return source;
            },
            isClientPayload: false,
            operation: operation,
            optimisticConfig: null,
            updater: null
        });
    };
    _proto.toJSON = function toJSON() {
        var _this$configName;
        return "RelayModernEnvironment(".concat((_this$configName = this.configName) !== null && _this$configName !== void 0 ? _this$configName : '', ")");
    };
    _proto._execute = function _execute(_ref5) {
        var _this10 = this;
        var createSource = _ref5.createSource, isClientPayload = _ref5.isClientPayload, operation = _ref5.operation, optimisticConfig = _ref5.optimisticConfig, updater = _ref5.updater;
        var publishQueue = this._publishQueue;
        var store = this._store;
        return RelayObservable.create(function(sink) {
            var executor = OperationExecutor.execute({
                actorIdentifier: INTERNAL_ACTOR_IDENTIFIER_DO_NOT_USE,
                getDataID: _this10._getDataID,
                isClientPayload: isClientPayload,
                log: _this10.__log,
                operation: operation,
                operationExecutions: _this10._operationExecutions,
                operationLoader: _this10._operationLoader,
                operationTracker: _this10._operationTracker,
                optimisticConfig: optimisticConfig,
                getPublishQueue: function getPublishQueue(actorIdentifier) {
                    assertInternalActorIdentifier(actorIdentifier);
                    return publishQueue;
                },
                scheduler: _this10._scheduler,
                shouldProcessClientComponents: _this10._shouldProcessClientComponents,
                sink: sink,
                source: createSource(),
                getStore: function getStore(actorIdentifier) {
                    assertInternalActorIdentifier(actorIdentifier);
                    return store;
                },
                treatMissingFieldsAsNull: _this10._treatMissingFieldsAsNull,
                updater: updater,
                normalizeResponse: _this10._normalizeResponse
            });
            return function() {
                return executor.cancel();
            };
        });
    };
    return RelayModernEnvironment;
}();
function operationHasClientAbstractTypes(operation) {
    return operation.root.node.kind === 'Operation' && operation.root.node.clientAbstractTypes != null;
}
RelayModernEnvironment.prototype['@@RelayModernEnvironment'] = true;
function emptyFunction() {}
module.exports = RelayModernEnvironment;
}),
"[project]/node_modules/relay-runtime/lib/subscription/requestSubscription.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var RelayDeclarativeMutationConfig = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayDeclarativeMutationConfig.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-rsc] (ecmascript)"), getRequest = _require.getRequest;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-rsc] (ecmascript)"), createOperationDescriptor = _require2.createOperationDescriptor;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-rsc] (ecmascript)"), createReaderSelector = _require3.createReaderSelector;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function requestSubscription(environment, config) {
    var subscription = getRequest(config.subscription);
    if (subscription.params.operationKind !== 'subscription') {
        throw new Error('requestSubscription: Must use Subscription operation');
    }
    var configs = config.configs, onCompleted = config.onCompleted, onError = config.onError, onNext = config.onNext, variables = config.variables, cacheConfig = config.cacheConfig;
    var operation = createOperationDescriptor(subscription, variables, cacheConfig);
    ("TURBOPACK compile-time truthy", 1) ? warning(!(config.updater && configs), 'requestSubscription: Expected only one of `updater` and `configs` to be provided') : "TURBOPACK unreachable";
    var _ref = configs ? RelayDeclarativeMutationConfig.convert(configs, subscription, null, config.updater) : config, updater = _ref.updater;
    var sub = environment.executeSubscription({
        operation: operation,
        updater: updater
    }).subscribe({
        next: function next(responses) {
            if (onNext != null) {
                var selector = operation.fragment;
                var nextID;
                if (Array.isArray(responses)) {
                    var _responses$, _responses$$extension;
                    nextID = (_responses$ = responses[0]) === null || _responses$ === void 0 ? void 0 : (_responses$$extension = _responses$.extensions) === null || _responses$$extension === void 0 ? void 0 : _responses$$extension.__relay_subscription_root_id;
                } else {
                    var _responses$extensions;
                    nextID = (_responses$extensions = responses.extensions) === null || _responses$extensions === void 0 ? void 0 : _responses$extensions.__relay_subscription_root_id;
                }
                if (typeof nextID === 'string') {
                    selector = createReaderSelector(selector.node, nextID, selector.variables, selector.owner);
                }
                var data = environment.lookup(selector).data;
                onNext(data);
            }
        },
        error: onError,
        complete: onCompleted
    });
    return {
        dispose: sub.unsubscribe
    };
}
module.exports = requestSubscription;
}),
"[project]/node_modules/relay-runtime/lib/util/createPayloadFor3DField.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)"), getModuleComponentKey = _require.getModuleComponentKey, getModuleOperationKey = _require.getModuleOperationKey;
function createPayloadFor3DField(name, operation, component, response) {
    var data = (0, _objectSpread2["default"])({}, response);
    data[getModuleComponentKey(name)] = component;
    data[getModuleOperationKey(name)] = operation;
    return data;
}
module.exports = createPayloadFor3DField;
}),
"[project]/node_modules/relay-runtime/lib/util/isEmptyObject.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var hasOwnProperty = Object.prototype.hasOwnProperty;
function isEmptyObject(obj) {
    for(var _key in obj){
        if (hasOwnProperty.call(obj, _key)) {
            return false;
        }
    }
    return true;
}
module.exports = isEmptyObject;
}),
"[project]/node_modules/relay-runtime/lib/util/getFragmentIdentifier.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-rsc] (ecmascript)"), getDataIDsFromFragment = _require.getDataIDsFromFragment, getSelector = _require.getSelector, getVariablesFromFragment = _require.getVariablesFromFragment;
var isEmptyObject = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/isEmptyObject.js [app-rsc] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-rsc] (ecmascript)"), stableCopy = _require2.stableCopy;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/StringInterner.js [app-rsc] (ecmascript)"), intern = _require3.intern;
function getFragmentIdentifier(fragmentNode, fragmentRef) {
    var selector = getSelector(fragmentNode, fragmentRef);
    var fragmentOwnerIdentifier = selector == null ? 'null' : selector.kind === 'SingularReaderSelector' ? selector.owner.identifier : '[' + selector.selectors.map(function(sel) {
        return sel.owner.identifier;
    }).join(',') + ']';
    var fragmentVariables = getVariablesFromFragment(fragmentNode, fragmentRef);
    var dataIDs = getDataIDsFromFragment(fragmentNode, fragmentRef);
    if (RelayFeatureFlags.ENABLE_GETFRAGMENTIDENTIFIER_OPTIMIZATION) {
        var ids = typeof dataIDs === 'undefined' ? 'missing' : dataIDs == null ? 'null' : Array.isArray(dataIDs) ? '[' + dataIDs.join(',') + ']' : dataIDs;
        ids = RelayFeatureFlags.STRING_INTERN_LEVEL <= 1 ? ids : intern(ids, RelayFeatureFlags.MAX_DATA_ID_LENGTH);
        return fragmentOwnerIdentifier + '/' + fragmentNode.name + '/' + (fragmentVariables == null || isEmptyObject(fragmentVariables) ? '{}' : JSON.stringify(stableCopy(fragmentVariables))) + '/' + ids;
    } else {
        var _JSON$stringify;
        var _ids = (_JSON$stringify = JSON.stringify(dataIDs)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : 'missing';
        _ids = RelayFeatureFlags.STRING_INTERN_LEVEL <= 1 ? _ids : intern(_ids, RelayFeatureFlags.MAX_DATA_ID_LENGTH);
        return fragmentOwnerIdentifier + '/' + fragmentNode.name + '/' + JSON.stringify(stableCopy(fragmentVariables)) + '/' + _ids;
    }
}
module.exports = getFragmentIdentifier;
}),
"[project]/node_modules/relay-runtime/lib/util/getRefetchMetadata.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function getRefetchMetadata(fragmentNode, componentDisplayName) {
    var _fragmentNode$metadat, _fragmentNode$metadat2;
    !(((_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) !== true) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getRefetchMetadata(): Expected fragment `%s` not to be plural when using ' + '`%s`. Remove `@relay(plural: true)` from fragment `%s` ' + 'in order to use it with `%s`.', fragmentNode.name, componentDisplayName, fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable" : void 0;
    var refetchMetadata = (_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.refetch;
    !(refetchMetadata != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getRefetchMetadata(): Expected fragment `%s` to be refetchable when using `%s`. ' + 'Did you forget to add a @refetchable directive to the fragment?', componentDisplayName, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    var refetchableRequest = refetchMetadata.operation["default"] ? refetchMetadata.operation["default"] : refetchMetadata.operation;
    var fragmentRefPathInResponse = refetchMetadata.fragmentPathInResult;
    !(typeof refetchableRequest !== 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getRefetchMetadata(): Expected refetch query to be an ' + "operation and not a string when using `%s`. If you're seeing this, " + 'this is likely a bug in Relay.', componentDisplayName) : "TURBOPACK unreachable" : void 0;
    var identifierInfo = refetchMetadata.identifierInfo;
    if (identifierInfo != null) {
        !(identifierInfo.identifierField == null || typeof identifierInfo.identifierField === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getRefetchMetadata(): Expected `identifierField` to be a string.') : "TURBOPACK unreachable" : void 0;
        !(identifierInfo.identifierQueryVariableName == null || typeof identifierInfo.identifierQueryVariableName === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getRefetchMetadata(): Expected `identifierQueryVariableName` to be a string.') : "TURBOPACK unreachable" : void 0;
    }
    return {
        fragmentRefPathInResponse: fragmentRefPathInResponse,
        identifierInfo: identifierInfo,
        refetchableRequest: refetchableRequest,
        refetchMetadata: refetchMetadata
    };
}
module.exports = getRefetchMetadata;
}),
"[project]/node_modules/relay-runtime/lib/util/getPaginationMetadata.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var getRefetchMetadata = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRefetchMetadata.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function getPaginationMetadata(fragmentNode, componentDisplayName) {
    var _fragmentNode$metadat, _fragmentNode$metadat2;
    var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName), paginationRequest = _getRefetchMetadata.refetchableRequest, refetchMetadata = _getRefetchMetadata.refetchMetadata;
    var paginationMetadata = refetchMetadata.connection;
    !(paginationMetadata != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getPaginationMetadata(): Expected fragment `%s` to include a ' + 'connection when using `%s`. Did you forget to add a @connection ' + 'directive to the connection field in the fragment?', componentDisplayName, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    var connectionPathInFragmentData = paginationMetadata.path;
    var connectionMetadata = ((_fragmentNode$metadat = (_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.connection) !== null && _fragmentNode$metadat !== void 0 ? _fragmentNode$metadat : [])[0];
    !(connectionMetadata != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getPaginationMetadata(): Expected fragment `%s` to include a ' + 'connection when using `%s`. Did you forget to add a @connection ' + 'directive to the connection field in the fragment?', componentDisplayName, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    var identifierInfo = refetchMetadata.identifierInfo;
    !((identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField) == null || typeof identifierInfo.identifierField === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: getRefetchMetadata(): Expected `identifierField` to be a string.') : "TURBOPACK unreachable" : void 0;
    return {
        connectionPathInFragmentData: connectionPathInFragmentData,
        identifierField: identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField,
        paginationRequest: paginationRequest,
        paginationMetadata: paginationMetadata,
        stream: connectionMetadata.stream === true
    };
}
module.exports = getPaginationMetadata;
}),
"[project]/node_modules/relay-runtime/lib/util/getPaginationVariables.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var _objectSpread4 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function getPaginationVariables(direction, count, cursor, baseVariables, extraVariables, paginationMetadata) {
    var _objectSpread3;
    var backwardMetadata = paginationMetadata.backward, forwardMetadata = paginationMetadata.forward;
    if (direction === 'backward') {
        var _objectSpread2;
        !(backwardMetadata != null && backwardMetadata.count != null && backwardMetadata.cursor != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected backward pagination metadata to be available. ' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable" : void 0;
        ("TURBOPACK compile-time truthy", 1) ? warning(!extraVariables.hasOwnProperty(backwardMetadata.cursor), 'Relay: `UNSTABLE_extraVariables` provided by caller should not ' + 'contain cursor variable `%s`. This variable is automatically ' + 'determined by Relay.', backwardMetadata.cursor) : "TURBOPACK unreachable";
        ("TURBOPACK compile-time truthy", 1) ? warning(!extraVariables.hasOwnProperty(backwardMetadata.count), 'Relay: `UNSTABLE_extraVariables` provided by caller should not ' + 'contain count variable `%s`. This variable is automatically ' + 'determined by Relay.', backwardMetadata.count) : "TURBOPACK unreachable";
        var _paginationVariables = (0, _objectSpread4["default"])((0, _objectSpread4["default"])((0, _objectSpread4["default"])({}, baseVariables), extraVariables), {}, (_objectSpread2 = {}, (0, _defineProperty2["default"])(_objectSpread2, backwardMetadata.cursor, cursor), (0, _defineProperty2["default"])(_objectSpread2, backwardMetadata.count, count), _objectSpread2));
        if (forwardMetadata && forwardMetadata.cursor) {
            _paginationVariables[forwardMetadata.cursor] = null;
        }
        if (forwardMetadata && forwardMetadata.count) {
            _paginationVariables[forwardMetadata.count] = null;
        }
        return _paginationVariables;
    }
    !(forwardMetadata != null && forwardMetadata.count != null && forwardMetadata.cursor != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected forward pagination metadata to be available. ' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable" : void 0;
    ("TURBOPACK compile-time truthy", 1) ? warning(!extraVariables.hasOwnProperty(forwardMetadata.cursor), 'Relay: `UNSTABLE_extraVariables` provided by caller should not ' + 'contain cursor variable `%s`. This variable is automatically ' + 'determined by Relay.', forwardMetadata.cursor) : "TURBOPACK unreachable";
    ("TURBOPACK compile-time truthy", 1) ? warning(!extraVariables.hasOwnProperty(forwardMetadata.count), 'Relay: `UNSTABLE_extraVariables` provided by caller should not ' + 'contain count variable `%s`. This variable is automatically ' + 'determined by Relay.', forwardMetadata.count) : "TURBOPACK unreachable";
    var paginationVariables = (0, _objectSpread4["default"])((0, _objectSpread4["default"])((0, _objectSpread4["default"])({}, baseVariables), extraVariables), {}, (_objectSpread3 = {}, (0, _defineProperty2["default"])(_objectSpread3, forwardMetadata.cursor, cursor), (0, _defineProperty2["default"])(_objectSpread3, forwardMetadata.count, count), _objectSpread3));
    if (backwardMetadata && backwardMetadata.cursor) {
        paginationVariables[backwardMetadata.cursor] = null;
    }
    if (backwardMetadata && backwardMetadata.count) {
        paginationVariables[backwardMetadata.count] = null;
    }
    return paginationVariables;
}
module.exports = getPaginationVariables;
}),
"[project]/node_modules/relay-runtime/lib/util/getValueAtPath.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function getValueAtPath(data, path) {
    var result = data;
    var _iterator = (0, _createForOfIteratorHelper2["default"])(path), _step;
    try {
        for(_iterator.s(); !(_step = _iterator.n()).done;){
            var key = _step.value;
            if (result == null) {
                return null;
            }
            if (typeof key === 'number') {
                !Array.isArray(result) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected an array when extracting value at path. ' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable" : void 0;
                result = result[key];
            } else {
                !(typeof result === 'object' && !Array.isArray(result)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected an object when extracting value at path. ' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable" : void 0;
                result = result[key];
            }
        }
    } catch (err) {
        _iterator.e(err);
    } finally{
        _iterator.f();
    }
    return result;
}
module.exports = getValueAtPath;
}),
"[project]/node_modules/relay-runtime/lib/util/RelayProfiler.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var profileHandlersByName = {};
var defaultProfiler = {
    stop: function stop() {}
};
var RelayProfiler = {
    profile: function profile(name, state) {
        var handlers = profileHandlersByName[name];
        if (handlers && handlers.length > 0) {
            var stopHandlers = [];
            for(var ii = handlers.length - 1; ii >= 0; ii--){
                var stopHandler = handlers[ii](name, state);
                stopHandlers.unshift(stopHandler);
            }
            return {
                stop: function stop(error) {
                    stopHandlers.forEach(function(stopHandler) {
                        return stopHandler(error);
                    });
                }
            };
        }
        return defaultProfiler;
    },
    attachProfileHandler: function attachProfileHandler(name, handler) {
        if (!profileHandlersByName.hasOwnProperty(name)) {
            profileHandlersByName[name] = [];
        }
        profileHandlersByName[name].push(handler);
    },
    detachProfileHandler: function detachProfileHandler(name, handler) {
        if (profileHandlersByName.hasOwnProperty(name)) {
            removeFromArray(profileHandlersByName[name], handler);
        }
    }
};
function removeFromArray(array, element) {
    var index = array.indexOf(element);
    if (index !== -1) {
        array.splice(index, 1);
    }
}
module.exports = RelayProfiler;
}),
"[project]/node_modules/relay-runtime/lib/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/experimental.js [app-rsc] (ecmascript)"), isErrorResult = _require.isErrorResult, isValueResult = _require.isValueResult;
var ConnectionHandler = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionHandler.js [app-rsc] (ecmascript)");
var ConnectionInterface = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/ConnectionInterface.js [app-rsc] (ecmascript)");
var MutationHandlers = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/connection/MutationHandlers.js [app-rsc] (ecmascript)");
var RelayDefaultHandlerProvider = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/handlers/RelayDefaultHandlerProvider.js [app-rsc] (ecmascript)");
var applyOptimisticMutation = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/applyOptimisticMutation.js [app-rsc] (ecmascript)");
var commitLocalUpdate = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/commitLocalUpdate.js [app-rsc] (ecmascript)");
var commitMutation = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/commitMutation.js [app-rsc] (ecmascript)");
var RelayDeclarativeMutationConfig = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/mutations/RelayDeclarativeMutationConfig.js [app-rsc] (ecmascript)");
var RelayNetwork = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayNetwork.js [app-rsc] (ecmascript)");
var RelayObservable = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayObservable.js [app-rsc] (ecmascript)");
var RelayQueryResponseCache = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/network/RelayQueryResponseCache.js [app-rsc] (ecmascript)");
var fetchQuery = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/fetchQuery.js [app-rsc] (ecmascript)");
var fetchQuery_DEPRECATED = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/fetchQuery_DEPRECATED.js [app-rsc] (ecmascript)");
var fetchQueryInternal = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/fetchQueryInternal.js [app-rsc] (ecmascript)");
var GraphQLTag = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/GraphQLTag.js [app-rsc] (ecmascript)");
var PreloadableQueryRegistry = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/query/PreloadableQueryRegistry.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ClientID.js [app-rsc] (ecmascript)"), generateClientID = _require2.generateClientID, generateUniqueClientID = _require2.generateUniqueClientID, isClientID = _require2.isClientID;
var createFragmentSpecResolver = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/createFragmentSpecResolver.js [app-rsc] (ecmascript)");
var createRelayContext = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/createRelayContext.js [app-rsc] (ecmascript)");
var createRelayLoggingContext = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/createRelayLoggingContext.js [app-rsc] (ecmascript)");
var isRelayModernEnvironment = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/isRelayModernEnvironment.js [app-rsc] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/live-resolvers/LiveResolverSuspenseSentinel.js [app-rsc] (ecmascript)"), isSuspenseSentinel = _require3.isSuspenseSentinel, suspenseSentinel = _require3.suspenseSentinel;
var normalizeResponse = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/normalizeResponse.js [app-rsc] (ecmascript)");
var readInlineData = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/readInlineData.js [app-rsc] (ecmascript)");
var RelayConcreteVariables = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js [app-rsc] (ecmascript)");
var RelayModernEnvironment = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernEnvironment.js [app-rsc] (ecmascript)");
var RelayModernOperationDescriptor = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernOperationDescriptor.js [app-rsc] (ecmascript)");
var RelayModernRecord = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernRecord.js [app-rsc] (ecmascript)");
var RelayModernSelector = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernSelector.js [app-rsc] (ecmascript)");
var RelayModernStore = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayModernStore.js [app-rsc] (ecmascript)");
var RelayOperationTracker = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayOperationTracker.js [app-rsc] (ecmascript)");
var RelayRecordSource = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayRecordSource.js [app-rsc] (ecmascript)");
var RelayStoreUtils = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/RelayStoreUtils.js [app-rsc] (ecmascript)");
var ResolverFragments = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ResolverFragments.js [app-rsc] (ecmascript)");
var ViewerPattern = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/store/ViewerPattern.js [app-rsc] (ecmascript)");
var requestSubscription = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/subscription/requestSubscription.js [app-rsc] (ecmascript)");
var createPayloadFor3DField = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/createPayloadFor3DField.js [app-rsc] (ecmascript)");
var deepFreeze = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/deepFreeze.js [app-rsc] (ecmascript)");
var getFragmentIdentifier = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getFragmentIdentifier.js [app-rsc] (ecmascript)");
var getPaginationMetadata = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getPaginationMetadata.js [app-rsc] (ecmascript)");
var getPaginationVariables = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getPaginationVariables.js [app-rsc] (ecmascript)");
var getPendingOperationsForFragment = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getPendingOperationsForFragment.js [app-rsc] (ecmascript)");
var getRefetchMetadata = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRefetchMetadata.js [app-rsc] (ecmascript)");
var getRelayHandleKey = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRelayHandleKey.js [app-rsc] (ecmascript)");
var getRequestIdentifier = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getRequestIdentifier.js [app-rsc] (ecmascript)");
var getValueAtPath = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/getValueAtPath.js [app-rsc] (ecmascript)");
var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/handlePotentialSnapshotErrors.js [app-rsc] (ecmascript)"), handlePotentialSnapshotErrors = _require4.handlePotentialSnapshotErrors;
var isPromise = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/isPromise.js [app-rsc] (ecmascript)");
var isScalarAndEqual = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/isScalarAndEqual.js [app-rsc] (ecmascript)");
var recycleNodesInto = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/recycleNodesInto.js [app-rsc] (ecmascript)");
var RelayConcreteNode = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayConcreteNode.js [app-rsc] (ecmascript)");
var RelayDefaultHandleKey = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayDefaultHandleKey.js [app-rsc] (ecmascript)");
var RelayError = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayError.js [app-rsc] (ecmascript)");
var RelayFeatureFlags = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayFeatureFlags.js [app-rsc] (ecmascript)");
var RelayProfiler = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayProfiler.js [app-rsc] (ecmascript)");
var RelayReplaySubject = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/RelayReplaySubject.js [app-rsc] (ecmascript)");
var _require5 = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/stableCopy.js [app-rsc] (ecmascript)"), hasCycle = _require5.hasCycle, stableCopy = _require5.stableCopy;
var withProvidedVariables = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/util/withProvidedVariables.js [app-rsc] (ecmascript)");
if ("TURBOPACK compile-time truthy", 1) {
    var mapStr = typeof Map !== 'function' ? 'Map' : null;
    var setStr = typeof Set !== 'function' ? 'Set' : null;
    var promiseStr = typeof Promise !== 'function' ? 'Promise' : null;
    var objStr = typeof Object.assign !== 'function' ? 'Object.assign' : null;
    if (mapStr || setStr || promiseStr || objStr) {
        throw new Error("relay-runtime requires ".concat([
            mapStr,
            setStr,
            promiseStr,
            objStr
        ].filter(Boolean).join(', and '), " to exist. ") + 'Use a polyfill to provide these for older browsers.');
    }
}
module.exports = {
    Environment: RelayModernEnvironment,
    Network: RelayNetwork,
    Observable: RelayObservable,
    QueryResponseCache: RelayQueryResponseCache,
    RecordSource: RelayRecordSource,
    Record: RelayModernRecord,
    ReplaySubject: RelayReplaySubject,
    Store: RelayModernStore,
    areEqualSelectors: RelayModernSelector.areEqualSelectors,
    createFragmentSpecResolver: createFragmentSpecResolver,
    createNormalizationSelector: RelayModernSelector.createNormalizationSelector,
    createOperationDescriptor: RelayModernOperationDescriptor.createOperationDescriptor,
    createReaderSelector: RelayModernSelector.createReaderSelector,
    createRequestDescriptor: RelayModernOperationDescriptor.createRequestDescriptor,
    getArgumentValues: RelayStoreUtils.getArgumentValues,
    getDataIDsFromFragment: RelayModernSelector.getDataIDsFromFragment,
    getDataIDsFromObject: RelayModernSelector.getDataIDsFromObject,
    getNode: GraphQLTag.getNode,
    getFragment: GraphQLTag.getFragment,
    getInlineDataFragment: GraphQLTag.getInlineDataFragment,
    getModuleComponentKey: RelayStoreUtils.getModuleComponentKey,
    getModuleOperationKey: RelayStoreUtils.getModuleOperationKey,
    getPaginationFragment: GraphQLTag.getPaginationFragment,
    getPluralSelector: RelayModernSelector.getPluralSelector,
    getRefetchableFragment: GraphQLTag.getRefetchableFragment,
    getRequest: GraphQLTag.getRequest,
    getRequestIdentifier: getRequestIdentifier,
    getSelector: RelayModernSelector.getSelector,
    getSelectorsFromObject: RelayModernSelector.getSelectorsFromObject,
    getSingularSelector: RelayModernSelector.getSingularSelector,
    getStorageKey: RelayStoreUtils.getStorageKey,
    getVariablesFromFragment: RelayModernSelector.getVariablesFromFragment,
    getVariablesFromObject: RelayModernSelector.getVariablesFromObject,
    getVariablesFromPluralFragment: RelayModernSelector.getVariablesFromPluralFragment,
    getVariablesFromSingularFragment: RelayModernSelector.getVariablesFromSingularFragment,
    handlePotentialSnapshotErrors: handlePotentialSnapshotErrors,
    graphql: GraphQLTag.graphql,
    isErrorResult: isErrorResult,
    isValueResult: isValueResult,
    isFragment: GraphQLTag.isFragment,
    isInlineDataFragment: GraphQLTag.isInlineDataFragment,
    isSuspenseSentinel: isSuspenseSentinel,
    suspenseSentinel: suspenseSentinel,
    isRequest: GraphQLTag.isRequest,
    readInlineData: readInlineData,
    readFragment: ResolverFragments.readFragment,
    MutationTypes: RelayDeclarativeMutationConfig.MutationTypes,
    RangeOperations: RelayDeclarativeMutationConfig.RangeOperations,
    DefaultHandlerProvider: RelayDefaultHandlerProvider,
    ConnectionHandler: ConnectionHandler,
    MutationHandlers: MutationHandlers,
    VIEWER_ID: ViewerPattern.VIEWER_ID,
    VIEWER_TYPE: ViewerPattern.VIEWER_TYPE,
    applyOptimisticMutation: applyOptimisticMutation,
    commitLocalUpdate: commitLocalUpdate,
    commitMutation: commitMutation,
    fetchQuery: fetchQuery,
    fetchQuery_DEPRECATED: fetchQuery_DEPRECATED,
    isRelayModernEnvironment: isRelayModernEnvironment,
    requestSubscription: requestSubscription,
    ConnectionInterface: ConnectionInterface,
    PreloadableQueryRegistry: PreloadableQueryRegistry,
    RelayProfiler: RelayProfiler,
    createPayloadFor3DField: createPayloadFor3DField,
    RelayConcreteNode: RelayConcreteNode,
    RelayError: RelayError,
    RelayFeatureFlags: RelayFeatureFlags,
    DEFAULT_HANDLE_KEY: RelayDefaultHandleKey.DEFAULT_HANDLE_KEY,
    FRAGMENTS_KEY: RelayStoreUtils.FRAGMENTS_KEY,
    FRAGMENT_OWNER_KEY: RelayStoreUtils.FRAGMENT_OWNER_KEY,
    ID_KEY: RelayStoreUtils.ID_KEY,
    REF_KEY: RelayStoreUtils.REF_KEY,
    REFS_KEY: RelayStoreUtils.REFS_KEY,
    ROOT_ID: RelayStoreUtils.ROOT_ID,
    ROOT_TYPE: RelayStoreUtils.ROOT_TYPE,
    TYPENAME_KEY: RelayStoreUtils.TYPENAME_KEY,
    deepFreeze: deepFreeze,
    generateClientID: generateClientID,
    generateUniqueClientID: generateUniqueClientID,
    getRelayHandleKey: getRelayHandleKey,
    isClientID: isClientID,
    isPromise: isPromise,
    isScalarAndEqual: isScalarAndEqual,
    recycleNodesInto: recycleNodesInto,
    stableCopy: stableCopy,
    hasCycle: hasCycle,
    getFragmentIdentifier: getFragmentIdentifier,
    getRefetchMetadata: getRefetchMetadata,
    getPaginationMetadata: getPaginationMetadata,
    getPaginationVariables: getPaginationVariables,
    getPendingOperationsForFragment: getPendingOperationsForFragment,
    getValueAtPath: getValueAtPath,
    __internal: {
        ResolverFragments: ResolverFragments,
        OperationTracker: RelayOperationTracker,
        createRelayContext: createRelayContext,
        createRelayLoggingContext: createRelayLoggingContext,
        getOperationVariables: RelayConcreteVariables.getOperationVariables,
        getLocalVariables: RelayConcreteVariables.getLocalVariables,
        fetchQuery: fetchQueryInternal.fetchQuery,
        fetchQueryDeduped: fetchQueryInternal.fetchQueryDeduped,
        getPromiseForActiveRequest: fetchQueryInternal.getPromiseForActiveRequest,
        getObservableForActiveRequest: fetchQueryInternal.getObservableForActiveRequest,
        normalizeResponse: normalizeResponse,
        withProvidedVariables: withProvidedVariables
    }
};
}),
"[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Relay v20.1.1
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ module.exports = __turbopack_context__.r("[project]/node_modules/relay-runtime/lib/index.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/react-relay/lib/ReactRelayContext.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), createRelayContext = _require.__internal.createRelayContext;
module.exports = createRelayContext(React);
}),
"[project]/node_modules/@babel/runtime/helpers/extends.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

function _extends() {
    return module.exports = _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : "TURBOPACK unreachable", module.exports.__esModule = true, module.exports["default"] = module.exports, _extends.apply(null, arguments);
}
module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/assertThisInitialized.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/setPrototypeOf.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

function _setPrototypeOf(t, e) {
    return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
        return t.__proto__ = e, t;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t, e);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/@babel/runtime/helpers/inheritsLoose.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var setPrototypeOf = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/setPrototypeOf.js [app-rsc] (ecmascript)");
function _inheritsLoose(t, o) {
    t.prototype = Object.create(o.prototype), t.prototype.constructor = t, setPrototypeOf(t, o);
}
module.exports = _inheritsLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
}),
"[project]/node_modules/react-relay/lib/assertFragmentMap.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function assertFragmentMap(componentName, fragmentSpec) {
    !(fragmentSpec && typeof fragmentSpec === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Could not create Relay Container for `%s`. ' + 'Expected a set of GraphQL fragments, got `%s` instead.', componentName, fragmentSpec) : "TURBOPACK unreachable" : void 0;
    for(var key in fragmentSpec){
        if (fragmentSpec.hasOwnProperty(key)) {
            var fragment = fragmentSpec[key];
            !(fragment && (typeof fragment === 'object' || typeof fragment === 'function')) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Could not create Relay Container for `%s`. ' + 'The value of fragment `%s` was expected to be a fragment, got `%s` instead.', componentName, key, fragment) : "TURBOPACK unreachable" : void 0;
        }
    }
}
module.exports = assertFragmentMap;
}),
"[project]/node_modules/react-relay/lib/ReactRelayContainerUtils.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function getComponentName(component) {
    return component.displayName || component.name || 'Component';
}
function getContainerName(Component) {
    return 'Relay(' + getComponentName(Component) + ')';
}
module.exports = {
    getComponentName: getComponentName,
    getContainerName: getContainerName
};
}),
"[project]/node_modules/react-relay/lib/ReactRelayQueryRendererContext.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
module.exports = React.createContext({
    rootIsQueryRenderer: false
});
}),
"[project]/node_modules/react-relay/lib/buildReactRelayContainer.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _extends2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/extends.js [app-rsc] (ecmascript)"));
var assertFragmentMap = __turbopack_context__.r("[project]/node_modules/react-relay/lib/assertFragmentMap.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContainerUtils.js [app-rsc] (ecmascript)"), getComponentName = _require.getComponentName, getContainerName = _require.getContainerName;
var ReactRelayContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContext.js [app-rsc] (ecmascript)");
var ReactRelayQueryRendererContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayQueryRendererContext.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), getFragment = _require2.getFragment;
var useContext = React.useContext;
function buildReactRelayContainer(ComponentClass, fragmentSpec, createContainerWithFragments) {
    var containerName = getContainerName(ComponentClass);
    assertFragmentMap(getComponentName(ComponentClass), fragmentSpec);
    var fragments = {};
    for(var key in fragmentSpec){
        fragments[key] = getFragment(fragmentSpec[key]);
    }
    var Container = createContainerWithFragments(ComponentClass, fragments);
    Container.displayName = containerName;
    function ForwardRef(props, ref) {
        var _queryRendererContext;
        var context = useContext(ReactRelayContext);
        !(context != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, '`%s` tried to render a context that was not valid this means that ' + '`%s` was rendered outside of a query renderer.', containerName, containerName) : "TURBOPACK unreachable" : void 0;
        var queryRendererContext = useContext(ReactRelayQueryRendererContext);
        return /*#__PURE__*/ React.createElement(Container, (0, _extends2["default"])({}, props, {
            __relayContext: context,
            __rootIsQueryRenderer: (_queryRendererContext = queryRendererContext === null || queryRendererContext === void 0 ? void 0 : queryRendererContext.rootIsQueryRenderer) !== null && _queryRendererContext !== void 0 ? _queryRendererContext : false,
            componentRef: props.componentRef || ref
        }));
    }
    ForwardRef.displayName = containerName;
    var ForwardContainer = React.forwardRef(ForwardRef);
    if ("TURBOPACK compile-time truthy", 1) {
        ForwardContainer.__ComponentClass = ComponentClass;
        ForwardContainer.displayName = containerName;
    }
    return ForwardContainer;
}
module.exports = buildReactRelayContainer;
}),
"[project]/node_modules/react-relay/lib/isRelayEnvironment.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function isRelayEnvironment(environment) {
    return typeof environment === 'object' && environment !== null && typeof environment.check === 'function' && typeof environment.lookup === 'function' && typeof environment.retain === 'function' && typeof environment.execute === 'function' && typeof environment.subscribe === 'function';
}
module.exports = isRelayEnvironment;
}),
"[project]/node_modules/react-relay/lib/RelayContext.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/isRelayEnvironment.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
function assertRelayContext(relay) {
    !isRelayContext(relay) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'RelayContext: Expected `context.relay` to be an object conforming to ' + 'the `RelayContext` interface, got `%s`.', relay) : "TURBOPACK unreachable" : void 0;
    return relay;
}
function isRelayContext(context) {
    return typeof context === 'object' && context !== null && !Array.isArray(context) && isRelayEnvironment(context.environment);
}
module.exports = {
    assertRelayContext: assertRelayContext,
    isRelayContext: isRelayContext
};
}),
"[project]/node_modules/react-relay/lib/ReactRelayFragmentContainer.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _extends2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/extends.js [app-rsc] (ecmascript)"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js [app-rsc] (ecmascript)"));
var _assertThisInitialized2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/assertThisInitialized.js [app-rsc] (ecmascript)"));
var _inheritsLoose2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/inheritsLoose.js [app-rsc] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var _excluded = [
    "componentRef",
    "__relayContext",
    "__rootIsQueryRenderer"
];
var buildReactRelayContainer = __turbopack_context__.r("[project]/node_modules/react-relay/lib/buildReactRelayContainer.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContainerUtils.js [app-rsc] (ecmascript)"), getContainerName = _require.getContainerName;
var _require2 = __turbopack_context__.r("[project]/node_modules/react-relay/lib/RelayContext.js [app-rsc] (ecmascript)"), assertRelayContext = _require2.assertRelayContext;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), createFragmentSpecResolver = _require3.createFragmentSpecResolver, getDataIDsFromObject = _require3.getDataIDsFromObject, isScalarAndEqual = _require3.isScalarAndEqual;
function createContainerWithFragments(Component, fragments) {
    var _class;
    var containerName = getContainerName(Component);
    return _class = /*#__PURE__*/ function(_React$Component) {
        (0, _inheritsLoose2["default"])(_class, _React$Component);
        function _class(props) {
            var _props$__rootIsQueryR, _this;
            _this = _React$Component.call(this, props) || this;
            (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleFragmentDataUpdate", function() {
                var resolverFromThisUpdate = _this.state.resolver;
                _this.setState(function(updatedState) {
                    return resolverFromThisUpdate === updatedState.resolver ? {
                        data: updatedState.resolver.resolve(),
                        relayProp: getRelayProp(updatedState.relayProp.environment)
                    } : null;
                });
            });
            var relayContext = assertRelayContext(props.__relayContext);
            var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false;
            var resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer);
            _this.state = {
                data: resolver.resolve(),
                prevProps: props,
                prevPropsContext: relayContext,
                relayProp: getRelayProp(relayContext.environment),
                resolver: resolver
            };
            return _this;
        }
        _class.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
            var _nextProps$__rootIsQu;
            var prevProps = prevState.prevProps;
            var relayContext = assertRelayContext(nextProps.__relayContext);
            var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;
            var prevIDs = getDataIDsFromObject(fragments, prevProps);
            var nextIDs = getDataIDsFromObject(fragments, nextProps);
            var resolver = prevState.resolver;
            if (prevState.prevPropsContext.environment !== relayContext.environment || !areEqual(prevIDs, nextIDs)) {
                resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer);
                return {
                    data: resolver.resolve(),
                    prevPropsContext: relayContext,
                    prevProps: nextProps,
                    relayProp: getRelayProp(relayContext.environment),
                    resolver: resolver
                };
            } else {
                resolver.setProps(nextProps);
                var data = resolver.resolve();
                if (data !== prevState.data) {
                    return {
                        data: data,
                        prevProps: nextProps,
                        prevPropsContext: relayContext,
                        relayProp: getRelayProp(relayContext.environment)
                    };
                }
            }
            return null;
        };
        var _proto = _class.prototype;
        _proto.componentDidMount = function componentDidMount() {
            this._subscribeToNewResolverAndRerenderIfStoreHasChanged();
        };
        _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
            if (this.state.resolver !== prevState.resolver) {
                prevState.resolver.dispose();
                this._subscribeToNewResolverAndRerenderIfStoreHasChanged();
            } else {
                this._rerenderIfStoreHasChanged();
            }
        };
        _proto.componentWillUnmount = function componentWillUnmount() {
            this.state.resolver.dispose();
        };
        _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
            if (nextState.data !== this.state.data) {
                return true;
            }
            var keys = Object.keys(nextProps);
            for(var ii = 0; ii < keys.length; ii++){
                var key = keys[ii];
                if (key === '__relayContext') {
                    if (nextState.prevPropsContext.environment !== this.state.prevPropsContext.environment) {
                        return true;
                    }
                } else {
                    if (!fragments.hasOwnProperty(key) && !isScalarAndEqual(nextProps[key], this.props[key])) {
                        return true;
                    }
                }
            }
            return false;
        };
        _proto._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {
            var _this$state = this.state, data = _this$state.data, resolver = _this$state.resolver;
            var maybeNewData = resolver.resolve();
            if (data !== maybeNewData) {
                this.setState({
                    data: maybeNewData
                });
            }
        };
        _proto._subscribeToNewResolverAndRerenderIfStoreHasChanged = function _subscribeToNewResolverAndRerenderIfStoreHasChanged() {
            var _this$state2 = this.state, data = _this$state2.data, resolver = _this$state2.resolver;
            var maybeNewData = resolver.resolve();
            resolver.setCallback(this.props, this._handleFragmentDataUpdate);
            if (data !== maybeNewData) {
                this.setState({
                    data: maybeNewData
                });
            }
        };
        _proto.render = function render() {
            var _this$props = this.props, componentRef = _this$props.componentRef, __relayContext = _this$props.__relayContext, __rootIsQueryRenderer = _this$props.__rootIsQueryRenderer, props = (0, _objectWithoutPropertiesLoose2["default"])(_this$props, _excluded);
            return /*#__PURE__*/ React.createElement(Component, (0, _extends2["default"])({}, props, this.state.data, {
                ref: componentRef,
                relay: this.state.relayProp
            }));
        };
        return _class;
    }(React.Component), (0, _defineProperty2["default"])(_class, "displayName", containerName), _class;
}
function getRelayProp(environment) {
    return {
        environment: environment
    };
}
function createContainer(Component, fragmentSpec) {
    return buildReactRelayContainer(Component, fragmentSpec, createContainerWithFragments);
}
module.exports = {
    createContainer: createContainer
};
}),
"[project]/node_modules/react-relay/lib/ReactRelayLocalQueryRenderer.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ReactRelayContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContext.js [app-rsc] (ecmascript)");
var ReactRelayQueryRendererContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayQueryRendererContext.js [app-rsc] (ecmascript)");
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), createOperationDescriptor = _require.createOperationDescriptor, deepFreeze = _require.deepFreeze, getRequest = _require.getRequest;
var useLayoutEffect = React.useLayoutEffect, useState = React.useState, useRef = React.useRef, useMemo = React.useMemo;
var queryRendererContext = {
    rootIsQueryRenderer: true
};
function useDeepCompare(value) {
    var latestValue = React.useRef(value);
    if (!areEqual(latestValue.current, value)) {
        if ("TURBOPACK compile-time truthy", 1) {
            deepFreeze(value);
        }
        latestValue.current = value;
    }
    return latestValue.current;
}
function ReactRelayLocalQueryRenderer(props) {
    var environment = props.environment, query = props.query, variables = props.variables, render = props.render;
    var latestVariables = useDeepCompare(variables);
    var operation = useMemo(function() {
        var request = getRequest(query);
        return createOperationDescriptor(request, latestVariables);
    }, [
        query,
        latestVariables
    ]);
    var relayContext = useMemo(function() {
        return {
            environment: environment
        };
    }, [
        environment
    ]);
    var dataRef = useRef(null);
    var _useState = useState(null), forceUpdate = _useState[1];
    var cleanupFnRef = useRef(null);
    var snapshot = useMemo(function() {
        environment.check(operation);
        var res = environment.lookup(operation.fragment);
        dataRef.current = res.data;
        var retainDisposable = environment.retain(operation);
        var subscribeDisposable = environment.subscribe(res, function(newSnapshot) {
            dataRef.current = newSnapshot.data;
            forceUpdate(dataRef.current);
        });
        var disposed = false;
        function nextCleanupFn() {
            if (!disposed) {
                disposed = true;
                cleanupFnRef.current = null;
                retainDisposable.dispose();
                subscribeDisposable.dispose();
            }
        }
        if (cleanupFnRef.current) {
            cleanupFnRef.current();
        }
        cleanupFnRef.current = nextCleanupFn;
        return res;
    }, [
        environment,
        operation
    ]);
    useLayoutEffect(function() {
        var cleanupFn = cleanupFnRef.current;
        return function() {
            cleanupFn && cleanupFn();
        };
    }, [
        snapshot
    ]);
    return /*#__PURE__*/ React.createElement(ReactRelayContext.Provider, {
        value: relayContext
    }, /*#__PURE__*/ React.createElement(ReactRelayQueryRendererContext.Provider, {
        value: queryRendererContext
    }, render({
        props: dataRef.current
    })));
}
module.exports = ReactRelayLocalQueryRenderer;
}),
"[project]/node_modules/react-relay/lib/getRootVariablesForFragments.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), getSelector = _require.getSelector;
function getRootVariablesForFragments(fragments, props) {
    var rootVariables = {};
    Object.keys(fragments).forEach(function(key) {
        var _selector$selectors$, _selector$selectors$2, _selector$owner$varia;
        var fragmentNode = fragments[key];
        var fragmentRef = props[key];
        var selector = getSelector(fragmentNode, fragmentRef);
        var fragmentOwnerVariables = selector != null && selector.kind === 'PluralReaderSelector' ? (_selector$selectors$ = (_selector$selectors$2 = selector.selectors[0]) === null || _selector$selectors$2 === void 0 ? void 0 : _selector$selectors$2.owner.variables) !== null && _selector$selectors$ !== void 0 ? _selector$selectors$ : {} : (_selector$owner$varia = selector === null || selector === void 0 ? void 0 : selector.owner.variables) !== null && _selector$owner$varia !== void 0 ? _selector$owner$varia : {};
        rootVariables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, rootVariables), fragmentOwnerVariables);
    });
    return rootVariables;
}
module.exports = getRootVariablesForFragments;
}),
"[project]/node_modules/react-relay/lib/ReactRelayQueryFetcher.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), fetchQuery = _require.__internal.fetchQuery, createOperationDescriptor = _require.createOperationDescriptor, isRelayModernEnvironment = _require.isRelayModernEnvironment;
var ReactRelayQueryFetcher = /*#__PURE__*/ function() {
    function ReactRelayQueryFetcher(args) {
        (0, _defineProperty2["default"])(this, "_selectionReferences", []);
        (0, _defineProperty2["default"])(this, "_didFetchFinish", false);
        if (args != null) {
            this._cacheSelectionReference = args.cacheSelectionReference;
            this._selectionReferences = args.selectionReferences;
        }
    }
    var _proto = ReactRelayQueryFetcher.prototype;
    _proto.getSelectionReferences = function getSelectionReferences() {
        return {
            cacheSelectionReference: this._cacheSelectionReference,
            selectionReferences: this._selectionReferences
        };
    };
    _proto.lookupInStore = function lookupInStore(environment, operation, fetchPolicy) {
        if (fetchPolicy === 'store-and-network' || fetchPolicy === 'store-or-network') {
            if (environment.check(operation).status === 'available') {
                this._retainCachedOperation(environment, operation);
                return environment.lookup(operation.fragment);
            }
        }
        return null;
    };
    _proto.getFetchResult = function getFetchResult() {
        if (this._didFetchFinish) {
            if (this._error != null) {
                return {
                    error: this._error
                };
            } else if (this._snapshot != null) {
                return {
                    snapshot: this._snapshot
                };
            }
        } else {
            return null;
        }
    };
    _proto.execute = function execute(_ref) {
        var _this = this;
        var environment = _ref.environment, operation = _ref.operation, _ref$preservePrevious = _ref.preservePreviousReferences, preservePreviousReferences = _ref$preservePrevious === void 0 ? false : _ref$preservePrevious;
        var reference = environment.retain(operation);
        var error = function error() {
            _this._selectionReferences = _this._selectionReferences.concat(reference);
        };
        var complete = function complete() {
            if (!preservePreviousReferences) {
                _this.disposeSelectionReferences();
            }
            _this._selectionReferences = _this._selectionReferences.concat(reference);
        };
        var unsubscribe = function unsubscribe() {
            _this._selectionReferences = _this._selectionReferences.concat(reference);
        };
        if (!isRelayModernEnvironment(environment)) {
            return environment.execute({
                operation: operation
            })["do"]({
                error: error,
                complete: complete,
                unsubscribe: unsubscribe
            });
        }
        return fetchQuery(environment, operation)["do"]({
            error: error,
            complete: complete,
            unsubscribe: unsubscribe
        });
    };
    _proto.setOnDataChange = function setOnDataChange(onDataChange) {
        !this._fetchOptions ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ReactRelayQueryFetcher: `setOnDataChange` should have been called after having called `fetch`') : "TURBOPACK unreachable" : void 0;
        if (typeof onDataChange === 'function') {
            this._fetchOptions.onDataChangeCallbacks = this._fetchOptions.onDataChangeCallbacks || [];
            this._fetchOptions.onDataChangeCallbacks.push(onDataChange);
            if (this._didFetchFinish) {
                if (this._error != null) {
                    onDataChange({
                        error: this._error
                    });
                } else if (this._snapshot != null) {
                    onDataChange({
                        snapshot: this._snapshot
                    });
                }
            }
        }
    };
    _proto.fetch = function fetch(fetchOptions, cacheConfigOverride) {
        var _this2 = this;
        var environment = fetchOptions.environment, operation = fetchOptions.operation, onDataChange = fetchOptions.onDataChange;
        var fetchHasReturned = false;
        var _error;
        this.disposeRequest();
        var oldOnDataChangeCallbacks = this._fetchOptions && this._fetchOptions.onDataChangeCallbacks;
        this._fetchOptions = {
            environment: environment,
            onDataChangeCallbacks: oldOnDataChangeCallbacks || [],
            operation: operation
        };
        if (onDataChange && this._fetchOptions.onDataChangeCallbacks.indexOf(onDataChange) === -1) {
            this._fetchOptions.onDataChangeCallbacks.push(onDataChange);
        }
        var operationOverride = cacheConfigOverride ? createOperationDescriptor(operation.request.node, operation.request.variables, cacheConfigOverride) : operation;
        var request = this.execute({
            environment: environment,
            operation: operationOverride
        })["finally"](function() {
            _this2._pendingRequest = null;
        }).subscribe({
            next: function next() {
                _this2._didFetchFinish = true;
                _this2._error = null;
                _this2._onQueryDataAvailable({
                    notifyFirstResult: fetchHasReturned
                });
            },
            error: function error(err) {
                _this2._didFetchFinish = true;
                _this2._error = err;
                _this2._snapshot = null;
                var onDataChangeCallbacks = _this2._fetchOptions && _this2._fetchOptions.onDataChangeCallbacks;
                if (fetchHasReturned) {
                    if (onDataChangeCallbacks) {
                        onDataChangeCallbacks.forEach(function(onDataChange) {
                            onDataChange({
                                error: err
                            });
                        });
                    }
                } else {
                    _error = err;
                }
            }
        });
        this._pendingRequest = {
            dispose: function dispose() {
                request.unsubscribe();
            }
        };
        fetchHasReturned = true;
        if (_error) {
            throw _error;
        }
        return this._snapshot;
    };
    _proto.retry = function retry(cacheConfigOverride) {
        !this._fetchOptions ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ReactRelayQueryFetcher: `retry` should be called after having called `fetch`') : "TURBOPACK unreachable" : void 0;
        return this.fetch({
            environment: this._fetchOptions.environment,
            operation: this._fetchOptions.operation,
            onDataChange: null
        }, cacheConfigOverride);
    };
    _proto.dispose = function dispose() {
        this.disposeRequest();
        this.disposeSelectionReferences();
    };
    _proto.disposeRequest = function disposeRequest() {
        this._error = null;
        this._snapshot = null;
        if (this._pendingRequest) {
            this._pendingRequest.dispose();
        }
        if (this._rootSubscription) {
            this._rootSubscription.dispose();
            this._rootSubscription = null;
        }
    };
    _proto._retainCachedOperation = function _retainCachedOperation(environment, operation) {
        this._disposeCacheSelectionReference();
        this._cacheSelectionReference = environment.retain(operation);
    };
    _proto._disposeCacheSelectionReference = function _disposeCacheSelectionReference() {
        this._cacheSelectionReference && this._cacheSelectionReference.dispose();
        this._cacheSelectionReference = null;
    };
    _proto.disposeSelectionReferences = function disposeSelectionReferences() {
        this._disposeCacheSelectionReference();
        this._selectionReferences.forEach(function(r) {
            return r.dispose();
        });
        this._selectionReferences = [];
    };
    _proto._onQueryDataAvailable = function _onQueryDataAvailable(_ref2) {
        var _this3 = this;
        var notifyFirstResult = _ref2.notifyFirstResult;
        !this._fetchOptions ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ReactRelayQueryFetcher: `_onQueryDataAvailable` should have been called after having called `fetch`') : "TURBOPACK unreachable" : void 0;
        var _this$_fetchOptions = this._fetchOptions, environment = _this$_fetchOptions.environment, onDataChangeCallbacks = _this$_fetchOptions.onDataChangeCallbacks, operation = _this$_fetchOptions.operation;
        if (this._snapshot) {
            return;
        }
        this._snapshot = environment.lookup(operation.fragment);
        this._rootSubscription = environment.subscribe(this._snapshot, function(snapshot) {
            if (_this3._fetchOptions != null) {
                var maybeNewOnDataChangeCallbacks = _this3._fetchOptions.onDataChangeCallbacks;
                if (Array.isArray(maybeNewOnDataChangeCallbacks)) {
                    maybeNewOnDataChangeCallbacks.forEach(function(onDataChange) {
                        return onDataChange({
                            snapshot: snapshot
                        });
                    });
                }
            }
        });
        if (this._snapshot && notifyFirstResult && Array.isArray(onDataChangeCallbacks)) {
            var snapshot = this._snapshot;
            onDataChangeCallbacks.forEach(function(onDataChange) {
                return onDataChange({
                    snapshot: snapshot
                });
            });
        }
    };
    return ReactRelayQueryFetcher;
}();
module.exports = ReactRelayQueryFetcher;
}),
"[project]/node_modules/react-relay/lib/ReactRelayPaginationContainer.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _extends2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/extends.js [app-rsc] (ecmascript)"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js [app-rsc] (ecmascript)"));
var _assertThisInitialized2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/assertThisInitialized.js [app-rsc] (ecmascript)"));
var _inheritsLoose2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/inheritsLoose.js [app-rsc] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var _objectSpread3 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _excluded = [
    "componentRef"
], _excluded2 = [
    "componentRef",
    "__relayContext",
    "__rootIsQueryRenderer"
], _excluded3 = [
    "componentRef",
    "__relayContext",
    "__rootIsQueryRenderer"
];
var buildReactRelayContainer = __turbopack_context__.r("[project]/node_modules/react-relay/lib/buildReactRelayContainer.js [app-rsc] (ecmascript)");
var getRootVariablesForFragments = __turbopack_context__.r("[project]/node_modules/react-relay/lib/getRootVariablesForFragments.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContainerUtils.js [app-rsc] (ecmascript)"), getComponentName = _require.getComponentName, getContainerName = _require.getContainerName;
var ReactRelayContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContext.js [app-rsc] (ecmascript)");
var ReactRelayQueryFetcher = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayQueryFetcher.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/react-relay/lib/RelayContext.js [app-rsc] (ecmascript)"), assertRelayContext = _require2.assertRelayContext;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), ConnectionInterface = _require3.ConnectionInterface, Observable = _require3.Observable, RelayFeatureFlags = _require3.RelayFeatureFlags, createFragmentSpecResolver = _require3.createFragmentSpecResolver, createOperationDescriptor = _require3.createOperationDescriptor, getDataIDsFromObject = _require3.getDataIDsFromObject, getRequest = _require3.getRequest, getVariablesFromObject = _require3.getVariablesFromObject, isScalarAndEqual = _require3.isScalarAndEqual;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
var FORWARD = 'forward';
function createGetConnectionFromProps(metadata) {
    var path = metadata.path;
    !path ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getConnectionFromProps function.') : "TURBOPACK unreachable" : void 0;
    return function(props) {
        var data = props[metadata.fragmentName];
        for(var i = 0; i < path.length; i++){
            if (!data || typeof data !== 'object') {
                return null;
            }
            data = data[path[i]];
        }
        return data;
    };
}
function createGetFragmentVariables(metadata) {
    var countVariable = metadata.count;
    !countVariable ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ReactRelayPaginationContainer: Unable to synthesize a ' + 'getFragmentVariables function.') : "TURBOPACK unreachable" : void 0;
    return function(prevVars, totalCount) {
        return (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, prevVars), {}, (0, _defineProperty2["default"])({}, countVariable, totalCount));
    };
}
function findConnectionMetadata(fragments) {
    var foundConnectionMetadata = null;
    var isRelayModern = false;
    for(var fragmentName in fragments){
        var fragment = fragments[fragmentName];
        var connectionMetadata = fragment.metadata && fragment.metadata.connection;
        if (fragment.metadata !== undefined) {
            isRelayModern = true;
        }
        if (connectionMetadata) {
            !(connectionMetadata.length === 1) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ReactRelayPaginationContainer: Only a single @connection is ' + 'supported, `%s` has %s.', fragmentName, connectionMetadata.length) : "TURBOPACK unreachable" : void 0;
            !!foundConnectionMetadata ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ReactRelayPaginationContainer: Only a single fragment with ' + '@connection is supported.') : "TURBOPACK unreachable" : void 0;
            foundConnectionMetadata = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, connectionMetadata[0]), {}, {
                fragmentName: fragmentName
            });
        }
    }
    !(!isRelayModern || foundConnectionMetadata !== null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ReactRelayPaginationContainer: A @connection directive must be present.') : "TURBOPACK unreachable" : void 0;
    return foundConnectionMetadata || {};
}
function toObserver(observerOrCallback) {
    return typeof observerOrCallback === 'function' ? {
        error: observerOrCallback,
        complete: observerOrCallback,
        unsubscribe: function unsubscribe(subscription) {
            typeof observerOrCallback === 'function' && observerOrCallback();
        }
    } : observerOrCallback || {};
}
function createContainerWithFragments(Component, fragments, connectionConfig) {
    var _class;
    var componentName = getComponentName(Component);
    var containerName = getContainerName(Component);
    var metadata = findConnectionMetadata(fragments);
    var getConnectionFromProps = connectionConfig.getConnectionFromProps || createGetConnectionFromProps(metadata);
    var direction = connectionConfig.direction || metadata.direction;
    !direction ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ReactRelayPaginationContainer: Unable to infer direction of the ' + 'connection, possibly because both first and last are provided.') : "TURBOPACK unreachable" : void 0;
    var getFragmentVariables = connectionConfig.getFragmentVariables || createGetFragmentVariables(metadata);
    return _class = /*#__PURE__*/ function(_React$Component) {
        (0, _inheritsLoose2["default"])(_class, _React$Component);
        function _class(props) {
            var _props$__rootIsQueryR, _this;
            _this = _React$Component.call(this, props) || this;
            (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleFragmentDataUpdate", function() {
                _this.setState({
                    data: _this._resolver.resolve()
                });
            });
            (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_hasMore", function() {
                var connectionData = _this._getConnectionData();
                return !!(connectionData && connectionData.hasMore && connectionData.cursor);
            });
            (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_isLoading", function() {
                return !!_this._refetchSubscription;
            });
            (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_refetchConnection", function(totalCount, observerOrCallback, refetchVariables) {
                if (!_this._canFetchPage('refetchConnection')) {
                    return {
                        dispose: function dispose() {}
                    };
                }
                _this._refetchVariables = refetchVariables;
                var paginatingVariables = {
                    count: totalCount,
                    cursor: null,
                    totalCount: totalCount
                };
                var fetch = _this._fetchPage(paginatingVariables, toObserver(observerOrCallback), {
                    force: true
                });
                return {
                    dispose: fetch.unsubscribe
                };
            });
            (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_loadMore", function(pageSize, observerOrCallback, options) {
                if (!_this._canFetchPage('loadMore')) {
                    return {
                        dispose: function dispose() {}
                    };
                }
                var observer = toObserver(observerOrCallback);
                var connectionData = _this._getConnectionData();
                if (!connectionData) {
                    Observable.create(function(sink) {
                        return sink.complete();
                    }).subscribe(observer);
                    return null;
                }
                var totalCount = connectionData.edgeCount + pageSize;
                if (options && options.force) {
                    return _this._refetchConnection(totalCount, observerOrCallback);
                }
                var _ConnectionInterface$ = ConnectionInterface.get(), END_CURSOR = _ConnectionInterface$.END_CURSOR, START_CURSOR = _ConnectionInterface$.START_CURSOR;
                var cursor = connectionData.cursor;
                ("TURBOPACK compile-time truthy", 1) ? warning(cursor != null && cursor !== '', 'ReactRelayPaginationContainer: Cannot `loadMore` without valid `%s` (got `%s`)', direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : "TURBOPACK unreachable";
                var paginatingVariables = {
                    count: pageSize,
                    cursor: cursor,
                    totalCount: totalCount
                };
                var fetch = _this._fetchPage(paginatingVariables, observer, options);
                return {
                    dispose: fetch.unsubscribe
                };
            });
            var relayContext = assertRelayContext(props.__relayContext);
            var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false;
            _this._isARequestInFlight = false;
            _this._refetchSubscription = null;
            _this._refetchVariables = null;
            if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
                _this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer);
            } else {
                _this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer, _this._handleFragmentDataUpdate);
            }
            _this.state = {
                data: _this._resolver.resolve(),
                prevContext: relayContext,
                contextForChildren: relayContext,
                relayProp: _this._buildRelayProp(relayContext),
                resolverGeneration: 0
            };
            _this._isUnmounted = false;
            _this._hasFetched = false;
            return _this;
        }
        var _proto = _class.prototype;
        _proto.componentDidMount = function componentDidMount() {
            this._isUnmounted = false;
            if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
                this._subscribeToNewResolverAndRerenderIfStoreHasChanged();
            }
        };
        _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
            if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
                if (prevState.resolverGeneration !== this.state.resolverGeneration) {
                    this._subscribeToNewResolverAndRerenderIfStoreHasChanged();
                } else {
                    this._rerenderIfStoreHasChanged();
                }
            }
        };
        _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {
            var _this2 = this;
            var _nextProps$__rootIsQu;
            var relayContext = assertRelayContext(nextProps.__relayContext);
            var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;
            var prevIDs = getDataIDsFromObject(fragments, this.props);
            var nextIDs = getDataIDsFromObject(fragments, nextProps);
            var prevRootVariables = getRootVariablesForFragments(fragments, this.props);
            var nextRootVariables = getRootVariablesForFragments(fragments, nextProps);
            if (relayContext.environment !== this.state.prevContext.environment || !areEqual(prevRootVariables, nextRootVariables) || !areEqual(prevIDs, nextIDs)) {
                this._cleanup();
                if (RelayFeatureFlags.ENABLE_CONTAINERS_SUBSCRIBE_ON_COMMIT === true) {
                    this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer);
                } else {
                    this._resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer, this._handleFragmentDataUpdate);
                }
                this.setState(function(prevState) {
                    return {
                        prevContext: relayContext,
                        contextForChildren: relayContext,
                        relayProp: _this2._buildRelayProp(relayContext),
                        resolverGeneration: prevState.resolverGeneration + 1
                    };
                });
            } else if (!this._hasFetched) {
                this._resolver.setProps(nextProps);
            }
            var data = this._resolver.resolve();
            if (data !== this.state.data) {
                this.setState({
                    data: data
                });
            }
        };
        _proto.componentWillUnmount = function componentWillUnmount() {
            this._isUnmounted = true;
            this._cleanup();
        };
        _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
            if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp || nextState.resolverGeneration !== this.state.resolverGeneration) {
                return true;
            }
            var keys = Object.keys(nextProps);
            for(var ii = 0; ii < keys.length; ii++){
                var key = keys[ii];
                if (key === '__relayContext') {
                    if (nextState.prevContext.environment !== this.state.prevContext.environment) {
                        return true;
                    }
                } else {
                    if (!fragments.hasOwnProperty(key) && !isScalarAndEqual(nextProps[key], this.props[key])) {
                        return true;
                    }
                }
            }
            return false;
        };
        _proto._buildRelayProp = function _buildRelayProp(relayContext) {
            return {
                hasMore: this._hasMore,
                isLoading: this._isLoading,
                loadMore: this._loadMore,
                refetchConnection: this._refetchConnection,
                environment: relayContext.environment
            };
        };
        _proto._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {
            var data = this.state.data;
            var maybeNewData = this._resolver.resolve();
            if (data !== maybeNewData) {
                this.setState({
                    data: maybeNewData
                });
            }
        };
        _proto._subscribeToNewResolverAndRerenderIfStoreHasChanged = function _subscribeToNewResolverAndRerenderIfStoreHasChanged() {
            var data = this.state.data;
            var maybeNewData = this._resolver.resolve();
            this._resolver.setCallback(this.props, this._handleFragmentDataUpdate);
            if (data !== maybeNewData) {
                this.setState({
                    data: maybeNewData
                });
            }
        };
        _proto._getConnectionData = function _getConnectionData() {
            var _this$props = this.props, _ = _this$props.componentRef, restProps = (0, _objectWithoutPropertiesLoose2["default"])(_this$props, _excluded);
            var props = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, restProps), this.state.data);
            var connectionData = getConnectionFromProps(props);
            if (connectionData == null) {
                return null;
            }
            var _ConnectionInterface$2 = ConnectionInterface.get(), EDGES = _ConnectionInterface$2.EDGES, PAGE_INFO = _ConnectionInterface$2.PAGE_INFO, HAS_NEXT_PAGE = _ConnectionInterface$2.HAS_NEXT_PAGE, HAS_PREV_PAGE = _ConnectionInterface$2.HAS_PREV_PAGE, END_CURSOR = _ConnectionInterface$2.END_CURSOR, START_CURSOR = _ConnectionInterface$2.START_CURSOR;
            !(typeof connectionData === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return `null` or a plain object with %s and %s properties, got `%s`.', componentName, EDGES, PAGE_INFO, connectionData) : "TURBOPACK unreachable" : void 0;
            var edges = connectionData[EDGES];
            var pageInfo = connectionData[PAGE_INFO];
            if (edges == null || pageInfo == null) {
                return null;
            }
            !Array.isArray(edges) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Array, got `%s`.', componentName, EDGES, edges) : "TURBOPACK unreachable" : void 0;
            !(typeof pageInfo === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ReactRelayPaginationContainer: Expected `getConnectionFromProps()` in `%s`' + 'to return an object with %s: Object, got `%s`.', componentName, PAGE_INFO, pageInfo) : "TURBOPACK unreachable" : void 0;
            var hasMore = direction === FORWARD ? pageInfo[HAS_NEXT_PAGE] : pageInfo[HAS_PREV_PAGE];
            var cursor = direction === FORWARD ? pageInfo[END_CURSOR] : pageInfo[START_CURSOR];
            if (typeof hasMore !== 'boolean' || edges.length !== 0 && typeof cursor === 'undefined') {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'ReactRelayPaginationContainer: Cannot paginate without %s fields in `%s`. ' + 'Be sure to fetch %s (got `%s`) and %s (got `%s`).', PAGE_INFO, componentName, direction === FORWARD ? HAS_NEXT_PAGE : HAS_PREV_PAGE, hasMore, direction === FORWARD ? END_CURSOR : START_CURSOR, cursor) : "TURBOPACK unreachable";
                return null;
            }
            return {
                cursor: cursor,
                edgeCount: edges.length,
                hasMore: hasMore
            };
        };
        _proto._getQueryFetcher = function _getQueryFetcher() {
            if (!this._queryFetcher) {
                this._queryFetcher = new ReactRelayQueryFetcher();
            }
            return this._queryFetcher;
        };
        _proto._canFetchPage = function _canFetchPage(method) {
            if (this._isUnmounted) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'ReactRelayPaginationContainer: Unexpected call of `%s` ' + 'on unmounted container `%s`. It looks like some instances ' + 'of your container still trying to fetch data but they already ' + 'unmounted. Please make sure you clear all timers, intervals, async ' + 'calls, etc that may trigger `%s` call.', method, containerName, method) : "TURBOPACK unreachable";
                return false;
            }
            return true;
        };
        _proto._fetchPage = function _fetchPage(paginatingVariables, observer, options) {
            var _this3 = this;
            var _assertRelayContext = assertRelayContext(this.props.__relayContext), environment = _assertRelayContext.environment;
            var _this$props2 = this.props, _ = _this$props2.componentRef, __relayContext = _this$props2.__relayContext, __rootIsQueryRenderer = _this$props2.__rootIsQueryRenderer, restProps = (0, _objectWithoutPropertiesLoose2["default"])(_this$props2, _excluded2);
            var props = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, restProps), this.state.data);
            var fragmentVariables;
            var rootVariables = getRootVariablesForFragments(fragments, restProps);
            fragmentVariables = getVariablesFromObject(fragments, restProps);
            fragmentVariables = (0, _objectSpread3["default"])((0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, rootVariables), fragmentVariables), this._refetchVariables);
            var fetchVariables = connectionConfig.getVariables(props, {
                count: paginatingVariables.count,
                cursor: paginatingVariables.cursor
            }, fragmentVariables);
            !(typeof fetchVariables === 'object' && fetchVariables !== null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'ReactRelayPaginationContainer: Expected `getVariables()` to ' + 'return an object, got `%s` in `%s`.', fetchVariables, componentName) : "TURBOPACK unreachable" : void 0;
            fetchVariables = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, fetchVariables), this._refetchVariables);
            fragmentVariables = (0, _objectSpread3["default"])((0, _objectSpread3["default"])({}, fetchVariables), fragmentVariables);
            var cacheConfig = options ? {
                force: !!options.force
            } : undefined;
            if (cacheConfig != null && (options === null || options === void 0 ? void 0 : options.metadata) != null) {
                cacheConfig.metadata = options === null || options === void 0 ? void 0 : options.metadata;
            }
            var request = getRequest(connectionConfig.query);
            var operation = createOperationDescriptor(request, fetchVariables, cacheConfig);
            var refetchSubscription = null;
            if (this._refetchSubscription) {
                this._refetchSubscription.unsubscribe();
            }
            this._hasFetched = true;
            var onNext = function onNext(payload, complete) {
                var prevData = _this3._resolver.resolve();
                _this3._resolver.setVariables(getFragmentVariables(fragmentVariables, paginatingVariables.totalCount), operation.request.node);
                var nextData = _this3._resolver.resolve();
                if (!areEqual(prevData, nextData)) {
                    _this3.setState({
                        data: nextData,
                        contextForChildren: {
                            environment: _this3.props.__relayContext.environment
                        }
                    }, complete);
                } else {
                    complete();
                }
            };
            var cleanup = function cleanup() {
                if (_this3._refetchSubscription === refetchSubscription) {
                    _this3._refetchSubscription = null;
                    _this3._isARequestInFlight = false;
                }
            };
            this._isARequestInFlight = true;
            refetchSubscription = this._getQueryFetcher().execute({
                environment: environment,
                operation: operation,
                preservePreviousReferences: true
            }).mergeMap(function(payload) {
                return Observable.create(function(sink) {
                    onNext(payload, function() {
                        sink.next();
                        sink.complete();
                    });
                });
            })["do"]({
                error: cleanup,
                complete: cleanup,
                unsubscribe: cleanup
            }).subscribe(observer || {});
            this._refetchSubscription = this._isARequestInFlight ? refetchSubscription : null;
            return refetchSubscription;
        };
        _proto._cleanup = function _cleanup() {
            this._resolver.dispose();
            this._refetchVariables = null;
            this._hasFetched = false;
            if (this._refetchSubscription) {
                this._refetchSubscription.unsubscribe();
                this._refetchSubscription = null;
                this._isARequestInFlight = false;
            }
            if (this._queryFetcher) {
                this._queryFetcher.dispose();
            }
        };
        _proto.render = function render() {
            var _this$props3 = this.props, componentRef = _this$props3.componentRef, __relayContext = _this$props3.__relayContext, __rootIsQueryRenderer = _this$props3.__rootIsQueryRenderer, props = (0, _objectWithoutPropertiesLoose2["default"])(_this$props3, _excluded3);
            return /*#__PURE__*/ React.createElement(ReactRelayContext.Provider, {
                value: this.state.contextForChildren
            }, /*#__PURE__*/ React.createElement(Component, (0, _extends2["default"])({}, props, this.state.data, {
                ref: componentRef,
                relay: this.state.relayProp
            })));
        };
        return _class;
    }(React.Component), (0, _defineProperty2["default"])(_class, "displayName", containerName), _class;
}
function createContainer(Component, fragmentSpec, connectionConfig) {
    return buildReactRelayContainer(Component, fragmentSpec, function(ComponentClass, fragments) {
        return createContainerWithFragments(ComponentClass, fragments, connectionConfig);
    });
}
module.exports = {
    createContainer: createContainer
};
}),
"[project]/node_modules/react-relay/lib/ReactRelayQueryRenderer.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _assertThisInitialized2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/assertThisInitialized.js [app-rsc] (ecmascript)"));
var _inheritsLoose2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/inheritsLoose.js [app-rsc] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var ReactRelayContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContext.js [app-rsc] (ecmascript)");
var ReactRelayQueryFetcher = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayQueryFetcher.js [app-rsc] (ecmascript)");
var ReactRelayQueryRendererContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayQueryRendererContext.js [app-rsc] (ecmascript)");
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), createOperationDescriptor = _require.createOperationDescriptor, deepFreeze = _require.deepFreeze, getRequest = _require.getRequest;
var requestCache = {};
var queryRendererContext = {
    rootIsQueryRenderer: true
};
var ReactRelayQueryRenderer = /*#__PURE__*/ function(_React$Component) {
    (0, _inheritsLoose2["default"])(ReactRelayQueryRenderer, _React$Component);
    function ReactRelayQueryRenderer(props) {
        var _this;
        _this = _React$Component.call(this, props) || this;
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleDataChange", function(params) {
            var error = params.error == null ? null : params.error;
            var snapshot = params.snapshot == null ? null : params.snapshot;
            _this.setState(function(prevState) {
                var prevRequestCacheKey = prevState.requestCacheKey;
                if (prevRequestCacheKey) {
                    delete requestCache[prevRequestCacheKey];
                }
                if (snapshot === prevState.snapshot && error === prevState.error) {
                    return null;
                }
                return {
                    renderProps: getRenderProps(error, snapshot, prevState.queryFetcher, prevState.retryCallbacks),
                    snapshot: snapshot,
                    requestCacheKey: null
                };
            });
        });
        var retryCallbacks = {
            handleDataChange: null,
            handleRetryAfterError: null
        };
        var queryFetcher;
        var requestCacheKey;
        if (props.query) {
            var query = props.query;
            var request = getRequest(query);
            requestCacheKey = getRequestCacheKey(request.params, props.variables);
            queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher();
        } else {
            queryFetcher = new ReactRelayQueryFetcher();
        }
        _this._maybeHiddenOrFastRefresh = false;
        _this.state = (0, _objectSpread2["default"])({
            prevPropsEnvironment: props.environment,
            prevPropsVariables: props.variables,
            prevQuery: props.query,
            queryFetcher: queryFetcher,
            retryCallbacks: retryCallbacks
        }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey));
        return _this;
    }
    ReactRelayQueryRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
        if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !areEqual(prevState.prevPropsVariables, nextProps.variables)) {
            return resetQueryStateForUpdate(nextProps, prevState);
        }
        return null;
    };
    var _proto = ReactRelayQueryRenderer.prototype;
    _proto.componentDidMount = function componentDidMount() {
        var _this2 = this;
        if (this._maybeHiddenOrFastRefresh === true) {
            this._maybeHiddenOrFastRefresh = false;
            this.setState(function(prevState) {
                var newState = resetQueryStateForUpdate(_this2.props, prevState);
                var requestCacheKey = newState.requestCacheKey, queryFetcher = newState.queryFetcher;
                if (requestCacheKey != null && requestCache[requestCacheKey] != null) {
                    queryFetcher.setOnDataChange(_this2._handleDataChange);
                }
                return newState;
            });
            return;
        }
        var _this$state = this.state, retryCallbacks = _this$state.retryCallbacks, queryFetcher = _this$state.queryFetcher, requestCacheKey = _this$state.requestCacheKey;
        if (requestCacheKey) {
            delete requestCache[requestCacheKey];
        }
        retryCallbacks.handleDataChange = this._handleDataChange;
        retryCallbacks.handleRetryAfterError = function(error) {
            return _this2.setState(function(prevState) {
                var prevRequestCacheKey = prevState.requestCacheKey;
                if (prevRequestCacheKey) {
                    delete requestCache[prevRequestCacheKey];
                }
                return {
                    renderProps: getLoadingRenderProps(),
                    requestCacheKey: null
                };
            });
        };
        if (this.props.query) {
            queryFetcher.setOnDataChange(this._handleDataChange);
        }
    };
    _proto.componentDidUpdate = function componentDidUpdate(_prevProps, prevState) {
        var _this$state2 = this.state, queryFetcher = _this$state2.queryFetcher, requestCacheKey = _this$state2.requestCacheKey;
        if (requestCacheKey) {
            delete requestCache[requestCacheKey];
            delete this.state.requestCacheKey;
        }
        if (this.props.query && queryFetcher !== prevState.queryFetcher) {
            queryFetcher.setOnDataChange(this._handleDataChange);
        }
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
        this.state.queryFetcher.dispose();
        this._maybeHiddenOrFastRefresh = true;
    };
    _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
        return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;
    };
    _proto.render = function render() {
        var _this$state3 = this.state, renderProps = _this$state3.renderProps, relayContext = _this$state3.relayContext;
        if ("TURBOPACK compile-time truthy", 1) {
            deepFreeze(renderProps);
        }
        return /*#__PURE__*/ React.createElement(ReactRelayContext.Provider, {
            value: relayContext
        }, /*#__PURE__*/ React.createElement(ReactRelayQueryRendererContext.Provider, {
            value: queryRendererContext
        }, this.props.render(renderProps)));
    };
    return ReactRelayQueryRenderer;
}(React.Component);
function getLoadingRenderProps() {
    return {
        error: null,
        props: null,
        retry: null
    };
}
function getEmptyRenderProps() {
    return {
        error: null,
        props: {},
        retry: null
    };
}
function getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {
    return {
        error: error ? error : null,
        props: snapshot ? snapshot.data : null,
        retry: function retry(cacheConfigOverride) {
            var syncSnapshot = queryFetcher.retry(cacheConfigOverride);
            if (syncSnapshot && typeof retryCallbacks.handleDataChange === 'function') {
                retryCallbacks.handleDataChange({
                    snapshot: syncSnapshot
                });
            } else if (error && typeof retryCallbacks.handleRetryAfterError === 'function') {
                retryCallbacks.handleRetryAfterError(error);
            }
        }
    };
}
function getRequestCacheKey(request, variables) {
    return JSON.stringify({
        id: request.cacheID ? request.cacheID : request.id,
        variables: variables
    });
}
function resetQueryStateForUpdate(props, prevState) {
    var query = props.query;
    var prevSelectionReferences = prevState.queryFetcher.getSelectionReferences();
    prevState.queryFetcher.disposeRequest();
    var queryFetcher;
    if (query) {
        var request = getRequest(query);
        var requestCacheKey = getRequestCacheKey(request.params, props.variables);
        queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher(prevSelectionReferences);
    } else {
        queryFetcher = new ReactRelayQueryFetcher(prevSelectionReferences);
    }
    return (0, _objectSpread2["default"])({
        prevQuery: props.query,
        prevPropsEnvironment: props.environment,
        prevPropsVariables: props.variables,
        queryFetcher: queryFetcher
    }, fetchQueryAndComputeStateFromProps(props, queryFetcher, prevState.retryCallbacks));
}
function fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey) {
    var environment = props.environment, query = props.query, variables = props.variables, cacheConfig = props.cacheConfig;
    var genericEnvironment = environment;
    if (query) {
        var request = getRequest(query);
        var operation = createOperationDescriptor(request, variables, cacheConfig);
        var relayContext = {
            environment: genericEnvironment
        };
        if (typeof requestCacheKey === 'string' && requestCache[requestCacheKey]) {
            var snapshot = requestCache[requestCacheKey].snapshot;
            if (snapshot) {
                return {
                    error: null,
                    relayContext: relayContext,
                    renderProps: getRenderProps(null, snapshot, queryFetcher, retryCallbacks),
                    snapshot: snapshot,
                    requestCacheKey: requestCacheKey
                };
            } else {
                return {
                    error: null,
                    relayContext: relayContext,
                    renderProps: getLoadingRenderProps(),
                    snapshot: null,
                    requestCacheKey: requestCacheKey
                };
            }
        }
        try {
            var storeSnapshot = queryFetcher.lookupInStore(genericEnvironment, operation, props.fetchPolicy);
            var querySnapshot = queryFetcher.fetch({
                environment: genericEnvironment,
                onDataChange: null,
                operation: operation
            });
            var _snapshot = querySnapshot || storeSnapshot;
            requestCacheKey = requestCacheKey || getRequestCacheKey(request.params, props.variables);
            requestCache[requestCacheKey] = {
                queryFetcher: queryFetcher,
                snapshot: _snapshot
            };
            if (!_snapshot) {
                return {
                    error: null,
                    relayContext: relayContext,
                    renderProps: getLoadingRenderProps(),
                    snapshot: null,
                    requestCacheKey: requestCacheKey
                };
            }
            return {
                error: null,
                relayContext: relayContext,
                renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),
                snapshot: _snapshot,
                requestCacheKey: requestCacheKey
            };
        } catch (error) {
            return {
                error: error,
                relayContext: relayContext,
                renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),
                snapshot: null,
                requestCacheKey: requestCacheKey
            };
        }
    } else {
        queryFetcher.dispose();
        var _relayContext = {
            environment: genericEnvironment
        };
        return {
            error: null,
            relayContext: _relayContext,
            renderProps: getEmptyRenderProps(),
            requestCacheKey: null
        };
    }
}
module.exports = ReactRelayQueryRenderer;
}),
"[project]/node_modules/react-relay/lib/ReactRelayRefetchContainer.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _extends2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/extends.js [app-rsc] (ecmascript)"));
var _objectWithoutPropertiesLoose2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js [app-rsc] (ecmascript)"));
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _assertThisInitialized2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/assertThisInitialized.js [app-rsc] (ecmascript)"));
var _inheritsLoose2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/inheritsLoose.js [app-rsc] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var _excluded = [
    "componentRef",
    "__relayContext",
    "__rootIsQueryRenderer"
];
var buildReactRelayContainer = __turbopack_context__.r("[project]/node_modules/react-relay/lib/buildReactRelayContainer.js [app-rsc] (ecmascript)");
var getRootVariablesForFragments = __turbopack_context__.r("[project]/node_modules/react-relay/lib/getRootVariablesForFragments.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContainerUtils.js [app-rsc] (ecmascript)"), getContainerName = _require.getContainerName;
var ReactRelayContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContext.js [app-rsc] (ecmascript)");
var ReactRelayQueryFetcher = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayQueryFetcher.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/react-relay/lib/RelayContext.js [app-rsc] (ecmascript)"), assertRelayContext = _require2.assertRelayContext;
var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), Observable = _require3.Observable, createFragmentSpecResolver = _require3.createFragmentSpecResolver, createOperationDescriptor = _require3.createOperationDescriptor, getDataIDsFromObject = _require3.getDataIDsFromObject, getRequest = _require3.getRequest, getVariablesFromObject = _require3.getVariablesFromObject, isScalarAndEqual = _require3.isScalarAndEqual;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function createContainerWithFragments(Component, fragments, taggedNode) {
    var _class;
    var containerName = getContainerName(Component);
    return _class = /*#__PURE__*/ function(_React$Component) {
        (0, _inheritsLoose2["default"])(_class, _React$Component);
        function _class(props) {
            var _props$__rootIsQueryR, _this;
            _this = _React$Component.call(this, props) || this;
            (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_handleFragmentDataUpdate", function() {
                var resolverFromThisUpdate = _this.state.resolver;
                _this.setState(function(updatedState) {
                    return resolverFromThisUpdate === updatedState.resolver ? {
                        data: updatedState.resolver.resolve()
                    } : null;
                });
            });
            (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_refetch", function(refetchVariables, renderVariables, observerOrCallback, options) {
                if (_this._isUnmounted) {
                    ("TURBOPACK compile-time truthy", 1) ? warning(false, 'ReactRelayRefetchContainer: Unexpected call of `refetch` ' + 'on unmounted container `%s`. It looks like some instances ' + 'of your container still trying to refetch the data but they already ' + 'unmounted. Please make sure you clear all timers, intervals, async ' + 'calls, etc that may trigger `refetch`.', containerName) : "TURBOPACK unreachable";
                    return {
                        dispose: function dispose() {}
                    };
                }
                var _assertRelayContext = assertRelayContext(_this.props.__relayContext), environment = _assertRelayContext.environment;
                var rootVariables = getRootVariablesForFragments(fragments, _this.props);
                var fetchVariables = typeof refetchVariables === 'function' ? refetchVariables(_this._getFragmentVariables()) : refetchVariables;
                fetchVariables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, rootVariables), fetchVariables);
                var fragmentVariables = renderVariables ? (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, fetchVariables), renderVariables) : fetchVariables;
                var cacheConfig = options ? {
                    force: !!options.force
                } : undefined;
                if (cacheConfig != null && (options === null || options === void 0 ? void 0 : options.metadata) != null) {
                    cacheConfig.metadata = options === null || options === void 0 ? void 0 : options.metadata;
                }
                var observer = typeof observerOrCallback === 'function' ? {
                    next: observerOrCallback,
                    error: observerOrCallback
                } : observerOrCallback || {};
                var query = getRequest(taggedNode);
                var operation = createOperationDescriptor(query, fetchVariables, cacheConfig);
                _this.state.localVariables = fetchVariables;
                _this._refetchSubscription && _this._refetchSubscription.unsubscribe();
                var refetchSubscription;
                var storeSnapshot = _this._getQueryFetcher().lookupInStore(environment, operation, options === null || options === void 0 ? void 0 : options.fetchPolicy);
                if (storeSnapshot != null) {
                    _this.state.resolver.setVariables(fragmentVariables, operation.request.node);
                    _this.setState(function(latestState) {
                        return {
                            data: latestState.resolver.resolve(),
                            contextForChildren: {
                                environment: _this.props.__relayContext.environment
                            }
                        };
                    }, function() {
                        observer.next && observer.next();
                        observer.complete && observer.complete();
                    });
                    return {
                        dispose: function dispose() {}
                    };
                }
                _this._getQueryFetcher().execute({
                    environment: environment,
                    operation: operation,
                    preservePreviousReferences: true
                }).mergeMap(function(response) {
                    _this.state.resolver.setVariables(fragmentVariables, operation.request.node);
                    return Observable.create(function(sink) {
                        return _this.setState(function(latestState) {
                            return {
                                data: latestState.resolver.resolve(),
                                contextForChildren: {
                                    environment: _this.props.__relayContext.environment
                                }
                            };
                        }, function() {
                            sink.next();
                            sink.complete();
                        });
                    });
                })["finally"](function() {
                    if (_this._refetchSubscription === refetchSubscription) {
                        _this._refetchSubscription = null;
                    }
                }).subscribe((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, observer), {}, {
                    start: function start(subscription) {
                        _this._refetchSubscription = refetchSubscription = subscription;
                        observer.start && observer.start(subscription);
                    }
                }));
                return {
                    dispose: function dispose() {
                        refetchSubscription && refetchSubscription.unsubscribe();
                    }
                };
            });
            var relayContext = assertRelayContext(props.__relayContext);
            var rootIsQueryRenderer = (_props$__rootIsQueryR = props.__rootIsQueryRenderer) !== null && _props$__rootIsQueryR !== void 0 ? _props$__rootIsQueryR : false;
            _this._refetchSubscription = null;
            var resolver = createFragmentSpecResolver(relayContext, containerName, fragments, props, rootIsQueryRenderer);
            _this.state = {
                data: resolver.resolve(),
                localVariables: null,
                prevProps: props,
                prevPropsContext: relayContext,
                contextForChildren: relayContext,
                relayProp: getRelayProp(relayContext.environment, _this._refetch),
                resolver: resolver
            };
            _this._isUnmounted = false;
            return _this;
        }
        var _proto = _class.prototype;
        _proto.componentDidMount = function componentDidMount() {
            this._isUnmounted = false;
            this._subscribeToNewResolverAndRerenderIfStoreHasChanged();
        };
        _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
            if (this.state.resolver !== prevState.resolver) {
                prevState.resolver.dispose();
                this._queryFetcher && this._queryFetcher.dispose();
                this._refetchSubscription && this._refetchSubscription.unsubscribe();
                this._subscribeToNewResolverAndRerenderIfStoreHasChanged();
            } else {
                this._rerenderIfStoreHasChanged();
            }
        };
        _class.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {
            var _nextProps$__rootIsQu;
            var prevProps = prevState.prevProps;
            var relayContext = assertRelayContext(nextProps.__relayContext);
            var rootIsQueryRenderer = (_nextProps$__rootIsQu = nextProps.__rootIsQueryRenderer) !== null && _nextProps$__rootIsQu !== void 0 ? _nextProps$__rootIsQu : false;
            var prevIDs = getDataIDsFromObject(fragments, prevProps);
            var nextIDs = getDataIDsFromObject(fragments, nextProps);
            var prevRootVariables = getRootVariablesForFragments(fragments, prevProps);
            var nextRootVariables = getRootVariablesForFragments(fragments, nextProps);
            var resolver = prevState.resolver;
            if (prevState.prevPropsContext.environment !== relayContext.environment || !areEqual(prevRootVariables, nextRootVariables) || !areEqual(prevIDs, nextIDs)) {
                resolver = createFragmentSpecResolver(relayContext, containerName, fragments, nextProps, rootIsQueryRenderer);
                return {
                    data: resolver.resolve(),
                    localVariables: null,
                    prevProps: nextProps,
                    prevPropsContext: relayContext,
                    contextForChildren: relayContext,
                    relayProp: getRelayProp(relayContext.environment, prevState.relayProp.refetch),
                    resolver: resolver
                };
            } else if (!prevState.localVariables) {
                resolver.setProps(nextProps);
            }
            var data = resolver.resolve();
            if (data !== prevState.data) {
                return {
                    data: data,
                    prevProps: nextProps
                };
            }
            return null;
        };
        _proto.componentWillUnmount = function componentWillUnmount() {
            this._isUnmounted = true;
            this.state.resolver.dispose();
            this._queryFetcher && this._queryFetcher.dispose();
            this._refetchSubscription && this._refetchSubscription.unsubscribe();
        };
        _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {
            if (nextState.data !== this.state.data || nextState.relayProp !== this.state.relayProp) {
                return true;
            }
            var keys = Object.keys(nextProps);
            for(var ii = 0; ii < keys.length; ii++){
                var key = keys[ii];
                if (key === '__relayContext') {
                    if (this.state.prevPropsContext.environment !== nextState.prevPropsContext.environment) {
                        return true;
                    }
                } else {
                    if (!fragments.hasOwnProperty(key) && !isScalarAndEqual(nextProps[key], this.props[key])) {
                        return true;
                    }
                }
            }
            return false;
        };
        _proto._rerenderIfStoreHasChanged = function _rerenderIfStoreHasChanged() {
            var _this$state = this.state, data = _this$state.data, resolver = _this$state.resolver;
            var maybeNewData = resolver.resolve();
            if (data !== maybeNewData) {
                this.setState({
                    data: maybeNewData
                });
            }
        };
        _proto._subscribeToNewResolverAndRerenderIfStoreHasChanged = function _subscribeToNewResolverAndRerenderIfStoreHasChanged() {
            var _this$state2 = this.state, data = _this$state2.data, resolver = _this$state2.resolver;
            var maybeNewData = resolver.resolve();
            resolver.setCallback(this.props, this._handleFragmentDataUpdate);
            if (data !== maybeNewData) {
                this.setState({
                    data: maybeNewData
                });
            }
        };
        _proto._getFragmentVariables = function _getFragmentVariables() {
            return getVariablesFromObject(fragments, this.props);
        };
        _proto._getQueryFetcher = function _getQueryFetcher() {
            if (!this._queryFetcher) {
                this._queryFetcher = new ReactRelayQueryFetcher();
            }
            return this._queryFetcher;
        };
        _proto.render = function render() {
            var _this$props = this.props, componentRef = _this$props.componentRef, __relayContext = _this$props.__relayContext, __rootIsQueryRenderer = _this$props.__rootIsQueryRenderer, props = (0, _objectWithoutPropertiesLoose2["default"])(_this$props, _excluded);
            var _this$state3 = this.state, relayProp = _this$state3.relayProp, contextForChildren = _this$state3.contextForChildren;
            return /*#__PURE__*/ React.createElement(ReactRelayContext.Provider, {
                value: contextForChildren
            }, /*#__PURE__*/ React.createElement(Component, (0, _extends2["default"])({}, props, this.state.data, {
                ref: componentRef,
                relay: relayProp
            })));
        };
        return _class;
    }(React.Component), (0, _defineProperty2["default"])(_class, "displayName", containerName), _class;
}
function getRelayProp(environment, refetch) {
    return {
        environment: environment,
        refetch: refetch
    };
}
function createContainer(Component, fragmentSpec, taggedNode) {
    return buildReactRelayContainer(Component, fragmentSpec, function(ComponentClass, fragments) {
        return createContainerWithFragments(ComponentClass, fragments, taggedNode);
    });
}
module.exports = {
    createContainer: createContainer
};
}),
"[project]/node_modules/react-relay/lib/relay-hooks/ProfilerContext.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var ProfilerContext = React.createContext({
    wrapPrepareQueryResource: function wrapPrepareQueryResource(cb) {
        return cb();
    }
});
module.exports = ProfilerContext;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ReactRelayContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContext.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useContext = _require.useContext;
function useRelayEnvironment() {
    var context = useContext(ReactRelayContext);
    !(context != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'useRelayEnvironment: Expected to have found a Relay environment provided by ' + 'a `RelayEnvironmentProvider` component. ' + 'This usually means that useRelayEnvironment was used in a ' + 'component that is not a descendant of a `RelayEnvironmentProvider`. ' + 'Please make sure a `RelayEnvironmentProvider` has been rendered somewhere ' + 'as a parent or ancestor of your component.') : "TURBOPACK unreachable" : void 0;
    return context.environment;
}
module.exports = useRelayEnvironment;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/EntryPointContainer.react.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ProfilerContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/ProfilerContext.js [app-rsc] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useContext = _require.useContext, useEffect = _require.useEffect;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function EntryPointContainer(_ref) {
    var entryPointReference = _ref.entryPointReference, props = _ref.props;
    ("TURBOPACK compile-time truthy", 1) ? warning(entryPointReference.isDisposed === false, '<EntryPointContainer>: Expected entryPointReference to not be disposed ' + 'yet. This is because disposing the entrypoint marks it for future garbage ' + 'collection, and as such may no longer be present in the Relay store. ' + 'In the future, this will become a hard error.') : "TURBOPACK unreachable";
    var getComponent = entryPointReference.getComponent, queries = entryPointReference.queries, entryPoints = entryPointReference.entryPoints, extraProps = entryPointReference.extraProps, rootModuleID = entryPointReference.rootModuleID;
    var Component = getComponent();
    var profilerContext = useContext(ProfilerContext);
    var environment = useRelayEnvironment();
    useEffect(function() {
        environment.__log({
            name: 'entrypoint.root.consume',
            profilerContext: profilerContext,
            rootModuleID: rootModuleID
        });
    }, [
        environment,
        profilerContext,
        rootModuleID
    ]);
    return /*#__PURE__*/ React.createElement(Component, {
        entryPoints: entryPoints,
        extraProps: extraProps,
        props: props,
        queries: queries
    });
}
module.exports = EntryPointContainer;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/loadQuery.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), fetchQueryDeduped = _require.__internal.fetchQueryDeduped, Observable = _require.Observable, PreloadableQueryRegistry = _require.PreloadableQueryRegistry, ReplaySubject = _require.ReplaySubject, createOperationDescriptor = _require.createOperationDescriptor, getRequest = _require.getRequest, getRequestIdentifier = _require.getRequestIdentifier;
var fetchKey = 100001;
function loadQuery(environment, preloadableRequest, variables, options, environmentProviderOptions) {
    var _options$fetchPolicy;
    fetchKey++;
    var fetchPolicy = (_options$fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy) !== null && _options$fetchPolicy !== void 0 ? _options$fetchPolicy : 'store-or-network';
    var networkCacheConfig = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, options === null || options === void 0 ? void 0 : options.networkCacheConfig), {}, {
        force: true
    });
    var retainReference;
    var didExecuteNetworkSource = false;
    var executeWithNetworkSource = function executeWithNetworkSource(operation, networkObservable) {
        didExecuteNetworkSource = true;
        return environment.executeWithSource({
            operation: operation,
            source: networkObservable
        });
    };
    var executionSubject = new ReplaySubject();
    var returnedObservable = Observable.create(function(sink) {
        return executionSubject.subscribe(sink);
    });
    var unsubscribeFromNetworkRequest;
    var networkError = null;
    var didMakeNetworkRequest = false;
    var makeNetworkRequest = function makeNetworkRequest(params, checkOperation) {
        didMakeNetworkRequest = true;
        var subject = new ReplaySubject();
        var identifier = 'raw-network-request-' + getRequestIdentifier(params, variables);
        var observable = fetchQueryDeduped(environment, identifier, function() {
            var network = environment.getNetwork();
            return network.execute(params, variables, networkCacheConfig, undefined, undefined, undefined, undefined, checkOperation);
        });
        var _observable$subscribe = observable.subscribe({
            error: function error(err) {
                networkError = err;
                subject.error(err);
            },
            next: function next(data) {
                subject.next(data);
            },
            complete: function complete() {
                subject.complete();
            }
        }), unsubscribe = _observable$subscribe.unsubscribe;
        unsubscribeFromNetworkRequest = unsubscribe;
        return Observable.create(function(sink) {
            var subjectSubscription = subject.subscribe(sink);
            return function() {
                subjectSubscription.unsubscribe();
                unsubscribeFromNetworkRequest();
            };
        });
    };
    var unsubscribeFromExecution;
    var executeDeduped = function executeDeduped(operation, fetchFn) {
        didMakeNetworkRequest = true;
        var _fetchQueryDeduped$su = fetchQueryDeduped(environment, operation.request.identifier, fetchFn).subscribe({
            error: function error(err) {
                executionSubject.error(err);
            },
            next: function next(data) {
                executionSubject.next(data);
            },
            complete: function complete() {
                executionSubject.complete();
            }
        });
        unsubscribeFromExecution = _fetchQueryDeduped$su.unsubscribe;
    };
    var checkAvailabilityAndExecute = function checkAvailabilityAndExecute(concreteRequest) {
        var operation = createOperationDescriptor(concreteRequest, variables, networkCacheConfig);
        retainReference = environment.retain(operation);
        if (fetchPolicy === 'store-only') {
            return;
        }
        var shouldFetch = fetchPolicy !== 'store-or-network' || environment.check(operation).status !== 'available';
        if (shouldFetch) {
            executeDeduped(operation, function() {
                var networkObservable = makeNetworkRequest(concreteRequest.params, function() {
                    return environment.check(operation);
                });
                var executeObservable = executeWithNetworkSource(operation, networkObservable);
                return executeObservable;
            });
        }
    };
    var params;
    var cancelOnLoadCallback;
    var queryId;
    if (preloadableRequest.kind === 'PreloadableConcreteRequest') {
        var preloadableConcreteRequest = preloadableRequest;
        params = preloadableConcreteRequest.params;
        var _params = params;
        queryId = _params.id;
        !(queryId !== null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: `loadQuery` requires that preloadable query `%s` has a persisted query id', params.name) : "TURBOPACK unreachable" : void 0;
        var _module = PreloadableQueryRegistry.get(queryId);
        if (_module != null) {
            checkAvailabilityAndExecute(_module);
        } else {
            var networkObservable = fetchPolicy === 'store-only' ? null : makeNetworkRequest(params);
            var _PreloadableQueryRegi = PreloadableQueryRegistry.onLoad(queryId, function(preloadedModule) {
                cancelOnLoadCallback();
                var operation = createOperationDescriptor(preloadedModule, variables, networkCacheConfig);
                retainReference = environment.retain(operation);
                if (networkObservable != null) {
                    executeDeduped(operation, function() {
                        return executeWithNetworkSource(operation, networkObservable);
                    });
                }
            });
            cancelOnLoadCallback = _PreloadableQueryRegi.dispose;
        }
    } else {
        var graphQlTaggedNode = preloadableRequest;
        var request = getRequest(graphQlTaggedNode);
        params = request.params;
        queryId = params.cacheID != null ? params.cacheID : params.id;
        checkAvailabilityAndExecute(request);
    }
    var isDisposed = false;
    var isReleased = false;
    var isNetworkRequestCancelled = false;
    var releaseQuery = function releaseQuery() {
        if (isReleased) {
            return;
        }
        retainReference && retainReference.dispose();
        isReleased = true;
    };
    var cancelNetworkRequest = function cancelNetworkRequest() {
        if (isNetworkRequestCancelled) {
            return;
        }
        if (didExecuteNetworkSource) {
            unsubscribeFromExecution && unsubscribeFromExecution();
        } else {
            unsubscribeFromNetworkRequest && unsubscribeFromNetworkRequest();
        }
        cancelOnLoadCallback && cancelOnLoadCallback();
        isNetworkRequestCancelled = true;
    };
    return {
        kind: 'PreloadedQuery',
        environment: environment,
        environmentProviderOptions: environmentProviderOptions,
        dispose: function dispose() {
            if (isDisposed) {
                return;
            }
            releaseQuery();
            cancelNetworkRequest();
            isDisposed = true;
        },
        releaseQuery: releaseQuery,
        cancelNetworkRequest: cancelNetworkRequest,
        fetchKey: fetchKey,
        id: queryId,
        get isDisposed () {
            return isDisposed || isReleased;
        },
        get networkError () {
            return networkError;
        },
        name: params.name,
        networkCacheConfig: networkCacheConfig,
        fetchPolicy: fetchPolicy,
        source: didMakeNetworkRequest ? returnedObservable : undefined,
        variables: variables
    };
}
module.exports = {
    loadQuery: loadQuery
};
}),
"[project]/node_modules/react-relay/lib/relay-hooks/loadEntryPoint.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/loadQuery.js [app-rsc] (ecmascript)"), loadQuery = _require.loadQuery;
function loadEntryPoint(environmentProvider, entryPoint, entryPointParams) {
    var loadingPromise = null;
    if (entryPoint.root.getModuleIfRequired() == null) {
        loadingPromise = entryPoint.root.load();
    }
    var preloadProps = entryPoint.getPreloadProps(entryPointParams);
    var queries = preloadProps.queries, entryPoints = preloadProps.entryPoints, extraProps = preloadProps.extraProps;
    var preloadedQueries = {};
    var preloadedEntryPoints = {};
    if (queries != null) {
        var queriesPropNames = Object.keys(queries);
        queriesPropNames.forEach(function(queryPropName) {
            var query = queries[queryPropName];
            if (query == null) {
                return;
            }
            var environmentProviderOptions = query.environmentProviderOptions, options = query.options, parameters = query.parameters, variables = query.variables;
            if ((options === null || options === void 0 ? void 0 : options.includeIf) === false) {
                return;
            }
            var environment = environmentProvider.getEnvironment(environmentProviderOptions);
            preloadedQueries[queryPropName] = loadQuery(environment, parameters, variables, {
                fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
                networkCacheConfig: options === null || options === void 0 ? void 0 : options.networkCacheConfig,
                __nameForWarning: 'loadEntryPoint'
            }, environmentProviderOptions);
        });
    }
    if (entryPoints != null) {
        var entryPointPropNames = Object.keys(entryPoints);
        entryPointPropNames.forEach(function(entryPointPropName) {
            var entryPointDescription = entryPoints[entryPointPropName];
            if (entryPointDescription == null) {
                return;
            }
            var nestedEntryPoint = entryPointDescription.entryPoint, nestedParams = entryPointDescription.entryPointParams;
            preloadedEntryPoints[entryPointPropName] = loadEntryPoint(environmentProvider, nestedEntryPoint, nestedParams);
        });
    }
    var isDisposed = false;
    return {
        dispose: function dispose() {
            if (isDisposed) {
                return;
            }
            if (preloadedQueries != null) {
                Object.values(preloadedQueries).forEach(function(_ref) {
                    var innerDispose = _ref.dispose;
                    innerDispose();
                });
            }
            if (preloadedEntryPoints != null) {
                Object.values(preloadedEntryPoints).forEach(function(_ref2) {
                    var innerDispose = _ref2.dispose;
                    innerDispose();
                });
            }
            isDisposed = true;
        },
        entryPoints: preloadedEntryPoints,
        extraProps: extraProps !== null && extraProps !== void 0 ? extraProps : null,
        getComponent: function getComponent() {
            var componentModule = entryPoint.root.getModuleIfRequired();
            if (componentModule == null) {
                var _loadingPromise;
                loadingPromise = (_loadingPromise = loadingPromise) !== null && _loadingPromise !== void 0 ? _loadingPromise : entryPoint.root.load();
                throw loadingPromise;
            }
            var component = componentModule["default"] != null ? componentModule["default"] : componentModule;
            return component;
        },
        get isDisposed () {
            return isDisposed;
        },
        queries: preloadedQueries,
        rootModuleID: entryPoint.root.getModuleId()
    };
}
module.exports = loadEntryPoint;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/RelayEnvironmentProvider.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ReactRelayContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContext.js [app-rsc] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var useMemo = React.useMemo;
function RelayEnvironmentProvider(props) {
    var children = props.children, environment = props.environment, getEnvironmentForActor = props.getEnvironmentForActor;
    var context = useMemo(function() {
        return {
            environment: environment,
            getEnvironmentForActor: getEnvironmentForActor
        };
    }, [
        environment,
        getEnvironmentForActor
    ]);
    return /*#__PURE__*/ React.createElement(ReactRelayContext.Provider, {
        value: context
    }, children);
}
module.exports = RelayEnvironmentProvider;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/LRUCache.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var LRUCache = /*#__PURE__*/ function() {
    function LRUCache(capacity) {
        this._capacity = capacity;
        !(this._capacity > 0) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'LRUCache: Unable to create instance of cache with zero or negative capacity.') : "TURBOPACK unreachable" : void 0;
        this._map = new Map();
    }
    var _proto = LRUCache.prototype;
    _proto.set = function set(key, value) {
        this._map["delete"](key);
        this._map.set(key, value);
        if (this._map.size > this._capacity) {
            var firstKey = this._map.keys().next();
            if (!firstKey.done) {
                this._map["delete"](firstKey.value);
            }
        }
    };
    _proto.get = function get(key) {
        var value = this._map.get(key);
        if (value != null) {
            this._map["delete"](key);
            this._map.set(key, value);
        }
        return value;
    };
    _proto.has = function has(key) {
        return this._map.has(key);
    };
    _proto["delete"] = function _delete(key) {
        this._map["delete"](key);
    };
    _proto.size = function size() {
        return this._map.size;
    };
    _proto.capacity = function capacity() {
        return this._capacity - this._map.size;
    };
    _proto.clear = function clear() {
        this._map.clear();
    };
    return LRUCache;
}();
function create(capacity) {
    return new LRUCache(capacity);
}
module.exports = {
    create: create
};
}),
"[project]/node_modules/react-relay/lib/relay-hooks/SuspenseResource.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
var TEMPORARY_RETAIN_DURATION_MS = 5 * 60 * 1000;
var SuspenseResource = /*#__PURE__*/ function() {
    function SuspenseResource(retain) {
        var _this = this;
        (0, _defineProperty2["default"])(this, "_retainCount", 0);
        (0, _defineProperty2["default"])(this, "_retainDisposable", null);
        (0, _defineProperty2["default"])(this, "_releaseTemporaryRetain", null);
        this._retain = function(environment) {
            _this._retainCount++;
            if (_this._retainCount === 1) {
                _this._retainDisposable = retain(environment);
            }
            return {
                dispose: function dispose() {
                    _this._retainCount = Math.max(0, _this._retainCount - 1);
                    if (_this._retainCount === 0) {
                        if (_this._retainDisposable != null) {
                            _this._retainDisposable.dispose();
                            _this._retainDisposable = null;
                        } else {
                            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected disposable to release query to be defined.' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable";
                        }
                    }
                }
            };
        };
    }
    var _proto = SuspenseResource.prototype;
    _proto.temporaryRetain = function temporaryRetain(environment) {
        var _this2 = this;
        var _this$_releaseTempora;
        if (environment.isServer()) {
            return {
                dispose: function dispose() {}
            };
        }
        var retention = this._retain(environment);
        var releaseQueryTimeout = null;
        var releaseTemporaryRetain = function releaseTemporaryRetain() {
            clearTimeout(releaseQueryTimeout);
            releaseQueryTimeout = null;
            _this2._releaseTemporaryRetain = null;
            retention.dispose();
        };
        releaseQueryTimeout = setTimeout(releaseTemporaryRetain, TEMPORARY_RETAIN_DURATION_MS);
        (_this$_releaseTempora = this._releaseTemporaryRetain) === null || _this$_releaseTempora === void 0 ? void 0 : _this$_releaseTempora.call(this);
        this._releaseTemporaryRetain = releaseTemporaryRetain;
        return {
            dispose: function dispose() {
                var _this$_releaseTempora2;
                (_this$_releaseTempora2 = _this2._releaseTemporaryRetain) === null || _this$_releaseTempora2 === void 0 ? void 0 : _this$_releaseTempora2.call(_this2);
            }
        };
    };
    _proto.permanentRetain = function permanentRetain(environment) {
        var disposable = this._retain(environment);
        this.releaseTemporaryRetain();
        return disposable;
    };
    _proto.releaseTemporaryRetain = function releaseTemporaryRetain() {
        var _this$_releaseTempora3;
        (_this$_releaseTempora3 = this._releaseTemporaryRetain) === null || _this$_releaseTempora3 === void 0 ? void 0 : _this$_releaseTempora3.call(this);
        this._releaseTemporaryRetain = null;
    };
    _proto.getRetainCount = function getRetainCount() {
        return this._retainCount;
    };
    return SuspenseResource;
}();
module.exports = SuspenseResource;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/QueryResource.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _defineProperty2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-rsc] (ecmascript)"));
var LRUCache = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/LRUCache.js [app-rsc] (ecmascript)");
var SuspenseResource = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/SuspenseResource.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), isPromise = _require.isPromise;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
var CACHE_CAPACITY = 1000;
var DEFAULT_FETCH_POLICY = 'store-or-network';
var DEFAULT_LIVE_FETCH_POLICY = 'store-and-network';
var WEAKMAP_SUPPORTED = typeof WeakMap === 'function';
function operationIsLiveQuery(operation) {
    return operation.request.node.params.metadata.live !== undefined;
}
function getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {
    var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : operationIsLiveQuery(operation) ? DEFAULT_LIVE_FETCH_POLICY : DEFAULT_FETCH_POLICY;
    var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();
    var cacheIdentifier = "".concat(fetchPolicy, "-").concat(renderPolicy, "-").concat(operation.request.identifier);
    if (cacheBreaker != null) {
        return "".concat(cacheIdentifier, "-").concat(cacheBreaker);
    }
    return cacheIdentifier;
}
function getQueryResult(operation, cacheIdentifier) {
    var rootFragmentRef = {
        __id: operation.fragment.dataID,
        __fragments: (0, _defineProperty2["default"])({}, operation.fragment.node.name, operation.request.variables),
        __fragmentOwner: operation.request
    };
    return {
        cacheIdentifier: cacheIdentifier,
        fragmentNode: operation.request.node.fragment,
        fragmentRef: rootFragmentRef,
        operation: operation
    };
}
var nextID = 200000;
function createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {
    var isLiveQuery = operationIsLiveQuery(operation);
    var currentValue = value;
    var currentNetworkSubscription = networkSubscription;
    var suspenseResource = new SuspenseResource(function(environment) {
        var retention = environment.retain(operation);
        return {
            dispose: function dispose() {
                if (isLiveQuery && currentNetworkSubscription != null) {
                    currentNetworkSubscription.unsubscribe();
                }
                retention.dispose();
                onDispose(cacheEntry);
            }
        };
    });
    var cacheEntry = {
        cacheIdentifier: cacheIdentifier,
        id: nextID++,
        processedPayloadsCount: 0,
        operationAvailability: operationAvailability,
        getValue: function getValue() {
            return currentValue;
        },
        setValue: function setValue(val) {
            currentValue = val;
        },
        setNetworkSubscription: function setNetworkSubscription(subscription) {
            if (isLiveQuery && currentNetworkSubscription != null) {
                currentNetworkSubscription.unsubscribe();
            }
            currentNetworkSubscription = subscription;
        },
        temporaryRetain: function temporaryRetain(environment) {
            return suspenseResource.temporaryRetain(environment);
        },
        permanentRetain: function permanentRetain(environment) {
            return suspenseResource.permanentRetain(environment);
        },
        releaseTemporaryRetain: function releaseTemporaryRetain() {
            suspenseResource.releaseTemporaryRetain();
        }
    };
    return cacheEntry;
}
var QueryResourceImpl = /*#__PURE__*/ function() {
    function QueryResourceImpl(environment) {
        var _this = this;
        (0, _defineProperty2["default"])(this, "_clearCacheEntry", function(cacheEntry) {
            _this._cache["delete"](cacheEntry.cacheIdentifier);
        });
        this._environment = environment;
        this._cache = LRUCache.create(CACHE_CAPACITY);
    }
    var _proto = QueryResourceImpl.prototype;
    _proto.prepare = function prepare(operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, cacheBreaker, profilerContext) {
        var cacheIdentifier = getQueryCacheIdentifier(this._environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);
        return this.prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext);
    };
    _proto.prepareWithIdentifier = function prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext) {
        var environment = this._environment;
        var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : operationIsLiveQuery(operation) ? DEFAULT_LIVE_FETCH_POLICY : DEFAULT_FETCH_POLICY;
        var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();
        var cacheEntry = this._cache.get(cacheIdentifier);
        var temporaryRetainDisposable = null;
        var entryWasCached = cacheEntry != null;
        if (cacheEntry == null) {
            cacheEntry = this._fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, observer), {}, {
                unsubscribe: function unsubscribe(subscription) {
                    if (temporaryRetainDisposable != null) {
                        temporaryRetainDisposable.dispose();
                    }
                    var observerUnsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe;
                    observerUnsubscribe && observerUnsubscribe(subscription);
                }
            }));
        }
        temporaryRetainDisposable = cacheEntry.temporaryRetain(environment);
        var cachedValue = cacheEntry.getValue();
        if (isPromise(cachedValue)) {
            environment.__log({
                name: 'suspense.query',
                fetchPolicy: fetchPolicy,
                isPromiseCached: entryWasCached,
                operation: operation,
                queryAvailability: cacheEntry.operationAvailability,
                renderPolicy: renderPolicy
            });
            throw cachedValue;
        }
        if (cachedValue instanceof Error) {
            throw cachedValue;
        }
        return cachedValue;
    };
    _proto.retain = function retain(queryResult, profilerContext) {
        var environment = this._environment;
        var cacheIdentifier = queryResult.cacheIdentifier, operation = queryResult.operation;
        var cacheEntry = this._getOrCreateCacheEntry(cacheIdentifier, operation, null, queryResult, null);
        var disposable = cacheEntry.permanentRetain(environment);
        environment.__log({
            name: 'queryresource.retain',
            profilerContext: profilerContext,
            resourceID: cacheEntry.id
        });
        return {
            dispose: function dispose() {
                disposable.dispose();
            }
        };
    };
    _proto.releaseTemporaryRetain = function releaseTemporaryRetain(queryResult) {
        var cacheEntry = this._cache.get(queryResult.cacheIdentifier);
        if (cacheEntry != null) {
            cacheEntry.releaseTemporaryRetain();
        }
    };
    _proto.TESTS_ONLY__getCacheEntry = function TESTS_ONLY__getCacheEntry(operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {
        var environment = this._environment;
        var cacheIdentifier = getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);
        return this._cache.get(cacheIdentifier);
    };
    _proto._getOrCreateCacheEntry = function _getOrCreateCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription) {
        var cacheEntry = this._cache.get(cacheIdentifier);
        if (cacheEntry == null) {
            cacheEntry = createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, this._clearCacheEntry);
            this._cache.set(cacheIdentifier, cacheEntry);
        }
        return cacheEntry;
    };
    _proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {
        var _this2 = this;
        var environment = this._environment;
        var queryAvailability = environment.check(operation);
        var queryStatus = queryAvailability.status;
        var hasFullQuery = queryStatus === 'available';
        var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';
        var shouldFetch;
        var shouldAllowRender;
        var resolveNetworkPromise = function resolveNetworkPromise() {};
        switch(fetchPolicy){
            case 'store-only':
                {
                    shouldFetch = false;
                    shouldAllowRender = true;
                    break;
                }
            case 'store-or-network':
                {
                    shouldFetch = !hasFullQuery;
                    shouldAllowRender = canPartialRender;
                    break;
                }
            case 'store-and-network':
                {
                    shouldFetch = true;
                    shouldAllowRender = canPartialRender;
                    break;
                }
            case 'network-only':
            default:
                {
                    shouldFetch = true;
                    shouldAllowRender = false;
                    break;
                }
        }
        if (shouldAllowRender) {
            var queryResult = getQueryResult(operation, cacheIdentifier);
            var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryAvailability, queryResult, null, this._clearCacheEntry);
            this._cache.set(cacheIdentifier, _cacheEntry);
        }
        if (shouldFetch) {
            var _queryResult = getQueryResult(operation, cacheIdentifier);
            var networkSubscription;
            fetchObservable.subscribe({
                start: function start(subscription) {
                    networkSubscription = subscription;
                    var cacheEntry = _this2._cache.get(cacheIdentifier);
                    if (cacheEntry) {
                        cacheEntry.setNetworkSubscription(networkSubscription);
                    }
                    var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;
                    if (observerStart) {
                        var subscriptionWithConditionalCancelation = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, subscription), {}, {
                            unsubscribe: function unsubscribe() {
                                if (operationIsLiveQuery(operation)) {
                                    subscription.unsubscribe();
                                }
                            }
                        });
                        observerStart(subscriptionWithConditionalCancelation);
                    }
                },
                next: function next() {
                    var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _queryResult, networkSubscription);
                    cacheEntry.processedPayloadsCount += 1;
                    cacheEntry.setValue(_queryResult);
                    resolveNetworkPromise();
                    var observerNext = observer === null || observer === void 0 ? void 0 : observer.next;
                    if (observerNext != null) {
                        var snapshot = environment.lookup(operation.fragment);
                        observerNext(snapshot);
                    }
                },
                error: function error(_error) {
                    var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _error, networkSubscription);
                    if (cacheEntry.processedPayloadsCount === 0) {
                        cacheEntry.setValue(_error);
                    } else {
                        ("TURBOPACK compile-time truthy", 1) ? warning(false, 'QueryResource: An incremental payload for query `%s` returned an error: `%s`.', operation.fragment.node.name, String(_error.message)) : "TURBOPACK unreachable";
                    }
                    resolveNetworkPromise();
                    networkSubscription = null;
                    cacheEntry.setNetworkSubscription(null);
                    var observerError = observer === null || observer === void 0 ? void 0 : observer.error;
                    observerError && observerError(_error);
                },
                complete: function complete() {
                    resolveNetworkPromise();
                    networkSubscription = null;
                    var cacheEntry = _this2._cache.get(cacheIdentifier);
                    if (cacheEntry) {
                        cacheEntry.setNetworkSubscription(null);
                    }
                    var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;
                    observerComplete && observerComplete();
                },
                unsubscribe: observer === null || observer === void 0 ? void 0 : observer.unsubscribe
            });
            var _cacheEntry2 = this._cache.get(cacheIdentifier);
            if (!_cacheEntry2) {
                var networkPromise = new Promise(function(resolve) {
                    resolveNetworkPromise = resolve;
                });
                networkPromise.displayName = 'Relay(' + operation.fragment.node.name + ')';
                _cacheEntry2 = createCacheEntry(cacheIdentifier, operation, queryAvailability, networkPromise, networkSubscription, this._clearCacheEntry);
                this._cache.set(cacheIdentifier, _cacheEntry2);
            }
        } else {
            var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;
            observerComplete && observerComplete();
        }
        var cacheEntry = this._cache.get(cacheIdentifier);
        !(cacheEntry != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to have cached a result when attempting to fetch query.' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable" : void 0;
        environment.__log({
            name: 'queryresource.fetch',
            resourceID: cacheEntry.id,
            operation: operation,
            profilerContext: profilerContext,
            fetchPolicy: fetchPolicy,
            renderPolicy: renderPolicy,
            queryAvailability: queryAvailability,
            shouldFetch: shouldFetch
        });
        return cacheEntry;
    };
    return QueryResourceImpl;
}();
function createQueryResource(environment) {
    return new QueryResourceImpl(environment);
}
var dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();
function getQueryResourceForEnvironment(environment) {
    var cached = dataResources.get(environment);
    if (cached) {
        return cached;
    }
    var newDataResource = createQueryResource(environment);
    dataResources.set(environment, newDataResource);
    return newDataResource;
}
module.exports = {
    createQueryResource: createQueryResource,
    getQueryResourceForEnvironment: getQueryResourceForEnvironment,
    getQueryCacheIdentifier: getQueryCacheIdentifier
};
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useUnsafeRef_DEPRECATED.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useMemo = _require.useMemo;
function useUnsafeRef_DEPRECATED(init) {
    return useMemo(function() {
        return {
            current: init
        };
    }, []);
}
module.exports = useUnsafeRef_DEPRECATED;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useFetchTrackingRef.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useUnsafeRef_DEPRECATED = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useUnsafeRef_DEPRECATED.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useCallback = _require.useCallback, useEffect = _require.useEffect;
function useFetchTrackingRef() {
    var subscriptionRef = useUnsafeRef_DEPRECATED(null);
    var isFetchingRef = useUnsafeRef_DEPRECATED(false);
    var disposeFetch = useCallback(function() {
        if (subscriptionRef.current != null) {
            subscriptionRef.current.unsubscribe();
            subscriptionRef.current = null;
        }
        isFetchingRef.current = false;
    }, []);
    var startFetch = useCallback(function(subscription) {
        subscriptionRef.current = subscription;
        isFetchingRef.current = true;
    }, []);
    var completeFetch = useCallback(function() {
        subscriptionRef.current = null;
        isFetchingRef.current = false;
    }, []);
    useEffect(function() {
        return disposeFetch;
    }, [
        disposeFetch
    ]);
    return {
        isFetchingRef: isFetchingRef,
        startFetch: startFetch,
        disposeFetch: disposeFetch,
        completeFetch: completeFetch
    };
}
module.exports = useFetchTrackingRef;
}),
"[project]/node_modules/react-relay/lib/ReactRelayLoggingContext.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), createRelayLoggingContext = _require.__internal.createRelayLoggingContext;
module.exports = createRelayLoggingContext(React);
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useRelayLoggingContext.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ReactRelayLoggingContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayLoggingContext.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useContext = _require.useContext;
function useRelayLoggingContext() {
    return useContext(ReactRelayLoggingContext);
}
module.exports = useRelayLoggingContext;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal_CURRENT.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/QueryResource.js [app-rsc] (ecmascript)"), getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var useRelayLoggingContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayLoggingContext.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useDebugValue = _require2.useDebugValue, useEffect = _require2.useEffect, useMemo = _require2.useMemo, useRef = _require2.useRef, useState = _require2.useState;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), _require3$__internal = _require3.__internal, fetchQueryInternal = _require3$__internal.fetchQuery, getPromiseForActiveRequest = _require3$__internal.getPromiseForActiveRequest, RelayFeatureFlags = _require3.RelayFeatureFlags, areEqualSelectors = _require3.areEqualSelectors, createOperationDescriptor = _require3.createOperationDescriptor, getPendingOperationsForFragment = _require3.getPendingOperationsForFragment, getSelector = _require3.getSelector, getVariablesFromFragment = _require3.getVariablesFromFragment, handlePotentialSnapshotErrors = _require3.handlePotentialSnapshotErrors, recycleNodesInto = _require3.recycleNodesInto;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function isMissingData(state) {
    if (state.kind === 'bailout') {
        return false;
    } else if (state.kind === 'singular') {
        return state.snapshot.isMissingData;
    } else {
        return state.snapshots.some(function(s) {
            return s.isMissingData;
        });
    }
}
function getMissingClientEdges(state) {
    if (state.kind === 'bailout') {
        return null;
    } else if (state.kind === 'singular') {
        var _state$snapshot$missi;
        return (_state$snapshot$missi = state.snapshot.missingClientEdges) !== null && _state$snapshot$missi !== void 0 ? _state$snapshot$missi : null;
    } else {
        var edges = null;
        var _iterator = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var snapshot = _step.value;
                if (snapshot.missingClientEdges) {
                    var _edges;
                    edges = (_edges = edges) !== null && _edges !== void 0 ? _edges : [];
                    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(snapshot.missingClientEdges), _step2;
                    try {
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                            var edge = _step2.value;
                            edges.push(edge);
                        }
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        return edges;
    }
}
function getSuspendingLiveResolver(state) {
    if (state.kind === 'bailout') {
        return null;
    } else if (state.kind === 'singular') {
        var _state$snapshot$missi2;
        return (_state$snapshot$missi2 = state.snapshot.missingLiveResolverFields) !== null && _state$snapshot$missi2 !== void 0 ? _state$snapshot$missi2 : null;
    } else {
        var missingFields = null;
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var snapshot = _step3.value;
                if (snapshot.missingLiveResolverFields) {
                    var _missingFields;
                    missingFields = (_missingFields = missingFields) !== null && _missingFields !== void 0 ? _missingFields : [];
                    var _iterator4 = (0, _createForOfIteratorHelper2["default"])(snapshot.missingLiveResolverFields), _step4;
                    try {
                        for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                            var edge = _step4.value;
                            missingFields.push(edge);
                        }
                    } catch (err) {
                        _iterator4.e(err);
                    } finally{
                        _iterator4.f();
                    }
                }
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
        return missingFields;
    }
}
function handlePotentialSnapshotErrorsForState(environment, state, loggingContext) {
    if (state.kind === 'singular') {
        handlePotentialSnapshotErrors(environment, state.snapshot.fieldErrors, loggingContext);
    } else if (state.kind === 'plural') {
        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step5;
        try {
            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                var snapshot = _step5.value;
                handlePotentialSnapshotErrors(environment, snapshot.fieldErrors, loggingContext);
            }
        } catch (err) {
            _iterator5.e(err);
        } finally{
            _iterator5.f();
        }
    }
}
function handleMissedUpdates(environment, state) {
    if (state.kind === 'bailout') {
        return null;
    }
    var currentEpoch = environment.getStore().getEpoch();
    if (currentEpoch === state.epoch) {
        return null;
    }
    if (state.kind === 'singular') {
        var currentSnapshot = environment.lookup(state.snapshot.selector);
        var updatedData = recycleNodesInto(state.snapshot.data, currentSnapshot.data);
        var updatedCurrentSnapshot = {
            data: updatedData,
            isMissingData: currentSnapshot.isMissingData,
            missingClientEdges: currentSnapshot.missingClientEdges,
            missingLiveResolverFields: currentSnapshot.missingLiveResolverFields,
            seenRecords: currentSnapshot.seenRecords,
            selector: currentSnapshot.selector,
            fieldErrors: currentSnapshot.fieldErrors
        };
        return [
            updatedData !== state.snapshot.data,
            {
                kind: 'singular',
                snapshot: updatedCurrentSnapshot,
                epoch: currentEpoch
            }
        ];
    } else {
        var didMissUpdates = false;
        var currentSnapshots = [];
        for(var index = 0; index < state.snapshots.length; index++){
            var snapshot = state.snapshots[index];
            var _currentSnapshot = environment.lookup(snapshot.selector);
            var _updatedData = recycleNodesInto(snapshot.data, _currentSnapshot.data);
            var _updatedCurrentSnapshot = {
                data: _updatedData,
                isMissingData: _currentSnapshot.isMissingData,
                missingClientEdges: _currentSnapshot.missingClientEdges,
                missingLiveResolverFields: _currentSnapshot.missingLiveResolverFields,
                seenRecords: _currentSnapshot.seenRecords,
                selector: _currentSnapshot.selector,
                fieldErrors: _currentSnapshot.fieldErrors
            };
            if (_updatedData !== snapshot.data) {
                didMissUpdates = true;
            }
            currentSnapshots.push(_updatedCurrentSnapshot);
        }
        !(currentSnapshots.length === state.snapshots.length) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected same number of snapshots') : "TURBOPACK unreachable" : void 0;
        return [
            didMissUpdates,
            {
                kind: 'plural',
                snapshots: currentSnapshots,
                epoch: currentEpoch
            }
        ];
    }
}
function handleMissingClientEdge(environment, parentFragmentNode, parentFragmentRef, missingClientEdgeRequestInfo, queryOptions) {
    var originalVariables = getVariablesFromFragment(parentFragmentNode, parentFragmentRef);
    var variables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, originalVariables), {}, {
        id: missingClientEdgeRequestInfo.clientEdgeDestinationID
    });
    var queryOperationDescriptor = createOperationDescriptor(missingClientEdgeRequestInfo.request, variables, queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.networkCacheConfig);
    var QueryResource = getQueryResourceForEnvironment(environment);
    var queryResult = QueryResource.prepare(queryOperationDescriptor, fetchQueryInternal(environment, queryOperationDescriptor), queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.fetchPolicy);
    return [
        queryResult,
        getPromiseForActiveRequest(environment, queryOperationDescriptor.request)
    ];
}
function subscribeToSnapshot(environment, state, setState, hasPendingStateChanges) {
    if (state.kind === 'bailout') {
        return function() {};
    } else if (state.kind === 'singular') {
        var disposable = environment.subscribe(state.snapshot, function(latestSnapshot) {
            setState(function(prevState) {
                if (prevState.kind !== 'singular' || prevState.snapshot.selector !== latestSnapshot.selector) {
                    var updates = handleMissedUpdates(environment, prevState);
                    if (updates != null) {
                        var dataChanged = updates[0], nextState = updates[1];
                        environment.__log({
                            name: 'useFragment.subscription.missedUpdates',
                            hasDataChanges: dataChanged
                        });
                        hasPendingStateChanges.current = dataChanged;
                        return dataChanged ? nextState : prevState;
                    } else {
                        return prevState;
                    }
                }
                hasPendingStateChanges.current = true;
                return {
                    kind: 'singular',
                    snapshot: latestSnapshot,
                    epoch: environment.getStore().getEpoch()
                };
            });
        });
        return function() {
            disposable.dispose();
        };
    } else {
        var disposables = state.snapshots.map(function(snapshot, index) {
            return environment.subscribe(snapshot, function(latestSnapshot) {
                setState(function(prevState) {
                    var _prevState$snapshots$;
                    if (prevState.kind !== 'plural' || ((_prevState$snapshots$ = prevState.snapshots[index]) === null || _prevState$snapshots$ === void 0 ? void 0 : _prevState$snapshots$.selector) !== latestSnapshot.selector) {
                        var updates = handleMissedUpdates(environment, prevState);
                        if (updates != null) {
                            var dataChanged = updates[0], nextState = updates[1];
                            environment.__log({
                                name: 'useFragment.subscription.missedUpdates',
                                hasDataChanges: dataChanged
                            });
                            hasPendingStateChanges.current = hasPendingStateChanges.current || dataChanged;
                            return dataChanged ? nextState : prevState;
                        } else {
                            return prevState;
                        }
                    }
                    var updated = (0, _toConsumableArray2["default"])(prevState.snapshots);
                    updated[index] = latestSnapshot;
                    hasPendingStateChanges.current = true;
                    return {
                        kind: 'plural',
                        snapshots: updated,
                        epoch: environment.getStore().getEpoch()
                    };
                });
            });
        });
        return function() {
            var _iterator6 = (0, _createForOfIteratorHelper2["default"])(disposables), _step6;
            try {
                for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){
                    var d = _step6.value;
                    d.dispose();
                }
            } catch (err) {
                _iterator6.e(err);
            } finally{
                _iterator6.f();
            }
        };
    }
}
function getFragmentState(environment, fragmentSelector) {
    if (fragmentSelector == null) {
        return {
            kind: 'bailout'
        };
    } else if (fragmentSelector.kind === 'PluralReaderSelector') {
        return {
            kind: 'plural',
            snapshots: fragmentSelector.selectors.map(function(s) {
                return environment.lookup(s);
            }),
            epoch: environment.getStore().getEpoch()
        };
    } else {
        return {
            kind: 'singular',
            snapshot: environment.lookup(fragmentSelector),
            epoch: environment.getStore().getEpoch()
        };
    }
}
function useFragmentInternal(fragmentNode, fragmentRef, hookDisplayName, queryOptions) {
    var _fragmentNode$metadat, _fragmentNode$metadat2;
    var fragmentSelector = useMemo(function() {
        return getSelector(fragmentNode, fragmentRef);
    }, [
        fragmentNode,
        fragmentRef
    ]);
    var isPlural = (fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true;
    if (isPlural) {
        !(fragmentRef == null || Array.isArray(fragmentRef)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    } else {
        !!Array.isArray(fragmentRef) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` not to be ' + 'an array, instead got `%s`. Add `@relay(plural: true)` ' + 'to fragment `%s` to allow the prop to be an array.', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    }
    !(fragmentRef == null || isPlural && Array.isArray(fragmentRef) && fragmentRef.length === 0 || fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\n' + "- Forgetting to spread `%s` in `%s`'s parent's fragment.\n" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'This issue can generally be fixed by adding `@alias` after `...%s`.\n' + 'See https://relay.dev/docs/next/guides/alias-directive/', fragmentNode.name, fragmentNode.name, hookDisplayName, fragmentNode.name, hookDisplayName, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    var environment = useRelayEnvironment();
    var loggerContext;
    if (RelayFeatureFlags.ENABLE_UI_CONTEXT_ON_RELAY_LOGGER) {
        loggerContext = useRelayLoggingContext();
    }
    var _useState = useState(function() {
        return getFragmentState(environment, fragmentSelector);
    }), _state = _useState[0], setState = _useState[1];
    var state = _state;
    var _useState2 = useState(state), _subscribedState = _useState2[0], setSubscribedState = _useState2[1];
    var subscribedState = _subscribedState;
    var _useState3 = useState(fragmentSelector), previousFragmentSelector = _useState3[0], setPreviousFragmentSelector = _useState3[1];
    var _useState4 = useState(environment), previousEnvironment = _useState4[0], setPreviousEnvironment = _useState4[1];
    if (!areEqualSelectors(fragmentSelector, previousFragmentSelector) || environment !== previousEnvironment) {
        setPreviousFragmentSelector(fragmentSelector);
        setPreviousEnvironment(environment);
        var newState = getFragmentState(environment, fragmentSelector);
        setState(newState);
        setSubscribedState(newState);
        state = newState;
        subscribedState = newState;
    }
    var committedFragmentSelectorRef = useRef(false);
    useEffect(function() {
        committedFragmentSelectorRef.current = fragmentSelector;
    }, [
        fragmentSelector
    ]);
    if (((_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.hasClientEdges) === true || RelayFeatureFlags.CHECK_ALL_FRAGMENTS_FOR_MISSING_CLIENT_EDGES) {
        var _useMemo = useMemo(function() {
            var missingClientEdges = getMissingClientEdges(state);
            var clientEdgeQueries;
            var activeRequestPromises = [];
            if (missingClientEdges !== null && missingClientEdges !== void 0 && missingClientEdges.length) {
                clientEdgeQueries = [];
                var _iterator7 = (0, _createForOfIteratorHelper2["default"])(missingClientEdges), _step7;
                try {
                    for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){
                        var edge = _step7.value;
                        var _handleMissingClientE = handleMissingClientEdge(environment, fragmentNode, fragmentRef, edge, queryOptions), queryResult = _handleMissingClientE[0], requestPromise = _handleMissingClientE[1];
                        clientEdgeQueries.push(queryResult);
                        if (requestPromise != null) {
                            activeRequestPromises.push(requestPromise);
                        }
                    }
                } catch (err) {
                    _iterator7.e(err);
                } finally{
                    _iterator7.f();
                }
            }
            return [
                clientEdgeQueries,
                activeRequestPromises
            ];
        }, [
            state,
            environment,
            fragmentNode,
            fragmentRef,
            queryOptions
        ]), clientEdgeQueries = _useMemo[0], activeRequestPromises = _useMemo[1];
        if (activeRequestPromises.length) {
            throw Promise.all(activeRequestPromises);
        }
        useEffect(function() {
            var QueryResource = getQueryResourceForEnvironment(environment);
            if (clientEdgeQueries !== null && clientEdgeQueries !== void 0 && clientEdgeQueries.length) {
                var disposables = [];
                var _iterator8 = (0, _createForOfIteratorHelper2["default"])(clientEdgeQueries), _step8;
                try {
                    for(_iterator8.s(); !(_step8 = _iterator8.n()).done;){
                        var query = _step8.value;
                        disposables.push(QueryResource.retain(query));
                    }
                } catch (err) {
                    _iterator8.e(err);
                } finally{
                    _iterator8.f();
                }
                return function() {
                    for(var _i = 0, _disposables = disposables; _i < _disposables.length; _i++){
                        var disposable = _disposables[_i];
                        disposable.dispose();
                    }
                };
            }
        }, [
            environment,
            clientEdgeQueries
        ]);
    }
    if (isMissingData(state)) {
        var suspendingLiveResolvers = getSuspendingLiveResolver(state);
        if (suspendingLiveResolvers != null && suspendingLiveResolvers.length > 0) {
            throw Promise.all(suspendingLiveResolvers.map(function(liveStateID) {
                return environment.getStore().getLiveResolverPromise(liveStateID);
            }));
        }
        if (RelayFeatureFlags.ENABLE_RELAY_OPERATION_TRACKER_SUSPENSE || environment !== previousEnvironment || !committedFragmentSelectorRef.current || !areEqualSelectors(committedFragmentSelectorRef.current, fragmentSelector)) {
            !(fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'refinement, see invariants above') : "TURBOPACK unreachable" : void 0;
            var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;
            var pendingOperationsResult = getPendingOperationsForFragment(environment, fragmentNode, fragmentOwner);
            if (pendingOperationsResult) {
                throw pendingOperationsResult.promise;
            }
        }
    }
    handlePotentialSnapshotErrorsForState(environment, state, loggerContext);
    var hasPendingStateChanges = useRef(false);
    useEffect(function() {
        var currentState = subscribedState;
        var updates = handleMissedUpdates(environment, subscribedState);
        if (updates !== null) {
            var didMissUpdates = updates[0], updatedState = updates[1];
            if (didMissUpdates) {
                setState(updatedState);
            }
            currentState = updatedState;
        }
        return subscribeToSnapshot(environment, currentState, setState, hasPendingStateChanges);
    }, [
        environment,
        subscribedState
    ]);
    if (hasPendingStateChanges.current) {
        var updates = handleMissedUpdates(environment, state);
        if (updates != null) {
            var hasStateUpdates = updates[0], updatedState = updates[1];
            if (hasStateUpdates) {
                setState(updatedState);
                state = updatedState;
            }
        }
        hasPendingStateChanges.current = false;
    }
    var data;
    if (isPlural) {
        var fragmentRefIsNullish = fragmentRef == null;
        data = useMemo(function() {
            if (state.kind === 'bailout') {
                return fragmentRefIsNullish ? null : [];
            } else {
                !(state.kind === 'plural') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected state to be plural because fragment is plural') : "TURBOPACK unreachable" : void 0;
                return state.snapshots.map(function(s) {
                    return s.data;
                });
            }
        }, [
            state,
            fragmentRefIsNullish
        ]);
    } else if (state.kind === 'bailout') {
        data = null;
    } else {
        !(state.kind === 'singular') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected state to be singular because fragment is singular') : "TURBOPACK unreachable" : void 0;
        data = state.snapshot.data;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (fragmentRef != null && (data === undefined || Array.isArray(data) && data.length > 0 && data.every(function(d) {
            return d === undefined;
        }))) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected to have been able to read non-null data for ' + 'fragment `%s` declared in ' + '`%s`, since fragment reference was non-null. ' + "Make sure that that `%s`'s parent isn't " + 'holding on to and/or passing a fragment reference for data that ' + 'has been deleted.', fragmentNode.name, hookDisplayName, hookDisplayName) : "TURBOPACK unreachable";
        }
    }
    if ("TURBOPACK compile-time truthy", 1) {
        useDebugValue({
            fragment: fragmentNode.name,
            data: data
        });
    }
    return data;
}
module.exports = useFragmentInternal;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal_EXPERIMENTAL.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var _toConsumableArray2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/toConsumableArray.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/QueryResource.js [app-rsc] (ecmascript)"), getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var useRelayLoggingContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayLoggingContext.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useDebugValue = _require2.useDebugValue, useEffect = _require2.useEffect, useMemo = _require2.useMemo, useRef = _require2.useRef, useState = _require2.useState;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), _require3$__internal = _require3.__internal, fetchQueryInternal = _require3$__internal.fetchQuery, getPromiseForActiveRequest = _require3$__internal.getPromiseForActiveRequest, RelayFeatureFlags = _require3.RelayFeatureFlags, areEqualSelectors = _require3.areEqualSelectors, createOperationDescriptor = _require3.createOperationDescriptor, getPendingOperationsForFragment = _require3.getPendingOperationsForFragment, getSelector = _require3.getSelector, getVariablesFromFragment = _require3.getVariablesFromFragment, handlePotentialSnapshotErrors = _require3.handlePotentialSnapshotErrors, recycleNodesInto = _require3.recycleNodesInto;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function isMissingData(state) {
    if (state.kind === 'bailout') {
        return false;
    } else if (state.kind === 'singular') {
        return state.snapshot.isMissingData;
    } else {
        return state.snapshots.some(function(s) {
            return s.isMissingData;
        });
    }
}
function getMissingClientEdges(state) {
    if (state.kind === 'bailout') {
        return null;
    } else if (state.kind === 'singular') {
        var _state$snapshot$missi;
        return (_state$snapshot$missi = state.snapshot.missingClientEdges) !== null && _state$snapshot$missi !== void 0 ? _state$snapshot$missi : null;
    } else {
        var edges = null;
        var _iterator = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var snapshot = _step.value;
                if (snapshot.missingClientEdges) {
                    var _edges;
                    edges = (_edges = edges) !== null && _edges !== void 0 ? _edges : [];
                    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(snapshot.missingClientEdges), _step2;
                    try {
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                            var edge = _step2.value;
                            edges.push(edge);
                        }
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        return edges;
    }
}
function getSuspendingLiveResolver(state) {
    if (state.kind === 'bailout') {
        return null;
    } else if (state.kind === 'singular') {
        var _state$snapshot$missi2;
        return (_state$snapshot$missi2 = state.snapshot.missingLiveResolverFields) !== null && _state$snapshot$missi2 !== void 0 ? _state$snapshot$missi2 : null;
    } else {
        var missingFields = null;
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var snapshot = _step3.value;
                if (snapshot.missingLiveResolverFields) {
                    var _missingFields;
                    missingFields = (_missingFields = missingFields) !== null && _missingFields !== void 0 ? _missingFields : [];
                    var _iterator4 = (0, _createForOfIteratorHelper2["default"])(snapshot.missingLiveResolverFields), _step4;
                    try {
                        for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                            var edge = _step4.value;
                            missingFields.push(edge);
                        }
                    } catch (err) {
                        _iterator4.e(err);
                    } finally{
                        _iterator4.f();
                    }
                }
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
        return missingFields;
    }
}
function handlePotentialSnapshotErrorsForState(environment, state, loggingContext) {
    if (state.kind === 'singular') {
        handlePotentialSnapshotErrors(environment, state.snapshot.fieldErrors, loggingContext);
    } else if (state.kind === 'plural') {
        var _iterator5 = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step5;
        try {
            for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){
                var snapshot = _step5.value;
                handlePotentialSnapshotErrors(environment, snapshot.fieldErrors, loggingContext);
            }
        } catch (err) {
            _iterator5.e(err);
        } finally{
            _iterator5.f();
        }
    }
}
function handleMissedUpdates(environment, state) {
    if (state.kind === 'bailout') {
        return null;
    }
    var currentEpoch = environment.getStore().getEpoch();
    if (currentEpoch === state.epoch) {
        return null;
    }
    if (state.kind === 'singular') {
        var currentSnapshot = environment.lookup(state.snapshot.selector);
        var updatedData = recycleNodesInto(state.snapshot.data, currentSnapshot.data);
        var updatedCurrentSnapshot = {
            data: updatedData,
            isMissingData: currentSnapshot.isMissingData,
            missingClientEdges: currentSnapshot.missingClientEdges,
            missingLiveResolverFields: currentSnapshot.missingLiveResolverFields,
            seenRecords: currentSnapshot.seenRecords,
            selector: currentSnapshot.selector,
            fieldErrors: currentSnapshot.fieldErrors
        };
        return [
            updatedData !== state.snapshot.data,
            {
                kind: 'singular',
                snapshot: updatedCurrentSnapshot,
                epoch: currentEpoch,
                selector: state.selector,
                environment: state.environment
            }
        ];
    } else {
        var didMissUpdates = false;
        var currentSnapshots = [];
        for(var index = 0; index < state.snapshots.length; index++){
            var snapshot = state.snapshots[index];
            var _currentSnapshot = environment.lookup(snapshot.selector);
            var _updatedData = recycleNodesInto(snapshot.data, _currentSnapshot.data);
            var _updatedCurrentSnapshot = {
                data: _updatedData,
                isMissingData: _currentSnapshot.isMissingData,
                missingClientEdges: _currentSnapshot.missingClientEdges,
                missingLiveResolverFields: _currentSnapshot.missingLiveResolverFields,
                seenRecords: _currentSnapshot.seenRecords,
                selector: _currentSnapshot.selector,
                fieldErrors: _currentSnapshot.fieldErrors
            };
            if (_updatedData !== snapshot.data) {
                didMissUpdates = true;
            }
            currentSnapshots.push(_updatedCurrentSnapshot);
        }
        !(currentSnapshots.length === state.snapshots.length) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected same number of snapshots') : "TURBOPACK unreachable" : void 0;
        return [
            didMissUpdates,
            {
                kind: 'plural',
                snapshots: currentSnapshots,
                epoch: currentEpoch,
                selector: state.selector,
                environment: state.environment
            }
        ];
    }
}
function handleMissingClientEdge(environment, parentFragmentNode, parentFragmentRef, missingClientEdgeRequestInfo, queryOptions) {
    var originalVariables = getVariablesFromFragment(parentFragmentNode, parentFragmentRef);
    var variables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, originalVariables), {}, {
        id: missingClientEdgeRequestInfo.clientEdgeDestinationID
    });
    var queryOperationDescriptor = createOperationDescriptor(missingClientEdgeRequestInfo.request, variables, queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.networkCacheConfig);
    var QueryResource = getQueryResourceForEnvironment(environment);
    var queryResult = QueryResource.prepare(queryOperationDescriptor, fetchQueryInternal(environment, queryOperationDescriptor), queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.fetchPolicy);
    var promise = getPromiseForActiveRequest(environment, queryOperationDescriptor.request);
    if (promise != null && promise.displayName == null) {
        promise.displayName = missingClientEdgeRequestInfo.request.params.name;
    }
    return [
        queryResult,
        promise
    ];
}
function subscribeToSnapshot(environment, state, setState) {
    if (state.kind === 'bailout') {
        return function() {};
    } else if (state.kind === 'singular') {
        var disposable = environment.subscribe(state.snapshot, function(latestSnapshot) {
            setState(function(prevState) {
                var nextState = null;
                if (prevState.kind !== 'singular' || prevState.snapshot.selector !== latestSnapshot.selector || prevState.environment !== environment) {
                    var updates = handleMissedUpdates(prevState.environment, prevState);
                    if (updates != null) {
                        var dataChanged = updates[0], updatedState = updates[1];
                        environment.__log({
                            name: 'useFragment.subscription.missedUpdates',
                            hasDataChanges: dataChanged
                        });
                        nextState = dataChanged ? updatedState : prevState;
                    } else {
                        nextState = prevState;
                    }
                } else {
                    nextState = {
                        kind: 'singular',
                        snapshot: latestSnapshot,
                        epoch: environment.getStore().getEpoch(),
                        selector: state.selector,
                        environment: state.environment
                    };
                }
                return nextState;
            });
        });
        return function() {
            disposable.dispose();
        };
    } else {
        var disposables = state.snapshots.map(function(snapshot, index) {
            return environment.subscribe(snapshot, function(latestSnapshot) {
                setState(function(prevState) {
                    var _prevState$snapshots$;
                    var nextState = null;
                    if (prevState.kind !== 'plural' || ((_prevState$snapshots$ = prevState.snapshots[index]) === null || _prevState$snapshots$ === void 0 ? void 0 : _prevState$snapshots$.selector) !== latestSnapshot.selector || prevState.environment !== environment) {
                        var updates = handleMissedUpdates(prevState.environment, prevState);
                        if (updates != null) {
                            var dataChanged = updates[0], updatedState = updates[1];
                            environment.__log({
                                name: 'useFragment.subscription.missedUpdates',
                                hasDataChanges: dataChanged
                            });
                            nextState = dataChanged ? updatedState : prevState;
                        } else {
                            nextState = prevState;
                        }
                    } else {
                        var updated = (0, _toConsumableArray2["default"])(prevState.snapshots);
                        updated[index] = latestSnapshot;
                        nextState = {
                            kind: 'plural',
                            snapshots: updated,
                            epoch: environment.getStore().getEpoch(),
                            selector: state.selector,
                            environment: state.environment
                        };
                    }
                    return nextState;
                });
            });
        });
        return function() {
            var _iterator6 = (0, _createForOfIteratorHelper2["default"])(disposables), _step6;
            try {
                for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){
                    var d = _step6.value;
                    d.dispose();
                }
            } catch (err) {
                _iterator6.e(err);
            } finally{
                _iterator6.f();
            }
        };
    }
}
function getFragmentState(environment, fragmentSelector) {
    if (fragmentSelector == null) {
        return {
            kind: 'bailout',
            environment: environment
        };
    } else if (fragmentSelector.kind === 'PluralReaderSelector') {
        return {
            kind: 'plural',
            snapshots: fragmentSelector.selectors.map(function(s) {
                return environment.lookup(s);
            }),
            epoch: environment.getStore().getEpoch(),
            selector: fragmentSelector,
            environment: environment
        };
    } else {
        return {
            kind: 'singular',
            snapshot: environment.lookup(fragmentSelector),
            epoch: environment.getStore().getEpoch(),
            selector: fragmentSelector,
            environment: environment
        };
    }
}
function useFragmentInternal_EXPERIMENTAL(fragmentNode, fragmentRef, hookDisplayName, queryOptions) {
    var _fragmentNode$metadat, _fragmentNode$metadat2;
    var fragmentSelector = useMemo(function() {
        return getSelector(fragmentNode, fragmentRef);
    }, [
        fragmentNode,
        fragmentRef
    ]);
    var isPlural = (fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true;
    if (isPlural) {
        !(fragmentRef == null || Array.isArray(fragmentRef)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    } else {
        !!Array.isArray(fragmentRef) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` not to be ' + 'an array, instead got `%s`. Add `@relay(plural: true)` ' + 'to fragment `%s` to allow the prop to be an array.', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    }
    !(fragmentRef == null || isPlural && Array.isArray(fragmentRef) && fragmentRef.length === 0 || fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\n' + "- Forgetting to spread `%s` in `%s`'s parent's fragment.\n" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread - then the fragment reference will not exist. ' + 'This issue can generally be fixed by adding `@alias` after `...%s`.\n' + 'See https://relay.dev/docs/next/guides/alias-directive/', fragmentNode.name, fragmentNode.name, hookDisplayName, fragmentNode.name, hookDisplayName) : "TURBOPACK unreachable" : void 0;
    var environment = useRelayEnvironment();
    var loggerContext;
    if (RelayFeatureFlags.ENABLE_UI_CONTEXT_ON_RELAY_LOGGER) {
        loggerContext = useRelayLoggingContext();
    }
    var _useState = useState(function() {
        return getFragmentState(environment, fragmentSelector);
    }), _state = _useState[0], setState = _useState[1];
    var state = _state;
    var previousEnvironment = state.environment;
    if (!areEqualSelectors(fragmentSelector, state.selector) || environment !== state.environment) {
        var newState = getFragmentState(environment, fragmentSelector);
        setState(newState);
        state = newState;
    }
    var committedFragmentSelectorRef = useRef(false);
    useEffect(function() {
        committedFragmentSelectorRef.current = fragmentSelector;
    }, [
        fragmentSelector
    ]);
    if (((_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.hasClientEdges) === true || RelayFeatureFlags.CHECK_ALL_FRAGMENTS_FOR_MISSING_CLIENT_EDGES) {
        var _useMemo = useMemo(function() {
            var missingClientEdges = getMissingClientEdges(state);
            var clientEdgeQueries;
            var activeRequestPromises = [];
            if (missingClientEdges !== null && missingClientEdges !== void 0 && missingClientEdges.length) {
                clientEdgeQueries = [];
                var _iterator7 = (0, _createForOfIteratorHelper2["default"])(missingClientEdges), _step7;
                try {
                    for(_iterator7.s(); !(_step7 = _iterator7.n()).done;){
                        var edge = _step7.value;
                        var _handleMissingClientE = handleMissingClientEdge(environment, fragmentNode, fragmentRef, edge, queryOptions), queryResult = _handleMissingClientE[0], requestPromise = _handleMissingClientE[1];
                        clientEdgeQueries.push(queryResult);
                        if (requestPromise != null) {
                            activeRequestPromises.push(requestPromise);
                        }
                    }
                } catch (err) {
                    _iterator7.e(err);
                } finally{
                    _iterator7.f();
                }
            }
            return [
                clientEdgeQueries,
                activeRequestPromises
            ];
        }, [
            state,
            environment,
            fragmentNode,
            fragmentRef,
            queryOptions
        ]), clientEdgeQueries = _useMemo[0], activeRequestPromises = _useMemo[1];
        if (activeRequestPromises.length) {
            var allPromises = Promise.all(activeRequestPromises);
            allPromises.displayName = "RelayClientEdge(".concat(activeRequestPromises.map(function(promise) {
                return promise.displayName;
            }).join(','), ")");
            throw allPromises;
        }
        useEffect(function() {
            var QueryResource = getQueryResourceForEnvironment(environment);
            if (clientEdgeQueries !== null && clientEdgeQueries !== void 0 && clientEdgeQueries.length) {
                var disposables = [];
                var _iterator8 = (0, _createForOfIteratorHelper2["default"])(clientEdgeQueries), _step8;
                try {
                    for(_iterator8.s(); !(_step8 = _iterator8.n()).done;){
                        var query = _step8.value;
                        disposables.push(QueryResource.retain(query));
                    }
                } catch (err) {
                    _iterator8.e(err);
                } finally{
                    _iterator8.f();
                }
                return function() {
                    for(var _i = 0, _disposables = disposables; _i < _disposables.length; _i++){
                        var disposable = _disposables[_i];
                        disposable.dispose();
                    }
                };
            }
        }, [
            environment,
            clientEdgeQueries
        ]);
    }
    if (isMissingData(state)) {
        var suspendingLiveResolvers = getSuspendingLiveResolver(state);
        if (suspendingLiveResolvers != null && suspendingLiveResolvers.length > 0) {
            var promise = Promise.all(suspendingLiveResolvers.map(function(liveStateID) {
                return environment.getStore().getLiveResolverPromise(liveStateID);
            }));
            promise.displayName = 'RelayLiveResolver(' + fragmentNode.name + ')';
            throw promise;
        }
        if (RelayFeatureFlags.ENABLE_RELAY_OPERATION_TRACKER_SUSPENSE || environment !== previousEnvironment || !committedFragmentSelectorRef.current || !areEqualSelectors(committedFragmentSelectorRef.current, fragmentSelector)) {
            !(fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'refinement, see invariants above') : "TURBOPACK unreachable" : void 0;
            var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;
            var pendingOperationsResult = getPendingOperationsForFragment(environment, fragmentNode, fragmentOwner);
            if (pendingOperationsResult) {
                throw pendingOperationsResult.promise;
            }
        }
    }
    handlePotentialSnapshotErrorsForState(environment, state, loggerContext);
    var storeSubscriptionRef = useRef(null);
    useEffect(function() {
        var storeSubscription = storeSubscriptionRef.current;
        if (storeSubscription != null) {
            if (state.environment === storeSubscription.environment && state.selector === storeSubscription.selector) {
                return;
            } else {
                storeSubscription.dispose();
            }
        }
        if (state.kind === 'bailout') {
            return;
        }
        var stateForSubscription = state;
        var updates = handleMissedUpdates(state.environment, state);
        if (updates !== null) {
            var didMissUpdates = updates[0], updatedState = updates[1];
            if (didMissUpdates) {
                setState(updatedState);
                return;
            }
            stateForSubscription = updatedState;
        }
        var dispose = subscribeToSnapshot(state.environment, stateForSubscription, setState);
        storeSubscriptionRef.current = {
            dispose: dispose,
            selector: state.selector,
            environment: state.environment
        };
    }, [
        state
    ]);
    useEffect(function() {
        if (storeSubscriptionRef.current == null && state.kind !== 'bailout') {
            var dispose = subscribeToSnapshot(state.environment, state, setState);
            storeSubscriptionRef.current = {
                dispose: dispose,
                selector: state.selector,
                environment: state.environment
            };
        }
        return function() {
            var _storeSubscriptionRef;
            (_storeSubscriptionRef = storeSubscriptionRef.current) === null || _storeSubscriptionRef === void 0 ? void 0 : _storeSubscriptionRef.dispose();
            storeSubscriptionRef.current = null;
        };
    }, []);
    var data;
    if (isPlural) {
        var fragmentRefIsNullish = fragmentRef == null;
        data = useMemo(function() {
            if (state.kind === 'bailout') {
                return fragmentRefIsNullish ? null : [];
            } else {
                !(state.kind === 'plural') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected state to be plural because fragment is plural') : "TURBOPACK unreachable" : void 0;
                return state.snapshots.map(function(s) {
                    return s.data;
                });
            }
        }, [
            state,
            fragmentRefIsNullish
        ]);
    } else if (state.kind === 'bailout') {
        data = null;
    } else {
        !(state.kind === 'singular') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected state to be singular because fragment is singular') : "TURBOPACK unreachable" : void 0;
        data = state.snapshot.data;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (fragmentRef != null && (data === undefined || Array.isArray(data) && data.length > 0 && data.every(function(d) {
            return d === undefined;
        }))) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected to have been able to read non-null data for ' + 'fragment `%s` declared in ' + '`%s`, since fragment reference was non-null. ' + "Make sure that that `%s`'s parent isn't " + 'holding on to and/or passing a fragment reference for data that ' + 'has been deleted.', fragmentNode.name, hookDisplayName, hookDisplayName) : "TURBOPACK unreachable";
        }
    }
    if ("TURBOPACK compile-time truthy", 1) {
        useDebugValue({
            fragment: fragmentNode.name,
            data: data
        });
    }
    return data;
}
module.exports = useFragmentInternal_EXPERIMENTAL;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _useFragmentInternal_CURRENT = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal_CURRENT.js [app-rsc] (ecmascript)"));
var _useFragmentInternal_EXPERIMENTAL = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal_EXPERIMENTAL.js [app-rsc] (ecmascript)"));
var _relayRuntime = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)");
function useFragmentInternal(fragmentNode, fragmentRef, hookDisplayName, queryOptions) {
    if (_relayRuntime.RelayFeatureFlags.ENABLE_ACTIVITY_COMPATIBILITY) {
        return (0, _useFragmentInternal_EXPERIMENTAL["default"])(fragmentNode, fragmentRef, hookDisplayName, queryOptions);
    }
    return (0, _useFragmentInternal_CURRENT["default"])(fragmentNode, fragmentRef, hookDisplayName, queryOptions);
}
module.exports = useFragmentInternal;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useLazyLoadQueryNode.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ProfilerContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/ProfilerContext.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/QueryResource.js [app-rsc] (ecmascript)"), getQueryCacheIdentifier = _require.getQueryCacheIdentifier, getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;
var useFetchTrackingRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFetchTrackingRef.js [app-rsc] (ecmascript)");
var useFragmentInternal = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal.js [app-rsc] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var useContext = React.useContext, useEffect = React.useEffect, useState = React.useState, useRef = React.useRef;
function useLazyLoadQueryNode(_ref) {
    var query = _ref.query, componentDisplayName = _ref.componentDisplayName, fetchObservable = _ref.fetchObservable, fetchPolicy = _ref.fetchPolicy, fetchKey = _ref.fetchKey, renderPolicy = _ref.renderPolicy;
    var environment = useRelayEnvironment();
    var profilerContext = useContext(ProfilerContext);
    var QueryResource = getQueryResourceForEnvironment(environment);
    var _useState = useState(0), forceUpdateKey = _useState[0], forceUpdate = _useState[1];
    var _useFetchTrackingRef = useFetchTrackingRef(), startFetch = _useFetchTrackingRef.startFetch, completeFetch = _useFetchTrackingRef.completeFetch;
    var cacheBreaker = "".concat(forceUpdateKey, "-").concat(fetchKey !== null && fetchKey !== void 0 ? fetchKey : '');
    var cacheIdentifier = getQueryCacheIdentifier(environment, query, fetchPolicy, renderPolicy, cacheBreaker);
    var preparedQueryResult = profilerContext.wrapPrepareQueryResource(function() {
        return QueryResource.prepareWithIdentifier(cacheIdentifier, query, fetchObservable, fetchPolicy, renderPolicy, {
            start: startFetch,
            complete: completeFetch,
            error: completeFetch
        }, profilerContext);
    });
    var maybeHiddenOrFastRefresh = useRef(false);
    useEffect(function() {
        return function() {
            maybeHiddenOrFastRefresh.current = true;
        };
    }, []);
    useEffect(function() {
        if (maybeHiddenOrFastRefresh.current === true) {
            maybeHiddenOrFastRefresh.current = false;
            forceUpdate(function(n) {
                return n + 1;
            });
            return;
        }
        var disposable = QueryResource.retain(preparedQueryResult, profilerContext);
        return function() {
            disposable.dispose();
        };
    }, [
        environment,
        cacheIdentifier
    ]);
    useEffect(function() {
        QueryResource.releaseTemporaryRetain(preparedQueryResult);
    });
    var fragmentNode = preparedQueryResult.fragmentNode, fragmentRef = preparedQueryResult.fragmentRef;
    var data = useFragmentInternal(fragmentNode, fragmentRef, componentDisplayName);
    return data;
}
module.exports = useLazyLoadQueryNode;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useMemoVariables.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var areEqual = __turbopack_context__.r("[project]/node_modules/fbjs/lib/areEqual.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useState = _require.useState;
function useMemoVariables(variables) {
    var _useState = useState(variables), mirroredVariables = _useState[0], setMirroredVariables = _useState[1];
    if (areEqual(variables, mirroredVariables)) {
        return mirroredVariables;
    } else {
        setMirroredVariables(variables);
        return variables;
    }
}
module.exports = useMemoVariables;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useMemoOperationDescriptor.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useMemoVariables = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useMemoVariables.js [app-rsc] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), createOperationDescriptor = _require.createOperationDescriptor, getRequest = _require.getRequest;
var useMemo = React.useMemo;
function useMemoOperationDescriptor(gqlQuery, variables, cacheConfig) {
    var memoVariables = useMemoVariables(variables);
    var memoCacheConfig = useMemoVariables(cacheConfig || {});
    return useMemo(function() {
        return createOperationDescriptor(getRequest(gqlQuery), memoVariables, memoCacheConfig);
    }, [
        gqlQuery,
        memoVariables,
        memoCacheConfig
    ]);
}
module.exports = useMemoOperationDescriptor;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useLazyLoadQuery.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useLazyLoadQueryNode = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useLazyLoadQueryNode.js [app-rsc] (ecmascript)");
var useMemoOperationDescriptor = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useMemoOperationDescriptor.js [app-rsc] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), fetchQuery = _require.__internal.fetchQuery;
function useLazyLoadQuery(gqlQuery, variables, options) {
    var environment = useRelayEnvironment();
    var query = useMemoOperationDescriptor(gqlQuery, variables, options && options.networkCacheConfig ? options.networkCacheConfig : {
        force: true
    });
    var data = useLazyLoadQueryNode({
        componentDisplayName: 'useLazyLoadQuery()',
        fetchKey: options === null || options === void 0 ? void 0 : options.fetchKey,
        fetchObservable: fetchQuery(environment, query),
        fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,
        query: query,
        renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
    });
    return data;
}
module.exports = useLazyLoadQuery;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useClientQuery.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var useLazyLoadQuery = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useLazyLoadQuery.js [app-rsc] (ecmascript)");
function useClientQuery(gqlQuery, variables, options) {
    var query = gqlQuery;
    return useLazyLoadQuery(query, variables, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, options), {}, {
        fetchPolicy: 'store-only'
    }));
}
module.exports = useClientQuery;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useEffect = _require.useEffect, useRef = _require.useRef;
function useIsMountedRef() {
    var isMountedRef = useRef(true);
    useEffect(function() {
        isMountedRef.current = true;
        return function() {
            isMountedRef.current = false;
        };
    }, []);
    return isMountedRef;
}
module.exports = useIsMountedRef;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useEntryPointLoader.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var loadEntryPoint = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/loadEntryPoint.js [app-rsc] (ecmascript)");
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useCallback = _require.useCallback, useEffect = _require.useEffect, useRef = _require.useRef, useState = _require.useState;
var initialNullEntryPointReferenceState = {
    kind: 'NullEntryPointReference'
};
function useLoadEntryPoint(environmentProvider, entryPoint, options) {
    var _options$TEST_ONLY__i, _options$TEST_ONLY__i2, _options$TEST_ONLY__i3, _options$TEST_ONLY__i4;
    var initialEntryPointReferenceInternal = (_options$TEST_ONLY__i = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i2 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i2 === void 0 ? void 0 : _options$TEST_ONLY__i2.entryPointReference) !== null && _options$TEST_ONLY__i !== void 0 ? _options$TEST_ONLY__i : initialNullEntryPointReferenceState;
    var initialEntryPointParamsInternal = (_options$TEST_ONLY__i3 = options === null || options === void 0 ? void 0 : (_options$TEST_ONLY__i4 = options.TEST_ONLY__initialEntryPointData) === null || _options$TEST_ONLY__i4 === void 0 ? void 0 : _options$TEST_ONLY__i4.entryPointParams) !== null && _options$TEST_ONLY__i3 !== void 0 ? _options$TEST_ONLY__i3 : null;
    var isMountedRef = useIsMountedRef();
    var undisposedEntryPointReferencesRef = useRef(new Set([
        initialEntryPointReferenceInternal
    ]));
    var _useState = useState(initialEntryPointReferenceInternal), entryPointReference = _useState[0], setEntryPointReference = _useState[1];
    var _useState2 = useState(initialEntryPointParamsInternal), entryPointParams = _useState2[0], setEntryPointParams = _useState2[1];
    var disposeEntryPoint = useCallback(function() {
        if (isMountedRef.current) {
            var nullEntryPointReference = {
                kind: 'NullEntryPointReference'
            };
            undisposedEntryPointReferencesRef.current.add(nullEntryPointReference);
            setEntryPointReference(nullEntryPointReference);
        }
    }, [
        setEntryPointReference,
        isMountedRef
    ]);
    var entryPointLoaderCallback = useCallback(function(params) {
        if (isMountedRef.current) {
            var updatedEntryPointReference = loadEntryPoint(environmentProvider, entryPoint, params);
            undisposedEntryPointReferencesRef.current.add(updatedEntryPointReference);
            setEntryPointReference(updatedEntryPointReference);
            setEntryPointParams(params);
        }
    }, [
        environmentProvider,
        entryPoint,
        setEntryPointReference,
        isMountedRef
    ]);
    var maybeHiddenOrFastRefresh = useRef(false);
    useEffect(function() {
        return function() {
            maybeHiddenOrFastRefresh.current = true;
        };
    }, []);
    useEffect(function() {
        if (maybeHiddenOrFastRefresh.current === true) {
            maybeHiddenOrFastRefresh.current = false;
            if (entryPointReference.kind !== 'NullEntryPointReference' && entryPointParams != null) {
                entryPointLoaderCallback(entryPointParams);
            }
            return;
        }
        var undisposedEntryPointReferences = undisposedEntryPointReferencesRef.current;
        if (isMountedRef.current) {
            var _iterator = (0, _createForOfIteratorHelper2["default"])(undisposedEntryPointReferences), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var undisposedEntryPointReference = _step.value;
                    if (undisposedEntryPointReference === entryPointReference) {
                        break;
                    }
                    undisposedEntryPointReferences["delete"](undisposedEntryPointReference);
                    if (undisposedEntryPointReference.kind !== 'NullEntryPointReference') {
                        undisposedEntryPointReference.dispose();
                    }
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
        }
    }, [
        entryPointReference,
        entryPointParams,
        entryPointLoaderCallback,
        isMountedRef
    ]);
    useEffect(function() {
        return function disposeAllRemainingEntryPointReferences() {
            var _iterator2 = (0, _createForOfIteratorHelper2["default"])(undisposedEntryPointReferencesRef.current), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var unhandledStateChange = _step2.value;
                    if (unhandledStateChange.kind !== 'NullEntryPointReference') {
                        unhandledStateChange.dispose();
                    }
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
        };
    }, []);
    return [
        entryPointReference.kind === 'NullEntryPointReference' ? null : entryPointReference,
        entryPointLoaderCallback,
        disposeEntryPoint
    ];
}
module.exports = useLoadEntryPoint;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useStaticFragmentNodeWarning.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useUnsafeRef_DEPRECATED = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useUnsafeRef_DEPRECATED.js [app-rsc] (ecmascript)");
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function useStaticFragmentNodeWarning(fragmentNode, warningContext) {
    if ("TURBOPACK compile-time truthy", 1) {
        var initialPropRef = useUnsafeRef_DEPRECATED(fragmentNode.name);
        ("TURBOPACK compile-time truthy", 1) ? warning(initialPropRef.current === fragmentNode.name, 'Relay: The %s has to remain the same over the lifetime of a component. ' + 'Changing it is not supported and will result in unexpected behavior.', warningContext) : "TURBOPACK unreachable";
    }
}
module.exports = useStaticFragmentNodeWarning;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useFragment.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useFragmentInternal = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal.js [app-rsc] (ecmascript)");
var useStaticFragmentNodeWarning = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useStaticFragmentNodeWarning.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useDebugValue = _require.useDebugValue;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), getFragment = _require2.getFragment;
function useFragment(fragment, key) {
    var fragmentNode = getFragment(fragment);
    useStaticFragmentNodeWarning(fragmentNode, 'first argument of useFragment()');
    var data = useFragmentInternal(fragmentNode, key, 'useFragment()');
    if ("TURBOPACK compile-time truthy", 1) {
        useDebugValue({
            fragment: fragmentNode.name,
            data: data
        });
    }
    return data;
}
module.exports = useFragment;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useMutation.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-rsc] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), defaultCommitMutation = _require.commitMutation;
var useState = React.useState, useEffect = React.useEffect, useRef = React.useRef, useCallback = React.useCallback;
function useMutation(mutation) {
    var commitMutationFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultCommitMutation;
    var environment = useRelayEnvironment();
    var isMountedRef = useIsMountedRef();
    var environmentRef = useRef(environment);
    var mutationRef = useRef(mutation);
    var inFlightMutationsRef = useRef(new Set());
    var _useState = useState(false), isMutationInFlight = _useState[0], setMutationInFlight = _useState[1];
    var cleanup = useCallback(function(disposable) {
        if (environmentRef.current === environment && mutationRef.current === mutation) {
            inFlightMutationsRef.current["delete"](disposable);
            if (isMountedRef.current) {
                setMutationInFlight(inFlightMutationsRef.current.size > 0);
            }
        }
    }, [
        environment,
        isMountedRef,
        mutation
    ]);
    useEffect(function() {
        if (environmentRef.current !== environment || mutationRef.current !== mutation) {
            inFlightMutationsRef.current = new Set();
            if (isMountedRef.current) {
                setMutationInFlight(false);
            }
            environmentRef.current = environment;
            mutationRef.current = mutation;
        }
    }, [
        environment,
        isMountedRef,
        mutation
    ]);
    var commit = useCallback(function(config) {
        if (isMountedRef.current) {
            setMutationInFlight(true);
        }
        var disposable = commitMutationFn(environment, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, config), {}, {
            mutation: mutation,
            onCompleted: function onCompleted(response, errors) {
                var _config$onCompleted;
                cleanup(disposable);
                (_config$onCompleted = config.onCompleted) === null || _config$onCompleted === void 0 ? void 0 : _config$onCompleted.call(config, response, errors);
            },
            onError: function onError(error) {
                var _config$onError;
                cleanup(disposable);
                (_config$onError = config.onError) === null || _config$onError === void 0 ? void 0 : _config$onError.call(config, error);
            },
            onUnsubscribe: function onUnsubscribe() {
                var _config$onUnsubscribe;
                cleanup(disposable);
                (_config$onUnsubscribe = config.onUnsubscribe) === null || _config$onUnsubscribe === void 0 ? void 0 : _config$onUnsubscribe.call(config);
            },
            onNext: function onNext() {
                var _config$onNext;
                (_config$onNext = config.onNext) === null || _config$onNext === void 0 ? void 0 : _config$onNext.call(config);
            }
        }));
        inFlightMutationsRef.current.add(disposable);
        return disposable;
    }, [
        cleanup,
        commitMutationFn,
        environment,
        isMountedRef,
        mutation
    ]);
    return [
        commit,
        isMutationInFlight
    ];
}
module.exports = useMutation;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/getConnectionState.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), ConnectionInterface = _require.ConnectionInterface, getValueAtPath = _require.getValueAtPath;
function getConnectionState(direction, fragmentNode, fragmentData, connectionPathInFragmentData) {
    var _pageInfo$END_CURSOR, _pageInfo$START_CURSO;
    var _ConnectionInterface$ = ConnectionInterface.get(), EDGES = _ConnectionInterface$.EDGES, PAGE_INFO = _ConnectionInterface$.PAGE_INFO, HAS_NEXT_PAGE = _ConnectionInterface$.HAS_NEXT_PAGE, HAS_PREV_PAGE = _ConnectionInterface$.HAS_PREV_PAGE, END_CURSOR = _ConnectionInterface$.END_CURSOR, START_CURSOR = _ConnectionInterface$.START_CURSOR;
    var connection = getValueAtPath(fragmentData, connectionPathInFragmentData);
    if (connection == null) {
        return {
            cursor: null,
            hasMore: false
        };
    }
    !(typeof connection === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected connection in fragment `%s` to have been `null`, or ' + 'a plain object with %s and %s properties. Instead got `%s`.', fragmentNode.name, EDGES, PAGE_INFO, connection) : "TURBOPACK unreachable" : void 0;
    var edges = connection[EDGES];
    var pageInfo = connection[PAGE_INFO];
    if (edges == null || pageInfo == null) {
        return {
            cursor: null,
            hasMore: false
        };
    }
    !Array.isArray(edges) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected connection in fragment `%s` to have a plural `%s` field. ' + 'Instead got `%s`.', fragmentNode.name, EDGES, edges) : "TURBOPACK unreachable" : void 0;
    !(typeof pageInfo === 'object') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected connection in fragment `%s` to have a `%s` field. ' + 'Instead got `%s`.', fragmentNode.name, PAGE_INFO, pageInfo) : "TURBOPACK unreachable" : void 0;
    var cursor = direction === 'forward' ? (_pageInfo$END_CURSOR = pageInfo[END_CURSOR]) !== null && _pageInfo$END_CURSOR !== void 0 ? _pageInfo$END_CURSOR : null : (_pageInfo$START_CURSO = pageInfo[START_CURSOR]) !== null && _pageInfo$START_CURSO !== void 0 ? _pageInfo$START_CURSO : null;
    !(cursor === null || typeof cursor === 'string') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected page info for connection in fragment `%s` to have a ' + 'valid `%s`. Instead got `%s`.', fragmentNode.name, START_CURSOR, cursor) : "TURBOPACK unreachable" : void 0;
    var hasMore;
    if (direction === 'forward') {
        hasMore = cursor != null && pageInfo[HAS_NEXT_PAGE] === true;
    } else {
        hasMore = cursor != null && pageInfo[HAS_PREV_PAGE] === true;
    }
    return {
        cursor: cursor,
        hasMore: hasMore
    };
}
module.exports = getConnectionState;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useIsOperationNodeActive.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), getObservableForActiveRequest = _require.__internal.getObservableForActiveRequest, getSelector = _require.getSelector;
var useEffect = React.useEffect, useState = React.useState, useMemo = React.useMemo;
function useIsOperationNodeActive(fragmentNode, fragmentRef) {
    var environment = useRelayEnvironment();
    var observable = useMemo(function() {
        var selector = getSelector(fragmentNode, fragmentRef);
        if (selector == null) {
            return null;
        }
        !(selector.kind === 'SingularReaderSelector') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'useIsOperationNodeActive: Plural fragments are not supported.') : "TURBOPACK unreachable" : void 0;
        return getObservableForActiveRequest(environment, selector.owner);
    }, [
        environment,
        fragmentNode,
        fragmentRef
    ]);
    var _useState = useState(observable != null), isActive = _useState[0], setIsActive = _useState[1];
    useEffect(function() {
        var subscription;
        setIsActive(observable != null);
        if (observable != null) {
            var onCompleteOrError = function onCompleteOrError() {
                setIsActive(false);
            };
            subscription = observable.subscribe({
                complete: onCompleteOrError,
                error: onCompleteOrError
            });
        }
        return function() {
            if (subscription) {
                subscription.unsubscribe();
            }
        };
    }, [
        observable
    ]);
    return isActive;
}
module.exports = useIsOperationNodeActive;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useLoadMoreFunction_EXPERIMENTAL.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var getConnectionState = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/getConnectionState.js [app-rsc] (ecmascript)");
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-rsc] (ecmascript)");
var useIsOperationNodeActive = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsOperationNodeActive.js [app-rsc] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useCallback = _require.useCallback, useRef = _require.useRef, useState = _require.useState;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), fetchQuery = _require2.__internal.fetchQuery, createOperationDescriptor = _require2.createOperationDescriptor, getPaginationVariables = _require2.getPaginationVariables, getRefetchMetadata = _require2.getRefetchMetadata, getSelector = _require2.getSelector;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function useLoadMoreFunction_EXPERIMENTAL(args) {
    var direction = args.direction, fragmentNode = args.fragmentNode, fragmentRef = args.fragmentRef, fragmentIdentifier = args.fragmentIdentifier, fragmentData = args.fragmentData, connectionPathInFragmentData = args.connectionPathInFragmentData, paginationRequest = args.paginationRequest, paginationMetadata = args.paginationMetadata, componentDisplayName = args.componentDisplayName, observer = args.observer, onReset = args.onReset;
    var environment = useRelayEnvironment();
    var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName), identifierInfo = _getRefetchMetadata.identifierInfo;
    var identifierValue = (identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField) != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierInfo.identifierField] : null;
    var fetchStatusRef = useRef({
        kind: 'none'
    });
    var _useState = useState(environment), mirroredEnvironment = _useState[0], setMirroredEnvironment = _useState[1];
    var _useState2 = useState(fragmentIdentifier), mirroredFragmentIdentifier = _useState2[0], setMirroredFragmentIdentifier = _useState2[1];
    var isParentQueryActive = useIsOperationNodeActive(fragmentNode, fragmentRef);
    var forceDisposeFn = useCallback(function() {
        if (fetchStatusRef.current.kind === 'fetching') {
            fetchStatusRef.current.subscription.unsubscribe();
        }
        fetchStatusRef.current = {
            kind: 'none'
        };
    }, []);
    var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;
    if (shouldReset) {
        forceDisposeFn();
        onReset();
        setMirroredEnvironment(environment);
        setMirroredFragmentIdentifier(fragmentIdentifier);
    }
    var _getConnectionState = getConnectionState(direction, fragmentNode, fragmentData, connectionPathInFragmentData), cursor = _getConnectionState.cursor, hasMore = _getConnectionState.hasMore;
    var isRequestInvalid = fragmentData == null || isParentQueryActive;
    var isMountedRef = useIsMountedRef();
    var loadMore = useCallback(function(count, options) {
        var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;
        if (isMountedRef.current !== true) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected fetch on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable";
            return {
                dispose: function dispose() {}
            };
        }
        var fragmentSelector = getSelector(fragmentNode, fragmentRef);
        if (fetchStatusRef.current.kind === 'fetching' || isRequestInvalid) {
            if (fragmentSelector == null) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected fetch while using a null fragment ref ' + 'for fragment `%s` in `%s`. When fetching more items, we expect ' + "initial fragment data to be non-null. Please make sure you're " + 'passing a valid fragment ref to `%s` before paginating.', fragmentNode.name, componentDisplayName, componentDisplayName) : "TURBOPACK unreachable";
            }
            if (onComplete) {
                onComplete(null);
            }
            return {
                dispose: function dispose() {}
            };
        }
        !(fragmentSelector != null && fragmentSelector.kind !== 'PluralReaderSelector') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to be able to find a non-plural fragment owner for ' + "fragment `%s` when using `%s`. If you're seeing this, " + 'this is likely a bug in Relay.', fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable" : void 0;
        var parentVariables = fragmentSelector.owner.variables;
        var fragmentVariables = fragmentSelector.variables;
        var extraVariables = options === null || options === void 0 ? void 0 : options.UNSTABLE_extraVariables;
        var baseVariables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, parentVariables), fragmentVariables);
        var paginationVariables = getPaginationVariables(direction, count, cursor, baseVariables, (0, _objectSpread2["default"])({}, extraVariables), paginationMetadata);
        if (identifierInfo != null) {
            if (typeof identifierValue !== 'string') {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierInfo.identifierField, identifierValue) : "TURBOPACK unreachable";
            }
            paginationVariables[identifierInfo.identifierQueryVariableName] = identifierValue;
        }
        var paginationQuery = createOperationDescriptor(paginationRequest, paginationVariables, {
            force: true
        });
        fetchQuery(environment, paginationQuery).subscribe((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, observer), {}, {
            start: function start(subscription) {
                fetchStatusRef.current = {
                    kind: 'fetching',
                    subscription: subscription
                };
                observer.start && observer.start(subscription);
            },
            complete: function complete() {
                fetchStatusRef.current = {
                    kind: 'none'
                };
                observer.complete && observer.complete();
                onComplete && onComplete(null);
            },
            error: function error(_error) {
                fetchStatusRef.current = {
                    kind: 'none'
                };
                observer.complete && observer.complete();
                onComplete && onComplete(_error);
            }
        }));
        return {
            dispose: function dispose() {}
        };
    }, [
        environment,
        identifierValue,
        direction,
        cursor,
        isRequestInvalid,
        fragmentNode.name,
        fragmentRef,
        componentDisplayName
    ]);
    return [
        loadMore,
        hasMore,
        forceDisposeFn
    ];
}
module.exports = useLoadMoreFunction_EXPERIMENTAL;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useLoadMoreFunction.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var getConnectionState = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/getConnectionState.js [app-rsc] (ecmascript)");
var useFetchTrackingRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFetchTrackingRef.js [app-rsc] (ecmascript)");
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-rsc] (ecmascript)");
var useIsOperationNodeActive = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsOperationNodeActive.js [app-rsc] (ecmascript)");
var useLoadMoreFunction_EXPERIMENTAL = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useLoadMoreFunction_EXPERIMENTAL.js [app-rsc] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useCallback = _require.useCallback, useEffect = _require.useEffect, useState = _require.useState;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), fetchQuery = _require2.__internal.fetchQuery, RelayFeatureFlags = _require2.RelayFeatureFlags, createOperationDescriptor = _require2.createOperationDescriptor, getPaginationVariables = _require2.getPaginationVariables, getRefetchMetadata = _require2.getRefetchMetadata, getSelector = _require2.getSelector;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function useLoadMoreFunction(args) {
    if (RelayFeatureFlags.ENABLE_ACTIVITY_COMPATIBILITY) {
        return useLoadMoreFunction_EXPERIMENTAL(args);
    }
    return useLoadMoreFunction_CURRENT(args);
}
function useLoadMoreFunction_CURRENT(args) {
    var direction = args.direction, fragmentNode = args.fragmentNode, fragmentRef = args.fragmentRef, fragmentIdentifier = args.fragmentIdentifier, fragmentData = args.fragmentData, connectionPathInFragmentData = args.connectionPathInFragmentData, paginationRequest = args.paginationRequest, paginationMetadata = args.paginationMetadata, componentDisplayName = args.componentDisplayName, observer = args.observer, onReset = args.onReset;
    var environment = useRelayEnvironment();
    var _useFetchTrackingRef = useFetchTrackingRef(), isFetchingRef = _useFetchTrackingRef.isFetchingRef, startFetch = _useFetchTrackingRef.startFetch, disposeFetch = _useFetchTrackingRef.disposeFetch, completeFetch = _useFetchTrackingRef.completeFetch;
    var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName), identifierInfo = _getRefetchMetadata.identifierInfo;
    var identifierValue = (identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField) != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierInfo.identifierField] : null;
    var isMountedRef = useIsMountedRef();
    var _useState = useState(environment), mirroredEnvironment = _useState[0], setMirroredEnvironment = _useState[1];
    var _useState2 = useState(fragmentIdentifier), mirroredFragmentIdentifier = _useState2[0], setMirroredFragmentIdentifier = _useState2[1];
    var isParentQueryActive = useIsOperationNodeActive(fragmentNode, fragmentRef);
    var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;
    if (shouldReset) {
        disposeFetch();
        onReset();
        setMirroredEnvironment(environment);
        setMirroredFragmentIdentifier(fragmentIdentifier);
    }
    var _getConnectionState = getConnectionState(direction, fragmentNode, fragmentData, connectionPathInFragmentData), cursor = _getConnectionState.cursor, hasMore = _getConnectionState.hasMore;
    useEffect(function() {
        return function() {
            disposeFetch();
        };
    }, [
        disposeFetch
    ]);
    var isRequestInvalid = fragmentData == null || isParentQueryActive;
    var loadMore = useCallback(function(count, options) {
        var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;
        if (isMountedRef.current !== true) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected fetch on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable";
            return {
                dispose: function dispose() {}
            };
        }
        var fragmentSelector = getSelector(fragmentNode, fragmentRef);
        if (isFetchingRef.current === true || isRequestInvalid) {
            if (fragmentSelector == null) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected fetch while using a null fragment ref ' + 'for fragment `%s` in `%s`. When fetching more items, we expect ' + "initial fragment data to be non-null. Please make sure you're " + 'passing a valid fragment ref to `%s` before paginating.', fragmentNode.name, componentDisplayName, componentDisplayName) : "TURBOPACK unreachable";
            }
            if (onComplete) {
                onComplete(null);
            }
            return {
                dispose: function dispose() {}
            };
        }
        !(fragmentSelector != null && fragmentSelector.kind !== 'PluralReaderSelector') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to be able to find a non-plural fragment owner for ' + "fragment `%s` when using `%s`. If you're seeing this, " + 'this is likely a bug in Relay.', fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable" : void 0;
        var parentVariables = fragmentSelector.owner.variables;
        var fragmentVariables = fragmentSelector.variables;
        var extraVariables = options === null || options === void 0 ? void 0 : options.UNSTABLE_extraVariables;
        var baseVariables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, parentVariables), fragmentVariables);
        var paginationVariables = getPaginationVariables(direction, count, cursor, baseVariables, (0, _objectSpread2["default"])({}, extraVariables), paginationMetadata);
        if (identifierInfo != null) {
            if (typeof identifierValue !== 'string') {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierInfo.identifierField, identifierValue) : "TURBOPACK unreachable";
            }
            paginationVariables[identifierInfo.identifierQueryVariableName] = identifierValue;
        }
        var paginationQuery = createOperationDescriptor(paginationRequest, paginationVariables, {
            force: true
        });
        fetchQuery(environment, paginationQuery).subscribe((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, observer), {}, {
            start: function start(subscription) {
                startFetch(subscription);
                observer.start && observer.start(subscription);
            },
            complete: function complete() {
                completeFetch();
                observer.complete && observer.complete();
                onComplete && onComplete(null);
            },
            error: function error(_error) {
                completeFetch();
                observer.error && observer.error(_error);
                onComplete && onComplete(_error);
            }
        }));
        return {
            dispose: disposeFetch
        };
    }, [
        environment,
        identifierValue,
        direction,
        cursor,
        startFetch,
        disposeFetch,
        completeFetch,
        isFetchingRef,
        isRequestInvalid,
        fragmentNode.name,
        fragmentRef,
        componentDisplayName
    ]);
    return [
        loadMore,
        hasMore,
        disposeFetch
    ];
}
module.exports = useLoadMoreFunction;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/readFragmentInternal.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/QueryResource.js [app-rsc] (ecmascript)"), getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), fetchQueryInternal = _require2.__internal.fetchQuery, RelayFeatureFlags = _require2.RelayFeatureFlags, createOperationDescriptor = _require2.createOperationDescriptor, getPendingOperationsForFragment = _require2.getPendingOperationsForFragment, getSelector = _require2.getSelector, getVariablesFromFragment = _require2.getVariablesFromFragment, handlePotentialSnapshotErrors = _require2.handlePotentialSnapshotErrors;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function isMissingData(state) {
    if (state.kind === 'bailout') {
        return false;
    } else if (state.kind === 'singular') {
        return state.snapshot.isMissingData;
    } else {
        return state.snapshots.some(function(s) {
            return s.isMissingData;
        });
    }
}
function getMissingClientEdges(state) {
    if (state.kind === 'bailout') {
        return null;
    } else if (state.kind === 'singular') {
        var _state$snapshot$missi;
        return (_state$snapshot$missi = state.snapshot.missingClientEdges) !== null && _state$snapshot$missi !== void 0 ? _state$snapshot$missi : null;
    } else {
        var edges = null;
        var _iterator = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var snapshot = _step.value;
                if (snapshot.missingClientEdges) {
                    var _edges;
                    edges = (_edges = edges) !== null && _edges !== void 0 ? _edges : [];
                    var _iterator2 = (0, _createForOfIteratorHelper2["default"])(snapshot.missingClientEdges), _step2;
                    try {
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                            var edge = _step2.value;
                            edges.push(edge);
                        }
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
        return edges;
    }
}
function handlePotentialSnapshotErrorsForState(environment, state) {
    if (state.kind === 'singular') {
        handlePotentialSnapshotErrors(environment, state.snapshot.fieldErrors);
    } else if (state.kind === 'plural') {
        var _iterator3 = (0, _createForOfIteratorHelper2["default"])(state.snapshots), _step3;
        try {
            for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){
                var snapshot = _step3.value;
                handlePotentialSnapshotErrors(environment, snapshot.fieldErrors);
            }
        } catch (err) {
            _iterator3.e(err);
        } finally{
            _iterator3.f();
        }
    }
}
function handleMissingClientEdge(environment, parentFragmentNode, parentFragmentRef, missingClientEdgeRequestInfo, queryOptions) {
    var originalVariables = getVariablesFromFragment(parentFragmentNode, parentFragmentRef);
    var variables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, originalVariables), {}, {
        id: missingClientEdgeRequestInfo.clientEdgeDestinationID
    });
    var queryOperationDescriptor = createOperationDescriptor(missingClientEdgeRequestInfo.request, variables, queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.networkCacheConfig);
    var QueryResource = getQueryResourceForEnvironment(environment);
    return QueryResource.prepare(queryOperationDescriptor, fetchQueryInternal(environment, queryOperationDescriptor), queryOptions === null || queryOptions === void 0 ? void 0 : queryOptions.fetchPolicy);
}
function getFragmentState(environment, fragmentSelector) {
    if (fragmentSelector == null) {
        return {
            kind: 'bailout'
        };
    } else if (fragmentSelector.kind === 'PluralReaderSelector') {
        if (fragmentSelector.selectors.length === 0) {
            return {
                kind: 'bailout'
            };
        } else {
            return {
                kind: 'plural',
                snapshots: fragmentSelector.selectors.map(function(s) {
                    return environment.lookup(s);
                }),
                epoch: environment.getStore().getEpoch()
            };
        }
    } else {
        return {
            kind: 'singular',
            snapshot: environment.lookup(fragmentSelector),
            epoch: environment.getStore().getEpoch()
        };
    }
}
function readFragmentInternal(environment, fragmentNode, fragmentRef, hookDisplayName, queryOptions, fragmentKey) {
    var _fragmentNode$metadat, _fragmentNode$metadat2;
    var fragmentSelector = getSelector(fragmentNode, fragmentRef);
    var isPlural = (fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true;
    if (isPlural) {
        !(fragmentRef == null || Array.isArray(fragmentRef)) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? " for key `".concat(fragmentKey, "`") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    } else {
        !!Array.isArray(fragmentRef) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` not to be ' + 'an array, instead got `%s`. Add `@relay(plural: true)` ' + 'to fragment `%s` to allow the prop to be an array.', fragmentKey != null ? " for key `".concat(fragmentKey, "`") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    }
    !(fragmentRef == null || isPlural && Array.isArray(fragmentRef) && fragmentRef.length === 0 || fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\n' + "- Forgetting to spread `%s` in `%s`'s parent's fragment.\n" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'This issue can generally be fixed by adding `@alias` after `...%s`.\n' + 'See https://relay.dev/docs/next/guides/alias-directive/', fragmentNode.name, fragmentNode.name, hookDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : "the `".concat(fragmentKey, "`"), hookDisplayName, fragmentNode.name) : "TURBOPACK unreachable" : void 0;
    var state = getFragmentState(environment, fragmentSelector);
    var clientEdgeQueries = null;
    if (((_fragmentNode$metadat2 = fragmentNode.metadata) === null || _fragmentNode$metadat2 === void 0 ? void 0 : _fragmentNode$metadat2.hasClientEdges) === true || RelayFeatureFlags.CHECK_ALL_FRAGMENTS_FOR_MISSING_CLIENT_EDGES) {
        var missingClientEdges = getMissingClientEdges(state);
        if (missingClientEdges !== null && missingClientEdges !== void 0 && missingClientEdges.length) {
            clientEdgeQueries = [];
            var _iterator4 = (0, _createForOfIteratorHelper2["default"])(missingClientEdges), _step4;
            try {
                for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){
                    var edge = _step4.value;
                    clientEdgeQueries.push(handleMissingClientEdge(environment, fragmentNode, fragmentRef, edge, queryOptions));
                }
            } catch (err) {
                _iterator4.e(err);
            } finally{
                _iterator4.f();
            }
        }
    }
    if (isMissingData(state)) {
        !(fragmentSelector != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'refinement, see invariants above') : "TURBOPACK unreachable" : void 0;
        var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;
        var pendingOperationsResult = getPendingOperationsForFragment(environment, fragmentNode, fragmentOwner);
        if (pendingOperationsResult) {
            throw pendingOperationsResult.promise;
        }
        handlePotentialSnapshotErrorsForState(environment, state);
    }
    var data;
    if (state.kind === 'bailout') {
        data = isPlural ? [] : null;
    } else if (state.kind === 'singular') {
        data = state.snapshot.data;
    } else {
        data = state.snapshots.map(function(s) {
            return s.data;
        });
    }
    if ("TURBOPACK compile-time truthy", 1) {
        if (fragmentRef != null && (data === undefined || Array.isArray(data) && data.length > 0 && data.every(function(d) {
            return d === undefined;
        }))) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected to have been able to read non-null data for ' + 'fragment `%s` declared in ' + '`%s`, since fragment reference was non-null. ' + "Make sure that that `%s`'s parent isn't " + 'holding on to and/or passing a fragment reference for data that ' + 'has been deleted.', fragmentNode.name, hookDisplayName, hookDisplayName) : "TURBOPACK unreachable";
        }
    }
    return {
        data: data,
        clientEdgeQueries: clientEdgeQueries
    };
}
module.exports = readFragmentInternal;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useQueryLoader_EXPERIMENTAL.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/loadQuery.js [app-rsc] (ecmascript)"), loadQuery = _require.loadQuery;
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-rsc] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useCallback = _require2.useCallback, useEffect = _require2.useEffect, useInsertionEffect = _require2.useInsertionEffect, useRef = _require2.useRef, useState = _require2.useState;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), getRequest = _require3.getRequest;
var initialNullQueryReferenceState = {
    kind: 'NullQueryReference'
};
function requestIsLiveQuery(preloadableRequest) {
    if (preloadableRequest.kind === 'PreloadableConcreteRequest') {
        return preloadableRequest.params.metadata.live !== undefined;
    }
    var request = getRequest(preloadableRequest);
    return request.params.metadata.live !== undefined;
}
var CLEANUP_TIMEOUT = 1000 * 60 * 5;
function useQueryLoader_EXPERIMENTAL(preloadableRequest, initialQueryReference) {
    var initialQueryReferenceInternal = initialQueryReference !== null && initialQueryReference !== void 0 ? initialQueryReference : initialNullQueryReferenceState;
    var environment = useRelayEnvironment();
    var isMountedRef = useIsMountedRef();
    var undisposedQueryReferencesRef = useRef(null);
    if (undisposedQueryReferencesRef.current == null) {
        undisposedQueryReferencesRef.current = new Set([
            initialQueryReferenceInternal
        ]);
    }
    var _useState = useState(function() {
        return initialQueryReferenceInternal;
    }), queryReference = _useState[0], setQueryReference = _useState[1];
    var _useState2 = useState(function() {
        return initialQueryReferenceInternal;
    }), previousInitialQueryReference = _useState2[0], setPreviousInitialQueryReference = _useState2[1];
    if (initialQueryReferenceInternal !== previousInitialQueryReference) {
        var _undisposedQueryRefer;
        (_undisposedQueryRefer = undisposedQueryReferencesRef.current) === null || _undisposedQueryRefer === void 0 ? void 0 : _undisposedQueryRefer.add(initialQueryReferenceInternal);
        setPreviousInitialQueryReference(initialQueryReferenceInternal);
        setQueryReference(initialQueryReferenceInternal);
    }
    var disposeQuery = useCallback(function() {
        if (isMountedRef.current) {
            var _undisposedQueryRefer2;
            (_undisposedQueryRefer2 = undisposedQueryReferencesRef.current) === null || _undisposedQueryRefer2 === void 0 ? void 0 : _undisposedQueryRefer2.add(initialNullQueryReferenceState);
            setQueryReference(initialNullQueryReferenceState);
        }
    }, [
        isMountedRef
    ]);
    var queryLoaderCallback = useCallback(function(variables, options) {
        var _options$__environmen, _undisposedQueryRefer3;
        if (!isMountedRef.current) {
            return;
        }
        var mergedOptions = options != null && options.hasOwnProperty('__environment') ? {
            fetchPolicy: options.fetchPolicy,
            networkCacheConfig: options.networkCacheConfig,
            __nameForWarning: options.__nameForWarning
        } : options;
        var updatedQueryReference = loadQuery((_options$__environmen = options === null || options === void 0 ? void 0 : options.__environment) !== null && _options$__environmen !== void 0 ? _options$__environmen : environment, preloadableRequest, variables, mergedOptions);
        (_undisposedQueryRefer3 = undisposedQueryReferencesRef.current) === null || _undisposedQueryRefer3 === void 0 ? void 0 : _undisposedQueryRefer3.add(updatedQueryReference);
        setQueryReference(updatedQueryReference);
    }, [
        environment,
        preloadableRequest,
        setQueryReference,
        isMountedRef
    ]);
    var disposeAllRemainingQueryReferences = useCallback(function disposeAllRemainingQueryReferences(preloadableRequest, currentQueryReference) {
        var _undisposedQueryRefer4;
        var undisposedQueryReferences = (_undisposedQueryRefer4 = undisposedQueryReferencesRef.current) !== null && _undisposedQueryRefer4 !== void 0 ? _undisposedQueryRefer4 : new Set();
        var _iterator = (0, _createForOfIteratorHelper2["default"])(undisposedQueryReferences), _step;
        try {
            for(_iterator.s(); !(_step = _iterator.n()).done;){
                var undisposedQueryReference = _step.value;
                if (undisposedQueryReference === currentQueryReference) {
                    continue;
                }
                if (undisposedQueryReference.kind !== 'NullQueryReference') {
                    if (requestIsLiveQuery(preloadableRequest)) {
                        undisposedQueryReference.dispose && undisposedQueryReference.dispose();
                    } else {
                        undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();
                    }
                }
            }
        } catch (err) {
            _iterator.e(err);
        } finally{
            _iterator.f();
        }
    }, []);
    var cleanupTimerRef = useRef(null);
    useEffect(function() {
        disposeAllRemainingQueryReferences(preloadableRequest, queryReference);
        if (cleanupTimerRef.current != null) {
            clearTimeout(cleanupTimerRef.current);
            cleanupTimerRef.current = null;
        }
        return function() {
            cleanupTimerRef.current = setTimeout(function() {
                disposeAllRemainingQueryReferences(preloadableRequest, null);
            }, CLEANUP_TIMEOUT);
        };
    }, [
        preloadableRequest,
        queryReference
    ]);
    useInsertionEffect(function() {
        return function() {
            cleanupTimerRef.current && clearTimeout(cleanupTimerRef.current);
            cleanupTimerRef.current = null;
            disposeAllRemainingQueryReferences(preloadableRequest, null);
        };
    }, [
        preloadableRequest
    ]);
    return [
        queryReference.kind === 'NullQueryReference' ? null : queryReference,
        queryLoaderCallback,
        disposeQuery
    ];
}
module.exports = useQueryLoader_EXPERIMENTAL;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useQueryLoader.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _createForOfIteratorHelper2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js [app-rsc] (ecmascript)"));
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/loadQuery.js [app-rsc] (ecmascript)"), loadQuery = _require.loadQuery;
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-rsc] (ecmascript)");
var useQueryLoader_EXPERIMENTAL = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useQueryLoader_EXPERIMENTAL.js [app-rsc] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useCallback = _require2.useCallback, useEffect = _require2.useEffect, useRef = _require2.useRef, useState = _require2.useState;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), RelayFeatureFlags = _require3.RelayFeatureFlags, getRequest = _require3.getRequest;
var initialNullQueryReferenceState = {
    kind: 'NullQueryReference'
};
function requestIsLiveQuery(preloadableRequest) {
    if (preloadableRequest.kind === 'PreloadableConcreteRequest') {
        return preloadableRequest.params.metadata.live !== undefined;
    }
    var request = getRequest(preloadableRequest);
    return request.params.metadata.live !== undefined;
}
function useQueryLoader(preloadableRequest, initialQueryReference) {
    if (RelayFeatureFlags.ENABLE_ACTIVITY_COMPATIBILITY) {
        return useQueryLoader_EXPERIMENTAL(preloadableRequest, initialQueryReference);
    }
    return useQueryLoader_CURRENT(preloadableRequest, initialQueryReference);
}
function useQueryLoader_CURRENT(preloadableRequest, initialQueryReference) {
    var initialQueryReferenceInternal = initialQueryReference !== null && initialQueryReference !== void 0 ? initialQueryReference : initialNullQueryReferenceState;
    var environment = useRelayEnvironment();
    var isMountedRef = useIsMountedRef();
    var undisposedQueryReferencesRef = useRef(new Set([
        initialQueryReferenceInternal
    ]));
    var _useState = useState(function() {
        return initialQueryReferenceInternal;
    }), queryReference = _useState[0], setQueryReference = _useState[1];
    var _useState2 = useState(function() {
        return initialQueryReferenceInternal;
    }), previousInitialQueryReference = _useState2[0], setPreviousInitialQueryReference = _useState2[1];
    if (initialQueryReferenceInternal !== previousInitialQueryReference) {
        undisposedQueryReferencesRef.current.add(initialQueryReferenceInternal);
        setPreviousInitialQueryReference(initialQueryReferenceInternal);
        setQueryReference(initialQueryReferenceInternal);
    }
    var disposeQuery = useCallback(function() {
        if (isMountedRef.current) {
            undisposedQueryReferencesRef.current.add(initialNullQueryReferenceState);
            setQueryReference(initialNullQueryReferenceState);
        }
    }, [
        isMountedRef
    ]);
    var queryLoaderCallback = useCallback(function(variables, options) {
        var mergedOptions = options != null && options.hasOwnProperty('__environment') ? {
            fetchPolicy: options.fetchPolicy,
            networkCacheConfig: options.networkCacheConfig,
            __nameForWarning: options.__nameForWarning
        } : options;
        if (isMountedRef.current) {
            var _options$__environmen;
            var updatedQueryReference = loadQuery((_options$__environmen = options === null || options === void 0 ? void 0 : options.__environment) !== null && _options$__environmen !== void 0 ? _options$__environmen : environment, preloadableRequest, variables, mergedOptions);
            undisposedQueryReferencesRef.current.add(updatedQueryReference);
            setQueryReference(updatedQueryReference);
        }
    }, [
        environment,
        preloadableRequest,
        setQueryReference,
        isMountedRef
    ]);
    var maybeHiddenOrFastRefresh = useRef(false);
    useEffect(function() {
        return function() {
            maybeHiddenOrFastRefresh.current = true;
        };
    }, []);
    useEffect(function() {
        if (maybeHiddenOrFastRefresh.current === true) {
            maybeHiddenOrFastRefresh.current = false;
            if (queryReference.kind !== 'NullQueryReference') {
                queryLoaderCallback(queryReference.variables, {
                    fetchPolicy: queryReference.fetchPolicy,
                    networkCacheConfig: queryReference.networkCacheConfig
                });
            }
            return;
        }
        var undisposedQueryReferences = undisposedQueryReferencesRef.current;
        if (isMountedRef.current) {
            var _iterator = (0, _createForOfIteratorHelper2["default"])(undisposedQueryReferences), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var undisposedQueryReference = _step.value;
                    if (undisposedQueryReference === queryReference) {
                        break;
                    }
                    undisposedQueryReferences["delete"](undisposedQueryReference);
                    if (undisposedQueryReference.kind !== 'NullQueryReference') {
                        if (requestIsLiveQuery(preloadableRequest)) {
                            undisposedQueryReference.dispose && undisposedQueryReference.dispose();
                        } else {
                            undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();
                        }
                    }
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
        }
    }, [
        queryReference,
        isMountedRef,
        queryLoaderCallback,
        preloadableRequest
    ]);
    useEffect(function() {
        return function disposeAllRemainingQueryReferences() {
            var _iterator2 = (0, _createForOfIteratorHelper2["default"])(undisposedQueryReferencesRef.current), _step2;
            try {
                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                    var undisposedQueryReference = _step2.value;
                    if (undisposedQueryReference.kind !== 'NullQueryReference') {
                        if (requestIsLiveQuery(preloadableRequest)) {
                            undisposedQueryReference.dispose && undisposedQueryReference.dispose();
                        } else {
                            undisposedQueryReference.releaseQuery && undisposedQueryReference.releaseQuery();
                        }
                    }
                }
            } catch (err) {
                _iterator2.e(err);
            } finally{
                _iterator2.f();
            }
        };
    }, [
        preloadableRequest
    ]);
    return [
        queryReference.kind === 'NullQueryReference' ? null : queryReference,
        queryLoaderCallback,
        disposeQuery
    ];
}
module.exports = useQueryLoader;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useRefetchableFragmentInternal.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var ProfilerContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/ProfilerContext.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/QueryResource.js [app-rsc] (ecmascript)"), getQueryResourceForEnvironment = _require.getQueryResourceForEnvironment;
var readFragmentInternal = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/readFragmentInternal.js [app-rsc] (ecmascript)");
var useFragmentInternal = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFragmentInternal.js [app-rsc] (ecmascript)");
var useIsMountedRef = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useIsMountedRef.js [app-rsc] (ecmascript)");
var useQueryLoader = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useQueryLoader.js [app-rsc] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var _require2 = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useCallback = _require2.useCallback, useContext = _require2.useContext, useReducer = _require2.useReducer;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), fetchQuery = _require3.__internal.fetchQuery, createOperationDescriptor = _require3.createOperationDescriptor, getFragmentIdentifier = _require3.getFragmentIdentifier, getRefetchMetadata = _require3.getRefetchMetadata, getSelector = _require3.getSelector, getValueAtPath = _require3.getValueAtPath;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function reducer(state, action) {
    switch(action.type){
        case 'refetch':
            {
                var _action$refetchEnviro;
                return (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, state), {}, {
                    fetchPolicy: action.fetchPolicy,
                    mirroredEnvironment: (_action$refetchEnviro = action.refetchEnvironment) !== null && _action$refetchEnviro !== void 0 ? _action$refetchEnviro : state.mirroredEnvironment,
                    onComplete: action.onComplete,
                    refetchEnvironment: action.refetchEnvironment,
                    refetchQuery: action.refetchQuery,
                    renderPolicy: action.renderPolicy
                });
            }
        case 'reset':
            {
                return {
                    fetchPolicy: undefined,
                    mirroredEnvironment: action.environment,
                    mirroredFragmentIdentifier: action.fragmentIdentifier,
                    onComplete: undefined,
                    refetchQuery: null,
                    renderPolicy: undefined
                };
            }
        default:
            {
                action.type;
                throw new Error('useRefetchableFragmentNode: Unexpected action type');
            }
    }
}
function useRefetchableFragmentInternal(fragmentNode, parentFragmentRef, componentDisplayName) {
    var parentEnvironment = useRelayEnvironment();
    var _getRefetchMetadata = getRefetchMetadata(fragmentNode, componentDisplayName), refetchableRequest = _getRefetchMetadata.refetchableRequest, fragmentRefPathInResponse = _getRefetchMetadata.fragmentRefPathInResponse, identifierInfo = _getRefetchMetadata.identifierInfo;
    var fragmentIdentifier = getFragmentIdentifier(fragmentNode, parentFragmentRef);
    var _useReducer = useReducer(reducer, {
        fetchPolicy: undefined,
        mirroredEnvironment: parentEnvironment,
        mirroredFragmentIdentifier: fragmentIdentifier,
        onComplete: undefined,
        refetchEnvironment: null,
        refetchQuery: null,
        renderPolicy: undefined
    }), refetchState = _useReducer[0], dispatch = _useReducer[1];
    var fetchPolicy = refetchState.fetchPolicy, mirroredEnvironment = refetchState.mirroredEnvironment, mirroredFragmentIdentifier = refetchState.mirroredFragmentIdentifier, onComplete = refetchState.onComplete, refetchEnvironment = refetchState.refetchEnvironment, refetchQuery = refetchState.refetchQuery, renderPolicy = refetchState.renderPolicy;
    var environment = refetchEnvironment !== null && refetchEnvironment !== void 0 ? refetchEnvironment : parentEnvironment;
    var QueryResource = getQueryResourceForEnvironment(environment);
    var profilerContext = useContext(ProfilerContext);
    var shouldReset = environment !== mirroredEnvironment || fragmentIdentifier !== mirroredFragmentIdentifier;
    var _useQueryLoader = useQueryLoader(refetchableRequest), queryRef = _useQueryLoader[0], loadQuery = _useQueryLoader[1], disposeQuery = _useQueryLoader[2];
    var fragmentRef = parentFragmentRef;
    if (shouldReset) {
        dispatch({
            type: 'reset',
            environment: environment,
            fragmentIdentifier: fragmentIdentifier
        });
        disposeQuery();
    } else if (refetchQuery != null && queryRef != null) {
        var debugPreviousIDAndTypename;
        if ("TURBOPACK compile-time truthy", 1) {
            debugPreviousIDAndTypename = debugFunctions.getInitialIDAndType(refetchQuery.request.variables, fragmentRefPathInResponse, identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierQueryVariableName, environment);
        }
        var handleQueryCompleted = function handleQueryCompleted(maybeError) {
            onComplete && onComplete(maybeError !== null && maybeError !== void 0 ? maybeError : null);
        };
        var fetchObservable = queryRef.source != null ? queryRef.source : fetchQuery(environment, refetchQuery);
        var queryResult = profilerContext.wrapPrepareQueryResource(function() {
            return QueryResource.prepare(refetchQuery, fetchObservable, fetchPolicy, renderPolicy, {
                error: handleQueryCompleted,
                complete: function complete() {
                    if ("TURBOPACK compile-time truthy", 1) {
                        debugFunctions.checkSameTypeAfterRefetch(debugPreviousIDAndTypename, environment, fragmentNode, componentDisplayName);
                    }
                    handleQueryCompleted();
                }
            }, queryRef.fetchKey, profilerContext);
        });
        var queryData = readFragmentInternal(environment, queryResult.fragmentNode, queryResult.fragmentRef, componentDisplayName).data;
        !(queryData != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Relay: Expected to be able to read refetch query response. ' + "If you're seeing this, this is likely a bug in Relay.") : "TURBOPACK unreachable" : void 0;
        var refetchedFragmentRef = getValueAtPath(queryData, fragmentRefPathInResponse);
        fragmentRef = refetchedFragmentRef;
        if ("TURBOPACK compile-time truthy", 1) {
            debugFunctions.checkSameIDAfterRefetch(debugPreviousIDAndTypename, fragmentRef, fragmentNode, componentDisplayName);
        }
    }
    var fragmentData = useFragmentInternal(fragmentNode, fragmentRef, componentDisplayName);
    var refetch = useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierInfo, loadQuery, parentFragmentRef, refetchableRequest);
    return {
        fragmentData: fragmentData,
        fragmentRef: fragmentRef,
        refetch: refetch
    };
}
function useRefetchFunction(componentDisplayName, dispatch, disposeQuery, fragmentData, fragmentIdentifier, fragmentNode, fragmentRefPathInResponse, identifierInfo, loadQuery, parentFragmentRef, refetchableRequest) {
    var isMountedRef = useIsMountedRef();
    var identifierValue = (identifierInfo === null || identifierInfo === void 0 ? void 0 : identifierInfo.identifierField) != null && fragmentData != null && typeof fragmentData === 'object' ? fragmentData[identifierInfo.identifierField] : null;
    return useCallback(function(providedRefetchVariables, options) {
        if (isMountedRef.current !== true) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected call to `refetch` on unmounted component for fragment ' + '`%s` in `%s`. It looks like some instances of your component are ' + 'still trying to fetch data but they already unmounted. ' + 'Please make sure you clear all timers, intervals, ' + 'async calls, etc that may trigger a fetch.', fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable";
            return {
                dispose: function dispose() {}
            };
        }
        if (parentFragmentRef == null) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Unexpected call to `refetch` while using a null fragment ref ' + 'for fragment `%s` in `%s`. When calling `refetch`, we expect ' + "initial fragment data to be non-null. Please make sure you're " + 'passing a valid fragment ref to `%s` before calling ' + '`refetch`, or make sure you pass all required variables to `refetch`.', fragmentNode.name, componentDisplayName, componentDisplayName) : "TURBOPACK unreachable";
        }
        var refetchEnvironment = options === null || options === void 0 ? void 0 : options.__environment;
        var fetchPolicy = options === null || options === void 0 ? void 0 : options.fetchPolicy;
        var renderPolicy = options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy;
        var onComplete = options === null || options === void 0 ? void 0 : options.onComplete;
        var fragmentSelector = getSelector(fragmentNode, parentFragmentRef);
        var parentVariables;
        var fragmentVariables;
        if (fragmentSelector == null) {
            parentVariables = {};
            fragmentVariables = {};
        } else if (fragmentSelector.kind === 'PluralReaderSelector') {
            var _fragmentSelector$sel, _fragmentSelector$sel2, _fragmentSelector$sel3, _fragmentSelector$sel4;
            parentVariables = (_fragmentSelector$sel = (_fragmentSelector$sel2 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel2 === void 0 ? void 0 : _fragmentSelector$sel2.owner.variables) !== null && _fragmentSelector$sel !== void 0 ? _fragmentSelector$sel : {};
            fragmentVariables = (_fragmentSelector$sel3 = (_fragmentSelector$sel4 = fragmentSelector.selectors[0]) === null || _fragmentSelector$sel4 === void 0 ? void 0 : _fragmentSelector$sel4.variables) !== null && _fragmentSelector$sel3 !== void 0 ? _fragmentSelector$sel3 : {};
        } else {
            parentVariables = fragmentSelector.owner.variables;
            fragmentVariables = fragmentSelector.variables;
        }
        var refetchVariables = (0, _objectSpread2["default"])((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, parentVariables), fragmentVariables), providedRefetchVariables);
        if (identifierInfo != null && !providedRefetchVariables.hasOwnProperty(identifierInfo.identifierQueryVariableName)) {
            if (typeof identifierValue !== 'string') {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Expected result to have a string  ' + '`%s` in order to refetch, got `%s`.', identifierInfo.identifierField, identifierValue) : "TURBOPACK unreachable";
            }
            refetchVariables[identifierInfo.identifierQueryVariableName] = identifierValue;
        }
        var refetchQuery = createOperationDescriptor(refetchableRequest, refetchVariables, {
            force: true
        });
        loadQuery(refetchQuery.request.variables, {
            fetchPolicy: fetchPolicy,
            __environment: refetchEnvironment,
            __nameForWarning: 'refetch'
        });
        dispatch({
            type: 'refetch',
            fetchPolicy: fetchPolicy,
            onComplete: onComplete,
            refetchEnvironment: refetchEnvironment,
            refetchQuery: refetchQuery,
            renderPolicy: renderPolicy
        });
        return {
            dispose: disposeQuery
        };
    }, [
        fragmentIdentifier,
        dispatch,
        disposeQuery,
        identifierValue,
        loadQuery
    ]);
}
var debugFunctions;
if ("TURBOPACK compile-time truthy", 1) {
    debugFunctions = {
        getInitialIDAndType: function getInitialIDAndType(memoRefetchVariables, fragmentRefPathInResponse, identifierQueryVariableName, environment) {
            var _require4 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), Record = _require4.Record;
            var id = memoRefetchVariables === null || memoRefetchVariables === void 0 ? void 0 : memoRefetchVariables[identifierQueryVariableName !== null && identifierQueryVariableName !== void 0 ? identifierQueryVariableName : 'id'];
            if (fragmentRefPathInResponse.length !== 1 || fragmentRefPathInResponse[0] !== 'node' || id == null) {
                return null;
            }
            var recordSource = environment.getStore().getSource();
            var record = recordSource.get(id);
            var typename = record == null ? null : Record.getType(record);
            if (typename == null) {
                return null;
            }
            return {
                id: id,
                typename: typename
            };
        },
        checkSameTypeAfterRefetch: function checkSameTypeAfterRefetch(previousIDAndType, environment, fragmentNode, componentDisplayName) {
            var _require5 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), Record = _require5.Record;
            if (!previousIDAndType) {
                return;
            }
            var recordSource = environment.getStore().getSource();
            var record = recordSource.get(previousIDAndType.id);
            var typename = record && Record.getType(record);
            if (typename !== previousIDAndType.typename) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Call to `refetch` returned data with a different ' + '__typename: was `%s`, now `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements' + 'unique id requirement.', previousIDAndType.typename, typename, fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable";
            }
        },
        checkSameIDAfterRefetch: function checkSameIDAfterRefetch(previousIDAndTypename, refetchedFragmentRef, fragmentNode, componentDisplayName) {
            if (previousIDAndTypename == null || refetchedFragmentRef == null) {
                return;
            }
            var _require6 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), ID_KEY = _require6.ID_KEY;
            var resultID = refetchedFragmentRef[ID_KEY];
            if (resultID != null && resultID !== previousIDAndTypename.id) {
                ("TURBOPACK compile-time truthy", 1) ? warning(false, 'Relay: Call to `refetch` returned a different id, expected ' + '`%s`, got `%s`, on `%s` in `%s`. ' + 'Please make sure the server correctly implements ' + 'unique id requirement.', resultID, previousIDAndTypename.id, fragmentNode.name, componentDisplayName) : "TURBOPACK unreachable";
            }
        }
    };
}
module.exports = useRefetchableFragmentInternal;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/usePaginationFragment.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var useLoadMoreFunction = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useLoadMoreFunction.js [app-rsc] (ecmascript)");
var useRefetchableFragmentInternal = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRefetchableFragmentInternal.js [app-rsc] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var useStaticFragmentNodeWarning = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useStaticFragmentNodeWarning.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useCallback = _require.useCallback, useDebugValue = _require.useDebugValue, useState = _require.useState;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), RelayFeatureFlags = _require2.RelayFeatureFlags, getFragment = _require2.getFragment, getFragmentIdentifier = _require2.getFragmentIdentifier, getPaginationMetadata = _require2.getPaginationMetadata;
function usePaginationFragment(fragmentInput, parentFragmentRef) {
    var fragmentNode = getFragment(fragmentInput);
    useStaticFragmentNodeWarning(fragmentNode, 'first argument of usePaginationFragment()');
    var componentDisplayName = 'usePaginationFragment()';
    var _getPaginationMetadat = getPaginationMetadata(fragmentNode, componentDisplayName), connectionPathInFragmentData = _getPaginationMetadat.connectionPathInFragmentData, paginationRequest = _getPaginationMetadat.paginationRequest, paginationMetadata = _getPaginationMetadat.paginationMetadata;
    var _useRefetchableFragme = useRefetchableFragmentInternal(fragmentNode, parentFragmentRef, componentDisplayName), fragmentData = _useRefetchableFragme.fragmentData, fragmentRef = _useRefetchableFragme.fragmentRef, refetch = _useRefetchableFragme.refetch;
    var fragmentIdentifier = getFragmentIdentifier(fragmentNode, fragmentRef);
    var _useLoadMore = useLoadMore({
        componentDisplayName: componentDisplayName,
        connectionPathInFragmentData: connectionPathInFragmentData,
        direction: 'backward',
        fragmentData: fragmentData,
        fragmentIdentifier: fragmentIdentifier,
        fragmentNode: fragmentNode,
        fragmentRef: fragmentRef,
        paginationMetadata: paginationMetadata,
        paginationRequest: paginationRequest
    }), loadPrevious = _useLoadMore[0], hasPrevious = _useLoadMore[1], isLoadingPrevious = _useLoadMore[2], disposeFetchPrevious = _useLoadMore[3];
    var _useLoadMore2 = useLoadMore({
        componentDisplayName: componentDisplayName,
        connectionPathInFragmentData: connectionPathInFragmentData,
        direction: 'forward',
        fragmentData: fragmentData,
        fragmentIdentifier: fragmentIdentifier,
        fragmentNode: fragmentNode,
        fragmentRef: fragmentRef,
        paginationMetadata: paginationMetadata,
        paginationRequest: paginationRequest
    }), loadNext = _useLoadMore2[0], hasNext = _useLoadMore2[1], isLoadingNext = _useLoadMore2[2], disposeFetchNext = _useLoadMore2[3];
    var refetchPagination = useCallback(function(variables, options) {
        disposeFetchNext();
        disposeFetchPrevious();
        return refetch(variables, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, options), {}, {
            __environment: undefined
        }));
    }, [
        disposeFetchNext,
        disposeFetchPrevious,
        refetch
    ]);
    if ("TURBOPACK compile-time truthy", 1) {
        useDebugValue({
            fragment: fragmentNode.name,
            data: fragmentData,
            hasNext: hasNext,
            isLoadingNext: isLoadingNext,
            hasPrevious: hasPrevious,
            isLoadingPrevious: isLoadingPrevious
        });
    }
    return {
        data: fragmentData,
        loadNext: loadNext,
        loadPrevious: loadPrevious,
        hasNext: hasNext,
        hasPrevious: hasPrevious,
        isLoadingNext: isLoadingNext,
        isLoadingPrevious: isLoadingPrevious,
        refetch: refetchPagination
    };
}
function useLoadMore(args) {
    var environment = useRelayEnvironment();
    var _useState = useState(false), isLoadingMore = _useState[0], reallySetIsLoadingMore = _useState[1];
    var setIsLoadingMore = function setIsLoadingMore(value) {
        var _environment$getSched;
        var schedule = (_environment$getSched = environment.getScheduler()) === null || _environment$getSched === void 0 ? void 0 : _environment$getSched.schedule;
        if (schedule) {
            schedule(function() {
                reallySetIsLoadingMore(value);
            });
        } else {
            reallySetIsLoadingMore(value);
        }
    };
    var observer = {
        start: function start() {
            return setIsLoadingMore(true);
        },
        complete: function complete() {
            return setIsLoadingMore(false);
        },
        error: function error() {
            return setIsLoadingMore(false);
        },
        unsubscribe: RelayFeatureFlags.ENABLE_USE_PAGINATION_IS_LOADING_FIX ? function() {
            return setIsLoadingMore(false);
        } : undefined
    };
    var handleReset = function handleReset() {
        return setIsLoadingMore(false);
    };
    var _useLoadMoreFunction = useLoadMoreFunction((0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, args), {}, {
        observer: observer,
        onReset: handleReset
    })), loadMore = _useLoadMoreFunction[0], hasMore = _useLoadMoreFunction[1], disposeFetch = _useLoadMoreFunction[2];
    return [
        loadMore,
        hasMore,
        isLoadingMore,
        disposeFetch
    ];
}
module.exports = usePaginationFragment;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/usePrefetchableForwardPaginationFragment.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _interopRequireDefault = __turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/interopRequireDefault.js [app-rsc] (ecmascript)")["default"];
var _objectSpread2 = _interopRequireDefault(__turbopack_context__.r("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-rsc] (ecmascript)"));
var useFragment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFragment.js [app-rsc] (ecmascript)");
var useLoadMoreFunction = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useLoadMoreFunction.js [app-rsc] (ecmascript)");
var useRefetchableFragmentInternal = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRefetchableFragmentInternal.js [app-rsc] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var useStaticFragmentNodeWarning = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useStaticFragmentNodeWarning.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useCallback = _require.useCallback, useDebugValue = _require.useDebugValue, useEffect = _require.useEffect, useLayoutEffect = _require.useLayoutEffect, useMemo = _require.useMemo, useRef = _require.useRef, useState = _require.useState;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), getFragment = _require2.getFragment, getFragmentIdentifier = _require2.getFragmentIdentifier, getPaginationMetadata = _require2.getPaginationMetadata;
var _require3 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), ConnectionInterface = _require3.ConnectionInterface, RelayFeatureFlags = _require3.RelayFeatureFlags, getSelector = _require3.getSelector, getValueAtPath = _require3.getValueAtPath;
function usePrefetchableForwardPaginationFragment(fragmentInput, parentFragmentRef, bufferSize, initialSize, prefetchingLoadMoreOptions) {
    var _fragmentInput$metada, _fragmentInput$metada2;
    var minimalFetchSize = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    var disablePrefetching = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var fragmentNode = getFragment(fragmentInput);
    useStaticFragmentNodeWarning(fragmentNode, 'first argument of usePrefetchableForwardPaginationFragment()');
    var componentDisplayName = 'usePrefetchableForwardPaginationFragment()';
    var _getPaginationMetadat = getPaginationMetadata(fragmentNode, componentDisplayName), connectionPathInFragmentData = _getPaginationMetadat.connectionPathInFragmentData, paginationRequest = _getPaginationMetadat.paginationRequest, paginationMetadata = _getPaginationMetadat.paginationMetadata;
    var _useRefetchableFragme = useRefetchableFragmentInternal(fragmentNode, parentFragmentRef, componentDisplayName), fragmentData = _useRefetchableFragme.fragmentData, fragmentRef = _useRefetchableFragme.fragmentRef, refetch = _useRefetchableFragme.refetch;
    var fragmentIdentifier = getFragmentIdentifier(fragmentNode, fragmentRef);
    var edgeKeys = useMemo(function() {
        var connection = getValueAtPath(fragmentData, connectionPathInFragmentData);
        if (connection == null) {
            return null;
        }
        var _ConnectionInterface$ = ConnectionInterface.get(), EDGES = _ConnectionInterface$.EDGES;
        return connection[EDGES];
    }, [
        connectionPathInFragmentData,
        fragmentData
    ]);
    var sourceSize = edgeKeys == null ? -1 : edgeKeys.length;
    var _useState = useState(initialSize != null ? initialSize : sourceSize), _numInUse = _useState[0], setNumInUse = _useState[1];
    var numInUse = _numInUse;
    if (_numInUse === -1 && sourceSize !== -1) {
        numInUse = initialSize != null ? initialSize : sourceSize;
        setNumInUse(numInUse);
    }
    var environment = useRelayEnvironment();
    var _useState2 = useState(false), isLoadingMore = _useState2[0], reallySetIsLoadingMore = _useState2[1];
    var _useState3 = useState(false), isRefetching = _useState3[0], setIsRefetching = _useState3[1];
    var availableSizeRef = useRef(0);
    var setIsLoadingMore = useCallback(function(value) {
        var _environment$getSched;
        var schedule = (_environment$getSched = environment.getScheduler()) === null || _environment$getSched === void 0 ? void 0 : _environment$getSched.schedule;
        if (schedule) {
            schedule(function() {
                reallySetIsLoadingMore(value);
            });
        } else {
            reallySetIsLoadingMore(value);
        }
    }, [
        environment
    ]);
    var isLoadingMoreRef = useRef(false);
    var observer = useMemo(function() {
        function setIsLoadingFalse() {
            isLoadingMoreRef.current = false;
            setIsLoadingMore(false);
        }
        return {
            start: function start() {
                isLoadingMoreRef.current = true;
                reallySetIsLoadingMore(true);
            },
            complete: setIsLoadingFalse,
            error: setIsLoadingFalse,
            unsubscribe: RelayFeatureFlags.ENABLE_USE_PAGINATION_IS_LOADING_FIX ? setIsLoadingFalse : undefined
        };
    }, [
        setIsLoadingMore
    ]);
    var handleReset = useCallback(function() {
        if (!isRefetching) {
            var _environment$getSched2;
            var schedule = (_environment$getSched2 = environment.getScheduler()) === null || _environment$getSched2 === void 0 ? void 0 : _environment$getSched2.schedule;
            if (schedule) {
                schedule(function() {
                    setNumInUse(-1);
                });
            } else {
                setNumInUse(-1);
            }
        }
        isLoadingMoreRef.current = false;
        setIsLoadingMore(false);
    }, [
        environment,
        isRefetching,
        setIsLoadingMore
    ]);
    var _useLoadMoreFunction = useLoadMoreFunction({
        componentDisplayName: componentDisplayName,
        connectionPathInFragmentData: connectionPathInFragmentData,
        direction: 'forward',
        fragmentData: fragmentData,
        fragmentIdentifier: fragmentIdentifier,
        fragmentNode: fragmentNode,
        fragmentRef: fragmentRef,
        paginationMetadata: paginationMetadata,
        paginationRequest: paginationRequest,
        observer: observer,
        onReset: handleReset
    }), loadMore = _useLoadMoreFunction[0], hasNext = _useLoadMoreFunction[1], disposeFetchNext = _useLoadMoreFunction[2];
    useLayoutEffect(function() {
        availableSizeRef.current = sourceSize - numInUse;
    }, [
        numInUse,
        sourceSize
    ]);
    var prefetchingUNSTABLE_extraVariables = prefetchingLoadMoreOptions === null || prefetchingLoadMoreOptions === void 0 ? void 0 : prefetchingLoadMoreOptions.UNSTABLE_extraVariables;
    var prefetchingOnComplete = prefetchingLoadMoreOptions === null || prefetchingLoadMoreOptions === void 0 ? void 0 : prefetchingLoadMoreOptions.onComplete;
    var showMore = useCallback(function(numToAdd, options) {
        if (!isLoadingMoreRef.current || availableSizeRef.current >= 0) {
            availableSizeRef.current -= numToAdd;
            setNumInUse(function(lastNumInUse) {
                return lastNumInUse + numToAdd;
            });
            if (!isLoadingMoreRef.current && availableSizeRef.current < 0) {
                loadMore(Math.max(minimalFetchSize, Math.min(numToAdd, bufferSize - availableSizeRef.current)), options !== null && options !== void 0 ? options : {
                    onComplete: prefetchingOnComplete,
                    UNSTABLE_extraVariables: typeof prefetchingUNSTABLE_extraVariables === 'function' ? prefetchingUNSTABLE_extraVariables({
                        hasNext: hasNext,
                        data: fragmentData,
                        getServerEdges: function getServerEdges() {
                            var selector = getSelector(edgesFragment, edgeKeys);
                            if (selector == null) {
                                return [];
                            }
                            !(selector.kind === 'PluralReaderSelector') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected a plural selector') : "TURBOPACK unreachable" : void 0;
                            return selector.selectors.map(function(sel) {
                                return environment.lookup(sel).data;
                            });
                        }
                    }) : prefetchingUNSTABLE_extraVariables
                });
            }
        }
    }, [
        bufferSize,
        loadMore,
        minimalFetchSize,
        edgeKeys,
        fragmentData,
        prefetchingUNSTABLE_extraVariables,
        prefetchingOnComplete
    ]);
    var edgesFragment = (_fragmentInput$metada = fragmentInput.metadata) === null || _fragmentInput$metada === void 0 ? void 0 : (_fragmentInput$metada2 = _fragmentInput$metada.refetch) === null || _fragmentInput$metada2 === void 0 ? void 0 : _fragmentInput$metada2.edgesFragment;
    !(edgesFragment != null) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'usePrefetchableForwardPaginationFragment: Expected the edge fragment to be defined, ' + 'please make sure you have added `prefetchable_pagination: true`  to `@connection`') : "TURBOPACK unreachable" : void 0;
    useEffect(function() {
        if (!isLoadingMoreRef.current && !isLoadingMore && !isRefetching && !disablePrefetching && hasNext && (sourceSize - numInUse < bufferSize || numInUse > sourceSize)) {
            var onComplete = prefetchingOnComplete;
            loadMore(Math.max(bufferSize - Math.max(sourceSize - numInUse, 0), numInUse - sourceSize, minimalFetchSize), {
                onComplete: onComplete,
                UNSTABLE_extraVariables: typeof prefetchingUNSTABLE_extraVariables === 'function' ? prefetchingUNSTABLE_extraVariables({
                    hasNext: hasNext,
                    data: fragmentData,
                    getServerEdges: function getServerEdges() {
                        var selector = getSelector(edgesFragment, edgeKeys);
                        if (selector == null) {
                            return [];
                        }
                        !(selector.kind === 'PluralReaderSelector') ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'Expected a plural selector') : "TURBOPACK unreachable" : void 0;
                        return selector.selectors.map(function(sel) {
                            return environment.lookup(sel).data;
                        });
                    }
                }) : prefetchingUNSTABLE_extraVariables
            });
        }
    }, [
        hasNext,
        bufferSize,
        isRefetching,
        loadMore,
        numInUse,
        prefetchingUNSTABLE_extraVariables,
        prefetchingOnComplete,
        sourceSize,
        edgeKeys,
        isLoadingMore,
        minimalFetchSize,
        environment,
        edgesFragment
    ]);
    var realNumInUse = Math.min(numInUse, sourceSize);
    var derivedEdgeKeys = useMemo(function() {
        var _edgeKeys$slice;
        return (_edgeKeys$slice = edgeKeys === null || edgeKeys === void 0 ? void 0 : edgeKeys.slice(0, realNumInUse)) !== null && _edgeKeys$slice !== void 0 ? _edgeKeys$slice : [];
    }, [
        edgeKeys,
        realNumInUse
    ]);
    var edges = useFragment(edgesFragment, derivedEdgeKeys);
    var refetchPagination = useCallback(function(variables, options) {
        disposeFetchNext();
        setIsRefetching(true);
        return refetch(variables, (0, _objectSpread2["default"])((0, _objectSpread2["default"])({}, options), {}, {
            onComplete: function onComplete(maybeError) {
                var _environment$getSched3, _options$onComplete;
                var schedule = (_environment$getSched3 = environment.getScheduler()) === null || _environment$getSched3 === void 0 ? void 0 : _environment$getSched3.schedule;
                if (schedule) {
                    schedule(function() {
                        setIsRefetching(false);
                        setNumInUse(-1);
                    });
                } else {
                    setIsRefetching(false);
                    setNumInUse(-1);
                }
                options === null || options === void 0 ? void 0 : (_options$onComplete = options.onComplete) === null || _options$onComplete === void 0 ? void 0 : _options$onComplete.call(options, maybeError);
            },
            __environment: undefined
        }));
    }, [
        disposeFetchNext,
        environment,
        refetch
    ]);
    if ("TURBOPACK compile-time truthy", 1) {
        useDebugValue({
            fragment: fragmentNode.name,
            data: fragmentData,
            hasNext: hasNext,
            isLoadingNext: isLoadingMore
        });
    }
    return {
        edges: edges,
        data: fragmentData,
        loadNext: showMore,
        hasNext: hasNext || sourceSize > numInUse,
        isLoadingNext: isLoadingMore && numInUse > sourceSize,
        refetch: refetchPagination
    };
}
module.exports = usePrefetchableForwardPaginationFragment;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/usePreloadedQuery.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useLazyLoadQueryNode = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useLazyLoadQueryNode.js [app-rsc] (ecmascript)");
var useMemoOperationDescriptor = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useMemoOperationDescriptor.js [app-rsc] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var invariant = __turbopack_context__.r("[project]/node_modules/invariant/invariant.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useDebugValue = _require.useDebugValue;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), _require2$__internal = _require2.__internal, fetchQueryDeduped = _require2$__internal.fetchQueryDeduped, fetchQuery = _require2$__internal.fetchQuery;
var warning = __turbopack_context__.r("[project]/node_modules/fbjs/lib/warning.js [app-rsc] (ecmascript)");
function usePreloadedQuery(gqlQuery, preloadedQuery, options) {
    var environment = useRelayEnvironment();
    var fetchKey = preloadedQuery.fetchKey, fetchPolicy = preloadedQuery.fetchPolicy, source = preloadedQuery.source, variables = preloadedQuery.variables, networkCacheConfig = preloadedQuery.networkCacheConfig;
    var operation = useMemoOperationDescriptor(gqlQuery, variables, networkCacheConfig);
    var useLazyLoadQueryNodeParams;
    if (preloadedQuery.kind === 'PreloadedQuery_DEPRECATED') {
        !(operation.request.node.params.name === preloadedQuery.name) ? ("TURBOPACK compile-time truthy", 1) ? invariant(false, 'usePreloadedQuery(): Expected data to be prefetched for query `%s`, ' + 'got prefetch results for query `%s`.', operation.request.node.params.name, preloadedQuery.name) : "TURBOPACK unreachable" : void 0;
        useLazyLoadQueryNodeParams = {
            componentDisplayName: 'usePreloadedQuery()',
            fetchKey: fetchKey,
            fetchObservable: fetchQueryDeduped(environment, operation.request.identifier, function() {
                if (environment === preloadedQuery.environment && source != null) {
                    return environment.executeWithSource({
                        operation: operation,
                        source: source
                    });
                } else {
                    return environment.execute({
                        operation: operation
                    });
                }
            }),
            fetchPolicy: fetchPolicy,
            query: operation,
            renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
        };
    } else {
        ("TURBOPACK compile-time truthy", 1) ? warning(preloadedQuery.isDisposed === false, 'usePreloadedQuery(): Expected preloadedQuery to not be disposed yet. ' + 'This is because disposing the query marks it for future garbage ' + 'collection, and as such query results may no longer be present in the Relay ' + 'store. In the future, this will become a hard error.') : "TURBOPACK unreachable";
        var fallbackFetchObservable = fetchQuery(environment, operation);
        var fetchObservable;
        if (source != null && environment === preloadedQuery.environment) {
            fetchObservable = source.ifEmpty(fallbackFetchObservable);
        } else if (environment !== preloadedQuery.environment) {
            ("TURBOPACK compile-time truthy", 1) ? warning(false, 'usePreloadedQuery(): usePreloadedQuery was passed a preloaded query ' + 'that was created with a different environment than the one that is currently ' + 'in context. In the future, this will become a hard error.') : "TURBOPACK unreachable";
            fetchObservable = fallbackFetchObservable;
        } else {
            fetchObservable = fallbackFetchObservable;
        }
        useLazyLoadQueryNodeParams = {
            componentDisplayName: 'usePreloadedQuery()',
            fetchObservable: fetchObservable,
            fetchKey: fetchKey,
            fetchPolicy: fetchPolicy,
            query: operation,
            renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
        };
    }
    var data = useLazyLoadQueryNode(useLazyLoadQueryNodeParams);
    if ("TURBOPACK compile-time truthy", 1) {
        useDebugValue({
            query: preloadedQuery.name,
            variables: preloadedQuery.variables,
            data: data,
            fetchKey: fetchKey,
            fetchPolicy: fetchPolicy,
            renderPolicy: options === null || options === void 0 ? void 0 : options.UNSTABLE_renderPolicy
        });
    }
    return data;
}
module.exports = usePreloadedQuery;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useRefetchableFragment.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useRefetchableFragmentInternal = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRefetchableFragmentInternal.js [app-rsc] (ecmascript)");
var useStaticFragmentNodeWarning = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useStaticFragmentNodeWarning.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useDebugValue = _require.useDebugValue;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), getFragment = _require2.getFragment;
function useRefetchableFragment(fragmentInput, fragmentRef) {
    var fragmentNode = getFragment(fragmentInput);
    useStaticFragmentNodeWarning(fragmentNode, 'first argument of useRefetchableFragment()');
    var _useRefetchableFragme = useRefetchableFragmentInternal(fragmentNode, fragmentRef, 'useRefetchableFragment()'), fragmentData = _useRefetchableFragme.fragmentData, refetch = _useRefetchableFragme.refetch;
    if ("TURBOPACK compile-time truthy", 1) {
        useDebugValue({
            fragment: fragmentNode.name,
            data: fragmentData
        });
    }
    return [
        fragmentData,
        refetch
    ];
}
module.exports = useRefetchableFragment;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useSubscribeToInvalidationState.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useEffect = _require.useEffect, useRef = _require.useRef;
function useSubscribeToInvalidationState(dataIDs, callback) {
    var environment = useRelayEnvironment();
    var disposableRef = useRef(null);
    var stableDataIDs = Array.from(dataIDs).sort().join('');
    useEffect(function() {
        var store = environment.getStore();
        var invalidationState = store.lookupInvalidationState(dataIDs);
        var disposable = store.subscribeToInvalidationState(invalidationState, callback);
        disposableRef.current = disposable;
        return function() {
            return disposable.dispose();
        };
    }, [
        stableDataIDs,
        callback,
        environment
    ]);
    return {
        dispose: function dispose() {
            if (disposableRef.current != null) {
                disposableRef.current.dispose();
            }
        }
    };
}
module.exports = useSubscribeToInvalidationState;
}),
"[project]/node_modules/react-relay/lib/relay-hooks/useSubscription.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js [app-rsc] (ecmascript)"), useEffect = _require.useEffect;
var _require2 = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)"), requestSubscription = _require2.requestSubscription;
function useSubscription(config, requestSubscriptionFn) {
    var actualRequestSubscription = requestSubscriptionFn !== null && requestSubscriptionFn !== void 0 ? requestSubscriptionFn : requestSubscription;
    var environment = useRelayEnvironment();
    useEffect(function() {
        var _actualRequestSubscri = actualRequestSubscription(environment, config), dispose = _actualRequestSubscri.dispose;
        return dispose;
    }, [
        environment,
        config,
        actualRequestSubscription
    ]);
}
module.exports = useSubscription;
}),
"[project]/node_modules/react-relay/lib/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var ReactRelayContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayContext.js [app-rsc] (ecmascript)");
var ReactRelayFragmentContainer = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayFragmentContainer.js [app-rsc] (ecmascript)");
var ReactRelayLocalQueryRenderer = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayLocalQueryRenderer.js [app-rsc] (ecmascript)");
var ReactRelayPaginationContainer = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayPaginationContainer.js [app-rsc] (ecmascript)");
var ReactRelayQueryRenderer = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayQueryRenderer.js [app-rsc] (ecmascript)");
var ReactRelayRefetchContainer = __turbopack_context__.r("[project]/node_modules/react-relay/lib/ReactRelayRefetchContainer.js [app-rsc] (ecmascript)");
var EntryPointContainer = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/EntryPointContainer.react.js [app-rsc] (ecmascript)");
var loadEntryPoint = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/loadEntryPoint.js [app-rsc] (ecmascript)");
var _require = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/loadQuery.js [app-rsc] (ecmascript)"), loadQuery = _require.loadQuery;
var ProfilerContext = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/ProfilerContext.js [app-rsc] (ecmascript)");
var RelayEnvironmentProvider = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/RelayEnvironmentProvider.js [app-rsc] (ecmascript)");
var useClientQuery = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useClientQuery.js [app-rsc] (ecmascript)");
var useEntryPointLoader = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useEntryPointLoader.js [app-rsc] (ecmascript)");
var useFragment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useFragment.js [app-rsc] (ecmascript)");
var useLazyLoadQuery = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useLazyLoadQuery.js [app-rsc] (ecmascript)");
var useMutation = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useMutation.js [app-rsc] (ecmascript)");
var usePaginationFragment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/usePaginationFragment.js [app-rsc] (ecmascript)");
var usePrefetchableForwardPaginationFragment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/usePrefetchableForwardPaginationFragment.js [app-rsc] (ecmascript)");
var usePreloadedQuery = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/usePreloadedQuery.js [app-rsc] (ecmascript)");
var useQueryLoader = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useQueryLoader.js [app-rsc] (ecmascript)");
var useRefetchableFragment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRefetchableFragment.js [app-rsc] (ecmascript)");
var useRelayEnvironment = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useRelayEnvironment.js [app-rsc] (ecmascript)");
var useSubscribeToInvalidationState = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useSubscribeToInvalidationState.js [app-rsc] (ecmascript)");
var useSubscription = __turbopack_context__.r("[project]/node_modules/react-relay/lib/relay-hooks/useSubscription.js [app-rsc] (ecmascript)");
var RelayRuntime = __turbopack_context__.r("[project]/node_modules/relay-runtime/index.js [app-rsc] (ecmascript)");
module.exports = {
    ConnectionHandler: RelayRuntime.ConnectionHandler,
    QueryRenderer: ReactRelayQueryRenderer,
    LocalQueryRenderer: ReactRelayLocalQueryRenderer,
    MutationTypes: RelayRuntime.MutationTypes,
    RangeOperations: RelayRuntime.RangeOperations,
    ReactRelayContext: ReactRelayContext,
    applyOptimisticMutation: RelayRuntime.applyOptimisticMutation,
    commitLocalUpdate: RelayRuntime.commitLocalUpdate,
    commitMutation: RelayRuntime.commitMutation,
    createFragmentContainer: ReactRelayFragmentContainer.createContainer,
    createPaginationContainer: ReactRelayPaginationContainer.createContainer,
    createRefetchContainer: ReactRelayRefetchContainer.createContainer,
    fetchQuery_DEPRECATED: RelayRuntime.fetchQuery_DEPRECATED,
    graphql: RelayRuntime.graphql,
    readInlineData: RelayRuntime.readInlineData,
    requestSubscription: RelayRuntime.requestSubscription,
    EntryPointContainer: EntryPointContainer,
    RelayEnvironmentProvider: RelayEnvironmentProvider,
    ProfilerContext: ProfilerContext,
    fetchQuery: RelayRuntime.fetchQuery,
    loadQuery: loadQuery,
    loadEntryPoint: loadEntryPoint,
    useClientQuery: useClientQuery,
    useFragment: useFragment,
    useLazyLoadQuery: useLazyLoadQuery,
    useEntryPointLoader: useEntryPointLoader,
    useQueryLoader: useQueryLoader,
    useMutation: useMutation,
    usePaginationFragment: usePaginationFragment,
    usePreloadedQuery: usePreloadedQuery,
    useRefetchableFragment: useRefetchableFragment,
    usePrefetchableForwardPaginationFragment: usePrefetchableForwardPaginationFragment,
    useRelayEnvironment: useRelayEnvironment,
    useSubscribeToInvalidationState: useSubscribeToInvalidationState,
    useSubscription: useSubscription
};
}),
"[project]/node_modules/react-relay/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Relay v20.1.1
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ module.exports = __turbopack_context__.r("[project]/node_modules/react-relay/lib/index.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/next/dist/esm/build/templates/app-page.js?page=/page { GLOBAL_ERROR_MODULE => \"[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-rsc] (ecmascript, Next.js Server Component)\", MODULE_0 => \"[project]/app/layout.tsx [app-rsc] (ecmascript, Next.js Server Component)\", MODULE_1 => \"[project]/node_modules/next/dist/client/components/builtin/not-found.js [app-rsc] (ecmascript, Next.js Server Component)\", MODULE_2 => \"[project]/node_modules/next/dist/client/components/builtin/forbidden.js [app-rsc] (ecmascript, Next.js Server Component)\", MODULE_3 => \"[project]/node_modules/next/dist/client/components/builtin/unauthorized.js [app-rsc] (ecmascript, Next.js Server Component)\", MODULE_4 => \"[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-rsc] (ecmascript, Next.js Server Component)\", MODULE_5 => \"[project]/app/page.tsx [app-rsc] (ecmascript, Next.js Server Component)\" } [app-rsc] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__next_app__",
    ()=>__next_app__,
    "handler",
    ()=>handler,
    "routeModule",
    ()=>routeModule
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$module$2e$compiled$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/route-modules/app-page/module.compiled.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/route-kind.js [app-rsc] (ecmascript, Next.js server utility)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$instrumentation$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/instrumentation/utils.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/tracer.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request-meta.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/trace/constants.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$interop$2d$default$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/interop-default.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$strip$2d$flight$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/strip-flight-headers.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$base$2d$http$2f$node$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/base-http/node.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$experimental$2f$ppr$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/experimental/ppr.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$fallback$2d$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/request/fallback-params.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$manifests$2d$singleton$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/manifests-singleton.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$streaming$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/streaming-metadata.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$app$2d$paths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/app-paths.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$server$2d$action$2d$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/lib/server-action-request-meta.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/app-router-headers.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$is$2d$bot$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/is-bot.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/index.js [app-rsc] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/response-cache/types.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$fallback$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/fallback.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/render-result.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/constants.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/stream-utils/encoded-tags.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$send$2d$payload$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/send-payload.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$shared$2f$lib$2f$no$2d$fallback$2d$error$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$shared$2f$lib$2f$no$2d$fallback$2d$error$2e$external$2e$js$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$global$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-rsc] (ecmascript, Next.js Server Component)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript, Next.js server utility) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript, Next.js server utility)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$redirect$2d$status$2d$code$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/client/components/redirect-status-code.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/invariant-error.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/lib/scheduler.js [app-rsc] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$interception$2d$routes$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/shared/lib/router/utils/interception-routes.js [app-rsc] (ecmascript)");
const __TURBOPACK__layout__$23$0__ = ()=>__turbopack_context__.r("[project]/app/layout.tsx [app-rsc] (ecmascript, Next.js Server Component)");
const __TURBOPACK__not$2d$found__$23$1__ = ()=>__turbopack_context__.r("[project]/node_modules/next/dist/client/components/builtin/not-found.js [app-rsc] (ecmascript, Next.js Server Component)");
const __TURBOPACK__forbidden__$23$2__ = ()=>__turbopack_context__.r("[project]/node_modules/next/dist/client/components/builtin/forbidden.js [app-rsc] (ecmascript, Next.js Server Component)");
const __TURBOPACK__unauthorized__$23$3__ = ()=>__turbopack_context__.r("[project]/node_modules/next/dist/client/components/builtin/unauthorized.js [app-rsc] (ecmascript, Next.js Server Component)");
const __TURBOPACK__global$2d$error__$23$4__ = ()=>__turbopack_context__.r("[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-rsc] (ecmascript, Next.js Server Component)");
const __TURBOPACK__page__$23$5__ = ()=>__turbopack_context__.r("[project]/app/page.tsx [app-rsc] (ecmascript, Next.js Server Component)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
// We inject the tree and pages here so that we can use them in the route
// module.
const tree = [
    "",
    {
        "children": [
            "__PAGE__",
            {},
            {
                metadata: {},
                "page": [
                    __TURBOPACK__page__$23$5__,
                    "[project]/app/page.tsx"
                ]
            }
        ]
    },
    {
        "layout": [
            __TURBOPACK__layout__$23$0__,
            "[project]/app/layout.tsx"
        ],
        "not-found": [
            __TURBOPACK__not$2d$found__$23$1__,
            "[project]/node_modules/next/dist/client/components/builtin/not-found.js"
        ],
        "forbidden": [
            __TURBOPACK__forbidden__$23$2__,
            "[project]/node_modules/next/dist/client/components/builtin/forbidden.js"
        ],
        "unauthorized": [
            __TURBOPACK__unauthorized__$23$3__,
            "[project]/node_modules/next/dist/client/components/builtin/unauthorized.js"
        ],
        "global-error": [
            __TURBOPACK__global$2d$error__$23$4__,
            "[project]/node_modules/next/dist/client/components/builtin/global-error.js"
        ]
    }
];
;
;
const __next_app_require__ = __turbopack_context__.r.bind(__turbopack_context__);
const __next_app_load_chunk__ = __turbopack_context__.l.bind(__turbopack_context__);
const __next_app__ = {
    require: __next_app_require__,
    loadChunk: __next_app_load_chunk__
};
;
;
;
;
;
;
const routeModule = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$modules$2f$app$2d$page$2f$module$2e$compiled$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AppPageRouteModule"]({
    definition: {
        kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["RouteKind"].APP_PAGE,
        page: "/page",
        pathname: "/",
        // The following aren't used in production.
        bundlePath: '',
        filename: '',
        appPaths: []
    },
    userland: {
        loaderTree: tree
    },
    distDir: ("TURBOPACK compile-time value", ".next\\dev") || '',
    relativeProjectDir: ("TURBOPACK compile-time value", "") || ''
});
async function handler(req, res, ctx) {
    var _this;
    if (routeModule.isDev) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addRequestMeta"])(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());
    }
    const isMinimalMode = Boolean(("TURBOPACK compile-time value", false) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'minimalMode'));
    let srcPage = "/page";
    // turbopack doesn't normalize `/index` in the page name
    // so we need to to process dynamic routes properly
    // TODO: fix turbopack providing differing value from webpack
    if ("TURBOPACK compile-time truthy", 1) {
        srcPage = srcPage.replace(/\/index$/, '') || '/';
    } else if (srcPage === '/index') {
        // we always normalize /index specifically
        srcPage = '/';
    }
    const multiZoneDraftMode = ("TURBOPACK compile-time value", false);
    const prepareResult = await routeModule.prepare(req, res, {
        srcPage,
        multiZoneDraftMode
    });
    if (!prepareResult) {
        res.statusCode = 400;
        res.end('Bad Request');
        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());
        return null;
    }
    const { buildId, query, params, pageIsDynamic, buildManifest, nextFontManifest, reactLoadableManifest, serverActionsManifest, clientReferenceManifest, subresourceIntegrityManifest, prerenderManifest, isDraftMode, resolvedPathname, revalidateOnlyGenerated, routerServerContext, nextConfig, parsedUrl, interceptionRoutePatterns, deploymentId } = prepareResult;
    const normalizedSrcPage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$app$2d$paths$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["normalizeAppPath"])(srcPage);
    let { isOnDemandRevalidate } = prepareResult;
    // We use the resolvedPathname instead of the parsedUrl.pathname because it
    // is not rewritten as resolvedPathname is. This will ensure that the correct
    // prerender info is used instead of using the original pathname as the
    // source. If however PPR is enabled and cacheComponents is disabled, we
    // treat the pathname as dynamic. Currently, there's a bug in the PPR
    // implementation that incorrectly leaves %%drp placeholders in the output of
    // parallel routes. This is addressed with cacheComponents.
    const prerenderInfo = nextConfig.experimental.ppr && !nextConfig.cacheComponents && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$interception$2d$routes$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isInterceptionRouteAppPath"])(resolvedPathname) ? null : routeModule.match(resolvedPathname, prerenderManifest);
    const isPrerendered = !!prerenderManifest.routes[resolvedPathname];
    const userAgent = req.headers['user-agent'] || '';
    const botType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$is$2d$bot$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getBotType"])(userAgent);
    const isHtmlBot = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$streaming$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["isHtmlBotRequest"])(req);
    /**
   * If true, this indicates that the request being made is for an app
   * prefetch request.
   */ const isPrefetchRSCRequest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'isPrefetchRSCRequest') ?? req.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_ROUTER_PREFETCH_HEADER"]] === '1' // exclude runtime prefetches, which use '2'
    ;
    // NOTE: Don't delete headers[RSC] yet, it still needs to be used in renderToHTML later
    const isRSCRequest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'isRSCRequest') ?? Boolean(req.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RSC_HEADER"]]);
    const isPossibleServerAction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$server$2d$action$2d$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getIsPossibleServerAction"])(req);
    /**
   * If the route being rendered is an app page, and the ppr feature has been
   * enabled, then the given route _could_ support PPR.
   */ const couldSupportPPR = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$experimental$2f$ppr$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["checkIsAppPPREnabled"])(nextConfig.experimental.ppr);
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'postponed') && couldSupportPPR && req.headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_RESUME_HEADER"]] === '1' && req.method === 'POST') {
        // Decode the postponed state from the request body, it will come as
        // an array of buffers, so collect them and then concat them to form
        // the string.
        const body = [];
        for await (const chunk of req){
            body.push(chunk);
        }
        const postponed = Buffer.concat(body).toString('utf8');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["addRequestMeta"])(req, 'postponed', postponed);
    }
    // When enabled, this will allow the use of the `?__nextppronly` query to
    // enable debugging of the static shell.
    const hasDebugStaticShellQuery = ("TURBOPACK compile-time value", false) === '1' && typeof query.__nextppronly !== 'undefined' && couldSupportPPR;
    // When enabled, this will allow the use of the `?__nextppronly` query
    // to enable debugging of the fallback shell.
    const hasDebugFallbackShellQuery = hasDebugStaticShellQuery && query.__nextppronly === 'fallback';
    // This page supports PPR if it is marked as being `PARTIALLY_STATIC` in the
    // prerender manifest and this is an app page.
    const isRoutePPREnabled = couldSupportPPR && (((_this = prerenderManifest.routes[normalizedSrcPage] ?? prerenderManifest.dynamicRoutes[normalizedSrcPage]) == null ? void 0 : _this.renderingMode) === 'PARTIALLY_STATIC' || // Ideally we'd want to check the appConfig to see if this page has PPR
    // enabled or not, but that would require plumbing the appConfig through
    // to the server during development. We assume that the page supports it
    // but only during development.
    hasDebugStaticShellQuery && (routeModule.isDev === true || (routerServerContext == null ? void 0 : routerServerContext.experimentalTestProxy) === true));
    const isDebugStaticShell = hasDebugStaticShellQuery && isRoutePPREnabled;
    // We should enable debugging dynamic accesses when the static shell
    // debugging has been enabled and we're also in development mode.
    const isDebugDynamicAccesses = isDebugStaticShell && routeModule.isDev === true;
    const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled;
    // If we're in minimal mode, then try to get the postponed information from
    // the request metadata. If available, use it for resuming the postponed
    // render.
    const minimalPostponed = isRoutePPREnabled ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'postponed') : undefined;
    // If PPR is enabled, and this is a RSC request (but not a prefetch), then
    // we can use this fact to only generate the flight data for the request
    // because we can't cache the HTML (as it's also dynamic).
    let isDynamicRSCRequest = isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest;
    // During a PPR revalidation, the RSC request is not dynamic if we do not have the postponed data.
    // We only attach the postponed data during a resume. If there's no postponed data, then it must be a revalidation.
    // This is to ensure that we don't bypass the cache during a revalidation.
    if (isMinimalMode) {
        isDynamicRSCRequest = isDynamicRSCRequest && !!minimalPostponed;
    }
    // Need to read this before it's stripped by stripFlightHeaders. We don't
    // need to transfer it to the request meta because it's only read
    // within this function; the static segment data should have already been
    // generated, so we will always either return a static response or a 404.
    const segmentPrefetchHeader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'segmentPrefetchRSCRequest');
    // TODO: investigate existing bug with shouldServeStreamingMetadata always
    // being true for a revalidate due to modifying the base-server this.renderOpts
    // when fixing this to correct logic it causes hydration issue since we set
    // serveStreamingMetadata to true during export
    const serveStreamingMetadata = isHtmlBot && isRoutePPREnabled ? false : !userAgent ? true : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$streaming$2d$metadata$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["shouldServeStreamingMetadata"])(userAgent, nextConfig.htmlLimitedBots);
    const isSSG = Boolean((prerenderInfo || isPrerendered || prerenderManifest.routes[normalizedSrcPage]) && // If this is a html bot request and PPR is enabled, then we don't want
    // to serve a static response.
    !(isHtmlBot && isRoutePPREnabled));
    // When a page supports cacheComponents, we can support RDC for Navigations
    const supportsRDCForNavigations = isRoutePPREnabled && nextConfig.cacheComponents === true;
    // In development, we always want to generate dynamic HTML.
    const supportsDynamicResponse = // a data request, in which case we only produce static HTML.
    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports
    // dynamic HTML.
    !isSSG || // If this request has provided postponed data, it supports dynamic
    // HTML.
    typeof minimalPostponed === 'string' || // If this handler supports onCacheEntryV2, then we can only support
    // dynamic responses if it's a dynamic RSC request and not in minimal mode. If it
    // doesn't support it we must fallback to the default behavior.
    (supportsRDCForNavigations && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'onCacheEntryV2') ? // RSC request, we'll pass the minimal postponed data to the render
    // which will trigger the `supportsDynamicResponse` to be true.
    isDynamicRSCRequest && !isMinimalMode : isDynamicRSCRequest);
    // When html bots request PPR page, perform the full dynamic rendering.
    const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled;
    let ssgCacheKey = null;
    if (!isDraftMode && isSSG && !supportsDynamicResponse && !isPossibleServerAction && !minimalPostponed && !isDynamicRSCRequest) {
        ssgCacheKey = resolvedPathname;
    }
    // the staticPathKey differs from ssgCacheKey since
    // ssgCacheKey is null in dev since we're always in "dynamic"
    // mode in dev to bypass the cache, but we still need to honor
    // dynamicParams = false in dev mode
    let staticPathKey = ssgCacheKey;
    if (!staticPathKey && routeModule.isDev) {
        staticPathKey = resolvedPathname;
    }
    // If this is a request for an app path that should be statically generated
    // and we aren't in the edge runtime, strip the flight headers so it will
    // generate the static response.
    if (!routeModule.isDev && !isDraftMode && isSSG && isRSCRequest && !isDynamicRSCRequest) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$strip$2d$flight$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["stripFlightHeaders"])(req.headers);
    }
    const ComponentMod = {
        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__,
        tree,
        GlobalError: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$global$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29$__["default"],
        handler,
        routeModule,
        __next_app__
    };
    // Before rendering (which initializes component tree modules), we have to
    // set the reference manifests to our global store so Server Action's
    // encryption util can access to them at the top level of the page module.
    if (serverActionsManifest && clientReferenceManifest) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$manifests$2d$singleton$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["setManifestsSingleton"])({
            page: srcPage,
            clientReferenceManifest,
            serverActionsManifest
        });
    }
    const method = req.method || 'GET';
    const tracer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getTracer"])();
    const activeSpan = tracer.getActiveScopeSpan();
    const render404 = async ()=>{
        // TODO: should route-module itself handle rendering the 404
        if (routerServerContext == null ? void 0 : routerServerContext.render404) {
            await routerServerContext.render404(req, res, parsedUrl, false);
        } else {
            res.end('This page could not be found');
        }
        return null;
    };
    try {
        const varyHeader = routeModule.getVaryHeader(resolvedPathname, interceptionRoutePatterns);
        res.setHeader('Vary', varyHeader);
        const invokeRouteModule = async (span, context)=>{
            const nextReq = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$base$2d$http$2f$node$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NodeNextRequest"](req);
            const nextRes = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$base$2d$http$2f$node$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NodeNextResponse"](res);
            return routeModule.render(nextReq, nextRes, context).finally(()=>{
                if (!span) return;
                span.setAttributes({
                    'http.status_code': res.statusCode,
                    'next.rsc': false
                });
                const rootSpanAttributes = tracer.getRootSpanAttributes();
                // We were unable to get attributes, probably OTEL is not enabled
                if (!rootSpanAttributes) {
                    return;
                }
                if (rootSpanAttributes.get('next.span_type') !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BaseServerSpan"].handleRequest) {
                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);
                    return;
                }
                const route = rootSpanAttributes.get('next.route');
                if (route) {
                    const name = `${method} ${route}`;
                    span.setAttributes({
                        'next.route': route,
                        'http.route': route,
                        'next.span_name': name
                    });
                    span.updateName(name);
                } else {
                    span.updateName(`${method} ${srcPage}`);
                }
            });
        };
        const incrementalCache = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'incrementalCache');
        const doRender = async ({ span, postponed, fallbackRouteParams, forceStaticRender })=>{
            const context = {
                query,
                params,
                page: normalizedSrcPage,
                sharedContext: {
                    buildId
                },
                serverComponentsHmrCache: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'serverComponentsHmrCache'),
                fallbackRouteParams,
                renderOpts: {
                    App: ()=>null,
                    Document: ()=>null,
                    pageConfig: {},
                    ComponentMod,
                    Component: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$interop$2d$default$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["interopDefault"])(ComponentMod),
                    params,
                    routeModule,
                    page: srcPage,
                    postponed,
                    shouldWaitOnAllReady,
                    serveStreamingMetadata,
                    supportsDynamicResponse: typeof postponed === 'string' || supportsDynamicResponse,
                    buildManifest,
                    nextFontManifest,
                    reactLoadableManifest,
                    subresourceIntegrityManifest,
                    setCacheStatus: routerServerContext == null ? void 0 : routerServerContext.setCacheStatus,
                    setIsrStatus: routerServerContext == null ? void 0 : routerServerContext.setIsrStatus,
                    setReactDebugChannel: routerServerContext == null ? void 0 : routerServerContext.setReactDebugChannel,
                    sendErrorsToBrowser: routerServerContext == null ? void 0 : routerServerContext.sendErrorsToBrowser,
                    dir: ("TURBOPACK compile-time truthy", 1) ? require('path').join(/* turbopackIgnore: true */ process.cwd(), routeModule.relativeProjectDir) : "TURBOPACK unreachable",
                    isDraftMode,
                    botType,
                    isOnDemandRevalidate,
                    isPossibleServerAction,
                    assetPrefix: nextConfig.assetPrefix,
                    nextConfigOutput: nextConfig.output,
                    crossOrigin: nextConfig.crossOrigin,
                    trailingSlash: nextConfig.trailingSlash,
                    images: nextConfig.images,
                    previewProps: prerenderManifest.preview,
                    deploymentId: deploymentId,
                    enableTainting: nextConfig.experimental.taint,
                    htmlLimitedBots: nextConfig.htmlLimitedBots,
                    reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,
                    multiZoneDraftMode,
                    incrementalCache,
                    cacheLifeProfiles: nextConfig.cacheLife,
                    basePath: nextConfig.basePath,
                    serverActions: nextConfig.experimental.serverActions,
                    ...isDebugStaticShell || isDebugDynamicAccesses || isDebugFallbackShell ? {
                        nextExport: true,
                        supportsDynamicResponse: false,
                        isStaticGeneration: true,
                        isDebugDynamicAccesses: isDebugDynamicAccesses
                    } : {},
                    cacheComponents: Boolean(nextConfig.cacheComponents),
                    experimental: {
                        isRoutePPREnabled,
                        expireTime: nextConfig.expireTime,
                        staleTimes: nextConfig.experimental.staleTimes,
                        dynamicOnHover: Boolean(nextConfig.experimental.dynamicOnHover),
                        inlineCss: Boolean(nextConfig.experimental.inlineCss),
                        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),
                        clientTraceMetadata: nextConfig.experimental.clientTraceMetadata || [],
                        clientParamParsingOrigins: nextConfig.experimental.clientParamParsingOrigins
                    },
                    waitUntil: ctx.waitUntil,
                    onClose: (cb)=>{
                        res.on('close', cb);
                    },
                    onAfterTaskError: ()=>{},
                    onInstrumentationRequestError: (error, _request, errorContext, silenceLog)=>routeModule.onRequestError(req, error, errorContext, silenceLog, routerServerContext),
                    err: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'invokeError'),
                    dev: routeModule.isDev
                }
            };
            if (isDebugStaticShell || isDebugDynamicAccesses) {
                context.renderOpts.nextExport = true;
                context.renderOpts.supportsDynamicResponse = false;
                context.renderOpts.isDebugDynamicAccesses = isDebugDynamicAccesses;
            }
            // When we're revalidating in the background, we should not allow dynamic
            // responses.
            if (forceStaticRender) {
                context.renderOpts.supportsDynamicResponse = false;
            }
            const result = await invokeRouteModule(span, context);
            const { metadata } = result;
            const { cacheControl, headers = {}, fetchTags: cacheTags, fetchMetrics } = metadata;
            if (cacheTags) {
                headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_CACHE_TAGS_HEADER"]] = cacheTags;
            }
            // Pull any fetch metrics from the render onto the request.
            ;
            req.fetchMetrics = fetchMetrics;
            // we don't throw static to dynamic errors in dev as isSSG
            // is a best guess in dev since we don't have the prerender pass
            // to know whether the path is actually static or not
            if (isSSG && (cacheControl == null ? void 0 : cacheControl.revalidate) === 0 && !routeModule.isDev && !isRoutePPREnabled) {
                const staticBailoutInfo = metadata.staticBailoutInfo;
                const err = Object.defineProperty(new Error(`Page changed from static to dynamic at runtime ${resolvedPathname}${(staticBailoutInfo == null ? void 0 : staticBailoutInfo.description) ? `, reason: ${staticBailoutInfo.description}` : ``}` + `\nsee more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`), "__NEXT_ERROR_CODE", {
                    value: "E132",
                    enumerable: false,
                    configurable: true
                });
                if (staticBailoutInfo == null ? void 0 : staticBailoutInfo.stack) {
                    const stack = staticBailoutInfo.stack;
                    err.stack = err.message + stack.substring(stack.indexOf('\n'));
                }
                throw err;
            }
            return {
                value: {
                    kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].APP_PAGE,
                    html: result,
                    headers,
                    rscData: metadata.flightData,
                    postponed: metadata.postponed,
                    status: metadata.statusCode,
                    segmentData: metadata.segmentData
                },
                cacheControl
            };
        };
        const responseGenerator = async ({ hasResolved, previousCacheEntry: previousIncrementalCacheEntry, isRevalidating, span, forceStaticRender = false })=>{
            const isProduction = routeModule.isDev === false;
            const didRespond = hasResolved || res.writableEnded;
            // skip on-demand revalidate if cache is not present and
            // revalidate-if-generated is set
            if (isOnDemandRevalidate && revalidateOnlyGenerated && !previousIncrementalCacheEntry && !isMinimalMode) {
                if (routerServerContext == null ? void 0 : routerServerContext.render404) {
                    await routerServerContext.render404(req, res);
                } else {
                    res.statusCode = 404;
                    res.end('This page could not be found');
                }
                return null;
            }
            let fallbackMode;
            if (prerenderInfo) {
                fallbackMode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$fallback$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["parseFallbackField"])(prerenderInfo.fallback);
            }
            // When serving a HTML bot request, we want to serve a blocking render and
            // not the prerendered page. This ensures that the correct content is served
            // to the bot in the head.
            if (fallbackMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$fallback$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FallbackMode"].PRERENDER && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$router$2f$utils$2f$is$2d$bot$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isBot"])(userAgent)) {
                if (!isRoutePPREnabled || isHtmlBot) {
                    fallbackMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$fallback$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FallbackMode"].BLOCKING_STATIC_RENDER;
                }
            }
            if ((previousIncrementalCacheEntry == null ? void 0 : previousIncrementalCacheEntry.isStale) === -1) {
                isOnDemandRevalidate = true;
            }
            // TODO: adapt for PPR
            // only allow on-demand revalidate for fallback: true/blocking
            // or for prerendered fallback: false paths
            if (isOnDemandRevalidate && (fallbackMode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$fallback$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FallbackMode"].NOT_FOUND || previousIncrementalCacheEntry)) {
                fallbackMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$fallback$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FallbackMode"].BLOCKING_STATIC_RENDER;
            }
            if (!isMinimalMode && fallbackMode !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$fallback$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FallbackMode"].BLOCKING_STATIC_RENDER && staticPathKey && !didRespond && !isDraftMode && pageIsDynamic && (isProduction || !isPrerendered)) {
                // if the page has dynamicParams: false and this pathname wasn't
                // prerendered trigger the no fallback handling
                if (// getStaticPaths.
                (isProduction || prerenderInfo) && // When fallback isn't present, abort this render so we 404
                fallbackMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$fallback$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["FallbackMode"].NOT_FOUND) {
                    if (nextConfig.experimental.adapterPath) {
                        return await render404();
                    }
                    throw new __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$shared$2f$lib$2f$no$2d$fallback$2d$error$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$shared$2f$lib$2f$no$2d$fallback$2d$error$2e$external$2e$js$2c$__cjs$29$__["NoFallbackError"]();
                }
                // When cacheComponents is enabled, we can use the fallback
                // response if the request is not a dynamic RSC request because the
                // RSC data when this feature flag is enabled does not contain any
                // param references. Without this feature flag enabled, the RSC data
                // contains param references, and therefore we can't use the fallback.
                if (isRoutePPREnabled && (nextConfig.cacheComponents ? !isDynamicRSCRequest : !isRSCRequest)) {
                    const cacheKey = isProduction && typeof (prerenderInfo == null ? void 0 : prerenderInfo.fallback) === 'string' ? prerenderInfo.fallback : normalizedSrcPage;
                    const fallbackRouteParams = // can use the manifest fallback route params.
                    isProduction && (prerenderInfo == null ? void 0 : prerenderInfo.fallbackRouteParams) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$fallback$2d$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createOpaqueFallbackRouteParams"])(prerenderInfo.fallbackRouteParams) : isDebugFallbackShell ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$fallback$2d$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getFallbackRouteParams"])(normalizedSrcPage, routeModule) : null;
                    // We use the response cache here to handle the revalidation and
                    // management of the fallback shell.
                    const fallbackResponse = await routeModule.handleResponse({
                        cacheKey,
                        req,
                        nextConfig,
                        routeKind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["RouteKind"].APP_PAGE,
                        isFallback: true,
                        prerenderManifest,
                        isRoutePPREnabled,
                        responseGenerator: async ()=>doRender({
                                span,
                                // We pass `undefined` as rendering a fallback isn't resumed
                                // here.
                                postponed: undefined,
                                fallbackRouteParams,
                                forceStaticRender: false
                            }),
                        waitUntil: ctx.waitUntil,
                        isMinimalMode
                    });
                    // If the fallback response was set to null, then we should return null.
                    if (fallbackResponse === null) return null;
                    // Otherwise, if we did get a fallback response, we should return it.
                    if (fallbackResponse) {
                        // Remove the cache control from the response to prevent it from being
                        // used in the surrounding cache.
                        delete fallbackResponse.cacheControl;
                        return fallbackResponse;
                    }
                }
            }
            // Only requests that aren't revalidating can be resumed. If we have the
            // minimal postponed data, then we should resume the render with it.
            let postponed = !isOnDemandRevalidate && !isRevalidating && minimalPostponed ? minimalPostponed : undefined;
            // If this is a dynamic RSC request, we should use the postponed data from
            // the static render (if available). This ensures that we can utilize the
            // resume data cache (RDC) from the static render to ensure that the data
            // is consistent between the static and dynamic renders.
            if (supportsRDCForNavigations && ("TURBOPACK compile-time value", "nodejs") !== 'edge' && !isMinimalMode && incrementalCache && isDynamicRSCRequest && // We don't typically trigger an on-demand revalidation for dynamic RSC
            // requests, as we're typically revalidating the page in the background
            // instead. However, if the cache entry is stale, we should trigger a
            // background revalidation on dynamic RSC requests. This prevents us
            // from entering an infinite loop of revalidations.
            !forceStaticRender) {
                const incrementalCacheEntry = await incrementalCache.get(resolvedPathname, {
                    kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["IncrementalCacheKind"].APP_PAGE,
                    isRoutePPREnabled: true,
                    isFallback: false
                });
                // If the cache entry is found, we should use the postponed data from
                // the cache.
                if (incrementalCacheEntry && incrementalCacheEntry.value && incrementalCacheEntry.value.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].APP_PAGE) {
                    // CRITICAL: we're assigning the postponed data from the cache entry
                    // here as we're using the RDC to resume the render.
                    postponed = incrementalCacheEntry.value.postponed;
                    // If the cache entry is stale, we should trigger a background
                    // revalidation so that subsequent requests will get a fresh response.
                    if (incrementalCacheEntry && // We want to trigger this flow if the cache entry is stale and if
                    // the requested revalidation flow is either foreground or
                    // background.
                    (incrementalCacheEntry.isStale === -1 || incrementalCacheEntry.isStale === true)) {
                        // We want to schedule this on the next tick to ensure that the
                        // render is not blocked on it.
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$scheduler$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["scheduleOnNextTick"])(async ()=>{
                            const responseCache = routeModule.getResponseCache(req);
                            try {
                                await responseCache.revalidate(resolvedPathname, incrementalCache, isRoutePPREnabled, false, (c)=>responseGenerator({
                                        ...c,
                                        // CRITICAL: we need to set this to true as we're
                                        // revalidating in the background and typically this dynamic
                                        // RSC request is not treated as static.
                                        forceStaticRender: true
                                    }), // previous cache entry here (which is stale) will switch on
                                // isOnDemandRevalidate and break the prerendering.
                                null, hasResolved, ctx.waitUntil);
                            } catch (err) {
                                console.error('Error revalidating the page in the background', err);
                            }
                        });
                    }
                }
            }
            // When we're in minimal mode, if we're trying to debug the static shell,
            // we should just return nothing instead of resuming the dynamic render.
            if ((isDebugStaticShell || isDebugDynamicAccesses) && typeof postponed !== 'undefined') {
                return {
                    cacheControl: {
                        revalidate: 1,
                        expire: undefined
                    },
                    value: {
                        kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].PAGES,
                        html: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].EMPTY,
                        pageData: {},
                        headers: undefined,
                        status: undefined
                    }
                };
            }
            const fallbackRouteParams = // can use the manifest fallback route params if we need to render the
            // fallback shell.
            isProduction && (prerenderInfo == null ? void 0 : prerenderInfo.fallbackRouteParams) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'renderFallbackShell') ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$fallback$2d$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["createOpaqueFallbackRouteParams"])(prerenderInfo.fallbackRouteParams) : isDebugFallbackShell ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2f$fallback$2d$params$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getFallbackRouteParams"])(normalizedSrcPage, routeModule) : null;
            // Perform the render.
            return doRender({
                span,
                postponed,
                fallbackRouteParams,
                forceStaticRender
            });
        };
        const handleResponse = async (span)=>{
            var _cacheEntry_value, _cachedData_headers;
            const cacheEntry = await routeModule.handleResponse({
                cacheKey: ssgCacheKey,
                responseGenerator: (c)=>responseGenerator({
                        span,
                        ...c
                    }),
                routeKind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$route$2d$kind$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["RouteKind"].APP_PAGE,
                isOnDemandRevalidate,
                isRoutePPREnabled,
                req,
                nextConfig,
                prerenderManifest,
                waitUntil: ctx.waitUntil,
                isMinimalMode
            });
            if (isDraftMode) {
                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');
            }
            // In dev, we should not cache pages for any reason.
            if (routeModule.isDev) {
                res.setHeader('Cache-Control', 'no-store, must-revalidate');
            }
            if (!cacheEntry) {
                if (ssgCacheKey) {
                    // A cache entry might not be generated if a response is written
                    // in `getInitialProps` or `getServerSideProps`, but those shouldn't
                    // have a cache key. If we do have a cache key but we don't end up
                    // with a cache entry, then either Next.js or the application has a
                    // bug that needs fixing.
                    throw Object.defineProperty(new Error('invariant: cache entry required but not generated'), "__NEXT_ERROR_CODE", {
                        value: "E62",
                        enumerable: false,
                        configurable: true
                    });
                }
                return null;
            }
            if (((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].APP_PAGE) {
                var _cacheEntry_value1;
                throw Object.defineProperty(new Error(`Invariant app-page handler received invalid cache entry ${(_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), "__NEXT_ERROR_CODE", {
                    value: "E707",
                    enumerable: false,
                    configurable: true
                });
            }
            const didPostpone = typeof cacheEntry.value.postponed === 'string';
            if (isSSG && // We don't want to send a cache header for requests that contain dynamic
            // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC
            // request, then we should set the cache header.
            !isDynamicRSCRequest && (!didPostpone || isPrefetchRSCRequest)) {
                if (!isMinimalMode) {
                    // set x-nextjs-cache header to match the header
                    // we set for the image-optimizer
                    res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');
                }
                // Set a header used by the client router to signal the response is static
                // and should respect the `static` cache staleTime value.
                res.setHeader(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_IS_PRERENDER_HEADER"], '1');
            }
            const { value: cachedData } = cacheEntry;
            // Coerce the cache control parameter from the render.
            let cacheControl;
            // If this is a resume request in minimal mode it is streamed with dynamic
            // content and should not be cached.
            if (minimalPostponed) {
                cacheControl = {
                    revalidate: 0,
                    expire: undefined
                };
            } else if (isDynamicRSCRequest) {
                cacheControl = {
                    revalidate: 0,
                    expire: undefined
                };
            } else if (!routeModule.isDev) {
                // If this is a preview mode request, we shouldn't cache it
                if (isDraftMode) {
                    cacheControl = {
                        revalidate: 0,
                        expire: undefined
                    };
                } else if (!isSSG) {
                    if (!res.getHeader('Cache-Control')) {
                        cacheControl = {
                            revalidate: 0,
                            expire: undefined
                        };
                    }
                } else if (cacheEntry.cacheControl) {
                    // If the cache entry has a cache control with a revalidate value that's
                    // a number, use it.
                    if (typeof cacheEntry.cacheControl.revalidate === 'number') {
                        var _cacheEntry_cacheControl;
                        if (cacheEntry.cacheControl.revalidate < 1) {
                            throw Object.defineProperty(new Error(`Invalid revalidate configuration provided: ${cacheEntry.cacheControl.revalidate} < 1`), "__NEXT_ERROR_CODE", {
                                value: "E22",
                                enumerable: false,
                                configurable: true
                            });
                        }
                        cacheControl = {
                            revalidate: cacheEntry.cacheControl.revalidate,
                            expire: ((_cacheEntry_cacheControl = cacheEntry.cacheControl) == null ? void 0 : _cacheEntry_cacheControl.expire) ?? nextConfig.expireTime
                        };
                    } else {
                        cacheControl = {
                            revalidate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CACHE_ONE_YEAR"],
                            expire: undefined
                        };
                    }
                }
            }
            cacheEntry.cacheControl = cacheControl;
            if (typeof segmentPrefetchHeader === 'string' && (cachedData == null ? void 0 : cachedData.kind) === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].APP_PAGE && cachedData.segmentData) {
                var _cachedData_headers1;
                // This is a prefetch request issued by the client Segment Cache. These
                // should never reach the application layer (lambda). We should either
                // respond from the cache (HIT) or respond with 204 No Content (MISS).
                // Set a header to indicate that PPR is enabled for this route. This
                // lets the client distinguish between a regular cache miss and a cache
                // miss due to PPR being disabled. In other contexts this header is used
                // to indicate that the response contains dynamic data, but here we're
                // only using it to indicate that the feature is enabled  the segment
                // response itself contains whether the data is dynamic.
                res.setHeader(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_DID_POSTPONE_HEADER"], '2');
                // Add the cache tags header to the response if it exists and we're in
                // minimal mode while rendering a static page.
                const tags = (_cachedData_headers1 = cachedData.headers) == null ? void 0 : _cachedData_headers1[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_CACHE_TAGS_HEADER"]];
                if (isMinimalMode && isSSG && tags && typeof tags === 'string') {
                    res.setHeader(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_CACHE_TAGS_HEADER"], tags);
                }
                const matchedSegment = cachedData.segmentData.get(segmentPrefetchHeader);
                if (matchedSegment !== undefined) {
                    // Cache hit
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$send$2d$payload$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sendRenderResult"])({
                        req,
                        res,
                        generateEtags: nextConfig.generateEtags,
                        poweredByHeader: nextConfig.poweredByHeader,
                        result: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].fromStatic(matchedSegment, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RSC_CONTENT_TYPE_HEADER"]),
                        cacheControl: cacheEntry.cacheControl
                    });
                }
                // Cache miss. Either a cache entry for this route has not been generated
                // (which technically should not be possible when PPR is enabled, because
                // at a minimum there should always be a fallback entry) or there's no
                // match for the requested segment. Respond with a 204 No Content. We
                // don't bother to respond with 404, because these requests are only
                // issued as part of a prefetch.
                res.statusCode = 204;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$send$2d$payload$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sendRenderResult"])({
                    req,
                    res,
                    generateEtags: nextConfig.generateEtags,
                    poweredByHeader: nextConfig.poweredByHeader,
                    result: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].EMPTY,
                    cacheControl: cacheEntry.cacheControl
                });
            }
            // If there's a callback for `onCacheEntry`, call it with the cache entry
            // and the revalidate options. If we support RDC for Navigations, we
            // prefer the `onCacheEntryV2` callback. Once RDC for Navigations is the
            // default, we can remove the fallback to `onCacheEntry` as
            // `onCacheEntryV2` is now fully supported.
            const onCacheEntry = supportsRDCForNavigations ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'onCacheEntryV2') ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'onCacheEntry') : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'onCacheEntry');
            if (onCacheEntry) {
                const finished = await onCacheEntry(cacheEntry, {
                    url: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$request$2d$meta$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRequestMeta"])(req, 'initURL') ?? req.url
                });
                if (finished) return null;
            }
            if (cachedData.headers) {
                const headers = {
                    ...cachedData.headers
                };
                if (!isMinimalMode || !isSSG) {
                    delete headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_CACHE_TAGS_HEADER"]];
                }
                for (let [key, value] of Object.entries(headers)){
                    if (typeof value === 'undefined') continue;
                    if (Array.isArray(value)) {
                        for (const v of value){
                            res.appendHeader(key, v);
                        }
                    } else if (typeof value === 'number') {
                        value = value.toString();
                        res.appendHeader(key, value);
                    } else {
                        res.appendHeader(key, value);
                    }
                }
            }
            // Add the cache tags header to the response if it exists and we're in
            // minimal mode while rendering a static page.
            const tags = (_cachedData_headers = cachedData.headers) == null ? void 0 : _cachedData_headers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_CACHE_TAGS_HEADER"]];
            if (isMinimalMode && isSSG && tags && typeof tags === 'string') {
                res.setHeader(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$lib$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_CACHE_TAGS_HEADER"], tags);
            }
            // If the request is a data request, then we shouldn't set the status code
            // from the response because it should always be 200. This should be gated
            // behind the experimental PPR flag.
            if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {
                res.statusCode = cachedData.status;
            }
            // Redirect information is encoded in RSC payload, so we don't need to use redirect status codes
            if (!isMinimalMode && cachedData.status && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$redirect$2d$status$2d$code$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RedirectStatusCode"][cachedData.status] && isRSCRequest) {
                res.statusCode = 200;
            }
            // Mark that the request did postpone.
            if (didPostpone && !isDynamicRSCRequest) {
                res.setHeader(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["NEXT_DID_POSTPONE_HEADER"], '1');
            }
            // we don't go through this block when preview mode is true
            // as preview mode is a dynamic request (bypasses cache) and doesn't
            // generate both HTML and payloads in the same request so continue to just
            // return the generated payload
            if (isRSCRequest && !isDraftMode) {
                // If this is a dynamic RSC request, then stream the response.
                if (typeof cachedData.rscData === 'undefined') {
                    // If the response is not an RSC response, then we can't serve it.
                    if (cachedData.html.contentType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RSC_CONTENT_TYPE_HEADER"]) {
                        if (nextConfig.cacheComponents) {
                            res.statusCode = 404;
                            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$send$2d$payload$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sendRenderResult"])({
                                req,
                                res,
                                generateEtags: nextConfig.generateEtags,
                                poweredByHeader: nextConfig.poweredByHeader,
                                result: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].EMPTY,
                                cacheControl: cacheEntry.cacheControl
                            });
                        } else {
                            // Otherwise this case is not expected.
                            throw Object.defineProperty(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$shared$2f$lib$2f$invariant$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["InvariantError"](`Expected RSC response, got ${cachedData.html.contentType}`), "__NEXT_ERROR_CODE", {
                                value: "E789",
                                enumerable: false,
                                configurable: true
                            });
                        }
                    }
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$send$2d$payload$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sendRenderResult"])({
                        req,
                        res,
                        generateEtags: nextConfig.generateEtags,
                        poweredByHeader: nextConfig.poweredByHeader,
                        result: cachedData.html,
                        cacheControl: cacheEntry.cacheControl
                    });
                }
                // As this isn't a prefetch request, we should serve the static flight
                // data.
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$send$2d$payload$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sendRenderResult"])({
                    req,
                    res,
                    generateEtags: nextConfig.generateEtags,
                    poweredByHeader: nextConfig.poweredByHeader,
                    result: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$render$2d$result$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["default"].fromStatic(cachedData.rscData, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$client$2f$components$2f$app$2d$router$2d$headers$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["RSC_CONTENT_TYPE_HEADER"]),
                    cacheControl: cacheEntry.cacheControl
                });
            }
            // This is a request for HTML data.
            const body = cachedData.html;
            // If there's no postponed state, we should just serve the HTML. This
            // should also be the case for a resume request because it's completed
            // as a server render (rather than a static render).
            if (!didPostpone || isMinimalMode || isRSCRequest) {
                // If we're in test mode, we should add a sentinel chunk to the response
                // that's between the static and dynamic parts so we can compare the
                // chunks and add assertions.
                if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                ;
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$send$2d$payload$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sendRenderResult"])({
                    req,
                    res,
                    generateEtags: nextConfig.generateEtags,
                    poweredByHeader: nextConfig.poweredByHeader,
                    result: body,
                    cacheControl: cacheEntry.cacheControl
                });
            }
            // If we're debugging the static shell or the dynamic API accesses, we
            // should just serve the HTML without resuming the render. The returned
            // HTML will be the static shell so all the Dynamic API's will be used
            // during static generation.
            if (isDebugStaticShell || isDebugDynamicAccesses) {
                // Since we're not resuming the render, we need to at least add the
                // closing body and html tags to create valid HTML.
                body.push(new ReadableStream({
                    start (controller) {
                        controller.enqueue(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$stream$2d$utils$2f$encoded$2d$tags$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["ENCODED_TAGS"].CLOSED.BODY_AND_HTML);
                        controller.close();
                    }
                }));
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$send$2d$payload$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sendRenderResult"])({
                    req,
                    res,
                    generateEtags: nextConfig.generateEtags,
                    poweredByHeader: nextConfig.poweredByHeader,
                    result: body,
                    cacheControl: {
                        revalidate: 0,
                        expire: undefined
                    }
                });
            }
            // If we're in test mode, we should add a sentinel chunk to the response
            // that's between the static and dynamic parts so we can compare the
            // chunks and add assertions.
            if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
            ;
            // This request has postponed, so let's create a new transformer that the
            // dynamic data can pipe to that will attach the dynamic data to the end
            // of the response.
            const transformer = new TransformStream();
            body.push(transformer.readable);
            // Perform the render again, but this time, provide the postponed state.
            // We don't await because we want the result to start streaming now, and
            // we've already chained the transformer's readable to the render result.
            doRender({
                span,
                postponed: cachedData.postponed,
                // This is a resume render, not a fallback render, so we don't need to
                // set this.
                fallbackRouteParams: null,
                forceStaticRender: false
            }).then(async (result)=>{
                var _result_value;
                if (!result) {
                    throw Object.defineProperty(new Error('Invariant: expected a result to be returned'), "__NEXT_ERROR_CODE", {
                        value: "E463",
                        enumerable: false,
                        configurable: true
                    });
                }
                if (((_result_value = result.value) == null ? void 0 : _result_value.kind) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$response$2d$cache$2f$types$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["CachedRouteKind"].APP_PAGE) {
                    var _result_value1;
                    throw Object.defineProperty(new Error(`Invariant: expected a page response, got ${(_result_value1 = result.value) == null ? void 0 : _result_value1.kind}`), "__NEXT_ERROR_CODE", {
                        value: "E305",
                        enumerable: false,
                        configurable: true
                    });
                }
                // Pipe the resume result to the transformer.
                await result.value.html.pipeTo(transformer.writable);
            }).catch((err)=>{
                // An error occurred during piping or preparing the render, abort
                // the transformers writer so we can terminate the stream.
                transformer.writable.abort(err).catch((e)=>{
                    console.error("couldn't abort transformer", e);
                });
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$send$2d$payload$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["sendRenderResult"])({
                req,
                res,
                generateEtags: nextConfig.generateEtags,
                poweredByHeader: nextConfig.poweredByHeader,
                result: body,
                // We don't want to cache the response if it has postponed data because
                // the response being sent to the client it's dynamic parts are streamed
                // to the client on the same request.
                cacheControl: {
                    revalidate: 0,
                    expire: undefined
                }
            });
        };
        // TODO: activeSpan code path is for when wrapped by
        // next-server can be removed when this is no longer used
        if (activeSpan) {
            await handleResponse(activeSpan);
        } else {
            return await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$constants$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["BaseServerSpan"].handleRequest, {
                    spanName: `${method} ${srcPage}`,
                    kind: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$lib$2f$trace$2f$tracer$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["SpanKind"].SERVER,
                    attributes: {
                        'http.method': method,
                        'http.target': req.url
                    }
                }, handleResponse));
        }
    } catch (err) {
        if (!(err instanceof __TURBOPACK__imported__module__$5b$externals$5d2f$next$2f$dist$2f$shared$2f$lib$2f$no$2d$fallback$2d$error$2e$external$2e$js__$5b$external$5d$__$28$next$2f$dist$2f$shared$2f$lib$2f$no$2d$fallback$2d$error$2e$external$2e$js$2c$__cjs$29$__["NoFallbackError"])) {
            const silenceLog = false;
            await routeModule.onRequestError(req, err, {
                routerKind: 'App Router',
                routePath: srcPage,
                routeType: 'render',
                revalidateReason: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$instrumentation$2f$utils$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["getRevalidateReason"])({
                    isStaticGeneration: isSSG,
                    isOnDemandRevalidate
                })
            }, silenceLog, routerServerContext);
        }
        // rethrow so that we can handle serving error page
        throw err;
    }
}
// TODO: omit this from production builds, only test builds should include it
/**
 * Creates a readable stream that emits a PPR boundary sentinel.
 *
 * @returns A readable stream that emits a PPR boundary sentinel.
 */ function createPPRBoundarySentinel() {
    return new ReadableStream({
        start (controller) {
            controller.enqueue(new TextEncoder().encode('<!-- PPR_BOUNDARY_SENTINEL -->'));
            controller.close();
        }
    });
} //# sourceMappingURL=app-page.js.map
}),
"[project]/node_modules/next/dist/esm/build/templates/app-page.js?page=/page { GLOBAL_ERROR_MODULE => \"[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-rsc] (ecmascript, Next.js Server Component)\", MODULE_0 => \"[project]/app/layout.tsx [app-rsc] (ecmascript, Next.js Server Component)\", MODULE_1 => \"[project]/node_modules/next/dist/client/components/builtin/not-found.js [app-rsc] (ecmascript, Next.js Server Component)\", MODULE_2 => \"[project]/node_modules/next/dist/client/components/builtin/forbidden.js [app-rsc] (ecmascript, Next.js Server Component)\", MODULE_3 => \"[project]/node_modules/next/dist/client/components/builtin/unauthorized.js [app-rsc] (ecmascript, Next.js Server Component)\", MODULE_4 => \"[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-rsc] (ecmascript, Next.js Server Component)\", MODULE_5 => \"[project]/app/page.tsx [app-rsc] (ecmascript, Next.js Server Component)\" } [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ClientPageRoot",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["ClientPageRoot"],
    "ClientSegmentRoot",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["ClientSegmentRoot"],
    "Fragment",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["Fragment"],
    "GlobalError",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$global$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29$__["default"],
    "HTTPAccessFallbackBoundary",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["HTTPAccessFallbackBoundary"],
    "LayoutRouter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["LayoutRouter"],
    "Postpone",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["Postpone"],
    "RenderFromTemplateContext",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["RenderFromTemplateContext"],
    "RootLayoutBoundary",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["RootLayoutBoundary"],
    "SegmentViewNode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["SegmentViewNode"],
    "SegmentViewStateNode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["SegmentViewStateNode"],
    "__next_app__",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$app$2d$page$2e$js$3f$page$3d2f$page__$7b$__GLOBAL_ERROR_MODULE__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$global$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_0__$3d3e$__$225b$project$5d2f$app$2f$layout$2e$tsx__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_1__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$not$2d$found$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_2__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$forbidden$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_3__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$unauthorized$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_4__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$global$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_5__$3d3e$__$225b$project$5d2f$app$2f$page$2e$tsx__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$2922$__$7d$__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["__next_app__"],
    "actionAsyncStorage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["actionAsyncStorage"],
    "captureOwnerStack",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["captureOwnerStack"],
    "collectSegmentData",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["collectSegmentData"],
    "createElement",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["createElement"],
    "createMetadataComponents",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["createMetadataComponents"],
    "createPrerenderParamsForClientSegment",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["createPrerenderParamsForClientSegment"],
    "createPrerenderSearchParamsForClientPage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["createPrerenderSearchParamsForClientPage"],
    "createServerParamsForServerSegment",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["createServerParamsForServerSegment"],
    "createServerSearchParamsForServerPage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["createServerSearchParamsForServerPage"],
    "createTemporaryReferenceSet",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["createTemporaryReferenceSet"],
    "decodeAction",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["decodeAction"],
    "decodeFormState",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["decodeFormState"],
    "decodeReply",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["decodeReply"],
    "handler",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$app$2d$page$2e$js$3f$page$3d2f$page__$7b$__GLOBAL_ERROR_MODULE__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$global$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_0__$3d3e$__$225b$project$5d2f$app$2f$layout$2e$tsx__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_1__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$not$2d$found$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_2__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$forbidden$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_3__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$unauthorized$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_4__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$global$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_5__$3d3e$__$225b$project$5d2f$app$2f$page$2e$tsx__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$2922$__$7d$__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["handler"],
    "patchFetch",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["patchFetch"],
    "preconnect",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["preconnect"],
    "preloadFont",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["preloadFont"],
    "preloadStyle",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["preloadStyle"],
    "prerender",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["prerender"],
    "renderToReadableStream",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["renderToReadableStream"],
    "routeModule",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$app$2d$page$2e$js$3f$page$3d2f$page__$7b$__GLOBAL_ERROR_MODULE__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$global$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_0__$3d3e$__$225b$project$5d2f$app$2f$layout$2e$tsx__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_1__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$not$2d$found$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_2__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$forbidden$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_3__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$unauthorized$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_4__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$global$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_5__$3d3e$__$225b$project$5d2f$app$2f$page$2e$tsx__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$2922$__$7d$__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__["routeModule"],
    "serverHooks",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["serverHooks"],
    "taintObjectReference",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["taintObjectReference"],
    "workAsyncStorage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["workAsyncStorage"],
    "workUnitAsyncStorage",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__["workUnitAsyncStorage"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$build$2f$templates$2f$app$2d$page$2e$js$3f$page$3d2f$page__$7b$__GLOBAL_ERROR_MODULE__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$global$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_0__$3d3e$__$225b$project$5d2f$app$2f$layout$2e$tsx__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_1__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$not$2d$found$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_2__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$forbidden$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_3__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$unauthorized$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_4__$3d3e$__$225b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$global$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29222c$__MODULE_5__$3d3e$__$225b$project$5d2f$app$2f$page$2e$tsx__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$2922$__$7d$__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i('[project]/node_modules/next/dist/esm/build/templates/app-page.js?page=/page { GLOBAL_ERROR_MODULE => "[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-rsc] (ecmascript, Next.js Server Component)", MODULE_0 => "[project]/app/layout.tsx [app-rsc] (ecmascript, Next.js Server Component)", MODULE_1 => "[project]/node_modules/next/dist/client/components/builtin/not-found.js [app-rsc] (ecmascript, Next.js Server Component)", MODULE_2 => "[project]/node_modules/next/dist/client/components/builtin/forbidden.js [app-rsc] (ecmascript, Next.js Server Component)", MODULE_3 => "[project]/node_modules/next/dist/client/components/builtin/unauthorized.js [app-rsc] (ecmascript, Next.js Server Component)", MODULE_4 => "[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-rsc] (ecmascript, Next.js Server Component)", MODULE_5 => "[project]/app/page.tsx [app-rsc] (ecmascript, Next.js Server Component)" } [app-rsc] (ecmascript) <locals>');
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$client$2f$components$2f$builtin$2f$global$2d$error$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__Server__Component$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-rsc] (ecmascript, Next.js Server Component)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$esm$2f$server$2f$app$2d$render$2f$entry$2d$base$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$2c$__Next$2e$js__server__utility$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/esm/server/app-render/entry-base.js [app-rsc] (ecmascript, Next.js server utility)");
}),
];

//# sourceMappingURL=node_modules_685691fb._.js.map