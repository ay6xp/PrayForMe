{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/memoize.js"],"sourcesContent":["export function memoize1(fn) {\n    const memoize1cache = new WeakMap();\n    return function memoized(a1) {\n        const cachedValue = memoize1cache.get(a1);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1);\n            memoize1cache.set(a1, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nexport function memoize2(fn) {\n    const memoize2cache = new WeakMap();\n    return function memoized(a1, a2) {\n        let cache2 = memoize2cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize2cache.set(a1, cache2);\n            const newValue = fn(a1, a2);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nexport function memoize3(fn) {\n    const memoize3Cache = new WeakMap();\n    return function memoized(a1, a2, a3) {\n        let cache2 = memoize3Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize3Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        const cachedValue = cache3.get(a3);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nexport function memoize4(fn) {\n    const memoize4Cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4) {\n        let cache2 = memoize4Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize4Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        const cache4 = cache3.get(a3);\n        if (!cache4) {\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        const cachedValue = cache4.get(a4);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nexport function memoize5(fn) {\n    const memoize5Cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4, a5) {\n        let cache2 = memoize5Cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize5Cache.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache4 = cache3.get(a3);\n        if (!cache4) {\n            cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        let cache5 = cache4.get(a4);\n        if (!cache5) {\n            cache5 = new WeakMap();\n            cache4.set(a4, cache5);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        const cachedValue = cache5.get(a5);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache5.set(a5, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nexport function memoize2of4(fn) {\n    const memoize2of4cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4) {\n        let cache2 = memoize2of4cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize2of4cache.set(a1, cache2);\n            const newValue = fn(a1, a2, a3, a4);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\nexport function memoize2of5(fn) {\n    const memoize2of4cache = new WeakMap();\n    return function memoized(a1, a2, a3, a4, a5) {\n        let cache2 = memoize2of4cache.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            memoize2of4cache.set(a1, cache2);\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4, a5);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAO,SAAS,SAAS,EAAE;IACvB,MAAM,gBAAgB,IAAI;IAC1B,OAAO,SAAS,SAAS,EAAE;QACvB,MAAM,cAAc,cAAc,GAAG,CAAC;QACtC,IAAI,gBAAgB,WAAW;YAC3B,MAAM,WAAW,GAAG;YACpB,cAAc,GAAG,CAAC,IAAI;YACtB,OAAO;QACX;QACA,OAAO;IACX;AACJ;AACO,SAAS,SAAS,EAAE;IACvB,MAAM,gBAAgB,IAAI;IAC1B,OAAO,SAAS,SAAS,EAAE,EAAE,EAAE;QAC3B,IAAI,SAAS,cAAc,GAAG,CAAC;QAC/B,IAAI,CAAC,QAAQ;YACT,SAAS,IAAI;YACb,cAAc,GAAG,CAAC,IAAI;YACtB,MAAM,WAAW,GAAG,IAAI;YACxB,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,MAAM,cAAc,OAAO,GAAG,CAAC;QAC/B,IAAI,gBAAgB,WAAW;YAC3B,MAAM,WAAW,GAAG,IAAI;YACxB,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,OAAO;IACX;AACJ;AACO,SAAS,SAAS,EAAE;IACvB,MAAM,gBAAgB,IAAI;IAC1B,OAAO,SAAS,SAAS,EAAE,EAAE,EAAE,EAAE,EAAE;QAC/B,IAAI,SAAS,cAAc,GAAG,CAAC;QAC/B,IAAI,CAAC,QAAQ;YACT,SAAS,IAAI;YACb,cAAc,GAAG,CAAC,IAAI;YACtB,MAAM,SAAS,IAAI;YACnB,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,WAAW,GAAG,IAAI,IAAI;YAC5B,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,IAAI,SAAS,OAAO,GAAG,CAAC;QACxB,IAAI,CAAC,QAAQ;YACT,SAAS,IAAI;YACb,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,WAAW,GAAG,IAAI,IAAI;YAC5B,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,MAAM,cAAc,OAAO,GAAG,CAAC;QAC/B,IAAI,gBAAgB,WAAW;YAC3B,MAAM,WAAW,GAAG,IAAI,IAAI;YAC5B,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,OAAO;IACX;AACJ;AACO,SAAS,SAAS,EAAE;IACvB,MAAM,gBAAgB,IAAI;IAC1B,OAAO,SAAS,SAAS,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;QACnC,IAAI,SAAS,cAAc,GAAG,CAAC;QAC/B,IAAI,CAAC,QAAQ;YACT,SAAS,IAAI;YACb,cAAc,GAAG,CAAC,IAAI;YACtB,MAAM,SAAS,IAAI;YACnB,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,SAAS,IAAI;YACnB,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI;YAChC,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,IAAI,SAAS,OAAO,GAAG,CAAC;QACxB,IAAI,CAAC,QAAQ;YACT,SAAS,IAAI;YACb,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,SAAS,IAAI;YACnB,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI;YAChC,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,MAAM,SAAS,OAAO,GAAG,CAAC;QAC1B,IAAI,CAAC,QAAQ;YACT,MAAM,SAAS,IAAI;YACnB,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI;YAChC,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,MAAM,cAAc,OAAO,GAAG,CAAC;QAC/B,IAAI,gBAAgB,WAAW;YAC3B,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI;YAChC,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,OAAO;IACX;AACJ;AACO,SAAS,SAAS,EAAE;IACvB,MAAM,gBAAgB,IAAI;IAC1B,OAAO,SAAS,SAAS,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;QACvC,IAAI,SAAS,cAAc,GAAG,CAAC;QAC/B,IAAI,CAAC,QAAQ;YACT,SAAS,IAAI;YACb,cAAc,GAAG,CAAC,IAAI;YACtB,MAAM,SAAS,IAAI;YACnB,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,SAAS,IAAI;YACnB,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,SAAS,IAAI;YACnB,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI,IAAI;YACpC,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,IAAI,SAAS,OAAO,GAAG,CAAC;QACxB,IAAI,CAAC,QAAQ;YACT,SAAS,IAAI;YACb,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,SAAS,IAAI;YACnB,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,SAAS,IAAI;YACnB,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI,IAAI;YACpC,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,IAAI,SAAS,OAAO,GAAG,CAAC;QACxB,IAAI,CAAC,QAAQ;YACT,SAAS,IAAI;YACb,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,SAAS,IAAI;YACnB,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI,IAAI;YACpC,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,IAAI,SAAS,OAAO,GAAG,CAAC;QACxB,IAAI,CAAC,QAAQ;YACT,SAAS,IAAI;YACb,OAAO,GAAG,CAAC,IAAI;YACf,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI,IAAI;YACpC,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,MAAM,cAAc,OAAO,GAAG,CAAC;QAC/B,IAAI,gBAAgB,WAAW;YAC3B,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI,IAAI;YACpC,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,OAAO;IACX;AACJ;AACO,SAAS,YAAY,EAAE;IAC1B,MAAM,mBAAmB,IAAI;IAC7B,OAAO,SAAS,SAAS,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;QACnC,IAAI,SAAS,iBAAiB,GAAG,CAAC;QAClC,IAAI,CAAC,QAAQ;YACT,SAAS,IAAI;YACb,iBAAiB,GAAG,CAAC,IAAI;YACzB,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI;YAChC,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,MAAM,cAAc,OAAO,GAAG,CAAC;QAC/B,IAAI,gBAAgB,WAAW;YAC3B,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI;YAChC,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,OAAO;IACX;AACJ;AACO,SAAS,YAAY,EAAE;IAC1B,MAAM,mBAAmB,IAAI;IAC7B,OAAO,SAAS,SAAS,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;QACvC,IAAI,SAAS,iBAAiB,GAAG,CAAC;QAClC,IAAI,CAAC,QAAQ;YACT,SAAS,IAAI;YACb,iBAAiB,GAAG,CAAC,IAAI;YACzB,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI,IAAI;YACpC,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,MAAM,cAAc,OAAO,GAAG,CAAC;QAC/B,IAAI,gBAAgB,WAAW;YAC3B,MAAM,WAAW,GAAG,IAAI,IAAI,IAAI,IAAI;YACpC,OAAO,GAAG,CAAC,IAAI;YACf,OAAO;QACX;QACA,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 224, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/AccumulatorMap.js"],"sourcesContent":["/**\n * ES6 Map with additional `add` method to accumulate items.\n */\nexport class AccumulatorMap extends Map {\n    get [Symbol.toStringTag]() {\n        return 'AccumulatorMap';\n    }\n    add(key, item) {\n        const group = this.get(key);\n        if (group === undefined) {\n            this.set(key, [item]);\n        }\n        else {\n            group.push(item);\n        }\n    }\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;AACM,MAAM,uBAAuB;IAChC,IAAI,CAAC,OAAO,WAAW,CAAC,GAAG;QACvB,OAAO;IACX;IACA,IAAI,GAAG,EAAE,IAAI,EAAE;QACX,MAAM,QAAQ,IAAI,CAAC,GAAG,CAAC;QACvB,IAAI,UAAU,WAAW;YACrB,IAAI,CAAC,GAAG,CAAC,KAAK;gBAAC;aAAK;QACxB,OACK;YACD,MAAM,IAAI,CAAC;QACf;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 249, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/directives.js"],"sourcesContent":["import { DirectiveLocation, GraphQLBoolean, GraphQLDirective, GraphQLInt, GraphQLNonNull, GraphQLString, } from 'graphql';\n/**\n * Used to conditionally defer fragments.\n */\nexport const GraphQLDeferDirective = new GraphQLDirective({\n    name: 'defer',\n    description: 'Directs the executor to defer this fragment when the `if` argument is true or undefined.',\n    locations: [DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],\n    args: {\n        if: {\n            type: new GraphQLNonNull(GraphQLBoolean),\n            description: 'Deferred when true or undefined.',\n            defaultValue: true,\n        },\n        label: {\n            type: GraphQLString,\n            description: 'Unique name',\n        },\n    },\n});\n/**\n * Used to conditionally stream list fields.\n */\nexport const GraphQLStreamDirective = new GraphQLDirective({\n    name: 'stream',\n    description: 'Directs the executor to stream plural fields when the `if` argument is true or undefined.',\n    locations: [DirectiveLocation.FIELD],\n    args: {\n        if: {\n            type: new GraphQLNonNull(GraphQLBoolean),\n            description: 'Stream when true or undefined.',\n            defaultValue: true,\n        },\n        label: {\n            type: GraphQLString,\n            description: 'Unique name',\n        },\n        initialCount: {\n            defaultValue: 0,\n            type: GraphQLInt,\n            description: 'Number of items to return immediately',\n        },\n    },\n});\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;;AAIO,MAAM,wBAAwB,IAAI,oKAAgB,CAAC;IACtD,MAAM;IACN,aAAa;IACb,WAAW;QAAC,gLAAiB,CAAC,eAAe;QAAE,gLAAiB,CAAC,eAAe;KAAC;IACjF,MAAM;QACF,IAAI;YACA,MAAM,IAAI,kKAAc,CAAC,+JAAc;YACvC,aAAa;YACb,cAAc;QAClB;QACA,OAAO;YACH,MAAM,8JAAa;YACnB,aAAa;QACjB;IACJ;AACJ;AAIO,MAAM,yBAAyB,IAAI,oKAAgB,CAAC;IACvD,MAAM;IACN,aAAa;IACb,WAAW;QAAC,gLAAiB,CAAC,KAAK;KAAC;IACpC,MAAM;QACF,IAAI;YACA,MAAM,IAAI,kKAAc,CAAC,+JAAc;YACvC,aAAa;YACb,cAAc;QAClB;QACA,OAAO;YACH,MAAM,8JAAa;YACnB,aAAa;QACjB;QACA,cAAc;YACV,cAAc;YACd,MAAM,2JAAU;YAChB,aAAa;QACjB;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 306, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/collectFields.js"],"sourcesContent":["import { getDirectiveValues, GraphQLIncludeDirective, GraphQLSkipDirective, isAbstractType, Kind, typeFromAST, } from 'graphql';\nimport { AccumulatorMap } from './AccumulatorMap.js';\nimport { GraphQLDeferDirective } from './directives.js';\nimport { memoize5 } from './memoize.js';\nfunction collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {\n    for (const selection of selectionSet.selections) {\n        switch (selection.kind) {\n            case Kind.FIELD: {\n                if (!shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                fields.add(getFieldEntryKey(selection), selection);\n                break;\n            }\n            case Kind.INLINE_FRAGMENT: {\n                if (!shouldIncludeNode(variableValues, selection) ||\n                    !doesFragmentConditionMatch(schema, selection, runtimeType)) {\n                    continue;\n                }\n                const defer = getDeferValues(variableValues, selection);\n                if (defer) {\n                    const patchFields = new AccumulatorMap();\n                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);\n                    patches.push({\n                        label: defer.label,\n                        fields: patchFields,\n                    });\n                }\n                else {\n                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);\n                }\n                break;\n            }\n            case Kind.FRAGMENT_SPREAD: {\n                const fragName = selection.name.value;\n                if (!shouldIncludeNode(variableValues, selection)) {\n                    continue;\n                }\n                const defer = getDeferValues(variableValues, selection);\n                if (visitedFragmentNames.has(fragName) && !defer) {\n                    continue;\n                }\n                const fragment = fragments[fragName];\n                if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {\n                    continue;\n                }\n                if (!defer) {\n                    visitedFragmentNames.add(fragName);\n                }\n                if (defer) {\n                    const patchFields = new AccumulatorMap();\n                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);\n                    patches.push({\n                        label: defer.label,\n                        fields: patchFields,\n                    });\n                }\n                else {\n                    collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);\n                }\n                break;\n            }\n        }\n    }\n}\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n */\nexport function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {\n    const fields = new AccumulatorMap();\n    const patches = [];\n    collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, patches, new Set());\n    return { fields, patches };\n}\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\nexport function shouldIncludeNode(variableValues, node) {\n    const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);\n    if (skip?.['if'] === true) {\n        return false;\n    }\n    const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);\n    if (include?.['if'] === false) {\n        return false;\n    }\n    return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\nexport function doesFragmentConditionMatch(schema, fragment, type) {\n    const typeConditionNode = fragment.typeCondition;\n    if (!typeConditionNode) {\n        return true;\n    }\n    const conditionalType = typeFromAST(schema, typeConditionNode);\n    if (conditionalType === type) {\n        return true;\n    }\n    if (isAbstractType(conditionalType)) {\n        const possibleTypes = schema.getPossibleTypes(conditionalType);\n        return possibleTypes.includes(type);\n    }\n    return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nexport function getFieldEntryKey(node) {\n    return node.alias ? node.alias.value : node.name.value;\n}\n/**\n * Returns an object containing the `@defer` arguments if a field should be\n * deferred based on the experimental flag, defer directive present and\n * not disabled by the \"if\" argument.\n */\nexport function getDeferValues(variableValues, node) {\n    const defer = getDirectiveValues(GraphQLDeferDirective, node, variableValues);\n    if (!defer) {\n        return;\n    }\n    if (defer['if'] === false) {\n        return;\n    }\n    return {\n        label: typeof defer['label'] === 'string' ? defer['label'] : undefined,\n    };\n}\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n */\nexport const collectSubFields = memoize5(function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {\n    const subFieldNodes = new AccumulatorMap();\n    const visitedFragmentNames = new Set();\n    const subPatches = [];\n    const subFieldsAndPatches = {\n        fields: subFieldNodes,\n        patches: subPatches,\n    };\n    for (const node of fieldNodes) {\n        if (node.selectionSet) {\n            collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);\n        }\n    }\n    return subFieldsAndPatches;\n});\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 462, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/Path.js"],"sourcesContent":["/**\n * Given a Path and a key, return a new Path containing the new key.\n */\nexport function addPath(prev, key, typename) {\n    return { prev, key, typename };\n}\n/**\n * Given a Path, return an Array of the path keys.\n */\nexport function pathToArray(path) {\n    const flattened = [];\n    let curr = path;\n    while (curr) {\n        flattened.push(curr.key);\n        curr = curr.prev;\n    }\n    return flattened.reverse();\n}\n/**\n * Build a string describing the path.\n */\nexport function printPathArray(path) {\n    return path\n        .map(key => (typeof key === 'number' ? '[' + key.toString() + ']' : '.' + key))\n        .join('');\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;AACM,SAAS,QAAQ,IAAI,EAAE,GAAG,EAAE,QAAQ;IACvC,OAAO;QAAE;QAAM;QAAK;IAAS;AACjC;AAIO,SAAS,YAAY,IAAI;IAC5B,MAAM,YAAY,EAAE;IACpB,IAAI,OAAO;IACX,MAAO,KAAM;QACT,UAAU,IAAI,CAAC,KAAK,GAAG;QACvB,OAAO,KAAK,IAAI;IACpB;IACA,OAAO,UAAU,OAAO;AAC5B;AAIO,SAAS,eAAe,IAAI;IAC/B,OAAO,KACF,GAAG,CAAC,CAAA,MAAQ,OAAO,QAAQ,WAAW,MAAM,IAAI,QAAQ,KAAK,MAAM,MAAM,KACzE,IAAI,CAAC;AACd","ignoreList":[0]}},
    {"offset": {"line": 495, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/errors.js"],"sourcesContent":["import { locatedError as _locatedError, GraphQLError, versionInfo } from 'graphql';\nconst possibleGraphQLErrorProperties = [\n    'message',\n    'locations',\n    'path',\n    'nodes',\n    'source',\n    'positions',\n    'originalError',\n    'name',\n    'stack',\n    'extensions',\n    'coordinate',\n];\nexport function isGraphQLErrorLike(error) {\n    return (error != null &&\n        typeof error === 'object' &&\n        Object.keys(error).every(key => possibleGraphQLErrorProperties.includes(key)));\n}\nexport function createGraphQLError(message, options) {\n    if (options?.originalError &&\n        !(options.originalError instanceof Error) &&\n        isGraphQLErrorLike(options.originalError)) {\n        options.originalError = createGraphQLError(options.originalError.message, options.originalError);\n    }\n    // To avoid type error on graphql <16, we have to use an any type here\n    const Constructor = GraphQLError;\n    const error = versionInfo.major >= 16\n        ? new Constructor(message, options)\n        : new Constructor(message, options?.nodes, options?.source, options?.positions, options?.path, options?.originalError, options?.extensions);\n    if (options?.coordinate && error.coordinate == null) {\n        Object.defineProperties(error, {\n            coordinate: { value: options.coordinate, enumerable: true, configurable: true },\n        });\n    }\n    return error;\n}\nexport function getSchemaCoordinate(error) {\n    return error.coordinate;\n}\nexport function locatedError(rawError, nodes, path, info) {\n    const error = _locatedError(rawError, nodes, path);\n    // `graphql` locatedError is only changing path and nodes if it is not already defined\n    if (!error.coordinate && info && error.coordinate == null) {\n        const coordinate = `${info.parentType.name}.${info.fieldName}`;\n        Object.defineProperties(error, {\n            coordinate: { value: coordinate, enumerable: true, configurable: true },\n        });\n    }\n    return error;\n}\nexport function relocatedError(originalError, path, info) {\n    return createGraphQLError(originalError.message, {\n        nodes: originalError.nodes,\n        source: originalError.source,\n        positions: originalError.positions,\n        path: path == null ? originalError.path : path,\n        originalError,\n        extensions: originalError.extensions,\n        coordinate: info ? `${info.parentType.name}.${info.fieldName}` : undefined,\n    });\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AAAA;AAAA;;AACA,MAAM,iCAAiC;IACnC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACH;AACM,SAAS,mBAAmB,KAAK;IACpC,OAAQ,SAAS,QACb,OAAO,UAAU,YACjB,OAAO,IAAI,CAAC,OAAO,KAAK,CAAC,CAAA,MAAO,+BAA+B,QAAQ,CAAC;AAChF;AACO,SAAS,mBAAmB,OAAO,EAAE,OAAO;IAC/C,IAAI,SAAS,iBACT,CAAC,CAAC,QAAQ,aAAa,YAAY,KAAK,KACxC,mBAAmB,QAAQ,aAAa,GAAG;QAC3C,QAAQ,aAAa,GAAG,mBAAmB,QAAQ,aAAa,CAAC,OAAO,EAAE,QAAQ,aAAa;IACnG;IACA,sEAAsE;IACtE,MAAM,cAAc,mKAAY;IAChC,MAAM,QAAQ,oJAAW,CAAC,KAAK,IAAI,KAC7B,IAAI,YAAY,SAAS,WACzB,IAAI,YAAY,SAAS,SAAS,OAAO,SAAS,QAAQ,SAAS,WAAW,SAAS,MAAM,SAAS,eAAe,SAAS;IACpI,IAAI,SAAS,cAAc,MAAM,UAAU,IAAI,MAAM;QACjD,OAAO,gBAAgB,CAAC,OAAO;YAC3B,YAAY;gBAAE,OAAO,QAAQ,UAAU;gBAAE,YAAY;gBAAM,cAAc;YAAK;QAClF;IACJ;IACA,OAAO;AACX;AACO,SAAS,oBAAoB,KAAK;IACrC,OAAO,MAAM,UAAU;AAC3B;AACO,SAAS,aAAa,QAAQ,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI;IACpD,MAAM,QAAQ,IAAA,mKAAa,EAAC,UAAU,OAAO;IAC7C,sFAAsF;IACtF,IAAI,CAAC,MAAM,UAAU,IAAI,QAAQ,MAAM,UAAU,IAAI,MAAM;QACvD,MAAM,aAAa,GAAG,KAAK,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,KAAK,SAAS,EAAE;QAC9D,OAAO,gBAAgB,CAAC,OAAO;YAC3B,YAAY;gBAAE,OAAO;gBAAY,YAAY;gBAAM,cAAc;YAAK;QAC1E;IACJ;IACA,OAAO;AACX;AACO,SAAS,eAAe,aAAa,EAAE,IAAI,EAAE,IAAI;IACpD,OAAO,mBAAmB,cAAc,OAAO,EAAE;QAC7C,OAAO,cAAc,KAAK;QAC1B,QAAQ,cAAc,MAAM;QAC5B,WAAW,cAAc,SAAS;QAClC,MAAM,QAAQ,OAAO,cAAc,IAAI,GAAG;QAC1C;QACA,YAAY,cAAc,UAAU;QACpC,YAAY,OAAO,GAAG,KAAK,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,KAAK,SAAS,EAAE,GAAG;IACrE;AACJ","ignoreList":[0]}},
    {"offset": {"line": 578, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/jsutils.js"],"sourcesContent":["import { handleMaybePromise, isPromise } from '@whatwg-node/promise-helpers';\nexport function isIterableObject(value) {\n    return value != null && typeof value === 'object' && Symbol.iterator in value;\n}\nexport function isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nexport { isPromise };\nexport function promiseReduce(values, callbackFn, initialValue) {\n    let accumulator = initialValue;\n    for (const value of values) {\n        accumulator = handleMaybePromise(() => accumulator, resolved => callbackFn(resolved, value));\n    }\n    return accumulator;\n}\nexport function hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AACO,SAAS,iBAAiB,KAAK;IAClC,OAAO,SAAS,QAAQ,OAAO,UAAU,YAAY,OAAO,QAAQ,IAAI;AAC5E;AACO,SAAS,aAAa,KAAK;IAC9B,OAAO,OAAO,UAAU,YAAY,UAAU;AAClD;;AAEO,SAAS,cAAc,MAAM,EAAE,UAAU,EAAE,YAAY;IAC1D,IAAI,cAAc;IAClB,KAAK,MAAM,SAAS,OAAQ;QACxB,cAAc,IAAA,8LAAkB,EAAC,IAAM,aAAa,CAAA,WAAY,WAAW,UAAU;IACzF;IACA,OAAO;AACX;AACO,SAAS,eAAe,GAAG,EAAE,IAAI;IACpC,OAAO,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK;AACrD","ignoreList":[0]}},
    {"offset": {"line": 611, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/getArgumentValues.js"],"sourcesContent":["import { inspect } from 'cross-inspect';\nimport { isNonNullType, Kind, print, valueFromAST, } from 'graphql';\nimport { createGraphQLError } from './errors.js';\nimport { hasOwnProperty } from './jsutils.js';\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getArgumentValues(def, node, variableValues = {}) {\n    const coercedValues = {};\n    const argumentNodes = node.arguments ?? [];\n    const argNodeMap = argumentNodes.reduce((prev, arg) => ({\n        ...prev,\n        [arg.name.value]: arg,\n    }), {});\n    for (const { name, type: argType, defaultValue } of def.args) {\n        const argumentNode = argNodeMap[name];\n        if (!argumentNode) {\n            if (defaultValue !== undefined) {\n                coercedValues[name] = defaultValue;\n            }\n            else if (isNonNullType(argType)) {\n                throw createGraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + 'was not provided.', {\n                    nodes: [node],\n                });\n            }\n            continue;\n        }\n        const valueNode = argumentNode.value;\n        let isNull = valueNode.kind === Kind.NULL;\n        if (valueNode.kind === Kind.VARIABLE) {\n            const variableName = valueNode.name.value;\n            if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {\n                if (defaultValue !== undefined) {\n                    coercedValues[name] = defaultValue;\n                }\n                else if (isNonNullType(argType)) {\n                    throw createGraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n                        `was provided the variable \"$${variableName}\" which was not provided a runtime value.`, {\n                        nodes: [valueNode],\n                    });\n                }\n                continue;\n            }\n            isNull = variableValues[variableName] == null;\n        }\n        if (isNull && isNonNullType(argType)) {\n            throw createGraphQLError(`Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` + 'must not be null.', {\n                nodes: [valueNode],\n            });\n        }\n        const coercedValue = valueFromAST(valueNode, argType, variableValues);\n        if (coercedValue === undefined) {\n            // Note: ValuesOfCorrectTypeRule validation should catch this before\n            // execution. This is a runtime check to ensure execution does not\n            // continue with an invalid argument value.\n            throw createGraphQLError(`Argument \"${name}\" has invalid value ${print(valueNode)}.`, {\n                nodes: [valueNode],\n            });\n        }\n        coercedValues[name] = coercedValue;\n    }\n    return coercedValues;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;;;AASO,SAAS,kBAAkB,GAAG,EAAE,IAAI,EAAE,iBAAiB,CAAC,CAAC;IAC5D,MAAM,gBAAgB,CAAC;IACvB,MAAM,gBAAgB,KAAK,SAAS,IAAI,EAAE;IAC1C,MAAM,aAAa,cAAc,MAAM,CAAC,CAAC,MAAM,MAAQ,CAAC;YACpD,GAAG,IAAI;YACP,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,EAAE;QACtB,CAAC,GAAG,CAAC;IACL,KAAK,MAAM,EAAE,IAAI,EAAE,MAAM,OAAO,EAAE,YAAY,EAAE,IAAI,IAAI,IAAI,CAAE;QAC1D,MAAM,eAAe,UAAU,CAAC,KAAK;QACrC,IAAI,CAAC,cAAc;YACf,IAAI,iBAAiB,WAAW;gBAC5B,aAAa,CAAC,KAAK,GAAG;YAC1B,OACK,IAAI,IAAA,iKAAa,EAAC,UAAU;gBAC7B,MAAM,IAAA,oLAAkB,EAAC,CAAC,UAAU,EAAE,KAAK,oBAAoB,EAAE,IAAA,6JAAO,EAAC,SAAS,EAAE,CAAC,GAAG,qBAAqB;oBACzG,OAAO;wBAAC;qBAAK;gBACjB;YACJ;YACA;QACJ;QACA,MAAM,YAAY,aAAa,KAAK;QACpC,IAAI,SAAS,UAAU,IAAI,KAAK,uJAAI,CAAC,IAAI;QACzC,IAAI,UAAU,IAAI,KAAK,uJAAI,CAAC,QAAQ,EAAE;YAClC,MAAM,eAAe,UAAU,IAAI,CAAC,KAAK;YACzC,IAAI,kBAAkB,QAAQ,CAAC,IAAA,iMAAc,EAAC,gBAAgB,eAAe;gBACzE,IAAI,iBAAiB,WAAW;oBAC5B,aAAa,CAAC,KAAK,GAAG;gBAC1B,OACK,IAAI,IAAA,iKAAa,EAAC,UAAU;oBAC7B,MAAM,IAAA,oLAAkB,EAAC,CAAC,UAAU,EAAE,KAAK,oBAAoB,EAAE,IAAA,6JAAO,EAAC,SAAS,EAAE,CAAC,GACjF,CAAC,4BAA4B,EAAE,aAAa,yCAAyC,CAAC,EAAE;wBACxF,OAAO;4BAAC;yBAAU;oBACtB;gBACJ;gBACA;YACJ;YACA,SAAS,cAAc,CAAC,aAAa,IAAI;QAC7C;QACA,IAAI,UAAU,IAAA,iKAAa,EAAC,UAAU;YAClC,MAAM,IAAA,oLAAkB,EAAC,CAAC,UAAU,EAAE,KAAK,oBAAoB,EAAE,IAAA,6JAAO,EAAC,SAAS,EAAE,CAAC,GAAG,qBAAqB;gBACzG,OAAO;oBAAC;iBAAU;YACtB;QACJ;QACA,MAAM,eAAe,IAAA,uKAAY,EAAC,WAAW,SAAS;QACtD,IAAI,iBAAiB,WAAW;YAC5B,oEAAoE;YACpE,kEAAkE;YAClE,2CAA2C;YAC3C,MAAM,IAAA,oLAAkB,EAAC,CAAC,UAAU,EAAE,KAAK,oBAAoB,EAAE,IAAA,0JAAK,EAAC,WAAW,CAAC,CAAC,EAAE;gBAClF,OAAO;oBAAC;iBAAU;YACtB;QACJ;QACA,aAAa,CAAC,KAAK,GAAG;IAC1B;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 691, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/rootTypes.js"],"sourcesContent":["import { createGraphQLError } from './errors.js';\nimport { memoize1 } from './memoize.js';\nexport function getDefinedRootType(schema, operation, nodes) {\n    const rootTypeMap = getRootTypeMap(schema);\n    const rootType = rootTypeMap.get(operation);\n    if (rootType == null) {\n        throw createGraphQLError(`Schema is not configured to execute ${operation} operation.`, {\n            nodes,\n        });\n    }\n    return rootType;\n}\nexport const getRootTypeNames = memoize1(function getRootTypeNames(schema) {\n    const rootTypes = getRootTypes(schema);\n    return new Set([...rootTypes].map(type => type.name));\n});\nexport const getRootTypes = memoize1(function getRootTypes(schema) {\n    const rootTypeMap = getRootTypeMap(schema);\n    return new Set(rootTypeMap.values());\n});\nexport const getRootTypeMap = memoize1(function getRootTypeMap(schema) {\n    const rootTypeMap = new Map();\n    const queryType = schema.getQueryType();\n    if (queryType) {\n        rootTypeMap.set('query', queryType);\n    }\n    const mutationType = schema.getMutationType();\n    if (mutationType) {\n        rootTypeMap.set('mutation', mutationType);\n    }\n    const subscriptionType = schema.getSubscriptionType();\n    if (subscriptionType) {\n        rootTypeMap.set('subscription', subscriptionType);\n    }\n    return rootTypeMap;\n});\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;;;AACO,SAAS,mBAAmB,MAAM,EAAE,SAAS,EAAE,KAAK;IACvD,MAAM,cAAc,eAAe;IACnC,MAAM,WAAW,YAAY,GAAG,CAAC;IACjC,IAAI,YAAY,MAAM;QAClB,MAAM,IAAA,oLAAkB,EAAC,CAAC,oCAAoC,EAAE,UAAU,WAAW,CAAC,EAAE;YACpF;QACJ;IACJ;IACA,OAAO;AACX;AACO,MAAM,mBAAmB,IAAA,2KAAQ,EAAC,SAAS,iBAAiB,MAAM;IACrE,MAAM,YAAY,aAAa;IAC/B,OAAO,IAAI,IAAI;WAAI;KAAU,CAAC,GAAG,CAAC,CAAA,OAAQ,KAAK,IAAI;AACvD;AACO,MAAM,eAAe,IAAA,2KAAQ,EAAC,SAAS,aAAa,MAAM;IAC7D,MAAM,cAAc,eAAe;IACnC,OAAO,IAAI,IAAI,YAAY,MAAM;AACrC;AACO,MAAM,iBAAiB,IAAA,2KAAQ,EAAC,SAAS,eAAe,MAAM;IACjE,MAAM,cAAc,IAAI;IACxB,MAAM,YAAY,OAAO,YAAY;IACrC,IAAI,WAAW;QACX,YAAY,GAAG,CAAC,SAAS;IAC7B;IACA,MAAM,eAAe,OAAO,eAAe;IAC3C,IAAI,cAAc;QACd,YAAY,GAAG,CAAC,YAAY;IAChC;IACA,MAAM,mBAAmB,OAAO,mBAAmB;IACnD,IAAI,kBAAkB;QAClB,YAAY,GAAG,CAAC,gBAAgB;IACpC;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 745, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/isAsyncIterable.js"],"sourcesContent":["export function isAsyncIterable(value) {\n    return value?.[Symbol.asyncIterator] != null;\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,gBAAgB,KAAK;IACjC,OAAO,OAAO,CAAC,OAAO,aAAa,CAAC,IAAI;AAC5C","ignoreList":[0]}},
    {"offset": {"line": 756, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/helpers.js"],"sourcesContent":["import { parse } from 'graphql';\nconst URL_REGEXP = /^(https?|wss?|file):\\/\\//;\n/**\n * Checks if the given string is a valid URL.\n *\n * @param str - The string to validate as a URL\n * @returns A boolean indicating whether the string is a valid URL\n *\n * @remarks\n * This function first attempts to use the `URL.canParse` method if available.\n * If not, it falls back to creating a new `URL` object to validate the string.\n */\nexport function isUrl(str) {\n    if (typeof str !== 'string') {\n        return false;\n    }\n    if (!URL_REGEXP.test(str)) {\n        return false;\n    }\n    if (URL.canParse) {\n        return URL.canParse(str);\n    }\n    try {\n        const url = new URL(str);\n        return !!url;\n    }\n    catch (e) {\n        return false;\n    }\n}\nexport const asArray = (fns) => (Array.isArray(fns) ? fns : fns ? [fns] : []);\nconst invalidDocRegex = /\\.[a-z0-9]+$/i;\n/**\n * Determines if a given input is a valid GraphQL document string.\n *\n * @param str - The input to validate as a GraphQL document\n * @returns A boolean indicating whether the input is a valid GraphQL document string\n *\n * @remarks\n * This function performs several validation checks:\n * - Ensures the input is a string\n * - Filters out strings with invalid document extensions\n * - Excludes URLs\n * - Attempts to parse the string as a GraphQL document\n *\n * @throws {Error} If the document fails to parse and is empty except GraphQL comments\n */\nexport function isDocumentString(str) {\n    if (typeof str !== 'string') {\n        return false;\n    }\n    // XXX: is-valid-path or is-glob treat SDL as a valid path\n    // (`scalar Date` for example)\n    // this why checking the extension is fast enough\n    // and prevent from parsing the string in order to find out\n    // if the string is a SDL\n    if (invalidDocRegex.test(str) || isUrl(str)) {\n        return false;\n    }\n    try {\n        parse(str);\n        return true;\n    }\n    catch (e) {\n        if (!e.message.includes('EOF') &&\n            str.replace(/(\\#[^*]*)/g, '').trim() !== '' &&\n            str.includes(' ')) {\n            throw new Error(`Failed to parse the GraphQL document. ${e.message}\\n${str}`);\n        }\n    }\n    return false;\n}\nconst invalidPathRegex = /[‘“!%^<>`\\n]/;\n/**\n * Checkes whether the `str` contains any path illegal characters.\n *\n * A string may sometimes look like a path but is not (like an SDL of a simple\n * GraphQL schema). To make sure we don't yield false-positives in such cases,\n * we disallow new lines in paths (even though most Unix systems support new\n * lines in file names).\n */\nexport function isValidPath(str) {\n    return typeof str === 'string' && !invalidPathRegex.test(str);\n}\nexport function compareStrings(a, b) {\n    if (String(a) < String(b)) {\n        return -1;\n    }\n    if (String(a) > String(b)) {\n        return 1;\n    }\n    return 0;\n}\nexport function nodeToString(a) {\n    let name;\n    if ('alias' in a) {\n        name = a.alias?.value;\n    }\n    if (name == null && 'name' in a) {\n        name = a.name?.value;\n    }\n    if (name == null) {\n        name = a.kind;\n    }\n    return name;\n}\nexport function compareNodes(a, b, customFn) {\n    const aStr = nodeToString(a);\n    const bStr = nodeToString(b);\n    if (typeof customFn === 'function') {\n        return customFn(aStr, bStr);\n    }\n    return compareStrings(aStr, bStr);\n}\nexport function isSome(input) {\n    return input != null;\n}\nexport function assertSome(input, message = 'Value should be something') {\n    if (input == null) {\n        throw new Error(message);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;;AACA,MAAM,aAAa;AAWZ,SAAS,MAAM,GAAG;IACrB,IAAI,OAAO,QAAQ,UAAU;QACzB,OAAO;IACX;IACA,IAAI,CAAC,WAAW,IAAI,CAAC,MAAM;QACvB,OAAO;IACX;IACA,IAAI,IAAI,QAAQ,EAAE;QACd,OAAO,IAAI,QAAQ,CAAC;IACxB;IACA,IAAI;QACA,MAAM,MAAM,IAAI,IAAI;QACpB,OAAO,CAAC,CAAC;IACb,EACA,OAAO,GAAG;QACN,OAAO;IACX;AACJ;AACO,MAAM,UAAU,CAAC,MAAS,MAAM,OAAO,CAAC,OAAO,MAAM,MAAM;QAAC;KAAI,GAAG,EAAE;AAC5E,MAAM,kBAAkB;AAgBjB,SAAS,iBAAiB,GAAG;IAChC,IAAI,OAAO,QAAQ,UAAU;QACzB,OAAO;IACX;IACA,0DAA0D;IAC1D,8BAA8B;IAC9B,iDAAiD;IACjD,2DAA2D;IAC3D,yBAAyB;IACzB,IAAI,gBAAgB,IAAI,CAAC,QAAQ,MAAM,MAAM;QACzC,OAAO;IACX;IACA,IAAI;QACA,IAAA,yJAAK,EAAC;QACN,OAAO;IACX,EACA,OAAO,GAAG;QACN,IAAI,CAAC,EAAE,OAAO,CAAC,QAAQ,CAAC,UACpB,IAAI,OAAO,CAAC,cAAc,IAAI,IAAI,OAAO,MACzC,IAAI,QAAQ,CAAC,MAAM;YACnB,MAAM,IAAI,MAAM,CAAC,sCAAsC,EAAE,EAAE,OAAO,CAAC,EAAE,EAAE,KAAK;QAChF;IACJ;IACA,OAAO;AACX;AACA,MAAM,mBAAmB;AASlB,SAAS,YAAY,GAAG;IAC3B,OAAO,OAAO,QAAQ,YAAY,CAAC,iBAAiB,IAAI,CAAC;AAC7D;AACO,SAAS,eAAe,CAAC,EAAE,CAAC;IAC/B,IAAI,OAAO,KAAK,OAAO,IAAI;QACvB,OAAO,CAAC;IACZ;IACA,IAAI,OAAO,KAAK,OAAO,IAAI;QACvB,OAAO;IACX;IACA,OAAO;AACX;AACO,SAAS,aAAa,CAAC;IAC1B,IAAI;IACJ,IAAI,WAAW,GAAG;QACd,OAAO,EAAE,KAAK,EAAE;IACpB;IACA,IAAI,QAAQ,QAAQ,UAAU,GAAG;QAC7B,OAAO,EAAE,IAAI,EAAE;IACnB;IACA,IAAI,QAAQ,MAAM;QACd,OAAO,EAAE,IAAI;IACjB;IACA,OAAO;AACX;AACO,SAAS,aAAa,CAAC,EAAE,CAAC,EAAE,QAAQ;IACvC,MAAM,OAAO,aAAa;IAC1B,MAAM,OAAO,aAAa;IAC1B,IAAI,OAAO,aAAa,YAAY;QAChC,OAAO,SAAS,MAAM;IAC1B;IACA,OAAO,eAAe,MAAM;AAChC;AACO,SAAS,OAAO,KAAK;IACxB,OAAO,SAAS;AACpB;AACO,SAAS,WAAW,KAAK,EAAE,UAAU,2BAA2B;IACnE,IAAI,SAAS,MAAM;QACf,MAAM,IAAI,MAAM;IACpB;AACJ","ignoreList":[0]}},
    {"offset": {"line": 868, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/mergeDeep.js"],"sourcesContent":["import { isSome } from './helpers.js';\nexport function mergeDeep(sources, respectPrototype = false, respectArrays = false, respectArrayLength = false) {\n    if (sources.length === 0) {\n        return;\n    }\n    if (sources.length === 1) {\n        return sources[0];\n    }\n    let expectedLength;\n    let allArrays = true;\n    const areArraysInTheSameLength = sources.every(source => {\n        if (Array.isArray(source)) {\n            if (expectedLength === undefined) {\n                expectedLength = source.length;\n                return true;\n            }\n            else if (expectedLength === source.length) {\n                return true;\n            }\n        }\n        else {\n            allArrays = false;\n        }\n        return false;\n    });\n    if (respectArrayLength && areArraysInTheSameLength) {\n        return new Array(expectedLength).fill(null).map((_, index) => mergeDeep(sources.map(source => source[index]), respectPrototype, respectArrays, respectArrayLength));\n    }\n    if (allArrays) {\n        return sources.flat(1);\n    }\n    let output;\n    let firstObjectSource;\n    if (respectPrototype) {\n        firstObjectSource = sources.find(source => isObject(source));\n        if (firstObjectSource) {\n            if (output == null) {\n                output = {};\n            }\n            Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(firstObjectSource)));\n        }\n    }\n    for (const source of sources) {\n        if (source == null) {\n            continue;\n        }\n        if (isObject(source)) {\n            if (firstObjectSource) {\n                const outputPrototype = Object.getPrototypeOf(output);\n                const sourcePrototype = Object.getPrototypeOf(source);\n                if (sourcePrototype) {\n                    for (const key of Object.getOwnPropertyNames(sourcePrototype)) {\n                        const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);\n                        if (isSome(descriptor)) {\n                            Object.defineProperty(outputPrototype, key, descriptor);\n                        }\n                    }\n                }\n            }\n            for (const key in source) {\n                if (output == null) {\n                    output = {};\n                }\n                if (key in output) {\n                    output[key] = mergeDeep([output[key], source[key]], respectPrototype, respectArrays, respectArrayLength);\n                }\n                else {\n                    output[key] = source[key];\n                }\n            }\n        }\n        else if (Array.isArray(source)) {\n            if (!Array.isArray(output)) {\n                output = source;\n            }\n            else {\n                output = mergeDeep([output, source], respectPrototype, respectArrays, respectArrayLength);\n            }\n        }\n        else {\n            output = source;\n        }\n    }\n    return output;\n}\nfunction isObject(item) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,UAAU,OAAO,EAAE,mBAAmB,KAAK,EAAE,gBAAgB,KAAK,EAAE,qBAAqB,KAAK;IAC1G,IAAI,QAAQ,MAAM,KAAK,GAAG;QACtB;IACJ;IACA,IAAI,QAAQ,MAAM,KAAK,GAAG;QACtB,OAAO,OAAO,CAAC,EAAE;IACrB;IACA,IAAI;IACJ,IAAI,YAAY;IAChB,MAAM,2BAA2B,QAAQ,KAAK,CAAC,CAAA;QAC3C,IAAI,MAAM,OAAO,CAAC,SAAS;YACvB,IAAI,mBAAmB,WAAW;gBAC9B,iBAAiB,OAAO,MAAM;gBAC9B,OAAO;YACX,OACK,IAAI,mBAAmB,OAAO,MAAM,EAAE;gBACvC,OAAO;YACX;QACJ,OACK;YACD,YAAY;QAChB;QACA,OAAO;IACX;IACA,IAAI,sBAAsB,0BAA0B;QAChD,OAAO,IAAI,MAAM,gBAAgB,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,QAAU,UAAU,QAAQ,GAAG,CAAC,CAAA,SAAU,MAAM,CAAC,MAAM,GAAG,kBAAkB,eAAe;IACnJ;IACA,IAAI,WAAW;QACX,OAAO,QAAQ,IAAI,CAAC;IACxB;IACA,IAAI;IACJ,IAAI;IACJ,IAAI,kBAAkB;QAClB,oBAAoB,QAAQ,IAAI,CAAC,CAAA,SAAU,SAAS;QACpD,IAAI,mBAAmB;YACnB,IAAI,UAAU,MAAM;gBAChB,SAAS,CAAC;YACd;YACA,OAAO,cAAc,CAAC,QAAQ,OAAO,MAAM,CAAC,OAAO,cAAc,CAAC;QACtE;IACJ;IACA,KAAK,MAAM,UAAU,QAAS;QAC1B,IAAI,UAAU,MAAM;YAChB;QACJ;QACA,IAAI,SAAS,SAAS;YAClB,IAAI,mBAAmB;gBACnB,MAAM,kBAAkB,OAAO,cAAc,CAAC;gBAC9C,MAAM,kBAAkB,OAAO,cAAc,CAAC;gBAC9C,IAAI,iBAAiB;oBACjB,KAAK,MAAM,OAAO,OAAO,mBAAmB,CAAC,iBAAkB;wBAC3D,MAAM,aAAa,OAAO,wBAAwB,CAAC,iBAAiB;wBACpE,IAAI,IAAA,yKAAM,EAAC,aAAa;4BACpB,OAAO,cAAc,CAAC,iBAAiB,KAAK;wBAChD;oBACJ;gBACJ;YACJ;YACA,IAAK,MAAM,OAAO,OAAQ;gBACtB,IAAI,UAAU,MAAM;oBAChB,SAAS,CAAC;gBACd;gBACA,IAAI,OAAO,QAAQ;oBACf,MAAM,CAAC,IAAI,GAAG,UAAU;wBAAC,MAAM,CAAC,IAAI;wBAAE,MAAM,CAAC,IAAI;qBAAC,EAAE,kBAAkB,eAAe;gBACzF,OACK;oBACD,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI;gBAC7B;YACJ;QACJ,OACK,IAAI,MAAM,OAAO,CAAC,SAAS;YAC5B,IAAI,CAAC,MAAM,OAAO,CAAC,SAAS;gBACxB,SAAS;YACb,OACK;gBACD,SAAS,UAAU;oBAAC;oBAAQ;iBAAO,EAAE,kBAAkB,eAAe;YAC1E;QACJ,OACK;YACD,SAAS;QACb;IACJ;IACA,OAAO;AACX;AACA,SAAS,SAAS,IAAI;IAClB,OAAO,QAAQ,OAAO,SAAS,YAAY,CAAC,MAAM,OAAO,CAAC;AAC9D","ignoreList":[0]}},
    {"offset": {"line": 965, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/astFromType.js"],"sourcesContent":["import { inspect } from 'cross-inspect';\nimport { isListType, isNonNullType, Kind } from 'graphql';\nexport function astFromType(type) {\n    if (isNonNullType(type)) {\n        const innerType = astFromType(type.ofType);\n        if (innerType.kind === Kind.NON_NULL_TYPE) {\n            throw new Error(`Invalid type node ${inspect(type)}. Inner type of non-null type cannot be a non-null type.`);\n        }\n        return {\n            kind: Kind.NON_NULL_TYPE,\n            type: innerType,\n        };\n    }\n    else if (isListType(type)) {\n        return {\n            kind: Kind.LIST_TYPE,\n            type: astFromType(type.ofType),\n        };\n    }\n    return {\n        kind: Kind.NAMED_TYPE,\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n    };\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;;;AACO,SAAS,YAAY,IAAI;IAC5B,IAAI,IAAA,iKAAa,EAAC,OAAO;QACrB,MAAM,YAAY,YAAY,KAAK,MAAM;QACzC,IAAI,UAAU,IAAI,KAAK,uJAAI,CAAC,aAAa,EAAE;YACvC,MAAM,IAAI,MAAM,CAAC,kBAAkB,EAAE,IAAA,6JAAO,EAAC,MAAM,wDAAwD,CAAC;QAChH;QACA,OAAO;YACH,MAAM,uJAAI,CAAC,aAAa;YACxB,MAAM;QACV;IACJ,OACK,IAAI,IAAA,8JAAU,EAAC,OAAO;QACvB,OAAO;YACH,MAAM,uJAAI,CAAC,SAAS;YACpB,MAAM,YAAY,KAAK,MAAM;QACjC;IACJ;IACA,OAAO;QACH,MAAM,uJAAI,CAAC,UAAU;QACrB,MAAM;YACF,MAAM,uJAAI,CAAC,IAAI;YACf,OAAO,KAAK,IAAI;QACpB;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1002, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/astFromValueUntyped.js"],"sourcesContent":["import { Kind } from 'graphql';\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using the following mapping.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String               |\n * | Number        | Int / Float          |\n * | BigInt        | Int                  |\n * | null          | NullValue            |\n *\n */\nexport function astFromValueUntyped(value) {\n    // only explicit null, not undefined, NaN\n    if (value === null) {\n        return { kind: Kind.NULL };\n    }\n    // undefined\n    if (value === undefined) {\n        return null;\n    }\n    // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n    // the value is not an array, convert the value using the list's item type.\n    if (Array.isArray(value)) {\n        const valuesNodes = [];\n        for (const item of value) {\n            const itemNode = astFromValueUntyped(item);\n            if (itemNode != null) {\n                valuesNodes.push(itemNode);\n            }\n        }\n        return { kind: Kind.LIST, values: valuesNodes };\n    }\n    if (typeof value === 'object') {\n        if (value?.toJSON) {\n            return astFromValueUntyped(value.toJSON());\n        }\n        const fieldNodes = [];\n        for (const fieldName in value) {\n            const fieldValue = value[fieldName];\n            const ast = astFromValueUntyped(fieldValue);\n            if (ast) {\n                fieldNodes.push({\n                    kind: Kind.OBJECT_FIELD,\n                    name: { kind: Kind.NAME, value: fieldName },\n                    value: ast,\n                });\n            }\n        }\n        return { kind: Kind.OBJECT, fields: fieldNodes };\n    }\n    // Others serialize based on their corresponding JavaScript scalar types.\n    if (typeof value === 'boolean') {\n        return { kind: Kind.BOOLEAN, value };\n    }\n    if (typeof value === 'bigint') {\n        return { kind: Kind.INT, value: String(value) };\n    }\n    // JavaScript numbers can be Int or Float values.\n    if (typeof value === 'number' && isFinite(value)) {\n        const stringNum = String(value);\n        return integerStringRegExp.test(stringNum)\n            ? { kind: Kind.INT, value: stringNum }\n            : { kind: Kind.FLOAT, value: stringNum };\n    }\n    if (typeof value === 'string') {\n        return { kind: Kind.STRING, value };\n    }\n    throw new TypeError(`Cannot convert value to AST: ${value}.`);\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n"],"names":[],"mappings":";;;;AAAA;;AAiBO,SAAS,oBAAoB,KAAK;IACrC,yCAAyC;IACzC,IAAI,UAAU,MAAM;QAChB,OAAO;YAAE,MAAM,uJAAI,CAAC,IAAI;QAAC;IAC7B;IACA,YAAY;IACZ,IAAI,UAAU,WAAW;QACrB,OAAO;IACX;IACA,8EAA8E;IAC9E,2EAA2E;IAC3E,IAAI,MAAM,OAAO,CAAC,QAAQ;QACtB,MAAM,cAAc,EAAE;QACtB,KAAK,MAAM,QAAQ,MAAO;YACtB,MAAM,WAAW,oBAAoB;YACrC,IAAI,YAAY,MAAM;gBAClB,YAAY,IAAI,CAAC;YACrB;QACJ;QACA,OAAO;YAAE,MAAM,uJAAI,CAAC,IAAI;YAAE,QAAQ;QAAY;IAClD;IACA,IAAI,OAAO,UAAU,UAAU;QAC3B,IAAI,OAAO,QAAQ;YACf,OAAO,oBAAoB,MAAM,MAAM;QAC3C;QACA,MAAM,aAAa,EAAE;QACrB,IAAK,MAAM,aAAa,MAAO;YAC3B,MAAM,aAAa,KAAK,CAAC,UAAU;YACnC,MAAM,MAAM,oBAAoB;YAChC,IAAI,KAAK;gBACL,WAAW,IAAI,CAAC;oBACZ,MAAM,uJAAI,CAAC,YAAY;oBACvB,MAAM;wBAAE,MAAM,uJAAI,CAAC,IAAI;wBAAE,OAAO;oBAAU;oBAC1C,OAAO;gBACX;YACJ;QACJ;QACA,OAAO;YAAE,MAAM,uJAAI,CAAC,MAAM;YAAE,QAAQ;QAAW;IACnD;IACA,yEAAyE;IACzE,IAAI,OAAO,UAAU,WAAW;QAC5B,OAAO;YAAE,MAAM,uJAAI,CAAC,OAAO;YAAE;QAAM;IACvC;IACA,IAAI,OAAO,UAAU,UAAU;QAC3B,OAAO;YAAE,MAAM,uJAAI,CAAC,GAAG;YAAE,OAAO,OAAO;QAAO;IAClD;IACA,iDAAiD;IACjD,IAAI,OAAO,UAAU,YAAY,SAAS,QAAQ;QAC9C,MAAM,YAAY,OAAO;QACzB,OAAO,oBAAoB,IAAI,CAAC,aAC1B;YAAE,MAAM,uJAAI,CAAC,GAAG;YAAE,OAAO;QAAU,IACnC;YAAE,MAAM,uJAAI,CAAC,KAAK;YAAE,OAAO;QAAU;IAC/C;IACA,IAAI,OAAO,UAAU,UAAU;QAC3B,OAAO;YAAE,MAAM,uJAAI,CAAC,MAAM;YAAE;QAAM;IACtC;IACA,MAAM,IAAI,UAAU,CAAC,6BAA6B,EAAE,MAAM,CAAC,CAAC;AAChE;AACA;;;;CAIC,GACD,MAAM,sBAAsB","ignoreList":[0]}},
    {"offset": {"line": 1099, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/astFromValue.js"],"sourcesContent":["import { inspect } from 'cross-inspect';\nimport { isEnumType, isInputObjectType, isLeafType, isListType, isNonNullType, Kind, } from 'graphql';\nimport { astFromValueUntyped } from './astFromValueUntyped.js';\nimport { isIterableObject, isObjectLike } from './jsutils.js';\n/**\n * Produces a GraphQL Value AST given a JavaScript object.\n * Function will match JavaScript/JSON values to GraphQL AST schema format\n * by using suggested GraphQLInputType. For example:\n *\n *     astFromValue(\"value\", GraphQLString)\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * JavaScript values.\n *\n * | JSON Value    | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String / Enum Value  |\n * | Number        | Int / Float          |\n * | BigInt        | Int                  |\n * | Unknown       | Enum Value           |\n * | null          | NullValue            |\n *\n */\nexport function astFromValue(value, type) {\n    if (isNonNullType(type)) {\n        const astValue = astFromValue(value, type.ofType);\n        if (astValue?.kind === Kind.NULL) {\n            return null;\n        }\n        return astValue;\n    }\n    // only explicit null, not undefined, NaN\n    if (value === null) {\n        return { kind: Kind.NULL };\n    }\n    // undefined\n    if (value === undefined) {\n        return null;\n    }\n    // Convert JavaScript array to GraphQL list. If the GraphQLType is a list, but\n    // the value is not an array, convert the value using the list's item type.\n    if (isListType(type)) {\n        const itemType = type.ofType;\n        if (isIterableObject(value)) {\n            const valuesNodes = [];\n            for (const item of value) {\n                const itemNode = astFromValue(item, itemType);\n                if (itemNode != null) {\n                    valuesNodes.push(itemNode);\n                }\n            }\n            return { kind: Kind.LIST, values: valuesNodes };\n        }\n        return astFromValue(value, itemType);\n    }\n    // Populate the fields of the input object by creating ASTs from each value\n    // in the JavaScript object according to the fields in the input type.\n    if (isInputObjectType(type)) {\n        if (!isObjectLike(value)) {\n            return null;\n        }\n        const fieldNodes = [];\n        for (const field of Object.values(type.getFields())) {\n            const fieldValue = astFromValue(value[field.name], field.type);\n            if (fieldValue) {\n                fieldNodes.push({\n                    kind: Kind.OBJECT_FIELD,\n                    name: { kind: Kind.NAME, value: field.name },\n                    value: fieldValue,\n                });\n            }\n        }\n        return { kind: Kind.OBJECT, fields: fieldNodes };\n    }\n    if (isLeafType(type)) {\n        // Since value is an internally represented value, it must be serialized\n        // to an externally represented value before converting into an AST.\n        const serialized = type.serialize(value);\n        if (serialized == null) {\n            return null;\n        }\n        if (isEnumType(type)) {\n            return { kind: Kind.ENUM, value: serialized };\n        }\n        // ID types can use Int literals.\n        if (type.name === 'ID' &&\n            typeof serialized === 'string' &&\n            integerStringRegExp.test(serialized)) {\n            return { kind: Kind.INT, value: serialized };\n        }\n        return astFromValueUntyped(serialized);\n    }\n    /* c8 ignore next 3 */\n    // Not reachable, all possible types have been considered.\n    console.assert(false, 'Unexpected input type: ' + inspect(type));\n}\n/**\n * IntValue:\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit ( Digit+ )?\n */\nconst integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AACA;AACA;;;;;AAuBO,SAAS,aAAa,KAAK,EAAE,IAAI;IACpC,IAAI,IAAA,iKAAa,EAAC,OAAO;QACrB,MAAM,WAAW,aAAa,OAAO,KAAK,MAAM;QAChD,IAAI,UAAU,SAAS,uJAAI,CAAC,IAAI,EAAE;YAC9B,OAAO;QACX;QACA,OAAO;IACX;IACA,yCAAyC;IACzC,IAAI,UAAU,MAAM;QAChB,OAAO;YAAE,MAAM,uJAAI,CAAC,IAAI;QAAC;IAC7B;IACA,YAAY;IACZ,IAAI,UAAU,WAAW;QACrB,OAAO;IACX;IACA,8EAA8E;IAC9E,2EAA2E;IAC3E,IAAI,IAAA,8JAAU,EAAC,OAAO;QAClB,MAAM,WAAW,KAAK,MAAM;QAC5B,IAAI,IAAA,mMAAgB,EAAC,QAAQ;YACzB,MAAM,cAAc,EAAE;YACtB,KAAK,MAAM,QAAQ,MAAO;gBACtB,MAAM,WAAW,aAAa,MAAM;gBACpC,IAAI,YAAY,MAAM;oBAClB,YAAY,IAAI,CAAC;gBACrB;YACJ;YACA,OAAO;gBAAE,MAAM,uJAAI,CAAC,IAAI;gBAAE,QAAQ;YAAY;QAClD;QACA,OAAO,aAAa,OAAO;IAC/B;IACA,2EAA2E;IAC3E,sEAAsE;IACtE,IAAI,IAAA,qKAAiB,EAAC,OAAO;QACzB,IAAI,CAAC,IAAA,+LAAY,EAAC,QAAQ;YACtB,OAAO;QACX;QACA,MAAM,aAAa,EAAE;QACrB,KAAK,MAAM,SAAS,OAAO,MAAM,CAAC,KAAK,SAAS,IAAK;YACjD,MAAM,aAAa,aAAa,KAAK,CAAC,MAAM,IAAI,CAAC,EAAE,MAAM,IAAI;YAC7D,IAAI,YAAY;gBACZ,WAAW,IAAI,CAAC;oBACZ,MAAM,uJAAI,CAAC,YAAY;oBACvB,MAAM;wBAAE,MAAM,uJAAI,CAAC,IAAI;wBAAE,OAAO,MAAM,IAAI;oBAAC;oBAC3C,OAAO;gBACX;YACJ;QACJ;QACA,OAAO;YAAE,MAAM,uJAAI,CAAC,MAAM;YAAE,QAAQ;QAAW;IACnD;IACA,IAAI,IAAA,8JAAU,EAAC,OAAO;QAClB,wEAAwE;QACxE,oEAAoE;QACpE,MAAM,aAAa,KAAK,SAAS,CAAC;QAClC,IAAI,cAAc,MAAM;YACpB,OAAO;QACX;QACA,IAAI,IAAA,8JAAU,EAAC,OAAO;YAClB,OAAO;gBAAE,MAAM,uJAAI,CAAC,IAAI;gBAAE,OAAO;YAAW;QAChD;QACA,iCAAiC;QACjC,IAAI,KAAK,IAAI,KAAK,QACd,OAAO,eAAe,YACtB,oBAAoB,IAAI,CAAC,aAAa;YACtC,OAAO;gBAAE,MAAM,uJAAI,CAAC,GAAG;gBAAE,OAAO;YAAW;QAC/C;QACA,OAAO,IAAA,kMAAmB,EAAC;IAC/B;IACA,oBAAoB,GACpB,0DAA0D;IAC1D,QAAQ,MAAM,CAAC,OAAO,4BAA4B,IAAA,6JAAO,EAAC;AAC9D;AACA;;;;CAIC,GACD,MAAM,sBAAsB","ignoreList":[0]}},
    {"offset": {"line": 1208, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/descriptionFromObject.js"],"sourcesContent":["import { Kind } from 'graphql';\nexport function getDescriptionNode(obj) {\n    if (obj.astNode?.description) {\n        return {\n            ...obj.astNode.description,\n            block: true,\n        };\n    }\n    if (obj.description) {\n        return {\n            kind: Kind.STRING,\n            value: obj.description,\n            block: true,\n        };\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,mBAAmB,GAAG;IAClC,IAAI,IAAI,OAAO,EAAE,aAAa;QAC1B,OAAO;YACH,GAAG,IAAI,OAAO,CAAC,WAAW;YAC1B,OAAO;QACX;IACJ;IACA,IAAI,IAAI,WAAW,EAAE;QACjB,OAAO;YACH,MAAM,uJAAI,CAAC,MAAM;YACjB,OAAO,IAAI,WAAW;YACtB,OAAO;QACX;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 1233, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/getDirectiveExtensions.js"],"sourcesContent":["import { valueFromAST, valueFromASTUntyped } from 'graphql';\nimport { getArgumentValues } from './getArgumentValues.js';\nimport { memoize1 } from './memoize.js';\nexport function getDirectiveExtensions(directableObj, schema, pathToDirectivesInExtensions = ['directives']) {\n    const directiveExtensions = {};\n    if (directableObj.extensions) {\n        let directivesInExtensions = directableObj.extensions;\n        for (const pathSegment of pathToDirectivesInExtensions) {\n            directivesInExtensions = directivesInExtensions?.[pathSegment];\n        }\n        if (directivesInExtensions != null) {\n            for (const directiveNameProp in directivesInExtensions) {\n                const directiveObjs = directivesInExtensions[directiveNameProp];\n                const directiveName = directiveNameProp;\n                if (Array.isArray(directiveObjs)) {\n                    for (const directiveObj of directiveObjs) {\n                        let existingDirectiveExtensions = directiveExtensions[directiveName];\n                        if (!existingDirectiveExtensions) {\n                            existingDirectiveExtensions = [];\n                            directiveExtensions[directiveName] = existingDirectiveExtensions;\n                        }\n                        existingDirectiveExtensions.push(directiveObj);\n                    }\n                }\n                else {\n                    let existingDirectiveExtensions = directiveExtensions[directiveName];\n                    if (!existingDirectiveExtensions) {\n                        existingDirectiveExtensions = [];\n                        directiveExtensions[directiveName] = existingDirectiveExtensions;\n                    }\n                    existingDirectiveExtensions.push(directiveObjs);\n                }\n            }\n        }\n    }\n    const memoizedStringify = memoize1(obj => JSON.stringify(obj));\n    const astNodes = [];\n    if (directableObj.astNode) {\n        astNodes.push(directableObj.astNode);\n    }\n    if (directableObj.extensionASTNodes) {\n        astNodes.push(...directableObj.extensionASTNodes);\n    }\n    for (const astNode of astNodes) {\n        if (astNode.directives?.length) {\n            for (const directive of astNode.directives) {\n                const directiveName = directive.name.value;\n                let existingDirectiveExtensions = directiveExtensions[directiveName];\n                if (!existingDirectiveExtensions) {\n                    existingDirectiveExtensions = [];\n                    directiveExtensions[directiveName] = existingDirectiveExtensions;\n                }\n                const directiveInSchema = schema?.getDirective(directiveName);\n                let value = {};\n                if (directiveInSchema) {\n                    value = getArgumentValues(directiveInSchema, directive);\n                }\n                if (directive.arguments) {\n                    for (const argNode of directive.arguments) {\n                        const argName = argNode.name.value;\n                        if (value[argName] == null) {\n                            const argInDirective = directiveInSchema?.args.find(arg => arg.name === argName);\n                            if (argInDirective) {\n                                value[argName] = valueFromAST(argNode.value, argInDirective.type);\n                            }\n                        }\n                        if (value[argName] == null) {\n                            value[argName] = valueFromASTUntyped(argNode.value);\n                        }\n                    }\n                }\n                if (astNodes.length > 0 && existingDirectiveExtensions.length > 0) {\n                    const valStr = memoizedStringify(value);\n                    if (existingDirectiveExtensions.some(val => memoizedStringify(val) === valStr)) {\n                        continue;\n                    }\n                }\n                existingDirectiveExtensions.push(value);\n            }\n        }\n    }\n    return directiveExtensions;\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;;;;AACO,SAAS,uBAAuB,aAAa,EAAE,MAAM,EAAE,+BAA+B;IAAC;CAAa;IACvG,MAAM,sBAAsB,CAAC;IAC7B,IAAI,cAAc,UAAU,EAAE;QAC1B,IAAI,yBAAyB,cAAc,UAAU;QACrD,KAAK,MAAM,eAAe,6BAA8B;YACpD,yBAAyB,wBAAwB,CAAC,YAAY;QAClE;QACA,IAAI,0BAA0B,MAAM;YAChC,IAAK,MAAM,qBAAqB,uBAAwB;gBACpD,MAAM,gBAAgB,sBAAsB,CAAC,kBAAkB;gBAC/D,MAAM,gBAAgB;gBACtB,IAAI,MAAM,OAAO,CAAC,gBAAgB;oBAC9B,KAAK,MAAM,gBAAgB,cAAe;wBACtC,IAAI,8BAA8B,mBAAmB,CAAC,cAAc;wBACpE,IAAI,CAAC,6BAA6B;4BAC9B,8BAA8B,EAAE;4BAChC,mBAAmB,CAAC,cAAc,GAAG;wBACzC;wBACA,4BAA4B,IAAI,CAAC;oBACrC;gBACJ,OACK;oBACD,IAAI,8BAA8B,mBAAmB,CAAC,cAAc;oBACpE,IAAI,CAAC,6BAA6B;wBAC9B,8BAA8B,EAAE;wBAChC,mBAAmB,CAAC,cAAc,GAAG;oBACzC;oBACA,4BAA4B,IAAI,CAAC;gBACrC;YACJ;QACJ;IACJ;IACA,MAAM,oBAAoB,IAAA,2KAAQ,EAAC,CAAA,MAAO,KAAK,SAAS,CAAC;IACzD,MAAM,WAAW,EAAE;IACnB,IAAI,cAAc,OAAO,EAAE;QACvB,SAAS,IAAI,CAAC,cAAc,OAAO;IACvC;IACA,IAAI,cAAc,iBAAiB,EAAE;QACjC,SAAS,IAAI,IAAI,cAAc,iBAAiB;IACpD;IACA,KAAK,MAAM,WAAW,SAAU;QAC5B,IAAI,QAAQ,UAAU,EAAE,QAAQ;YAC5B,KAAK,MAAM,aAAa,QAAQ,UAAU,CAAE;gBACxC,MAAM,gBAAgB,UAAU,IAAI,CAAC,KAAK;gBAC1C,IAAI,8BAA8B,mBAAmB,CAAC,cAAc;gBACpE,IAAI,CAAC,6BAA6B;oBAC9B,8BAA8B,EAAE;oBAChC,mBAAmB,CAAC,cAAc,GAAG;gBACzC;gBACA,MAAM,oBAAoB,QAAQ,aAAa;gBAC/C,IAAI,QAAQ,CAAC;gBACb,IAAI,mBAAmB;oBACnB,QAAQ,IAAA,8LAAiB,EAAC,mBAAmB;gBACjD;gBACA,IAAI,UAAU,SAAS,EAAE;oBACrB,KAAK,MAAM,WAAW,UAAU,SAAS,CAAE;wBACvC,MAAM,UAAU,QAAQ,IAAI,CAAC,KAAK;wBAClC,IAAI,KAAK,CAAC,QAAQ,IAAI,MAAM;4BACxB,MAAM,iBAAiB,mBAAmB,KAAK,KAAK,CAAA,MAAO,IAAI,IAAI,KAAK;4BACxE,IAAI,gBAAgB;gCAChB,KAAK,CAAC,QAAQ,GAAG,IAAA,uKAAY,EAAC,QAAQ,KAAK,EAAE,eAAe,IAAI;4BACpE;wBACJ;wBACA,IAAI,KAAK,CAAC,QAAQ,IAAI,MAAM;4BACxB,KAAK,CAAC,QAAQ,GAAG,IAAA,qLAAmB,EAAC,QAAQ,KAAK;wBACtD;oBACJ;gBACJ;gBACA,IAAI,SAAS,MAAM,GAAG,KAAK,4BAA4B,MAAM,GAAG,GAAG;oBAC/D,MAAM,SAAS,kBAAkB;oBACjC,IAAI,4BAA4B,IAAI,CAAC,CAAA,MAAO,kBAAkB,SAAS,SAAS;wBAC5E;oBACJ;gBACJ;gBACA,4BAA4B,IAAI,CAAC;YACrC;QACJ;IACJ;IACA,OAAO;AACX","ignoreList":[0]}},
    {"offset": {"line": 1329, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/get-directives.js"],"sourcesContent":["import { getDirectiveExtensions } from './getDirectiveExtensions.js';\nexport function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ['directives']) {\n    const directiveExtensions = getDirectiveExtensions(node, undefined, pathToDirectivesInExtensions);\n    return Object.entries(directiveExtensions)\n        .map(([directiveName, directiveArgsArr]) => directiveArgsArr?.map(directiveArgs => ({\n        name: directiveName,\n        args: directiveArgs,\n    })))\n        .flat(Infinity)\n        .filter(Boolean);\n}\nexport function getDirectiveInExtensions(node, directiveName, pathToDirectivesInExtensions = ['directives']) {\n    const directiveExtensions = getDirectiveExtensions(node, undefined, pathToDirectivesInExtensions);\n    return directiveExtensions[directiveName];\n}\nexport function getDirectives(schema, node, pathToDirectivesInExtensions = ['directives']) {\n    const directiveExtensions = getDirectiveExtensions(node, schema, pathToDirectivesInExtensions);\n    return Object.entries(directiveExtensions)\n        .map(([directiveName, directiveArgsArr]) => directiveArgsArr?.map(directiveArgs => ({\n        name: directiveName,\n        args: directiveArgs,\n    })))\n        .flat(Infinity)\n        .filter(Boolean);\n}\nexport function getDirective(schema, node, directiveName, pathToDirectivesInExtensions = ['directives']) {\n    const directiveExtensions = getDirectiveExtensions(node, schema, pathToDirectivesInExtensions);\n    return directiveExtensions[directiveName];\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AACO,SAAS,0BAA0B,IAAI,EAAE,+BAA+B;IAAC;CAAa;IACzF,MAAM,sBAAsB,IAAA,wMAAsB,EAAC,MAAM,WAAW;IACpE,OAAO,OAAO,OAAO,CAAC,qBACjB,GAAG,CAAC,CAAC,CAAC,eAAe,iBAAiB,GAAK,kBAAkB,IAAI,CAAA,gBAAiB,CAAC;gBACpF,MAAM;gBACN,MAAM;YACV,CAAC,IACI,IAAI,CAAC,UACL,MAAM,CAAC;AAChB;AACO,SAAS,yBAAyB,IAAI,EAAE,aAAa,EAAE,+BAA+B;IAAC;CAAa;IACvG,MAAM,sBAAsB,IAAA,wMAAsB,EAAC,MAAM,WAAW;IACpE,OAAO,mBAAmB,CAAC,cAAc;AAC7C;AACO,SAAS,cAAc,MAAM,EAAE,IAAI,EAAE,+BAA+B;IAAC;CAAa;IACrF,MAAM,sBAAsB,IAAA,wMAAsB,EAAC,MAAM,QAAQ;IACjE,OAAO,OAAO,OAAO,CAAC,qBACjB,GAAG,CAAC,CAAC,CAAC,eAAe,iBAAiB,GAAK,kBAAkB,IAAI,CAAA,gBAAiB,CAAC;gBACpF,MAAM;gBACN,MAAM;YACV,CAAC,IACI,IAAI,CAAC,UACL,MAAM,CAAC;AAChB;AACO,SAAS,aAAa,MAAM,EAAE,IAAI,EAAE,aAAa,EAAE,+BAA+B;IAAC;CAAa;IACnG,MAAM,sBAAsB,IAAA,wMAAsB,EAAC,MAAM,QAAQ;IACjE,OAAO,mBAAmB,CAAC,cAAc;AAC7C","ignoreList":[0]}},
    {"offset": {"line": 1375, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/print-schema-with-directives.js"],"sourcesContent":["import { GraphQLDeprecatedDirective, isEnumType, isInputObjectType, isInterfaceType, isIntrospectionType, isObjectType, isScalarType, isSpecifiedDirective, isSpecifiedScalarType, isUnionType, Kind, print, specifiedDirectives, } from 'graphql';\nimport { astFromType } from './astFromType.js';\nimport { astFromValue } from './astFromValue.js';\nimport { astFromValueUntyped } from './astFromValueUntyped.js';\nimport { getDescriptionNode } from './descriptionFromObject.js';\nimport { getDirectivesInExtensions, } from './get-directives.js';\nimport { isSome } from './helpers.js';\nimport { getRootTypeMap } from './rootTypes.js';\nexport function getDocumentNodeFromSchema(schema, options = {}) {\n    const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;\n    const typesMap = schema.getTypeMap();\n    const schemaNode = astFromSchema(schema, pathToDirectivesInExtensions);\n    const definitions = schemaNode != null ? [schemaNode] : [];\n    const directives = schema.getDirectives();\n    for (const directive of directives) {\n        if (isSpecifiedDirective(directive)) {\n            continue;\n        }\n        definitions.push(astFromDirective(directive, schema, pathToDirectivesInExtensions));\n    }\n    for (const typeName in typesMap) {\n        const type = typesMap[typeName];\n        const isPredefinedScalar = isSpecifiedScalarType(type);\n        const isIntrospection = isIntrospectionType(type);\n        if (isPredefinedScalar || isIntrospection) {\n            continue;\n        }\n        if (isObjectType(type)) {\n            definitions.push(astFromObjectType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isInterfaceType(type)) {\n            definitions.push(astFromInterfaceType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isUnionType(type)) {\n            definitions.push(astFromUnionType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isInputObjectType(type)) {\n            definitions.push(astFromInputObjectType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isEnumType(type)) {\n            definitions.push(astFromEnumType(type, schema, pathToDirectivesInExtensions));\n        }\n        else if (isScalarType(type)) {\n            definitions.push(astFromScalarType(type, schema, pathToDirectivesInExtensions));\n        }\n        else {\n            throw new Error(`Unknown type ${type}.`);\n        }\n    }\n    return {\n        kind: Kind.DOCUMENT,\n        definitions,\n    };\n}\n// this approach uses the default schema printer rather than a custom solution, so may be more backwards compatible\n// currently does not allow customization of printSchema options having to do with comments.\nexport function printSchemaWithDirectives(schema, options = {}) {\n    const documentNode = getDocumentNodeFromSchema(schema, options);\n    return print(documentNode);\n}\nexport function astFromSchema(schema, pathToDirectivesInExtensions) {\n    const operationTypeMap = new Map([\n        ['query', undefined],\n        ['mutation', undefined],\n        ['subscription', undefined],\n    ]);\n    const nodes = [];\n    if (schema.astNode != null) {\n        nodes.push(schema.astNode);\n    }\n    if (schema.extensionASTNodes != null) {\n        for (const extensionASTNode of schema.extensionASTNodes) {\n            nodes.push(extensionASTNode);\n        }\n    }\n    for (const node of nodes) {\n        if (node.operationTypes) {\n            for (const operationTypeDefinitionNode of node.operationTypes) {\n                operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);\n            }\n        }\n    }\n    const rootTypeMap = getRootTypeMap(schema);\n    for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {\n        const rootType = rootTypeMap.get(operationTypeNode);\n        if (rootType != null) {\n            const rootTypeAST = astFromType(rootType);\n            if (operationTypeDefinitionNode != null) {\n                operationTypeDefinitionNode.type = rootTypeAST;\n            }\n            else {\n                operationTypeMap.set(operationTypeNode, {\n                    kind: Kind.OPERATION_TYPE_DEFINITION,\n                    operation: operationTypeNode,\n                    type: rootTypeAST,\n                });\n            }\n        }\n    }\n    const operationTypes = [...operationTypeMap.values()].filter(isSome);\n    const directives = getDirectiveNodes(schema, schema, pathToDirectivesInExtensions);\n    if (!operationTypes.length && !directives.length) {\n        return null;\n    }\n    const schemaNode = {\n        kind: operationTypes != null ? Kind.SCHEMA_DEFINITION : Kind.SCHEMA_EXTENSION,\n        operationTypes,\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: directives,\n    };\n    const descriptionNode = getDescriptionNode(schema);\n    if (descriptionNode) {\n        schemaNode.description = descriptionNode;\n    }\n    return schemaNode;\n}\nexport function astFromDirective(directive, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.DIRECTIVE_DEFINITION,\n        description: getDescriptionNode(directive),\n        name: {\n            kind: Kind.NAME,\n            value: directive.name,\n        },\n        arguments: directive.args?.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n        repeatable: directive.isRepeatable,\n        locations: directive.locations?.map(location => ({\n            kind: Kind.NAME,\n            value: location,\n        })) || [],\n    };\n}\nexport function getDirectiveNodes(entity, schema, pathToDirectivesInExtensions) {\n    let directiveNodesBesidesNativeDirectives = [];\n    const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);\n    let directives;\n    if (directivesInExtensions != null) {\n        directives = makeDirectiveNodes(schema, directivesInExtensions);\n    }\n    let deprecatedDirectiveNode = null;\n    let specifiedByDirectiveNode = null;\n    let oneOfDirectiveNode = null;\n    if (directives != null) {\n        directiveNodesBesidesNativeDirectives = directives.filter(directive => specifiedDirectives.every(specifiedDirective => specifiedDirective.name !== directive.name.value));\n        deprecatedDirectiveNode = directives.find(directive => directive.name.value === 'deprecated');\n        specifiedByDirectiveNode = directives.find(directive => directive.name.value === 'specifiedBy');\n        oneOfDirectiveNode = directives.find(directive => directive.name.value === 'oneOf');\n    }\n    if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {\n        deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);\n    }\n    if (entity.specifiedByUrl != null ||\n        (entity.specifiedByURL != null && specifiedByDirectiveNode == null)) {\n        const specifiedByValue = entity.specifiedByUrl || entity.specifiedByURL;\n        const specifiedByArgs = {\n            url: specifiedByValue,\n        };\n        specifiedByDirectiveNode = makeDirectiveNode('specifiedBy', specifiedByArgs);\n    }\n    if (entity.isOneOf && oneOfDirectiveNode == null) {\n        oneOfDirectiveNode = makeDirectiveNode('oneOf');\n    }\n    if (deprecatedDirectiveNode != null) {\n        directiveNodesBesidesNativeDirectives.push(deprecatedDirectiveNode);\n    }\n    if (specifiedByDirectiveNode != null) {\n        directiveNodesBesidesNativeDirectives.push(specifiedByDirectiveNode);\n    }\n    if (oneOfDirectiveNode != null) {\n        directiveNodesBesidesNativeDirectives.push(oneOfDirectiveNode);\n    }\n    return directiveNodesBesidesNativeDirectives;\n}\nexport function astFromArg(arg, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.INPUT_VALUE_DEFINITION,\n        description: getDescriptionNode(arg),\n        name: {\n            kind: Kind.NAME,\n            value: arg.name,\n        },\n        type: astFromType(arg.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        defaultValue: arg.defaultValue !== undefined\n            ? (astFromValue(arg.defaultValue, arg.type) ?? undefined)\n            : undefined,\n        directives: getDirectiveNodes(arg, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromObjectType(type, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.OBJECT_TYPE_DEFINITION,\n        description: getDescriptionNode(type),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n        interfaces: Object.values(type.getInterfaces()).map(iFace => astFromType(iFace)),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromInterfaceType(type, schema, pathToDirectivesInExtensions) {\n    const node = {\n        kind: Kind.INTERFACE_TYPE_DEFINITION,\n        description: getDescriptionNode(type),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromField(field, schema, pathToDirectivesInExtensions)),\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n    if ('getInterfaces' in type) {\n        node.interfaces = Object.values(type.getInterfaces()).map(iFace => astFromType(iFace));\n    }\n    return node;\n}\nexport function astFromUnionType(type, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.UNION_TYPE_DEFINITION,\n        description: getDescriptionNode(type),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n        types: type.getTypes().map(type => astFromType(type)),\n    };\n}\nexport function astFromInputObjectType(type, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        description: getDescriptionNode(type),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        fields: Object.values(type.getFields()).map(field => astFromInputField(field, schema, pathToDirectivesInExtensions)),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromEnumType(type, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.ENUM_TYPE_DEFINITION,\n        description: getDescriptionNode(type),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        values: Object.values(type.getValues()).map(value => astFromEnumValue(value, schema, pathToDirectivesInExtensions)),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(type, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromScalarType(type, schema, pathToDirectivesInExtensions) {\n    const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);\n    const directives = makeDirectiveNodes(schema, directivesInExtensions);\n    const specifiedByValue = (type['specifiedByUrl'] ||\n        type['specifiedByURL']);\n    if (specifiedByValue &&\n        !directives.some(directiveNode => directiveNode.name.value === 'specifiedBy')) {\n        const specifiedByArgs = {\n            url: specifiedByValue,\n        };\n        directives.push(makeDirectiveNode('specifiedBy', specifiedByArgs));\n    }\n    return {\n        kind: Kind.SCALAR_TYPE_DEFINITION,\n        description: getDescriptionNode(type),\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: directives,\n    };\n}\nexport function astFromField(field, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.FIELD_DEFINITION,\n        description: getDescriptionNode(field),\n        name: {\n            kind: Kind.NAME,\n            value: field.name,\n        },\n        arguments: field.args.map(arg => astFromArg(arg, schema, pathToDirectivesInExtensions)),\n        type: astFromType(field.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function astFromInputField(field, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.INPUT_VALUE_DEFINITION,\n        description: getDescriptionNode(field),\n        name: {\n            kind: Kind.NAME,\n            value: field.name,\n        },\n        type: astFromType(field.type),\n        // ConstXNode has been introduced in v16 but it is not compatible with XNode so we do `as any` for backwards compatibility\n        directives: getDirectiveNodes(field, schema, pathToDirectivesInExtensions),\n        defaultValue: astFromValue(field.defaultValue, field.type) ?? undefined,\n    };\n}\nexport function astFromEnumValue(value, schema, pathToDirectivesInExtensions) {\n    return {\n        kind: Kind.ENUM_VALUE_DEFINITION,\n        description: getDescriptionNode(value),\n        name: {\n            kind: Kind.NAME,\n            value: value.name,\n        },\n        directives: getDirectiveNodes(value, schema, pathToDirectivesInExtensions),\n    };\n}\nexport function makeDeprecatedDirective(deprecationReason) {\n    return makeDirectiveNode('deprecated', { reason: deprecationReason }, GraphQLDeprecatedDirective);\n}\nexport function makeDirectiveNode(name, args, directive) {\n    const directiveArguments = [];\n    for (const argName in args) {\n        const argValue = args[argName];\n        let value;\n        if (directive != null) {\n            const arg = directive.args.find(arg => arg.name === argName);\n            if (arg) {\n                value = astFromValue(argValue, arg.type);\n            }\n        }\n        if (value == null) {\n            value = astFromValueUntyped(argValue);\n        }\n        if (value != null) {\n            directiveArguments.push({\n                kind: Kind.ARGUMENT,\n                name: {\n                    kind: Kind.NAME,\n                    value: argName,\n                },\n                value,\n            });\n        }\n    }\n    return {\n        kind: Kind.DIRECTIVE,\n        name: {\n            kind: Kind.NAME,\n            value: name,\n        },\n        arguments: directiveArguments,\n    };\n}\nexport function makeDirectiveNodes(schema, directiveValues) {\n    const directiveNodes = [];\n    for (const { name, args } of directiveValues) {\n        const directive = schema?.getDirective(name);\n        directiveNodes.push(makeDirectiveNode(name, args, directive));\n    }\n    return directiveNodes;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1795, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/isDocumentNode.js"],"sourcesContent":["import { Kind } from 'graphql';\nexport function isDocumentNode(object) {\n    return object && typeof object === 'object' && 'kind' in object && object.kind === Kind.DOCUMENT;\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,eAAe,MAAM;IACjC,OAAO,UAAU,OAAO,WAAW,YAAY,UAAU,UAAU,OAAO,IAAI,KAAK,uJAAI,CAAC,QAAQ;AACpG","ignoreList":[0]}},
    {"offset": {"line": 1808, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/comments.js"],"sourcesContent":["import { TokenKind, visit, } from 'graphql';\nconst MAX_LINE_LENGTH = 80;\nlet commentsRegistry = {};\nexport function resetComments() {\n    commentsRegistry = {};\n}\nexport function collectComment(node) {\n    const entityName = node.name?.value;\n    if (entityName == null) {\n        return;\n    }\n    pushComment(node, entityName);\n    switch (node.kind) {\n        case 'EnumTypeDefinition':\n            if (node.values) {\n                for (const value of node.values) {\n                    pushComment(value, entityName, value.name.value);\n                }\n            }\n            break;\n        case 'ObjectTypeDefinition':\n        case 'InputObjectTypeDefinition':\n        case 'InterfaceTypeDefinition':\n            if (node.fields) {\n                for (const field of node.fields) {\n                    pushComment(field, entityName, field.name.value);\n                    if (isFieldDefinitionNode(field) && field.arguments) {\n                        for (const arg of field.arguments) {\n                            pushComment(arg, entityName, field.name.value, arg.name.value);\n                        }\n                    }\n                }\n            }\n            break;\n    }\n}\nexport function pushComment(node, entity, field, argument) {\n    const comment = getComment(node);\n    if (typeof comment !== 'string' || comment.length === 0) {\n        return;\n    }\n    const keys = [entity];\n    if (field) {\n        keys.push(field);\n        if (argument) {\n            keys.push(argument);\n        }\n    }\n    const path = keys.join('.');\n    if (!commentsRegistry[path]) {\n        commentsRegistry[path] = [];\n    }\n    commentsRegistry[path].push(comment);\n}\nexport function printComment(comment) {\n    return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n    return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\nfunction hasMultilineItems(maybeArray) {\n    return maybeArray?.some(str => str.includes('\\n')) ?? false;\n}\nfunction addDescription(cb) {\n    return (node, _key, _parent, path, ancestors) => {\n        const keys = [];\n        const parent = path.reduce((prev, key) => {\n            if (['fields', 'arguments', 'values'].includes(key) && prev.name) {\n                keys.push(prev.name.value);\n            }\n            return prev[key];\n        }, ancestors[0]);\n        const key = [...keys, parent?.name?.value].filter(Boolean).join('.');\n        const items = [];\n        if (node.kind.includes('Definition') && commentsRegistry[key]) {\n            items.push(...commentsRegistry[key]);\n        }\n        return join([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], '\\n');\n    };\n}\nfunction indent(maybeString) {\n    return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n    return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n    return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription = false) {\n    const escaped = value.replace(/\\\\/g, '\\\\\\\\').replace(/\"\"\"/g, '\\\\\"\"\"');\n    return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1\n        ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"`\n        : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\nconst printDocASTReducer = {\n    Name: { leave: node => node.value },\n    Variable: { leave: node => '$' + node.name },\n    // Document\n    Document: {\n        leave: node => join(node.definitions, '\\n\\n'),\n    },\n    OperationDefinition: {\n        leave: node => {\n            const varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n            const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, ' ')], ' ');\n            // the query short form.\n            return prefix + ' ' + node.selectionSet;\n        },\n    },\n    VariableDefinition: {\n        leave: ({ variable, type, defaultValue, directives }) => variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' ')),\n    },\n    SelectionSet: { leave: ({ selections }) => block(selections) },\n    Field: {\n        leave({ alias, name, arguments: args, directives, selectionSet }) {\n            const prefix = wrap('', alias, ': ') + name;\n            let argsLine = prefix + wrap('(', join(args, ', '), ')');\n            if (argsLine.length > MAX_LINE_LENGTH) {\n                argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n            }\n            return join([argsLine, join(directives, ' '), selectionSet], ' ');\n        },\n    },\n    Argument: { leave: ({ name, value }) => name + ': ' + value },\n    // Fragments\n    FragmentSpread: {\n        leave: ({ name, directives }) => '...' + name + wrap(' ', join(directives, ' ')),\n    },\n    InlineFragment: {\n        leave: ({ typeCondition, directives, selectionSet }) => join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' '),\n    },\n    FragmentDefinition: {\n        leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => \n        // Note: fragment variable definitions are experimental and may be changed\n        // or removed in the future.\n        `fragment ${name}${wrap('(', join(variableDefinitions, ', '), ')')} ` +\n            `on ${typeCondition} ${wrap('', join(directives, ' '), ' ')}` +\n            selectionSet,\n    },\n    // Value\n    IntValue: { leave: ({ value }) => value },\n    FloatValue: { leave: ({ value }) => value },\n    StringValue: {\n        leave: ({ value, block: isBlockString }) => {\n            if (isBlockString) {\n                return printBlockString(value);\n            }\n            return JSON.stringify(value);\n        },\n    },\n    BooleanValue: { leave: ({ value }) => (value ? 'true' : 'false') },\n    NullValue: { leave: () => 'null' },\n    EnumValue: { leave: ({ value }) => value },\n    ListValue: { leave: ({ values }) => '[' + join(values, ', ') + ']' },\n    ObjectValue: { leave: ({ fields }) => '{' + join(fields, ', ') + '}' },\n    ObjectField: { leave: ({ name, value }) => name + ': ' + value },\n    // Directive\n    Directive: {\n        leave: ({ name, arguments: args }) => '@' + name + wrap('(', join(args, ', '), ')'),\n    },\n    // Type\n    NamedType: { leave: ({ name }) => name },\n    ListType: { leave: ({ type }) => '[' + type + ']' },\n    NonNullType: { leave: ({ type }) => type + '!' },\n    // Type System Definitions\n    SchemaDefinition: {\n        leave: ({ directives, operationTypes }) => join(['schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    OperationTypeDefinition: {\n        leave: ({ operation, type }) => operation + ': ' + type,\n    },\n    ScalarTypeDefinition: {\n        leave: ({ name, directives }) => join(['scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join([\n            'type',\n            name,\n            wrap('implements ', join(interfaces, ' & ')),\n            join(directives, ' '),\n            block(fields),\n        ], ' '),\n    },\n    FieldDefinition: {\n        leave: ({ name, arguments: args, type, directives }) => name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            ': ' +\n            type +\n            wrap(' ', join(directives, ' ')),\n    },\n    InputValueDefinition: {\n        leave: ({ name, type, defaultValue, directives }) => join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' '),\n    },\n    InterfaceTypeDefinition: {\n        leave: ({ name, interfaces, directives, fields }) => join([\n            'interface',\n            name,\n            wrap('implements ', join(interfaces, ' & ')),\n            join(directives, ' '),\n            block(fields),\n        ], ' '),\n    },\n    UnionTypeDefinition: {\n        leave: ({ name, directives, types }) => join(['union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeDefinition: {\n        leave: ({ name, directives, values }) => join(['enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    EnumValueDefinition: {\n        leave: ({ name, directives }) => join([name, join(directives, ' ')], ' '),\n    },\n    InputObjectTypeDefinition: {\n        leave: ({ name, directives, fields }) => join(['input', name, join(directives, ' '), block(fields)], ' '),\n    },\n    DirectiveDefinition: {\n        leave: ({ name, arguments: args, repeatable, locations }) => 'directive @' +\n            name +\n            (hasMultilineItems(args)\n                ? wrap('(\\n', indent(join(args, '\\n')), '\\n)')\n                : wrap('(', join(args, ', '), ')')) +\n            (repeatable ? ' repeatable' : '') +\n            ' on ' +\n            join(locations, ' | '),\n    },\n    SchemaExtension: {\n        leave: ({ directives, operationTypes }) => join(['extend schema', join(directives, ' '), block(operationTypes)], ' '),\n    },\n    ScalarTypeExtension: {\n        leave: ({ name, directives }) => join(['extend scalar', name, join(directives, ' ')], ' '),\n    },\n    ObjectTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join([\n            'extend type',\n            name,\n            wrap('implements ', join(interfaces, ' & ')),\n            join(directives, ' '),\n            block(fields),\n        ], ' '),\n    },\n    InterfaceTypeExtension: {\n        leave: ({ name, interfaces, directives, fields }) => join([\n            'extend interface',\n            name,\n            wrap('implements ', join(interfaces, ' & ')),\n            join(directives, ' '),\n            block(fields),\n        ], ' '),\n    },\n    UnionTypeExtension: {\n        leave: ({ name, directives, types }) => join(['extend union', name, join(directives, ' '), wrap('= ', join(types, ' | '))], ' '),\n    },\n    EnumTypeExtension: {\n        leave: ({ name, directives, values }) => join(['extend enum', name, join(directives, ' '), block(values)], ' '),\n    },\n    InputObjectTypeExtension: {\n        leave: ({ name, directives, fields }) => join(['extend input', name, join(directives, ' '), block(fields)], ' '),\n    },\n};\nconst printDocASTReducerWithComments = Object.keys(printDocASTReducer).reduce((prev, key) => ({\n    ...prev,\n    [key]: {\n        leave: addDescription(printDocASTReducer[key].leave),\n    },\n}), {});\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nexport function printWithComments(ast) {\n    return visit(ast, printDocASTReducerWithComments);\n}\nfunction isFieldDefinitionNode(node) {\n    return node.kind === 'FieldDefinition';\n}\n// graphql < v13 and > v15 does not export getDescription\nexport function getDescription(node, options) {\n    if (node.description != null) {\n        return node.description.value;\n    }\n    if (options?.commentDescriptions) {\n        return getComment(node);\n    }\n}\nexport function getComment(node) {\n    const rawValue = getLeadingCommentBlock(node);\n    if (rawValue !== undefined) {\n        return dedentBlockStringValue(`\\n${rawValue}`);\n    }\n}\nexport function getLeadingCommentBlock(node) {\n    const loc = node.loc;\n    if (!loc) {\n        return;\n    }\n    const comments = [];\n    let token = loc.startToken.prev;\n    while (token != null &&\n        token.kind === TokenKind.COMMENT &&\n        token.next != null &&\n        token.prev != null &&\n        token.line + 1 === token.next.line &&\n        token.line !== token.prev.line) {\n        const value = String(token.value);\n        comments.push(value);\n        token = token.prev;\n    }\n    return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\nexport function dedentBlockStringValue(rawString) {\n    // Expand a block string's raw value into independent lines.\n    const lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n    // Remove common indentation from all lines but first.\n    const commonIndent = getBlockStringIndentation(lines);\n    if (commonIndent !== 0) {\n        for (let i = 1; i < lines.length; i++) {\n            lines[i] = lines[i].slice(commonIndent);\n        }\n    }\n    // Remove leading and trailing blank lines.\n    while (lines.length > 0 && isBlank(lines[0])) {\n        lines.shift();\n    }\n    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n        lines.pop();\n    }\n    // Return a string of the lines joined with U+000A.\n    return lines.join('\\n');\n}\n/**\n * @internal\n */\nexport function getBlockStringIndentation(lines) {\n    let commonIndent = null;\n    for (let i = 1; i < lines.length; i++) {\n        const line = lines[i];\n        const indent = leadingWhitespace(line);\n        if (indent === line.length) {\n            continue; // skip empty lines\n        }\n        if (commonIndent === null || indent < commonIndent) {\n            commonIndent = indent;\n            if (commonIndent === 0) {\n                break;\n            }\n        }\n    }\n    return commonIndent === null ? 0 : commonIndent;\n}\nfunction leadingWhitespace(str) {\n    let i = 0;\n    while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n        i++;\n    }\n    return i;\n}\nfunction isBlank(str) {\n    return leadingWhitespace(str) === str.length;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2299, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/forEachDefaultValue.js"],"sourcesContent":["import { getNamedType, isInputObjectType, isObjectType } from 'graphql';\nexport function forEachDefaultValue(schema, fn) {\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        if (!getNamedType(type).name.startsWith('__')) {\n            if (isObjectType(type)) {\n                const fields = type.getFields();\n                for (const fieldName in fields) {\n                    const field = fields[fieldName];\n                    for (const arg of field.args) {\n                        arg.defaultValue = fn(arg.type, arg.defaultValue);\n                    }\n                }\n            }\n            else if (isInputObjectType(type)) {\n                const fields = type.getFields();\n                for (const fieldName in fields) {\n                    const field = fields[fieldName];\n                    field.defaultValue = fn(field.type, field.defaultValue);\n                }\n            }\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,oBAAoB,MAAM,EAAE,EAAE;IAC1C,MAAM,UAAU,OAAO,UAAU;IACjC,IAAK,MAAM,YAAY,QAAS;QAC5B,MAAM,OAAO,OAAO,CAAC,SAAS;QAC9B,IAAI,CAAC,IAAA,gKAAY,EAAC,MAAM,IAAI,CAAC,UAAU,CAAC,OAAO;YAC3C,IAAI,IAAA,gKAAY,EAAC,OAAO;gBACpB,MAAM,SAAS,KAAK,SAAS;gBAC7B,IAAK,MAAM,aAAa,OAAQ;oBAC5B,MAAM,QAAQ,MAAM,CAAC,UAAU;oBAC/B,KAAK,MAAM,OAAO,MAAM,IAAI,CAAE;wBAC1B,IAAI,YAAY,GAAG,GAAG,IAAI,IAAI,EAAE,IAAI,YAAY;oBACpD;gBACJ;YACJ,OACK,IAAI,IAAA,qKAAiB,EAAC,OAAO;gBAC9B,MAAM,SAAS,KAAK,SAAS;gBAC7B,IAAK,MAAM,aAAa,OAAQ;oBAC5B,MAAM,QAAQ,MAAM,CAAC,UAAU;oBAC/B,MAAM,YAAY,GAAG,GAAG,MAAM,IAAI,EAAE,MAAM,YAAY;gBAC1D;YACJ;QACJ;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2332, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/forEachField.js"],"sourcesContent":["import { getNamedType, isObjectType } from 'graphql';\nexport function forEachField(schema, fn) {\n    const typeMap = schema.getTypeMap();\n    for (const typeName in typeMap) {\n        const type = typeMap[typeName];\n        // TODO: maybe have an option to include these?\n        if (!getNamedType(type).name.startsWith('__') && isObjectType(type)) {\n            const fields = type.getFields();\n            for (const fieldName in fields) {\n                const field = fields[fieldName];\n                fn(field, typeName, fieldName);\n            }\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,aAAa,MAAM,EAAE,EAAE;IACnC,MAAM,UAAU,OAAO,UAAU;IACjC,IAAK,MAAM,YAAY,QAAS;QAC5B,MAAM,OAAO,OAAO,CAAC,SAAS;QAC9B,+CAA+C;QAC/C,IAAI,CAAC,IAAA,gKAAY,EAAC,MAAM,IAAI,CAAC,UAAU,CAAC,SAAS,IAAA,gKAAY,EAAC,OAAO;YACjE,MAAM,SAAS,KAAK,SAAS;YAC7B,IAAK,MAAM,aAAa,OAAQ;gBAC5B,MAAM,QAAQ,MAAM,CAAC,UAAU;gBAC/B,GAAG,OAAO,UAAU;YACxB;QACJ;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2356, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/heal.js"],"sourcesContent":["import { GraphQLList, GraphQLNonNull, isInputObjectType, isInterfaceType, isLeafType, isListType, isNamedType, isNonNullType, isObjectType, isUnionType, } from 'graphql';\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n//\n// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.\n// Therefore, private variables (such as the stored implementation map and the proper root types)\n// are not updated.\n//\n// If this causes issues, the schema could be more aggressively healed as follows:\n//\n// healSchema(schema);\n// const config = schema.toConfig()\n// const healedSchema = new GraphQLSchema({\n//   ...config,\n//   query: schema.getType('<desired new root query type name>'),\n//   mutation: schema.getType('<desired new root mutation type name>'),\n//   subscription: schema.getType('<desired new root subscription type name>'),\n// });\n//\n// One can then also -- if necessary --  assign the correct private variables to the initial schema\n// as follows:\n// Object.assign(schema, healedSchema);\n//\n// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.\n// See https://github.com/ardatan/graphql-tools/issues/1462\n//\n// They were briefly taken in v5, but can now be phased out as they were only required when other\n// areas of the codebase were using healSchema and visitSchema more extensively.\n//\nexport function healSchema(schema) {\n    healTypes(schema.getTypeMap(), schema.getDirectives());\n    return schema;\n}\nexport function healTypes(originalTypeMap, directives) {\n    const actualNamedTypeMap = Object.create(null);\n    // If any of the .name properties of the GraphQLNamedType objects in\n    // schema.getTypeMap() have changed, the keys of the type map need to\n    // be updated accordingly.\n    for (const typeName in originalTypeMap) {\n        const namedType = originalTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            continue;\n        }\n        const actualName = namedType.name;\n        if (actualName.startsWith('__')) {\n            continue;\n        }\n        if (actualNamedTypeMap[actualName] != null) {\n            console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);\n            continue;\n        }\n        actualNamedTypeMap[actualName] = namedType;\n        // Note: we are deliberately leaving namedType in the schema by its\n        // original name (which might be different from actualName), so that\n        // references by that name can be healed.\n    }\n    // Now add back every named type by its actual name.\n    for (const typeName in actualNamedTypeMap) {\n        const namedType = actualNamedTypeMap[typeName];\n        originalTypeMap[typeName] = namedType;\n    }\n    // Directive declaration argument types can refer to named types.\n    for (const decl of directives) {\n        decl.args = decl.args.filter(arg => {\n            arg.type = healType(arg.type);\n            return arg.type !== null;\n        });\n    }\n    for (const typeName in originalTypeMap) {\n        const namedType = originalTypeMap[typeName];\n        // Heal all named types, except for dangling references, kept only to redirect.\n        if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n            if (namedType != null) {\n                healNamedType(namedType);\n            }\n        }\n    }\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n            delete originalTypeMap[typeName];\n        }\n    }\n    function healNamedType(type) {\n        if (isObjectType(type)) {\n            healFields(type);\n            healInterfaces(type);\n            return;\n        }\n        else if (isInterfaceType(type)) {\n            healFields(type);\n            if ('getInterfaces' in type) {\n                healInterfaces(type);\n            }\n            return;\n        }\n        else if (isUnionType(type)) {\n            healUnderlyingTypes(type);\n            return;\n        }\n        else if (isInputObjectType(type)) {\n            healInputFields(type);\n            return;\n        }\n        else if (isLeafType(type)) {\n            return;\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function healFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.args\n                .map(arg => {\n                arg.type = healType(arg.type);\n                return arg.type === null ? null : arg;\n            })\n                .filter(Boolean);\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healInterfaces(type) {\n        if ('getInterfaces' in type) {\n            const interfaces = type.getInterfaces();\n            interfaces.push(...interfaces\n                .splice(0)\n                .map(iface => healType(iface))\n                .filter(Boolean));\n        }\n    }\n    function healInputFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healUnderlyingTypes(type) {\n        const types = type.getTypes();\n        types.push(...types\n            .splice(0)\n            .map(t => healType(t))\n            .filter(Boolean));\n    }\n    function healType(type) {\n        // Unwrap the two known wrapper types\n        if (isListType(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new GraphQLList(healedType) : null;\n        }\n        else if (isNonNullType(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new GraphQLNonNull(healedType) : null;\n        }\n        else if (isNamedType(type)) {\n            // If a type annotation on a field or an argument or a union member is\n            // any `GraphQLNamedType` with a `name`, then it must end up identical\n            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n            // of truth for all named schema types.\n            // Note that new types can still be simply added by adding a field, as\n            // the official type will be undefined, not null.\n            const officialType = originalTypeMap[type.name];\n            if (officialType && type !== officialType) {\n                return officialType;\n            }\n        }\n        return type;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2498, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/Interfaces.js"],"sourcesContent":["export var MapperKind;\n(function (MapperKind) {\n    MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n    MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n    MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n    MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n    MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n    MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n    MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n    MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n    MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n    MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n    MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n    MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n    MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n    MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n    MapperKind[\"FIELD\"] = \"MapperKind.FIELD\";\n    MapperKind[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n    MapperKind[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n    MapperKind[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n    MapperKind[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n    MapperKind[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n    MapperKind[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n    MapperKind[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n    MapperKind[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n    MapperKind[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n    MapperKind[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(MapperKind || (MapperKind = {}));\n"],"names":[],"mappings":";;;;AAAO,IAAI;AACX,CAAC,SAAU,UAAU;IACjB,UAAU,CAAC,OAAO,GAAG;IACrB,UAAU,CAAC,cAAc,GAAG;IAC5B,UAAU,CAAC,YAAY,GAAG;IAC1B,UAAU,CAAC,iBAAiB,GAAG;IAC/B,UAAU,CAAC,cAAc,GAAG;IAC5B,UAAU,CAAC,oBAAoB,GAAG;IAClC,UAAU,CAAC,gBAAgB,GAAG;IAC9B,UAAU,CAAC,aAAa,GAAG;IAC3B,UAAU,CAAC,iBAAiB,GAAG;IAC/B,UAAU,CAAC,cAAc,GAAG;IAC5B,UAAU,CAAC,QAAQ,GAAG;IACtB,UAAU,CAAC,WAAW,GAAG;IACzB,UAAU,CAAC,eAAe,GAAG;IAC7B,UAAU,CAAC,YAAY,GAAG;IAC1B,UAAU,CAAC,QAAQ,GAAG;IACtB,UAAU,CAAC,kBAAkB,GAAG;IAChC,UAAU,CAAC,eAAe,GAAG;IAC7B,UAAU,CAAC,aAAa,GAAG;IAC3B,UAAU,CAAC,mBAAmB,GAAG;IACjC,UAAU,CAAC,sBAAsB,GAAG;IACpC,UAAU,CAAC,0BAA0B,GAAG;IACxC,UAAU,CAAC,kBAAkB,GAAG;IAChC,UAAU,CAAC,qBAAqB,GAAG;IACnC,UAAU,CAAC,WAAW,GAAG;IACzB,UAAU,CAAC,aAAa,GAAG;AAC/B,CAAC,EAAE,cAAc,CAAC,aAAa,CAAC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2534, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/getObjectTypeFromTypeMap.js"],"sourcesContent":["import { isObjectType } from 'graphql';\nexport function getObjectTypeFromTypeMap(typeMap, type) {\n    if (type) {\n        const maybeObjectType = typeMap[type.name];\n        if (isObjectType(maybeObjectType)) {\n            return maybeObjectType;\n        }\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,yBAAyB,OAAO,EAAE,IAAI;IAClD,IAAI,MAAM;QACN,MAAM,kBAAkB,OAAO,CAAC,KAAK,IAAI,CAAC;QAC1C,IAAI,IAAA,gKAAY,EAAC,kBAAkB;YAC/B,OAAO;QACX;IACJ;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2552, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/stub.js"],"sourcesContent":["import { GraphQLBoolean, GraphQLFloat, GraphQLID, GraphQLInputObjectType, GraphQLInt, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLString, Kind, } from 'graphql';\nexport function createNamedStub(name, type) {\n    let constructor;\n    if (type === 'object') {\n        constructor = GraphQLObjectType;\n    }\n    else if (type === 'interface') {\n        constructor = GraphQLInterfaceType;\n    }\n    else {\n        constructor = GraphQLInputObjectType;\n    }\n    return new constructor({\n        name,\n        fields: {\n            _fake: {\n                type: GraphQLString,\n            },\n        },\n    });\n}\nexport function createStub(node, type) {\n    switch (node.kind) {\n        case Kind.LIST_TYPE:\n            return new GraphQLList(createStub(node.type, type));\n        case Kind.NON_NULL_TYPE:\n            return new GraphQLNonNull(createStub(node.type, type));\n        default:\n            if (type === 'output') {\n                return createNamedStub(node.name.value, 'object');\n            }\n            return createNamedStub(node.name.value, 'input');\n    }\n}\nexport function isNamedStub(type) {\n    if ('getFields' in type) {\n        const fields = type.getFields();\n        // eslint-disable-next-line no-unreachable-loop\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            return field.name === '_fake';\n        }\n    }\n    return false;\n}\nexport function getBuiltInForStub(type) {\n    switch (type.name) {\n        case GraphQLInt.name:\n            return GraphQLInt;\n        case GraphQLFloat.name:\n            return GraphQLFloat;\n        case GraphQLString.name:\n            return GraphQLString;\n        case GraphQLBoolean.name:\n            return GraphQLBoolean;\n        case GraphQLID.name:\n            return GraphQLID;\n        default:\n            return type;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;;AACO,SAAS,gBAAgB,IAAI,EAAE,IAAI;IACtC,IAAI;IACJ,IAAI,SAAS,UAAU;QACnB,cAAc,qKAAiB;IACnC,OACK,IAAI,SAAS,aAAa;QAC3B,cAAc,wKAAoB;IACtC,OACK;QACD,cAAc,0KAAsB;IACxC;IACA,OAAO,IAAI,YAAY;QACnB;QACA,QAAQ;YACJ,OAAO;gBACH,MAAM,8JAAa;YACvB;QACJ;IACJ;AACJ;AACO,SAAS,WAAW,IAAI,EAAE,IAAI;IACjC,OAAQ,KAAK,IAAI;QACb,KAAK,uJAAI,CAAC,SAAS;YACf,OAAO,IAAI,+JAAW,CAAC,WAAW,KAAK,IAAI,EAAE;QACjD,KAAK,uJAAI,CAAC,aAAa;YACnB,OAAO,IAAI,kKAAc,CAAC,WAAW,KAAK,IAAI,EAAE;QACpD;YACI,IAAI,SAAS,UAAU;gBACnB,OAAO,gBAAgB,KAAK,IAAI,CAAC,KAAK,EAAE;YAC5C;YACA,OAAO,gBAAgB,KAAK,IAAI,CAAC,KAAK,EAAE;IAChD;AACJ;AACO,SAAS,YAAY,IAAI;IAC5B,IAAI,eAAe,MAAM;QACrB,MAAM,SAAS,KAAK,SAAS;QAC7B,+CAA+C;QAC/C,IAAK,MAAM,aAAa,OAAQ;YAC5B,MAAM,QAAQ,MAAM,CAAC,UAAU;YAC/B,OAAO,MAAM,IAAI,KAAK;QAC1B;IACJ;IACA,OAAO;AACX;AACO,SAAS,kBAAkB,IAAI;IAClC,OAAQ,KAAK,IAAI;QACb,KAAK,2JAAU,CAAC,IAAI;YAChB,OAAO,2JAAU;QACrB,KAAK,6JAAY,CAAC,IAAI;YAClB,OAAO,6JAAY;QACvB,KAAK,8JAAa,CAAC,IAAI;YACnB,OAAO,8JAAa;QACxB,KAAK,+JAAc,CAAC,IAAI;YACpB,OAAO,+JAAc;QACzB,KAAK,0JAAS,CAAC,IAAI;YACf,OAAO,0JAAS;QACpB;YACI,OAAO;IACf;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2628, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/rewire.js"],"sourcesContent":["import { GraphQLDirective, GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLScalarType, GraphQLUnionType, isEnumType, isInputObjectType, isInterfaceType, isListType, isNamedType, isNonNullType, isObjectType, isScalarType, isSpecifiedDirective, isSpecifiedScalarType, isUnionType, } from 'graphql';\nimport { getBuiltInForStub, isNamedStub } from './stub.js';\nexport function rewireTypes(originalTypeMap, directives) {\n    const referenceTypeMap = Object.create(null);\n    for (const typeName in originalTypeMap) {\n        referenceTypeMap[typeName] = originalTypeMap[typeName];\n    }\n    const newTypeMap = Object.create(null);\n    for (const typeName in referenceTypeMap) {\n        const namedType = referenceTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            continue;\n        }\n        const newName = namedType.name;\n        if (newName.startsWith('__')) {\n            continue;\n        }\n        if (newTypeMap[newName] != null) {\n            console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);\n            continue;\n        }\n        newTypeMap[newName] = namedType;\n    }\n    for (const typeName in newTypeMap) {\n        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n    }\n    const newDirectives = directives.map(directive => rewireDirective(directive));\n    return {\n        typeMap: newTypeMap,\n        directives: newDirectives,\n    };\n    function rewireDirective(directive) {\n        if (isSpecifiedDirective(directive)) {\n            return directive;\n        }\n        const directiveConfig = directive.toConfig();\n        directiveConfig.args = rewireArgs(directiveConfig.args);\n        return new GraphQLDirective(directiveConfig);\n    }\n    function rewireArgs(args) {\n        const rewiredArgs = {};\n        for (const argName in args) {\n            const arg = args[argName];\n            const rewiredArgType = rewireType(arg.type);\n            if (rewiredArgType != null) {\n                arg.type = rewiredArgType;\n                rewiredArgs[argName] = arg;\n            }\n        }\n        return rewiredArgs;\n    }\n    function rewireNamedType(type) {\n        if (isObjectType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireFields(config.fields),\n                interfaces: () => rewireNamedTypes(config.interfaces),\n            };\n            return new GraphQLObjectType(newConfig);\n        }\n        else if (isInterfaceType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireFields(config.fields),\n            };\n            if ('interfaces' in newConfig) {\n                newConfig.interfaces = () => rewireNamedTypes(config.interfaces);\n            }\n            return new GraphQLInterfaceType(newConfig);\n        }\n        else if (isUnionType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                types: () => rewireNamedTypes(config.types),\n            };\n            return new GraphQLUnionType(newConfig);\n        }\n        else if (isInputObjectType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireInputFields(config.fields),\n            };\n            return new GraphQLInputObjectType(newConfig);\n        }\n        else if (isEnumType(type)) {\n            const enumConfig = type.toConfig();\n            return new GraphQLEnumType(enumConfig);\n        }\n        else if (isScalarType(type)) {\n            if (isSpecifiedScalarType(type)) {\n                return type;\n            }\n            const scalarConfig = type.toConfig();\n            return new GraphQLScalarType(scalarConfig);\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function rewireFields(fields) {\n        const rewiredFields = {};\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null && field.args) {\n                field.type = rewiredFieldType;\n                field.args = rewireArgs(field.args);\n                rewiredFields[fieldName] = field;\n            }\n        }\n        return rewiredFields;\n    }\n    function rewireInputFields(fields) {\n        const rewiredFields = {};\n        for (const fieldName in fields) {\n            const field = fields[fieldName];\n            const rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null) {\n                field.type = rewiredFieldType;\n                rewiredFields[fieldName] = field;\n            }\n        }\n        return rewiredFields;\n    }\n    function rewireNamedTypes(namedTypes) {\n        const rewiredTypes = [];\n        for (const namedType of namedTypes) {\n            const rewiredType = rewireType(namedType);\n            if (rewiredType != null) {\n                rewiredTypes.push(rewiredType);\n            }\n        }\n        return rewiredTypes;\n    }\n    function rewireType(type) {\n        if (isListType(type)) {\n            const rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new GraphQLList(rewiredType) : null;\n        }\n        else if (isNonNullType(type)) {\n            const rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new GraphQLNonNull(rewiredType) : null;\n        }\n        else if (isNamedType(type)) {\n            let rewiredType = referenceTypeMap[type.name];\n            if (rewiredType === undefined) {\n                rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);\n                newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;\n            }\n            return rewiredType != null ? newTypeMap[rewiredType.name] : null;\n        }\n        return null;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AACA;;;AACO,SAAS,YAAY,eAAe,EAAE,UAAU;IACnD,MAAM,mBAAmB,OAAO,MAAM,CAAC;IACvC,IAAK,MAAM,YAAY,gBAAiB;QACpC,gBAAgB,CAAC,SAAS,GAAG,eAAe,CAAC,SAAS;IAC1D;IACA,MAAM,aAAa,OAAO,MAAM,CAAC;IACjC,IAAK,MAAM,YAAY,iBAAkB;QACrC,MAAM,YAAY,gBAAgB,CAAC,SAAS;QAC5C,IAAI,aAAa,QAAQ,SAAS,UAAU,CAAC,OAAO;YAChD;QACJ;QACA,MAAM,UAAU,UAAU,IAAI;QAC9B,IAAI,QAAQ,UAAU,CAAC,OAAO;YAC1B;QACJ;QACA,IAAI,UAAU,CAAC,QAAQ,IAAI,MAAM;YAC7B,QAAQ,IAAI,CAAC,CAAC,2BAA2B,EAAE,QAAQ,oDAAoD,CAAC;YACxG;QACJ;QACA,UAAU,CAAC,QAAQ,GAAG;IAC1B;IACA,IAAK,MAAM,YAAY,WAAY;QAC/B,UAAU,CAAC,SAAS,GAAG,gBAAgB,UAAU,CAAC,SAAS;IAC/D;IACA,MAAM,gBAAgB,WAAW,GAAG,CAAC,CAAA,YAAa,gBAAgB;IAClE,OAAO;QACH,SAAS;QACT,YAAY;IAChB;;;IACA,SAAS,gBAAgB,SAAS;QAC9B,IAAI,IAAA,wKAAoB,EAAC,YAAY;YACjC,OAAO;QACX;QACA,MAAM,kBAAkB,UAAU,QAAQ;QAC1C,gBAAgB,IAAI,GAAG,WAAW,gBAAgB,IAAI;QACtD,OAAO,IAAI,oKAAgB,CAAC;IAChC;IACA,SAAS,WAAW,IAAI;QACpB,MAAM,cAAc,CAAC;QACrB,IAAK,MAAM,WAAW,KAAM;YACxB,MAAM,MAAM,IAAI,CAAC,QAAQ;YACzB,MAAM,iBAAiB,WAAW,IAAI,IAAI;YAC1C,IAAI,kBAAkB,MAAM;gBACxB,IAAI,IAAI,GAAG;gBACX,WAAW,CAAC,QAAQ,GAAG;YAC3B;QACJ;QACA,OAAO;IACX;IACA,SAAS,gBAAgB,IAAI;QACzB,IAAI,IAAA,gKAAY,EAAC,OAAO;YACpB,MAAM,SAAS,KAAK,QAAQ;YAC5B,MAAM,YAAY;gBACd,GAAG,MAAM;gBACT,QAAQ,IAAM,aAAa,OAAO,MAAM;gBACxC,YAAY,IAAM,iBAAiB,OAAO,UAAU;YACxD;YACA,OAAO,IAAI,qKAAiB,CAAC;QACjC,OACK,IAAI,IAAA,mKAAe,EAAC,OAAO;YAC5B,MAAM,SAAS,KAAK,QAAQ;YAC5B,MAAM,YAAY;gBACd,GAAG,MAAM;gBACT,QAAQ,IAAM,aAAa,OAAO,MAAM;YAC5C;YACA,IAAI,gBAAgB,WAAW;gBAC3B,UAAU,UAAU,GAAG,IAAM,iBAAiB,OAAO,UAAU;YACnE;YACA,OAAO,IAAI,wKAAoB,CAAC;QACpC,OACK,IAAI,IAAA,+JAAW,EAAC,OAAO;YACxB,MAAM,SAAS,KAAK,QAAQ;YAC5B,MAAM,YAAY;gBACd,GAAG,MAAM;gBACT,OAAO,IAAM,iBAAiB,OAAO,KAAK;YAC9C;YACA,OAAO,IAAI,oKAAgB,CAAC;QAChC,OACK,IAAI,IAAA,qKAAiB,EAAC,OAAO;YAC9B,MAAM,SAAS,KAAK,QAAQ;YAC5B,MAAM,YAAY;gBACd,GAAG,MAAM;gBACT,QAAQ,IAAM,kBAAkB,OAAO,MAAM;YACjD;YACA,OAAO,IAAI,0KAAsB,CAAC;QACtC,OACK,IAAI,IAAA,8JAAU,EAAC,OAAO;YACvB,MAAM,aAAa,KAAK,QAAQ;YAChC,OAAO,IAAI,mKAAe,CAAC;QAC/B,OACK,IAAI,IAAA,gKAAY,EAAC,OAAO;YACzB,IAAI,IAAA,sKAAqB,EAAC,OAAO;gBAC7B,OAAO;YACX;YACA,MAAM,eAAe,KAAK,QAAQ;YAClC,OAAO,IAAI,qKAAiB,CAAC;QACjC;QACA,MAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,MAAM;IACrD;IACA,SAAS,aAAa,MAAM;QACxB,MAAM,gBAAgB,CAAC;QACvB,IAAK,MAAM,aAAa,OAAQ;YAC5B,MAAM,QAAQ,MAAM,CAAC,UAAU;YAC/B,MAAM,mBAAmB,WAAW,MAAM,IAAI;YAC9C,IAAI,oBAAoB,QAAQ,MAAM,IAAI,EAAE;gBACxC,MAAM,IAAI,GAAG;gBACb,MAAM,IAAI,GAAG,WAAW,MAAM,IAAI;gBAClC,aAAa,CAAC,UAAU,GAAG;YAC/B;QACJ;QACA,OAAO;IACX;IACA,SAAS,kBAAkB,MAAM;QAC7B,MAAM,gBAAgB,CAAC;QACvB,IAAK,MAAM,aAAa,OAAQ;YAC5B,MAAM,QAAQ,MAAM,CAAC,UAAU;YAC/B,MAAM,mBAAmB,WAAW,MAAM,IAAI;YAC9C,IAAI,oBAAoB,MAAM;gBAC1B,MAAM,IAAI,GAAG;gBACb,aAAa,CAAC,UAAU,GAAG;YAC/B;QACJ;QACA,OAAO;IACX;IACA,SAAS,iBAAiB,UAAU;QAChC,MAAM,eAAe,EAAE;QACvB,KAAK,MAAM,aAAa,WAAY;YAChC,MAAM,cAAc,WAAW;YAC/B,IAAI,eAAe,MAAM;gBACrB,aAAa,IAAI,CAAC;YACtB;QACJ;QACA,OAAO;IACX;IACA,SAAS,WAAW,IAAI;QACpB,IAAI,IAAA,8JAAU,EAAC,OAAO;YAClB,MAAM,cAAc,WAAW,KAAK,MAAM;YAC1C,OAAO,eAAe,OAAO,IAAI,+JAAW,CAAC,eAAe;QAChE,OACK,IAAI,IAAA,iKAAa,EAAC,OAAO;YAC1B,MAAM,cAAc,WAAW,KAAK,MAAM;YAC1C,OAAO,eAAe,OAAO,IAAI,kKAAc,CAAC,eAAe;QACnE,OACK,IAAI,IAAA,+JAAW,EAAC,OAAO;YACxB,IAAI,cAAc,gBAAgB,CAAC,KAAK,IAAI,CAAC;YAC7C,IAAI,gBAAgB,WAAW;gBAC3B,cAAc,IAAA,2KAAW,EAAC,QAAQ,IAAA,iLAAiB,EAAC,QAAQ,gBAAgB;gBAC5E,UAAU,CAAC,YAAY,IAAI,CAAC,GAAG,gBAAgB,CAAC,KAAK,IAAI,CAAC,GAAG;YACjE;YACA,OAAO,eAAe,OAAO,UAAU,CAAC,YAAY,IAAI,CAAC,GAAG;QAChE;QACA,OAAO;IACX;AACJ","ignoreList":[0]}},
    {"offset": {"line": 2791, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/transformInputValue.js"],"sourcesContent":["import { getNullableType, isInputObjectType, isLeafType, isListType, } from 'graphql';\nimport { asArray } from './helpers.js';\nexport function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {\n    if (value == null) {\n        return value;\n    }\n    const nullableType = getNullableType(type);\n    if (isLeafType(nullableType)) {\n        return inputLeafValueTransformer != null\n            ? inputLeafValueTransformer(nullableType, value)\n            : value;\n    }\n    else if (isListType(nullableType)) {\n        return asArray(value).map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));\n    }\n    else if (isInputObjectType(nullableType)) {\n        const fields = nullableType.getFields();\n        const newValue = {};\n        for (const key in value) {\n            const field = fields[key];\n            if (field != null) {\n                newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);\n            }\n        }\n        return inputObjectValueTransformer != null\n            ? inputObjectValueTransformer(nullableType, newValue)\n            : newValue;\n    }\n    // unreachable, no other possible return value\n}\nexport function serializeInputValue(type, value) {\n    return transformInputValue(type, value, (t, v) => {\n        try {\n            return t.serialize(v);\n        }\n        catch {\n            return v;\n        }\n    });\n}\nexport function parseInputValue(type, value) {\n    return transformInputValue(type, value, (t, v) => {\n        try {\n            return t.parseValue(v);\n        }\n        catch {\n            return v;\n        }\n    });\n}\nexport function parseInputValueLiteral(type, value) {\n    return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;;;AACO,SAAS,oBAAoB,IAAI,EAAE,KAAK,EAAE,4BAA4B,IAAI,EAAE,8BAA8B,IAAI;IACjH,IAAI,SAAS,MAAM;QACf,OAAO;IACX;IACA,MAAM,eAAe,IAAA,mKAAe,EAAC;IACrC,IAAI,IAAA,8JAAU,EAAC,eAAe;QAC1B,OAAO,6BAA6B,OAC9B,0BAA0B,cAAc,SACxC;IACV,OACK,IAAI,IAAA,8JAAU,EAAC,eAAe;QAC/B,OAAO,IAAA,0KAAO,EAAC,OAAO,GAAG,CAAC,CAAC,aAAe,oBAAoB,aAAa,MAAM,EAAE,YAAY,2BAA2B;IAC9H,OACK,IAAI,IAAA,qKAAiB,EAAC,eAAe;QACtC,MAAM,SAAS,aAAa,SAAS;QACrC,MAAM,WAAW,CAAC;QAClB,IAAK,MAAM,OAAO,MAAO;YACrB,MAAM,QAAQ,MAAM,CAAC,IAAI;YACzB,IAAI,SAAS,MAAM;gBACf,QAAQ,CAAC,IAAI,GAAG,oBAAoB,MAAM,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,2BAA2B;YAC3F;QACJ;QACA,OAAO,+BAA+B,OAChC,4BAA4B,cAAc,YAC1C;IACV;AACA,8CAA8C;AAClD;AACO,SAAS,oBAAoB,IAAI,EAAE,KAAK;IAC3C,OAAO,oBAAoB,MAAM,OAAO,CAAC,GAAG;QACxC,IAAI;YACA,OAAO,EAAE,SAAS,CAAC;QACvB,EACA,OAAM;YACF,OAAO;QACX;IACJ;AACJ;AACO,SAAS,gBAAgB,IAAI,EAAE,KAAK;IACvC,OAAO,oBAAoB,MAAM,OAAO,CAAC,GAAG;QACxC,IAAI;YACA,OAAO,EAAE,UAAU,CAAC;QACxB,EACA,OAAM;YACF,OAAO;QACX;IACJ;AACJ;AACO,SAAS,uBAAuB,IAAI,EAAE,KAAK;IAC9C,OAAO,oBAAoB,MAAM,OAAO,CAAC,GAAG,IAAM,EAAE,YAAY,CAAC,GAAG,CAAC;AACzE","ignoreList":[0]}},
    {"offset": {"line": 2852, "column": 0}, "map": {"version":3,"sources":["file:///C:/dev/Ruby/node_modules/%40graphql-tools/utils/esm/mapSchema.js"],"sourcesContent":["import { GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLSchema, isEnumType, isInputObjectType, isInterfaceType, isLeafType, isListType, isNamedType, isNonNullType, isObjectType, isScalarType, isUnionType, Kind, } from 'graphql';\nimport { getObjectTypeFromTypeMap } from './getObjectTypeFromTypeMap.js';\nimport { MapperKind, } from './Interfaces.js';\nimport { rewireTypes } from './rewire.js';\nimport { parseInputValue, serializeInputValue } from './transformInputValue.js';\nexport function mapSchema(schema, schemaMapper = {}) {\n    const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, type => isLeafType(type)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, type => !isLeafType(type)), schema, schemaMapper), schema, schemaMapper);\n    const originalDirectives = schema.getDirectives();\n    const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n    const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);\n    return new GraphQLSchema({\n        ...schema.toConfig(),\n        query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),\n        mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),\n        subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),\n        types: Object.values(typeMap),\n        directives,\n    });\n}\nconst builtinTypes = ['String', 'ID', 'Int', 'Float', 'Boolean'];\nfunction mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__') && !builtinTypes.includes(typeName)) {\n            const originalType = originalTypeMap[typeName];\n            if (originalType == null || !testFn(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n            if (typeMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const maybeNewType = typeMapper(originalType, schema);\n            if (maybeNewType === undefined) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            newTypeMap[typeName] = maybeNewType;\n        }\n    }\n    return newTypeMap;\n}\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n    const enumValueMapper = getEnumValueMapper(schemaMapper);\n    if (!enumValueMapper) {\n        return originalTypeMap;\n    }\n    return mapTypes(originalTypeMap, schema, {\n        [MapperKind.ENUM_TYPE]: type => {\n            const config = type.toConfig();\n            const originalEnumValueConfigMap = config.values;\n            const newEnumValueConfigMap = {};\n            for (const externalValue in originalEnumValueConfigMap) {\n                const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n                const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n                if (mappedEnumValue === undefined) {\n                    newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n                }\n                else if (Array.isArray(mappedEnumValue)) {\n                    const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n                    newEnumValueConfigMap[newExternalValue] =\n                        newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n                }\n                else if (mappedEnumValue !== null) {\n                    newEnumValueConfigMap[externalValue] = mappedEnumValue;\n                }\n            }\n            return correctASTNodes(new GraphQLEnumType({\n                ...config,\n                values: newEnumValueConfigMap,\n            }));\n        },\n    }, type => isEnumType(type));\n}\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n    const newTypeMap = mapArguments(originalTypeMap, schema, {\n        [MapperKind.ARGUMENT]: argumentConfig => {\n            if (argumentConfig.defaultValue === undefined) {\n                return argumentConfig;\n            }\n            const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...argumentConfig,\n                    defaultValue: fn(maybeNewType, argumentConfig.defaultValue),\n                };\n            }\n        },\n    });\n    return mapFields(newTypeMap, schema, {\n        [MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n            if (inputFieldConfig.defaultValue === undefined) {\n                return inputFieldConfig;\n            }\n            const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...inputFieldConfig,\n                    defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue),\n                };\n            }\n        },\n    });\n}\nfunction getNewType(newTypeMap, type) {\n    if (isListType(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new GraphQLList(newType) : null;\n    }\n    else if (isNonNullType(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new GraphQLNonNull(newType) : null;\n    }\n    else if (isNamedType(type)) {\n        const newType = newTypeMap[type.name];\n        return newType != null ? newType : null;\n    }\n    return null;\n}\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!isObjectType(originalType) &&\n                !isInterfaceType(originalType) &&\n                !isInputObjectType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n            if (fieldMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n                if (mappedField === undefined) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                }\n                else if (Array.isArray(mappedField)) {\n                    const [newFieldName, newFieldConfig] = mappedField;\n                    if (newFieldConfig.astNode != null) {\n                        newFieldConfig.astNode = {\n                            ...newFieldConfig.astNode,\n                            name: {\n                                ...newFieldConfig.astNode.name,\n                                value: newFieldName,\n                            },\n                        };\n                    }\n                    newFieldConfigMap[newFieldName] =\n                        newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n                }\n                else if (mappedField !== null) {\n                    newFieldConfigMap[fieldName] = mappedField;\n                }\n            }\n            if (isObjectType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else if (isInterfaceType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    for (const typeName in originalTypeMap) {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!isObjectType(originalType) && !isInterfaceType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const argumentMapper = getArgumentMapper(schemaMapper);\n            if (argumentMapper == null) {\n                newTypeMap[typeName] = originalType;\n                continue;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            for (const fieldName in originalFieldConfigMap) {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const originalArgumentConfigMap = originalFieldConfig.args;\n                if (originalArgumentConfigMap == null) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const argumentNames = Object.keys(originalArgumentConfigMap);\n                if (!argumentNames.length) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    continue;\n                }\n                const newArgumentConfigMap = {};\n                for (const argumentName of argumentNames) {\n                    const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n                    const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n                    if (mappedArgument === undefined) {\n                        newArgumentConfigMap[argumentName] = originalArgumentConfig;\n                    }\n                    else if (Array.isArray(mappedArgument)) {\n                        const [newArgumentName, newArgumentConfig] = mappedArgument;\n                        newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n                    }\n                    else if (mappedArgument !== null) {\n                        newArgumentConfigMap[argumentName] = mappedArgument;\n                    }\n                }\n                newFieldConfigMap[fieldName] = {\n                    ...originalFieldConfig,\n                    args: newArgumentConfigMap,\n                };\n            }\n            if (isObjectType(originalType)) {\n                newTypeMap[typeName] = new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else if (isInterfaceType(originalType)) {\n                newTypeMap[typeName] = new GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else {\n                newTypeMap[typeName] = new GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n        }\n    }\n    return newTypeMap;\n}\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n    const directiveMapper = getDirectiveMapper(schemaMapper);\n    if (directiveMapper == null) {\n        return originalDirectives.slice();\n    }\n    const newDirectives = [];\n    for (const directive of originalDirectives) {\n        const mappedDirective = directiveMapper(directive, schema);\n        if (mappedDirective === undefined) {\n            newDirectives.push(directive);\n        }\n        else if (mappedDirective !== null) {\n            newDirectives.push(mappedDirective);\n        }\n    }\n    return newDirectives;\n}\nfunction getTypeSpecifiers(schema, typeName) {\n    const type = schema.getType(typeName);\n    const specifiers = [MapperKind.TYPE];\n    if (isObjectType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n        if (typeName === schema.getQueryType()?.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n        }\n        else if (typeName === schema.getMutationType()?.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n        }\n        else if (typeName === schema.getSubscriptionType()?.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n        }\n    }\n    else if (isInputObjectType(type)) {\n        specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n    }\n    else if (isInterfaceType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);\n    }\n    else if (isUnionType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);\n    }\n    else if (isEnumType(type)) {\n        specifiers.push(MapperKind.ENUM_TYPE);\n    }\n    else if (isScalarType(type)) {\n        specifiers.push(MapperKind.SCALAR_TYPE);\n    }\n    return specifiers;\n}\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n    const specifiers = getTypeSpecifiers(schema, typeName);\n    let typeMapper;\n    const stack = [...specifiers];\n    while (!typeMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        typeMapper = schemaMapper[next];\n    }\n    return typeMapper != null ? typeMapper : null;\n}\nfunction getFieldSpecifiers(schema, typeName) {\n    const type = schema.getType(typeName);\n    const specifiers = [MapperKind.FIELD];\n    if (isObjectType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);\n        if (typeName === schema.getQueryType()?.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);\n        }\n        else if (typeName === schema.getMutationType()?.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);\n        }\n        else if (typeName === schema.getSubscriptionType()?.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);\n        }\n    }\n    else if (isInterfaceType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);\n    }\n    else if (isInputObjectType(type)) {\n        specifiers.push(MapperKind.INPUT_OBJECT_FIELD);\n    }\n    return specifiers;\n}\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n    const specifiers = getFieldSpecifiers(schema, typeName);\n    let fieldMapper;\n    const stack = [...specifiers];\n    while (!fieldMapper && stack.length > 0) {\n        // It is safe to use the ! operator here as we check the length.\n        const next = stack.pop();\n        // TODO: fix this as unknown cast\n        fieldMapper = schemaMapper[next];\n    }\n    return fieldMapper ?? null;\n}\nfunction getArgumentMapper(schemaMapper) {\n    const argumentMapper = schemaMapper[MapperKind.ARGUMENT];\n    return argumentMapper != null ? argumentMapper : null;\n}\nfunction getDirectiveMapper(schemaMapper) {\n    const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n}\nfunction getEnumValueMapper(schemaMapper) {\n    const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];\n    return enumValueMapper != null ? enumValueMapper : null;\n}\nexport function correctASTNodes(type) {\n    if (isObjectType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: Kind.OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: Kind.OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new GraphQLObjectType(config);\n    }\n    else if (isInterfaceType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: Kind.INTERFACE_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: Kind.INTERFACE_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new GraphQLInterfaceType(config);\n    }\n    else if (isInputObjectType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            for (const fieldName in config.fields) {\n                const fieldConfig = config.fields[fieldName];\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new GraphQLInputObjectType(config);\n    }\n    else if (isEnumType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const values = [];\n            for (const enumKey in config.values) {\n                const enumValueConfig = config.values[enumKey];\n                if (enumValueConfig.astNode != null) {\n                    values.push(enumValueConfig.astNode);\n                }\n            }\n            config.astNode = {\n                ...config.astNode,\n                values,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                values: undefined,\n            }));\n        }\n        return new GraphQLEnumType(config);\n    }\n    else {\n        return type;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}